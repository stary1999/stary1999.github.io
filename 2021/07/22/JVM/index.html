<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM入门"><meta name="keywords" content="java,jvm"><meta name="author" content="stary,undefined"><meta name="copyright" content="stary"><title>JVM入门【繁星点点】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: false,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="繁星点点" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81jvm%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、jvm概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E4%BA%BA%E7%BE%A4"><span class="toc-number">1.2.</span> <span class="toc-text">2.面向人群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-java%E5%8F%8Ajvm%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3.java及jvm简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%94%9F%E6%80%81%E5%9C%88"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">java生态圈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%9Ajava"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">跨平台的语言：java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0%EF%BC%9AJVM"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">跨语言的平台：JVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-java%E5%8F%91%E5%B1%95%E7%9A%84%E9%87%8D%E5%A4%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.java发展的重大事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Ejava%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">5.虚拟机与java虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-jvm%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">6.jvm的整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7.java代码执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-jvm%E5%8F%91%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">8.jvm发架构模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-jvm%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9.jvm的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-jvm%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">10.jvm的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sun-Classic-VM"><span class="toc-number">1.10.1.</span> <span class="toc-text">Sun Classic VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exact-VM"><span class="toc-number">1.10.2.</span> <span class="toc-text">Exact VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SUN%E5%85%AC%E5%8F%B8%E7%9A%84HotSpot-VM"><span class="toc-number">1.10.3.</span> <span class="toc-text">SUN公司的HotSpot VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BEA%E7%9A%84JRockit"><span class="toc-number">1.10.4.</span> <span class="toc-text">BEA的JRockit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVM%E5%92%8CICDC-CLDC-Hotspot"><span class="toc-number">1.10.5.</span> <span class="toc-text">KVM和ICDC&#x2F;CLDC Hotspot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Azul-VM"><span class="toc-number">1.10.6.</span> <span class="toc-text">Azul VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TaobaoJVM"><span class="toc-number">1.10.7.</span> <span class="toc-text">TaobaoJVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dalvik-VM"><span class="toc-number">1.10.8.</span> <span class="toc-text">Dalvik VM:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graal-VM"><span class="toc-number">1.10.9.</span> <span class="toc-text">Graal VM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">二、类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1.内存结构概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.类加载器与类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">类加载子系统的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader%E8%A7%92%E8%89%B2"><span class="toc-number">2.2.2.</span> <span class="toc-text">类加载器ClassLoader角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">类加载过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">3.类加载器的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ClassLoader%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">2.4.</span> <span class="toc-text">4.ClassLoader的使用说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Classloader"><span class="toc-number">2.4.1.</span> <span class="toc-text">获取Classloader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">5.双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.1.</span> <span class="toc-text">沙箱安全机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96"><span class="toc-number">2.6.</span> <span class="toc-text">6.其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、运行时数据区概述及线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">四、程序计数器（PC寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-PC-Register-%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">1. PC Register 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">2. 举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">3. 两个常见问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">5.</span> <span class="toc-text">五、虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1.虚拟机栈概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-number">5.1.2.</span> <span class="toc-text">基本内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.1.3.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-number">5.2.</span> <span class="toc-text">2.栈的存储单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.2.</span> <span class="toc-text">栈帧的内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">3.局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Slot"><span class="toc-number">5.3.2.</span> <span class="toc-text">Slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.3.3.</span> <span class="toc-text">静态变量与局部变量的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.4.</span> <span class="toc-text">补充说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">5.4.</span> <span class="toc-text">4.操作数栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA"><span class="toc-number">5.5.</span> <span class="toc-text">5.代码追踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">5.6.</span> <span class="toc-text">6.栈顶缓存技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.7.</span> <span class="toc-text">7.动态链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9A%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%86%E6%B4%BE"><span class="toc-number">5.8.</span> <span class="toc-text">8.方法的调用：解析与分派</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.1.</span> <span class="toc-text">虚方法与非虚方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invokedynamic"><span class="toc-number">5.8.2.</span> <span class="toc-text">invokedynamic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">5.8.3.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">5.8.4.</span> <span class="toc-text">虚方法表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">5.9.</span> <span class="toc-text">9.方法返回地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">5.10.</span> <span class="toc-text">10.一些附加信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.11.</span> <span class="toc-text">11.栈的相关面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">六、本地方法接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">什么是本地方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Native-Method"><span class="toc-number">6.2.</span> <span class="toc-text">为什么要使用Native Method</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">7.</span> <span class="toc-text">七、本地方法栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%A0%86"><span class="toc-number">8.</span> <span class="toc-text">八、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">1. 堆的核心概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="toc-number">8.2.</span> <span class="toc-text">2. 设置堆内存大小与OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">8.3.</span> <span class="toc-text">3. 年轻代与老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9B%BE%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">4. 图解对象分配过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="toc-number">8.5.</span> <span class="toc-text">5. Minor GC、Major GC、Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.5.1.</span> <span class="toc-text">触发条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3GC%EF%BC%88Major-GC-Full-GC%EF%BC%89%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">8.5.1.1.</span> <span class="toc-text">老年代GC（Major GC&#x2F;Full GC）触发机制:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">8.5.1.2.</span> <span class="toc-text">Full GC触发机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-number">8.6.</span> <span class="toc-text">6. 堆空间分代思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">8.6.1.</span> <span class="toc-text">为什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">8.7.</span> <span class="toc-text">7. 内存分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="toc-number">8.8.</span> <span class="toc-text">8. 为对象分配内存：TLAB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%B0%8F%E7%BB%93%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.9.</span> <span class="toc-text">9. 小结堆空间的参数设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="toc-number">8.10.</span> <span class="toc-text">10. 堆是分配对象的唯一选择吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">8.10.1.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">8.10.2.</span> <span class="toc-text">代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E9%99%A4"><span class="toc-number">8.10.2.1.</span> <span class="toc-text">同步消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">8.10.2.2.</span> <span class="toc-text">标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93"><span class="toc-number">8.10.2.3.</span> <span class="toc-text">逃逸分析小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">8.11.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">9.</span> <span class="toc-text">九、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-number">9.1.</span> <span class="toc-text">1. 栈、堆、方法区的交互关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">9.2.</span> <span class="toc-text">2. 方法区的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="toc-number">9.3.</span> <span class="toc-text">3. 设置方法区大小与OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">9.4.</span> <span class="toc-text">4. 方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">9.4.1.</span> <span class="toc-text">方法区的内部结构:</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">stary</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/stary1999" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:stary2020@163.com" target="_blank">E-Mail<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1497447121&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">30</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">36</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">6</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/home">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">繁星点点</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">JVM入门</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2021-07-22 | 更新于 2021-07-27</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/jvm/">jvm</a></div></div></div><div class="main-content"><h1 id="一、jvm概述"><a href="#一、jvm概述" class="headerlink" title="一、jvm概述"></a>一、jvm概述</h1><p>jvm与java体系结构</p>
<ul>
<li>前言</li>
<li>面向人群及参考书目</li>
<li>java及jvm简介</li>
<li>java发展的重大事件</li>
<li>虚拟机与java虚拟机</li>
<li>jvm的整体结构</li>
<li>java代码执行流程</li>
<li>jvm发架构模型</li>
<li>jvm的生命周期</li>
<li>jvm的发展历程</li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>问题：</p>
<ul>
<li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM==（ OOM，全称“Out Of Memory”==，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。）</li>
<li>想解决线上jvm GC问题，但却无从下手</li>
<li>新项目上线，对各种jvm参数设置不了解</li>
<li>面试：实际项目中如何调优jvm参数，如何解决GC、OOM等问题</li>
</ul>
<p>应用程序–》框架–》java API–》jvm</p>
<p>架构师：</p>
<ul>
<li>应该如何让系统更快</li>
<li>如何避免系统出现瓶颈</li>
</ul>
<p>高年薪：</p>
<ul>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定技术方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈。解决各种疑难杂症，性能调优等</li>
</ul>
<p>GC（Garbage Collection）：</p>
<ul>
<li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构，工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是java工程师进阶的必备技能。</li>
</ul>
<h2 id="2-面向人群"><a href="#2-面向人群" class="headerlink" title="2.面向人群"></a>2.面向人群</h2><ul>
<li>拥有一定开发经验的java平台开发人员</li>
<li>软件设计师、架构师</li>
<li>系统调优人员</li>
<li>有一定的java编程基础并希望进一步理解java的程序员</li>
<li>虚拟机爱好者，jvm实践者</li>
</ul>
<p>参考书目：</p>
<p>《The java Virtual Machine Specification》</p>
<p>中文版：《深入理解Java虚拟机》第三版</p>
<h2 id="3-java及jvm简介"><a href="#3-java及jvm简介" class="headerlink" title="3.java及jvm简介"></a>3.java及jvm简介</h2><h4 id="java生态圈"><a href="#java生态圈" class="headerlink" title="java生态圈"></a>java生态圈</h4><ul>
<li>平台</li>
<li>文化</li>
<li>社区</li>
</ul>
<h4 id="跨平台的语言：java"><a href="#跨平台的语言：java" class="headerlink" title="跨平台的语言：java"></a>跨平台的语言：java</h4><p>java程序–》字节码文件–》win版JVM、Linux版JVM、Mac版JVM</p>
<p>java程序可以在多个平台上运行，“一次编译，四处运行”</p>
<h4 id="跨语言的平台：JVM"><a href="#跨语言的平台：JVM" class="headerlink" title="跨语言的平台：JVM"></a>跨语言的平台：JVM</h4><p>不同种类的语言，编译成字节码文件后，都可以在JVM上运行</p>
<p>字节码：</p>
<ul>
<li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说，任何能在JVM平台上执行的字节码格式都是一样的。所以应该统称为：JVM字节码</li>
<li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行</li>
<li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了java虚拟机指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。</li>
</ul>
<p>多语言混合编程：</p>
<ul>
<li>java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向</li>
<li>例如：一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己的语言的原生API一样方便，因为他们最终都运行在一个虚拟机之上。</li>
<li>对这些运行与java虚拟机之上、java之外的语言，来自系统级的、底层的支持正在快速增强，以JSR-292为核心的一系列项目和功能改进，推动Java虚拟机从“java语言的虚拟机”向“多语言虚拟机”的方向发展</li>
</ul>
<h2 id="4-java发展的重大事件"><a href="#4-java发展的重大事件" class="headerlink" title="4.java发展的重大事件"></a>4.java发展的重大事件</h2><ul>
<li>1990年，在Sun计算机公司中，由Patrick Naughton、 MikeSheridan及James Gosling 领导的小组Green Team,开发出的新的程序语言，命名为0ak,后期命名为Java</li>
<li>1995年，Sun正式发 布Java和HotJava产品，Java 首次公开亮相。</li>
<li>1996年1月23日Sun Microsystems发布 了JDK 1.0。</li>
<li>1998年，JDK 1.2版本发布。同时，Sun发布了JSP/Servlet、 EJB规范，以及将Java分成了J2EE、 J2SE和J2ME。这 表明了Java开始向企业、 桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK 1.3发布，Java HotSpot Virtual Machinei正式发布，成为Java的默认虚拟机。</li>
<li>2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台。</li>
<li>2003年年底，Java平台的Scalai正式发布，同年Groovy也加入了Java阵营。</li>
<li>2004年，JDK 1.5发布。同时JDK 1.5改 名为JavaSE 5.0。</li>
<li>2006年，JDK 6发布。同年，Java开源并建立了OpenJDK。 顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li>
<li>2007年，Java平台迎来了新伙伴Clojure。</li>
<li>2008年，Oracle收购了BEA, 得到了JRockit 虚拟机。</li>
<li>2009年，Twitter宜布把后台大部分程序从Ruby迁移到Scala,这是Java平台的又一次大规模应用。.</li>
<li>2010年，oracle收购了Sun,获得Java商标和最具价值的Hotspot虚拟机。此时，0racle拥有市场占用率最高的两款虚拟机Hotspot和JRockit,并计划在未来对它们进行整合: HotRockit</li>
<li>2011年，JDK7发布。在JDK 1.7u4中，正式启用了新的垃圾回收器G1。</li>
<li>2014年三月，JDK8发布。历史性版本。</li>
<li>2017年，JDK9发布。将G1设置为默认GC，替代CHS</li>
<li>同年，IBM的J9开源，形成了现在的open J9社区</li>
<li>2018年，Android的Java侵权案判决，Google赔偿oracleit88亿美元</li>
<li>同年，Oracle宣告JavaEE成为历史名词，JDBC、 JMS、Servlet赠了Eclipse基金会</li>
<li>同年，JDK11发布， LTS版木的JDK, 发布革命性的zGC,调整JDK授权许可</li>
<li>2019年，JDK12发布， 加入RedHat领导开发的Shenandoah GC<br>A</li>
</ul>
<h2 id="5-虚拟机与java虚拟机"><a href="#5-虚拟机与java虚拟机" class="headerlink" title="5.虚拟机与java虚拟机"></a>5.虚拟机与java虚拟机</h2><ul>
<li>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机，它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机<ul>
<li>Visual Box，VMware就属于系统虚拟机，他们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令</li>
</ul>
</li>
<li>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中</li>
<li>JVM是运行在操作系统之上的，它与硬件没有直接的交互</li>
</ul>
<h2 id="6-jvm的整体结构"><a href="#6-jvm的整体结构" class="headerlink" title="6.jvm的整体结构"></a>6.jvm的整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一</li>
<li>它采用解释器与即时编译器并存的架构</li>
<li>在今天，Java程序的运行性能已经渐渐达到了可以和C、C++一较高下的地步</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210722191927638.png" alt="image-20210722191927638"></p>
<h2 id="7-java代码执行流程"><a href="#7-java代码执行流程" class="headerlink" title="7.java代码执行流程"></a>7.java代码执行流程</h2><ul>
<li>java源码</li>
<li>java编译器<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语法、抽象语法树</li>
<li>语义分析</li>
<li>注解抽象语法树</li>
<li>字节码生成器</li>
</ul>
</li>
<li>字节码</li>
<li>Java虚拟机<ul>
<li>类加载器</li>
<li>字节码校验器</li>
<li>翻译字节码</li>
<li>JIT编译器（编译执行）</li>
</ul>
</li>
<li>操作系统</li>
</ul>
<p>注意：</p>
<ul>
<li>java编译器编译过程中，任何一个节点执行失败就会造成编译失败</li>
<li>虽然各个平台的Java虚拟机内部实现细节不尽相同，但是他们共同执行的字节码内容却是一样的</li>
<li>JVM的主要任务就是负责将字节码装载到其内部，解释、编译为对应平台上的机器指令。即：汇编语言，执行。</li>
<li>Java虚拟机使用类加载器（Class Loader）装载class文件</li>
<li>类加载完成之后，会进行字节码校验，字节码校验通过之后，JVM解释器会把字节码翻译成机器码，即汇编语言，交由操作系统执行</li>
<li>但不是所有的代码都是解释执行的，JVM对此做了优化，比如，以HotSpot虚拟机来说，它本身提供了JIT（Just In Time）</li>
</ul>
<h2 id="8-jvm发架构模型"><a href="#8-jvm发架构模型" class="headerlink" title="8.jvm发架构模型"></a>8.jvm发架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集结构则是基于寄存器的指令集架构</p>
<p>具体来说，这两种架构之间的区别：</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题，使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令。其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li>
<li>指令集架构则完全依赖硬件，可移植差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ul>
</li>
</ul>
<p>举例，同样执行2+3这种逻辑操作，其指令分别如下：</p>
<ul>
<li><p>基于栈式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istor_l</span><br><span class="line">iconst_3  <span class="comment">//常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2、3出栈，执行相加</span></span><br><span class="line">istore_0<span class="comment">//结果5入栈</span></span><br></pre></td></tr></table></figure></li>
<li><p>基于寄存器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为2</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值+3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结</p>
<ul>
<li>==由于跨平台性的设计，Java的指令都是根据栈来设计的==。不同平台的CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样功能需要更多的指令。</li>
</ul>
<p>栈：</p>
<ul>
<li>跨平台性能，指令集小，指令多，执行性能比寄存器差</li>
</ul>
<h2 id="9-jvm的生命周期"><a href="#9-jvm的生命周期" class="headerlink" title="9.jvm的生命周期"></a>9.jvm的生命周期</h2><p>虚拟机的启动：</p>
<ul>
<li>Java虚拟机的启动是通过引导类加载器（BootStrap class loader）创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的</li>
</ul>
<p>虚拟机的执行</p>
<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行时它才运行，程序结束时他就停止</li>
<li>==执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程==</li>
</ul>
<h2 id="10-jvm的发展历程"><a href="#10-jvm的发展历程" class="headerlink" title="10.jvm的发展历程"></a>10.jvm的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul>
<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为Sun Classic VM的Java虚拟机，它同时也是世界上第- -款商用Java虚拟机，JDK1 . 4时完全被淘汰。</li>
<li>这款虚拟机内部只提供解释器。</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在hotspot内置了此虚拟机。</li>
</ul>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul>
<li>为了解决 上一个虚拟机问题，jdk1.2时, sun提供了此虚拟机。</li>
<li>Exact Memory Management: 准确式内存管理<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li>
</ul>
</li>
<li>具备现代高性能虚拟机的雏形<ul>
<li>热点探测</li>
<li>编译器与解释器混合工.作模式</li>
<li>只在Solaris平台短暂使用， 其他平台上还是classic vm .</li>
<li>英雄气短，终被Hotspot虚拟机替换</li>
</ul>
</li>
</ul>
<h3 id="SUN公司的HotSpot-VM"><a href="#SUN公司的HotSpot-VM" class="headerlink" title="SUN公司的HotSpot VM"></a>SUN公司的HotSpot VM</h3><ul>
<li>HotSpot历史<ul>
<li>最初由一家名为”Longview tchnologies”的小公司设计</li>
<li>1997年, 此公司被Sun收购:;2009年, Sun公司被甲骨文收购。</li>
<li>JDK1.3时，HotSpot VIM成为默认虚拟机</li>
</ul>
</li>
<li>目前Hotspot占有绝对的市场地位，称霸武林。<ul>
<li>不管是现在仍在广泛使用的JDK6,还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>
<li>Sun/oracle JDK和OpenJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是HotSpot,相关机制也主要是指HotSpot的GC机制。(比如其他两个商用虚拟机都没有方法区的概念)</li>
</ul>
</li>
<li>从服务器、桌而到移动端、嵌入式都有应用。</li>
<li>名称中的HotSpot指的就是它的热点代码探测技术。<ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上:替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
</li>
</ul>
<h3 id="BEA的JRockit"><a href="#BEA的JRockit" class="headerlink" title="BEA的JRockit"></a>BEA的JRockit</h3><ul>
<li><p>专注于服务器端应用</p>
<ul>
<li>它可以不太关注程序启动速度，囚此JRockit内部不包含解析器实现， 全部代码<br>都靠即时编译器编译后执行。|</li>
</ul>
</li>
<li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高(一些超过了70号)和硬件成本的减少(达50%)。</li>
</ul>
</li>
<li><p>优势:全面的Java运行时解决方案组合</p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或 微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 </li>
<li>MissionContro1服务套件，它是一组以极低的开销来监控、管理和分析生产 环境中的应用程序的L具。 </li>
</ul>
</li>
<li><p>2008年，BEA被Oracle收购，</p>
</li>
<li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在 HotSpot的基础上,移JRockit的优秀特性。 </p>
</li>
<li><p>高斯林:目前就职于谷歌，研究人工智能和水下机器人 </p>
</li>
</ul>
<h3 id="KVM和ICDC-CLDC-Hotspot"><a href="#KVM和ICDC-CLDC-Hotspot" class="headerlink" title="KVM和ICDC/CLDC Hotspot"></a>KVM和ICDC/CLDC Hotspot</h3><ul>
<li>Oracle在Java ME产品线上:的两款虚拟机为: CDC/CLDC HotSpot Implementation VM</li>
<li>KVM (Kilobyte) 是CLDC-HI早期产品</li>
<li>目前移动领域地位尴尬，智能手机被Android和ios.二分天下。</li>
<li>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
<li>所有的虚拟机的原则:一次编译,到处运行。</li>
</ul>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul>
<li>前面三大“高性能Java虚拟机”使用在通用硬件平台上</li>
<li>这里Azul VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机<ul>
<li>高性能Java虚拟机中的战斗机。</li>
</ul>
</li>
<li>Azul VM是Azul Systems公司在Hotspot基础上进行大量改进，运行于 Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li>
<li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的C时间的垃圾收集器、传有硬件优化的线程调度等优秀特性。</li>
<li>2010年，Azul systems公司开始从硬件转向软件， 发布了自己的zing JVM，可以在通用x86平台 上提供接近于Vega系统的特性。</li>
</ul>
<h3 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h3><ul>
<li><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司， 覆盖云计算，金融、物流、电商等众多领城，需要解决高并发、 高可用、分布式的复合问题。有大量的开源产品。</p>
</li>
<li><p>基于OpenJDK开发了自己的定制版本AlibabaJDK, 简称AJDK. 是整个阿里Java体<br>系的基石。</p>
</li>
<li><p>基于OpenfDK HotSpot VM发布的国内第一 个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>创新的GCIH (GC invisible heap ) 技术实现了off-heap ,即将生命周期较长的Java对象Wheap中移到heap之外，并ALGC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li>
<li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li>
<li>使用crc32指令实现JVM intrinsic降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助功能</li>
<li>针对大数据场录的ZenGC</li>
</ul>
</li>
<li><p>taobao vm应用在阿里产品上:性能高， 硬件严重依赖intel的cpu, 损失了兼容性,但<br>提高了性能</p>
<ul>
<li>目前已经在淘宝、天猫上线， 把oracle 官方JVM版本全部替换了。</li>
</ul>
</li>
</ul>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM:"></a>Dalvik VM:</h3><ul>
<li><p>谷歌开发的，应用于FAndroid系统，并在Android2.2中提供了JIT, 发展迅猛。</p>
</li>
<li><p>Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循Java虚拟机规范</p>
</li>
<li><p>不能直接执行Java 的Class文件</p>
</li>
<li><p>基于寄存器架构,不是jvm的栈架构。</p>
</li>
<li><p>执行的是编译以后的dex (Dalvik Executable) 文件。执行效率比较高。</p>
<ul>
<li>它执行的dex (Dalvik Executable)文件可以通过Class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>
</ul>
</li>
<li><p>Android 5.0使用支持提前编译(Ahead Of Time Compilation, AOT)的ART VM替换Dalvik WM。</p>
</li>
</ul>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul>
<li><p>2018年4月，Oracle Labs公开了Graal VM,号称”Run Programs Faster Anywhere”,勃勃野心。与1995年java的” write once, run anywhere” 遏相呼应。</p>
</li>
<li><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”<br>的运行平台使用。语言包括: Java、 Scala, Groovy, Kotlin; C. C++.JavaScript、Ruby、 Python、 R等</p>
</li>
<li><p>支持不同语言中混用对方的接口和对象， 支持这些语言使用已经编写好的木地库文件</p>
</li>
<li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
</li>
<li><p>如果说HotSpot有一天 真的被取代，Graal VM希 望最大。但是Java的软件生态没有丝毫变化。</p>
</li>
</ul>
<h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><ul>
<li>内存结构概述</li>
<li>类加载器与类的加载过程</li>
<li>类加载器分类</li>
<li>ClassLoader的使用说明</li>
<li>双亲委派机制</li>
<li>其他</li>
</ul>
<h2 id="1-内存结构概述"><a href="#1-内存结构概述" class="headerlink" title="1.内存结构概述"></a>1.内存结构概述</h2><p><img src="/2021/07/22/JVM/image-20210722112228303.png" alt="image-20210722112228303"></p>
<p><img src="/2021/07/22/JVM/image-20210722112240202.png" alt="image-20210722112240202"></p>
<p>如果自己动手写一个java虚拟机，主要考虑结构：类加载器、执行引擎</p>
<h2 id="2-类加载器与类的加载过程"><a href="#2-类加载器与类的加载过程" class="headerlink" title="2.类加载器与类的加载过程"></a>2.类加载器与类的加载过程</h2><h3 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h3><p><img src="/2021/07/22/JVM/image-20210722112816870.png" alt="image-20210722112816870"></p>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件所在问价开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于文件是否可运行，则由Execution Engine决定</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li>
</ul>
<h3 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h3><ol>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</li>
<li>class file加载到jvm中，被称为DNA元数据模板，放在方法区</li>
<li>在.class文件–》JVM–》最终成为元数据模板，此过程就需要一个运输工具（类装载器Class Loader），扮演一个快递员的角色</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul>
<li>加载</li>
<li>链接<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210722113355272.png" alt="image-20210722113355272"></p>
<p>加载：</p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
<li>加载.class文件的方式：<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础、</li>
<li>运行时计算生成，使用得最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：jsp应用</li>
<li>从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
</li>
</ol>
<p>验证：</p>
<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</li>
</ul>
<p>准备：</p>
<ul>
<li>为类变量分配内存并设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为final在编译时就会自动分配了，准备阶段会显式初始化</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li>
</ul>
<p>解析：</p>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上没解析操作往往会伴随着jvm在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_indo、CONSTANT_Methodref_info等。</li>
</ul>
<h2 id="3-类加载器的分类"><a href="#3-类加载器的分类" class="headerlink" title="3.类加载器的分类"></a>3.类加载器的分类</h2><ul>
<li>jvm支持两种类型的类加载器，分别为引导类加载器（Bootstrap Classloader）和自定义类加载器（User-Defined Classloader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范将所有派生于抽象类Classloader的类加载器都划分为自定义类加载器</li>
<li>程序中常见的类加载器只有三个：Bootstrap Classloader、Extension Classloader、System Classloader。都是继承于Classloader。</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210722094252090.png" alt="image-20210722094252090"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机自带的加载器</p>
<ul>
<li>启动类加载器（引导类加载器，Bootstrap Classloader）<ul>
<li>这个类加载使用c/c++语言实现，嵌套在jvm内部</li>
<li>它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar、resource.jar或sun.boot.class.path路径下的内容），用于提供自身需要的类</li>
<li>并不继承自java.lang.Classloader，没有父加载器</li>
<li>加载拓展类和程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun、等开头的类</li>
</ul>
</li>
<li>拓展类加载器（Extension Classloader)<ul>
<li>java语言编写，由sun.misc.Launcher$ExtClassloader实现</li>
<li>派生与Classloader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（拓展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
</li>
<li>应用程序类加载器（系统类加载器，AppClassloader）<ul>
<li>java语言编写，由sun.misc.launcher$AppClassloader实现</li>
<li>派生与ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性：java.class.path 指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载</li>
<li>通过Classloader#getSystemClassloader（）方法可以获取到该类加载器</li>
</ul>
</li>
</ul>
<p>用户自定义类加载器</p>
<ul>
<li>在java的日常应用程序开发中，类加载几乎是由上述三种类加载器互相配合执行的，在必要时，用户可以自定义类加载器，来定制类的加载方式</li>
<li>原因：<ul>
<li>隔离加载类</li>
<li>修改类的加载方式</li>
<li>扩展加载源</li>
<li>放置源码泄露</li>
</ul>
</li>
<li>实现<ol>
<li>继承抽象类java.lang.ClassLoader类</li>
<li>在jdk1.2之前，在自定义类加载器时，总会去继承Classloader类并重写loadClass（）方法，从而实现自定义的类加载类。在jdk1.2之后，建议吧自定义的类加载逻辑写在findClass（）方法中</li>
<li>在编写自定义类加载类时，如果没有太多过于复杂的需求，可以直接继承URLClassloader类，避免自己编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
</li>
</ul>
<h2 id="4-ClassLoader的使用说明"><a href="#4-ClassLoader的使用说明" class="headerlink" title="4.ClassLoader的使用说明"></a>4.ClassLoader的使用说明</h2><p>ClassLoader：一个抽象类，其后所有的类加载器都继承自Classloader（不包括启动类加载器Bootstrap ClassLoader）</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent（）</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass（String name)</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name,byte[] b,int off,int len)</td>
<td>把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resloveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个java类</td>
</tr>
</tbody></table>
<p>sun.misc,Launcher是一个java虚拟机的入口应用</p>
<h3 id="获取Classloader"><a href="#获取Classloader" class="headerlink" title="获取Classloader"></a>获取Classloader</h3><ol>
<li>获取当前类的ClassLoader：clazz.getClassLoader()</li>
<li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li>
<li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li>
<li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li>
</ol>
<h2 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.双亲委派机制</h2><p>java虚拟机对class文件采用的是按需加载的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式</p>
<ul>
<li><p>工作原理</p>
<ol>
<li>如果一个类加载器收到了类加载的请求，它不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，则成功返回，否则，其子类加载器尝试自己去加载</li>
</ol>
<p><img src="/2021/07/22/JVM/image-20210722110502837.png" alt="image-20210722110502837"></p>
</li>
<li><p>优势</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
</li>
</ul>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类，这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><ul>
<li>在JVM中表示两个class对象是否为同一个了存在的两个必要条件：<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader必须相同</li>
</ul>
</li>
<li>在JVM中，即使两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</li>
<li>对类加载器的引用：JVM必须要知道一个类型是由启动加载器加载还是由用户类加载器加载的。如果一个类型是由用户加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
<li>类的主动使用和被动使用：<ul>
<li>主动使用：<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>java虚拟机启动时被标明为启动类的类</li>
<li>jdk7开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果<br>REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ol>
</li>
<li>除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化</li>
</ul>
</li>
</ul>
<h1 id="三、运行时数据区概述及线程"><a href="#三、运行时数据区概述及线程" class="headerlink" title="三、运行时数据区概述及线程"></a>三、运行时数据区概述及线程</h1><ul>
<li>概述</li>
<li>线程</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2021/07/22/JVM/image-20210723135417340.png" alt="image-20210723135417340"></p>
<p><img src="/2021/07/22/JVM/image-20210723135453262.png" alt="image-20210723135453262"></p>
<ul>
<li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对内存的划分方式和管理机制存在着部分差异。</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210723135831346.png" alt="image-20210723135831346"></p>
<p><img src="/2021/07/22/JVM/image-20210723135839778.png" alt="image-20210723135839778"></p>
<ul>
<li>java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而自动创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li>
<li>下图中，灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210723140233739.png" alt="image-20210723140233739"></p>
<p>关于线程间共享的说明：</p>
<p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的部分：运行时环境。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li>
<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
</li>
<li>操作系统负责所有的线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</li>
</ul>
<p>守护线程、普通线程：</p>
<ul>
<li>如果使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用pubic static void main（String[] args)的main线程以及所有这个main线程自己创建的线程。</li>
<li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-word”的垃圾收集，线程收集，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
</li>
</ul>
<h1 id="四、程序计数器（PC寄存器）"><a href="#四、程序计数器（PC寄存器）" class="headerlink" title="四、程序计数器（PC寄存器）"></a>四、程序计数器（PC寄存器）</h1><ul>
<li>PC Register 介绍</li>
<li>举例说明</li>
<li>两个常见问题</li>
</ul>
<h2 id="1-PC-Register-介绍"><a href="#1-PC-Register-介绍" class="headerlink" title="1. PC Register 介绍"></a>1. PC Register 介绍</h2><ul>
<li>JVm中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能运行。</li>
<li>这里，并非是广义上所指的物理寄存器，将之称为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中PC寄存器是对物理PC寄存器的一种抽象模拟。</li>
<li>作用：<ul>
<li>PC寄存器用来存储向下一条指令的地址，也即将要执行的指令的代码。由执行引擎读取下一条指令。</li>
</ul>
</li>
<li>说明：<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有他自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果实在执行native方法，则是未知的值（underfined）。</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域</li>
</ul>
</li>
</ul>
<h2 id="2-举例说明"><a href="#2-举例说明" class="headerlink" title="2. 举例说明"></a>2. 举例说明</h2><p><img src="/2021/07/22/JVM/image-20210723142904937.png" alt="image-20210723142904937"></p>
<p><img src="/2021/07/22/JVM/image-20210723163819844.png" alt="image-20210723163819844"></p>
<h2 id="3-两个常见问题"><a href="#3-两个常见问题" class="headerlink" title="3. 两个常见问题"></a>3. 两个常见问题</h2><ul>
<li><p>使用PC寄存器存储字节码指令地址有什么用？</p>
</li>
<li><p>为什么使用PC寄存器记录当前线程的执行地址？</p>
<ul>
<li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li>
<li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li>
</ul>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<ul>
<li>所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复。为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法便是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li>
<li>由于CPU时间片轮限制，众多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li>
<li>这样必然导致经常中断或恢复。如何保证分毫不差？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li>
</ul>
</li>
<li><p>CPU时间片</p>
<ul>
<li>CPU时间片，即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片</li>
<li>在宏观上，PC上可以打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>在微观上，，由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法是引入时间片，每个程序轮流执行。</li>
</ul>
</li>
<li><p>==并行和并发==</p>
<ul>
<li>并行：vs串行</li>
<li>并发：cpu快速切换以达到模拟并行的效果</li>
</ul>
</li>
</ul>
<h1 id="五、虚拟机栈"><a href="#五、虚拟机栈" class="headerlink" title="五、虚拟机栈"></a>五、虚拟机栈</h1><ul>
<li>1.虚拟机栈概述</li>
<li>2.栈的存储单位</li>
<li>3.局部变量表</li>
<li>4.操作数栈</li>
<li>5.代码追踪</li>
<li>6.栈顶缓存技术</li>
<li>7.动态链接</li>
<li>8.方法的调用：解析与分派</li>
<li>9.方法返回地址</li>
<li>10.一些附加信息</li>
<li>11.栈的相关面试题</li>
</ul>
<h2 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1.虚拟机栈概述"></a>1.虚拟机栈概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</li>
<li>==优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令==。</li>
</ul>
<h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul>
<li>栈是运行时的单位，堆是存储的单位。<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储问题，即数据怎么放、放在哪。</li>
</ul>
</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li>Java虚拟机栈是什么？<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</li>
<li>是线程私有的</li>
</ul>
</li>
<li>生命周期<ul>
<li>生命周期与线程一致</li>
</ul>
</li>
<li>作用<ul>
<li>主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址【对象实际存储在堆空间中】、部分结果，并参与方法的调用和返回。</li>
<li>局部变量：vs成员变量（或属性）</li>
<li>基本数据变量：vs引用类型变量（类、数组、接口）</li>
</ul>
</li>
<li>特点<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>每个方法执行：伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾收集的问题<ul>
<li>==栈可能存在OOM，但是不存在GC==</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>面试题：开发中遇到的异常有哪些？</p>
<p>栈中可能出现的异常：</p>
<ul>
<li>Java虚拟机规范允许Java栈的大小是动态的或者固定不变的。<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出一个==StackOverflowError异常==。</li>
<li>如果Java虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个==OutOfMemoryError异常==</li>
<li><img src="/2021/07/22/JVM/image-20210723151032215.png" alt="image-20210723151032215"></li>
</ul>
</li>
<li>设置栈内存大小<ul>
<li>我们可以使用参数-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li>
<li><img src="/2021/07/22/JVM/image-20210723151235829.png" alt="image-20210723151235829"></li>
</ul>
</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210723182611919.png" alt="image-20210723182611919"></p>
<p><img src="/2021/07/22/JVM/2021-06-29-hexoInstallAndUse/image-20210723182652414.png" alt="image-20210723182652414"></p>
<p><img src="/2021/07/22/JVM/image-20210723182728027.png" alt="image-20210723182728027"></p>
<h2 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2.栈的存储单位"></a>2.栈的存储单位</h2><p>栈中存储什么？</p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<p>复习：</p>
<ul>
<li>OOP（Object Oriented Programming）的基本概念：类、对象</li>
<li>类中的基本结构：field（属性、字段、域）、method</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的==压栈==和==出栈==，遵循==“先进后出”/“后进先出”原则==</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为==当前栈帧（Current Frame）==，与当前栈帧对应的方法就是==当前方法（Current Method）==，定义这个方法的类就是==当前类（Current Class)==。</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前帧。</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210723152139975.png" alt="image-20210723152139975"></p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式，==一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。==</li>
</ul>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p>
<ul>
<li>==局部变量表（Local Variables）==</li>
<li>==操作数栈（Operand Stack）（或表达式栈）==</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210723152831789.png" alt="image-20210723152831789"></p>
<h2 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3.局部变量表"></a>3.局部变量表</h2><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>==定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量==，这些数据类型包括各类基本数据类型、对象引用（Reference)，以及returnAddress类型</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此==不存在数据安全问题==</li>
<li>==局部变量表所需要的容量大小是在编译期确定下来的==，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>==方法嵌套调用的次数由栈的大小决定==。一般来说，==栈越大，方法嵌套调用次数越多==。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数会减少。</li>
<li>==局部变量表中的变量只在当前方法调用中有效==。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。==当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。==</li>
</ul>
<h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li>
<li>局部变量表，最基本的存储单元是Slot（变量槽）</li>
<li>局部变量中存放编译器可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量</li>
<li>在局部变量里，==32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。==<ul>
<li>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占两个slot</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会==按照顺序被复制==到局部变量表中的每一个slot上</li>
<li>==如果需要访问局部变量中一个64bit的局部变量值，只需要使用前一个索引即可==</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么==该对象引用this将会存放在index为0的slot处==，其余的参数按照参数表顺序继续排列</li>
</ul>
<p>Slot的重复利用</p>
<ul>
<li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</li>
</ul>
<h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><ul>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li>
<li>我们知道类变量表有两次初始化的机会，第一次是在“==准备阶段==”，执行系统初始化，对类变量设置零值，来一次则是在“==初始化==”阶段，赋予程序员在代码中定义的初始值。</li>
<li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</li>
<li><img src="/2021/07/22/JVM/image-20210723155347082.png" alt="image-20210723155347082"></li>
</ul>
<p>变量的分类：</p>
<ul>
<li>按照数据类型分：<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>类变量：linking的prepare阶段，给类变量赋默认值—》initial阶段，给类变量显式赋值即静态代码赋值</li>
<li>实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>局部变量：在使用前，必须进行显式赋值，否则编译不通过</li>
</ul>
</li>
</ul>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li>==局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。==</li>
</ul>
<h2 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4.操作数栈"></a>4.操作数栈</h2><ul>
<li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个==后进先出==的操作数栈，也可以称之为==表达式栈==</li>
<li>==操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop)==<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用他们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>操作数栈，==主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。==</li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，==这个方法的操作数栈是空的==</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值</li>
<li>栈中任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈==并非采用访问索引的方式来进行数据访问==的，而是只能通过标准的入栈（push）和出栈（pop)操作来完成一次数据访问</li>
</ul>
<hr>
<ul>
<li>==如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中==，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>另外，我们说Java虚拟机的==解释引擎是基于栈的执行引擎==，其中的栈指的就是操作数栈。</li>
</ul>
<h2 id="5-代码追踪"><a href="#5-代码追踪" class="headerlink" title="5.代码追踪"></a>5.代码追踪</h2><p><img src="/2021/07/22/JVM/image-20210723195639171.png" alt="image-20210723195639171"></p>
<p><img src="/2021/07/22/JVM/2021-06-29-hexoInstallAndUse/image-20210723195646274.png" alt="image-20210723195646274"></p>
<p><img src="/2021/07/22/JVM/image-20210723195701605.png" alt="image-20210723195701605"></p>
<p><img src="/2021/07/22/JVM/image-20210723195719108.png" alt="image-20210723195719108"></p>
<p><img src="/2021/07/22/JVM/image-20210723195728664.png" alt="image-20210723195728664"></p>
<p>常见i++和++i的区别</p>
<h2 id="6-栈顶缓存技术"><a href="#6-栈顶缓存技术" class="headerlink" title="6.栈顶缓存技术"></a>6.栈顶缓存技术</h2><ul>
<li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，Hotspot JVM的设计者们提出了栈顶缓存技术，==将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。==</li>
</ul>
<h2 id="7-动态链接"><a href="#7-动态链接" class="headerlink" title="7.动态链接"></a>7.动态链接</h2><ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如invokedynamic指令</li>
<li>在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li>
</ul>
<hr>
<p>为什么需要常量池？</p>
<p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
<h2 id="8-方法的调用：解析与分派"><a href="#8-方法的调用：解析与分派" class="headerlink" title="8.方法的调用：解析与分派"></a>8.方法的调用：解析与分派</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li>==静态链接==<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
</ul>
</li>
<li>==动态链接==<ul>
<li>如果被调用的方法在编译期间无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
</li>
</ul>
<hr>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<ul>
<li>==早期绑定==<ul>
<li>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li>==晚期绑定==<ul>
<li>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
</li>
</ul>
<hr>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然==这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。==</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<hr>
<h3 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h3><p>非虚方法：</p>
<ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法</li>
</ul>
<p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例<br><img src="/2021/07/22/JVM/image-20210724102300938.png" alt="image-20210724102300938"></p>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>普通调用指令：<ol>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用&lt;init&gt;方法，私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用所有接口方法</li>
</ol>
</li>
<li>动态调用指令：<ol start="5">
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ol>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p>
<h3 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h3><ul>
<li>JVM字节码指令集一直比较稳定，知道Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。知道Java8的Lambda表达式出现，invokedynamic指令的生成在Java中才有了直接的生成方式。</li>
<li>Java7中增加对动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言编译器。</li>
</ul>
<p>动态类型语言和静态类型语言：</p>
<ul>
<li>动态类型语言和静态类型语言两者的区别就在于对类型的检查是编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言</li>
<li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li>
</ul>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>Java语言中方法重写的本质：</p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p>IllegalAccessError：</p>
<ul>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
</ul>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（Virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>虚方法表的创建：<ul>
<li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li>
</ul>
</li>
</ul>
<h2 id="9-方法返回地址"><a href="#9-方法返回地址" class="headerlink" title="9.方法返回地址"></a>9.方法返回地址</h2><ul>
<li>存放调用该方法的PC寄存器的值</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，==调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址==。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<hr>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>==正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。==</p>
<hr>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口。<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是Boolean、byte、char、short和int类型时使用、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ul>
</li>
<li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口</li>
</ol>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<hr>
<p>本质上，方法的退出就是当前栈帧出栈的过程。，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值</p>
<h2 id="10-一些附加信息"><a href="#10-一些附加信息" class="headerlink" title="10.一些附加信息"></a>10.一些附加信息</h2><p><img src="/2021/07/22/JVM/image-20210724111024676.png" alt="image-20210724111024676"></p>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<h2 id="11-栈的相关面试题"><a href="#11-栈的相关面试题" class="headerlink" title="11.栈的相关面试题"></a>11.栈的相关面试题</h2><ul>
<li>举例栈溢出的情况？（StackOverflowError)<ul>
<li>通过-Xss设置栈的大小；OOM</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出吗？不能</li>
<li>分配的栈内存越大越好吗？不是</li>
<li>垃圾回收是否会设计到虚拟机栈？不会的</li>
<li>方法中定义的局部变量是否线程安全？具体问题具体分析。</li>
</ul>
<h1 id="六、本地方法接口"><a href="#六、本地方法接口" class="headerlink" title="六、本地方法接口"></a>六、本地方法接口</h1><p><img src="/2021/07/22/JVM/image-20210724123523449.png" alt="image-20210724123523449"></p>
<h2 id="什么是本地方法？"><a href="#什么是本地方法？" class="headerlink" title="什么是本地方法？"></a>什么是本地方法？</h2><ul>
<li>简单地讲，一个Native Method 就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法；该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这样一个机制，比如在C++中，你可以使用extern “C”告知C++编译器去调用C的一个函数。</li>
<li>“A native method is a Java method whose implementation is provided by non-java code.”</li>
<li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java所用，它的初衷是融合C/C++程序。</li>
</ul>
<p>例子：</p>
<p><img src="/2021/07/22/JVM/image-20210724125029029.png" alt="image-20210724125029029"></p>
<p>==标识符native可以与所有其它的java标识符连用，但是abstract除外==</p>
<h2 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>与Java环境外交互：<ul>
<li>==有时候Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。==你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
</ul>
</li>
<li>与操作系统交互<ul>
<li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。==通过使用本地方法，我们得以用Java实现了jre的域底层系统的交互，甚至JVM的一些部分就是用C写的。==还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</li>
</ul>
</li>
<li>sun’s Java<ul>
<li>S==un的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互==。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriorty（）。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法啊最终将调用win32 SetPriority（） API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ul>
</li>
</ul>
<p>现状：</p>
<ul>
<li>==目前该方法的使用越来越少了，除非是与硬件有关的应用，==比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以在使用Socket通信，也可以使用Web Service等等。</li>
</ul>
<h1 id="七、本地方法栈"><a href="#七、本地方法栈" class="headerlink" title="七、本地方法栈"></a>七、本地方法栈</h1><ul>
<li>==Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。==</li>
<li>本地方法栈，也是线程私有的</li>
<li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常</li>
</ul>
</li>
<li>本地方法是使用C语言实现的</li>
<li>它的具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载本地方法库</li>
</ul>
<hr>
<ul>
<li>==当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。==<ul>
<li>本地方法可以通过本地方法接口来==访问虚拟机内部的运行时数据区==</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</li>
<li>==并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等==。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li>
<li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li>
</ul>
<h1 id="八、堆"><a href="#八、堆" class="headerlink" title="八、堆"></a>八、堆</h1><ul>
<li>堆的核心概述</li>
<li>设置堆内存大小与OOM</li>
<li>年轻代与老年代</li>
<li>图解对象分配过程</li>
<li>Minor GC、Major GC、Full GC</li>
<li>堆空间分代思想</li>
<li>内存分配策略</li>
<li>为对象分配内存：TLAB</li>
<li>小结堆空间的参数设置</li>
<li>堆是分配对象的唯一选择吗</li>
</ul>
<h2 id="1-堆的核心概述"><a href="#1-堆的核心概述" class="headerlink" title="1. 堆的核心概述"></a>1. 堆的核心概述</h2><p><img src="/2021/07/22/JVM/image-20210724184900268.png" alt="image-20210724184900268"></p>
<ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。<ul>
<li>从实际使用角度看，应该是“几乎”所有的对象实例都在这里分配内存。</li>
</ul>
</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210724185643895.png" alt="image-20210724185643895"></p>
<p>现代垃圾收集器大部分都是基于分代收集理论设计，堆空间细分为：</p>
<p>Java7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区 Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure Generation Space 养老区 Old/Tenure</li>
<li>Permanent Space  永久区  Perm</li>
</ul>
<p>Java8及之后堆内存逻辑上分为三个部分：新生区+养老区+元空间</p>
<ul>
<li>Young Generation Space 新生区 Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure Generation Space 养老区 Old/Tenure</li>
<li>Meta Space 元空间  Meta</li>
</ul>
<p>约定：</p>
<ul>
<li>新生区=新生代=年轻代</li>
<li>养老区=老年区=老年代</li>
<li>永久区=永久代</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210724190408530.png" alt="image-20210724190408530"></p>
<h2 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2. 设置堆内存大小与OOM"></a>2. 设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xmx”用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li>
<li>“-Xms”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过”-Xms”所指定的最大内存时，将会抛出OutOfMemoryError异常</p>
<p>通常会将”-Xmx”和”-Xms”两个参数配置相同的值，其==目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。==</p>
<p>默认情况下，初始内存大小：物理电脑内存大小/64。最大内存大小：物理电脑内存大小/4。</p>
<p>OOM举例</p>
<p><img src="/2021/07/22/JVM/image-20210724191238285.png" alt="image-20210724191238285"></p>
<h2 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3. 年轻代与老年代"></a>3. 年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代和老年代</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）<br><img src="/2021/07/22/JVM/image-20210724191604855.png" alt="image-20210724191604855"></p>
<p>下面这些参数开发中一般不会调：<br><img src="/2021/07/22/JVM/image-20210724191702658.png" alt="image-20210724191702658"></p>
<p>新时代与老年代在堆结构的占比：</p>
<ul>
<li>默认-XX:NewRatio=2，表示新时代占1，老年代占2，新时代占整个堆的1/3</li>
<li>可以修改-XX:NewRatio=4，表示新时代占1，老年代占4，新时代占整个堆的1/5</li>
</ul>
<p>在Hotspot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</p>
<p>开发人员可以通过选项”-XX:SurvivorRatio”调整这个空间比例。比如”-XX:SurvivorRatio=8”</p>
<p>==几乎所有的==Java对象都是在Eden区被New出来的</p>
<p>绝大部分的Java对象的销毁都在新时代进行了。</p>
<ul>
<li>IBM公司的专门研究表明，新时代中80%的对象都是“朝生暮死”的</li>
</ul>
<p>可以使用选项”-Xmn”设置新时代的最大内存大小</p>
<ul>
<li>这个参数一般使用默认值就可以了</li>
</ul>
<h2 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4. 图解对象分配过程"></a>4. 图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>new的对象先放在伊甸园区，此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾收集器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存区0的，如果没有回收，就会放到幸存者1区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区</li>
<li>啥时候能去养老区？可以设置次数，默认是15次。<ul>
<li>==可以设置参数：-XX:MaxTenuringThreshold=&lt;N&gt;进行设置==</li>
</ul>
</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</li>
<li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</li>
</ol>
<p><img src="/2021/07/22/JVM/image-20210724193456788.png" alt="image-20210724193456788"></p>
<hr>
<p>总结：</p>
<ul>
<li>针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210724193543173.png" alt="image-20210724193543173"></p>
<hr>
<p>常用调优工具：</p>
<ul>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
<h2 id="5-Minor-GC、Major-GC、Full-GC"><a href="#5-Minor-GC、Major-GC、Full-GC" class="headerlink" title="5. Minor GC、Major GC、Full GC"></a>5. Minor GC、Major GC、Full GC</h2><p>JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代：方法区）区域一起回收的，大部分时候回收都是指新生代。</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分手机（Partial GC），一种是整堆收集（Full GC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集器。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC /old GC）：只是老年代的垃圾收集器。<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<br>目前，只有G1 GC会有这种行为</li>
</ul>
<p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集</p>
<p>年轻代GC（Minor GC）触发机制：当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）。因为Java对象大多具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也会比较快。这一定义既清晰又易于理解。Minor GC会引发STW，暂停其他用户的进程，等待垃圾回收结束，用户线程才恢复运行。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><h4 id="老年代GC（Major-GC-Full-GC）触发机制"><a href="#老年代GC（Major-GC-Full-GC）触发机制" class="headerlink" title="老年代GC（Major GC/Full GC）触发机制:"></a>老年代GC（Major GC/Full GC）触发机制:</h4><p>指发生在老年代的GC,对象从老年代消失时,我们说”Major GC” 或”Full GC”发生了.</p>
<p>出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对,在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。也就是在老年代空间不足时,会先尝试触发Minor GC</p>
<p>Major GC的速度一般会比Minor GC慢10倍以上,STW的时间更长</p>
<p>如果Major GC后,内存还不足,就报爆OOM了,</p>
<p>Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h4><p>触发Full GC执行的情况有如下五种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.调用System.gc()时,系统建议执行Full GC,但是不必然执行</span><br><span class="line">2.老年代空间不足</span><br><span class="line">3.方法区空间不足</span><br><span class="line">4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span><br><span class="line">5. 由于Eden区,survivor Space0(From)区向survivor Space1(To)区复制时,对象大小小于To Space可用内存,则把该对象转存到老年代,且老年代的可用内存小于该对象的大小。</span><br></pre></td></tr></table></figure>

<p>说明:Full GC是开发或调优中尽量要避免的,这样暂停时间会短一些</p>
<h2 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6. 堆空间分代思想"></a>6. 堆空间分代思想</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p>
<p>经研究,不同对象的生命周期不同。70%-99%的对象都是临时对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新生代:有Eden、两块大小相同的Survivor(又称为from/to,s0/s1)构成,to总为空。</span><br><span class="line">老年代:存放新生代中经历多次GC仍然存活的对象。</span><br></pre></td></tr></table></figure>

<p>其实不分代完全可以,分代的唯一理由就是优化GC性能。如果没有分代,那所有的对象都在一块,就如同把一个学校的人都关在一个教室。GC的时候就要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生暮死的,如果分代的话,把新创建的对象放到某一地方,当GC的时候先把这块存储朝生暮死对象的区域进行回收,这样就会腾出很大的空间出来</p>
<h2 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7. 内存分配策略"></a>7. 内存分配策略</h2><p>如果对象在Eden出生并经历第一次Minor GC后任然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄设为1.对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认是15岁,其实每个GC都有所不同)时,就会被晋升到老年代中。</p>
<p>对象那个晋升到老年代的年龄阈值,可以通过选项:-XX:MaxTenuringThreshold来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示:</p>
<ul>
<li>优先分配到Eden</li>
<li>打对象直接分配到老年代——尽量避免程序中出现过多的大对象</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断:如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象可以直接进入老年代,无需等到MaxTenuringThreshold中要求的年龄</li>
<li>空间分配担保:-XX:HandlePromotionFailure</li>
</ul>
<h2 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8. 为对象分配内存：TLAB"></a>8. 为对象分配内存：TLAB</h2><p>为什么有TLAB(Thread Local Allocation Buffer)?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆区是线程共享区域,任何线程都可以访问到堆区中的共享数据</span><br><span class="line">由于对象实例的创建在JVM中非常频繁,因此在并发环境下从堆区中划分内存空间是线程不安全的</span><br><span class="line">为避免多个线程操作同一地址,需要使用加锁等机制,进而影响分配速度。</span><br></pre></td></tr></table></figure>

<p>什么是TLAB?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从内存模型而不是垃圾收集的角度,对Eden区域继续进行划分,JVM为每个线程分配了一个私有缓存区域,它包含在Eden空间内。</span><br><span class="line">多线程同时分配内存时,使用TALB可以避免一系列的非线程安全问题,同时还能够提升内存分配的吞吐量,因此我们可以将这种内存分配方式称之为快速分配策略。</span><br><span class="line">(据说)所有的OpenJDK衍生出来的JVM都提供了TLAB的设计。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存,但是==JVM确实是将TLAB作为内存分配的首选==<br>在程序中,开发人员可以通过选项”-XX:UserTLAB”设置是否开启TLAB空间</p>
<p>默认情况下,TLAB空间的内存非常小,仅占整个Eden空间的1%,当然我们可以通过选项”-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时,JVM就会尝试通过==使用加锁机制==确保数据操作的原子性,从而直接在Eden空间中分配内存。</p>
<h2 id="9-小结堆空间的参数设置"><a href="#9-小结堆空间的参数设置" class="headerlink" title="9. 小结堆空间的参数设置"></a>9. 小结堆空间的参数设置</h2><p><img src="/2021/07/22/JVM/image-20210727131541260.png" alt="image-20210727131541260"></p>
<p><img src="/2021/07/22/JVM/image-20210727131555702.png" alt="image-20210727131555702"></p>
<p>在发生Minor GC之前,==虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。==</p>
<p>如果大于,则此次Minor GC是安全的</p>
<p>如果小于,则虚拟机会查看-XX:HandlePromotionFailure设置是否允许担保失败。</p>
<ul>
<li>如果HandlePromotionFailure=true,那么会继续==检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。==<ul>
<li>如果大于,则尝试进行一次Minor GC,但这次Minor GC依然是有风险的,</li>
<li>如果小于,则改为进行一次Full GC</li>
</ul>
</li>
<li>如果HandlePromotionFailure=false,则改进为进行一次Full GC</li>
</ul>
<p>在JDK6 update=24之后,HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略,观察OpenJDK中的源码变化,虽然源码中还定义了HandlePromotionFailure参数,但是在代码中已经不会再使用它。==JDK6 update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC==。</p>
<h2 id="10-堆是分配对象的唯一选择吗"><a href="#10-堆是分配对象的唯一选择吗" class="headerlink" title="10. 堆是分配对象的唯一选择吗"></a>10. 堆是分配对象的唯一选择吗</h2><p>《深入理解Java虚拟机》中关于堆内存的描述:随着JIT编译期的发展与==逃逸分析技术==逐渐成熟,==栈上分配、标量替换优化技术==将会导致一些微妙的变化,所有的对象都分配到堆上也渐渐变得不那么”绝对”了。</p>
<p>在Java虚拟机中,对象是在Java堆中分配内存的,这是一个普遍的常识。但是,有一种特殊的情况,那就是==如果经过逃逸分析(Escape Analysis)后发现,一个对象并没有逃逸出方法的话,那么就可能被优化成栈上分配==。这样就无需在堆上分配内存,也无须进行垃圾回收了,这也是最常见的堆外存储技术。</p>
<p>此外,前面提到的基于OpenJDK深度定制的TaoBaoVM,其中创新的GCIH(GC invisible heap)技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外,并且GC不能管理GCIH内部的Java对象,以此达到降低GC的回收频率和提升GC回收效率的目的。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>如何将堆上的对象分配到栈,需要使用逃逸分析手段。</p>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>通过逃逸分析,Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域:</p>
<ul>
<li>当一个对象在方法中被定义后,对象只在方法内部使用,则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后,它被外部方法所 引用,则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210727134156197.png" alt="image-20210727134156197"></p>
<p>参数设置:</p>
<ul>
<li>在JDK 6u23版本之后,HotSpot中默认就已经开启了逃逸分析。</li>
<li>如果使用的是较早的版本,开发人员则可通过:<ul>
<li>选项”-XX:+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项”-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
</li>
</ul>
<p>==结论:开发中能使用局部变量的,就不要使用在方法外定义==</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析,编译器可以对代码做如下优化:</p>
<p>一、栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配,要使指向该对象的指针永远不会逃逸,对象可以是栈分配的候选,而不是堆分配。</p>
<p>二、同步省略。如果一个对象被发现只能从一个线程访问到,那么对于这个对象的操作可以不考虑同步</p>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到,那么对象的部分(或全部)可以不存储在内部,而是存储在CPU寄存器中。</p>
<p>JIT编译器在编译期间根据逃逸分析的结果,发现如果一个对象并没有逃逸出方法的话,就可能被优化成栈上分配。分配完成之后,继续在调用栈内执行,最后线程结束,栈空间被回收,局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的栈上分配场景:给成员变量赋值、方法返回值]实例引用传递。</p>
<h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><p>线程同步的代价是相当高的,同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候,JIT编译器可以借助逃逸分析来==判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程==。如果没有,那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略,也叫==锁消除==。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>==标量(Scalar)==是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的,那些还可以分解的数据叫做==聚合量(Aggregate)==,Java中的对象就是聚合量,因为它可以分解成其他聚合量和标量。</p>
<p>在JIT阶段,如果经过逃逸分析,发现一个对象不会被外界访问的话,那么经过JIT优化,就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<p>==标量替换后,可以大大减少堆内存的占用==。因为一旦不需要创建对象了,那么久不需要分配堆内存了</p>
<p>标量替换为栈上分配提供了很好的基础。</p>
<p>标量替换参数设置:-XX:+EliminateAllocations:开启了标量替换(默认打开),允许将对象打散分配在栈上。</p>
<p><img src="/2021/07/22/JVM/image-20210727140819791.png" alt="image-20210727140819791"></p>
<h4 id="逃逸分析小结"><a href="#逃逸分析小结" class="headerlink" title="逃逸分析小结"></a>逃逸分析小结</h4><p>==逃逸分析并不成熟==</p>
<p>关于逃逸分析的论文在1999年就已经发表了,但是直到JDK1.6才有实现,而且这项技术到如今也不是十分成熟。</p>
<p>其根本原因就是==无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的,这其实也是一个相对耗时的过程。==</p>
<p>一个极端的例子,就是经过逃逸分析 之后,发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然项技术并不十分成熟,但是它也是==即时编译器优化技术中一个十分重要的手段。==</p>
<p>注意到一些观点,认为通过逃逸分析,JVM会在栈上分配那些不会逃逸的对象,这在理论上是可行的,但是取决于JVM设计者的选择。(据说)Oracle HotSpot JVM中并没有这么做,所有的对象实例都是创建在堆上的</p>
<p>==!!==</p>
<p>目前很多书籍都还是基于JDK7以前的版本,但是JDK以及发生了很大的变化,intern字符串的缓存和静态变量曾经都被分配在永久代上,而永久代已经被元数据区取代。但是,intern字符串缓存和静态变量并不是转移到元数据区,而是直接在堆上分配,所以这一点同样符合前面的结论;==对象实例都是分配在堆上。==</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域,一个对象在这里产生、应用,最后被垃圾回收器收集,结束生命。</p>
<p>老年代 放置长生命周期的对象,通常都是从Survivor区域筛选拷贝过来的Java对象。当然,也有特殊情况,我们知道普通的对象会被分配在TLAB上,如果对象较大,JVM会试图直接分配在Eden其他位置上,如果对象太大,完全无法再新时代找到足够长的连续空闲空间,JVM就会直接分配到老年代。</p>
<p>当GC只发生在年轻代中,回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时,则被称为Major GC,或者Full GC。一般的,Minor GC的发送频率要比Major GC高很多,即老年代中垃圾回收发送的频率大大低于年轻代。</p>
<h1 id="九、方法区"><a href="#九、方法区" class="headerlink" title="九、方法区"></a>九、方法区</h1><p>栈、堆、方法区的交互关系</p>
<p>方法区的理解</p>
<p>设置方法区大小与OOM</p>
<p>方法区的内部结构</p>
<p>方法区的使用举例</p>
<p>方法区的演进细节</p>
<p>方法区的垃圾回收</p>
<p>总结</p>
<h2 id="1-栈、堆、方法区的交互关系"><a href="#1-栈、堆、方法区的交互关系" class="headerlink" title="1. 栈、堆、方法区的交互关系"></a>1. 栈、堆、方法区的交互关系</h2><p>运行时数据区结构图</p>
<p><img src="/2021/07/22/JVM/image-20210727172018327.png" alt="image-20210727172018327"></p>
<p><img src="/2021/07/22/JVM/image-20210727172128638.png" alt="image-20210727172128638"></p>
<p><img src="/2021/07/22/JVM/image-20210727172143017.png" alt="image-20210727172143017"></p>
<h2 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2. 方法区的理解"></a>2. 方法区的理解</h2><p><img src="/2021/07/22/JVM/image-20210727172216547.png" alt="image-20210727172216547"></p>
<p>《Java虚拟机规范》中明确说明:”尽管所有的方法区在逻辑上是属于堆的一部分,但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言,方法区还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开。所以,==方法区看做是一块独立于Java堆的内存空间。==</p>
<hr>
<p>基本理解:</p>
<p>方法区(Method Area)与Java堆一样,是各个线程共享的内存区域。</p>
<p>方法区在JVM启动的时候被创建,并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。</p>
<p>方法区的大小,根堆空间一样,可以选择固定大小或者可拓展。</p>
<p>方法区的大小决定了系统可以保存多少个类,如果系统定义了太多的类,导致方法区溢出,虚拟机同样会抛出内存溢出错误:java.lang.OutOfMemoryError:PermGen space或者java.lang.OutOfMemoryError:Metespace。加载大量的第三方的jar包:Tomcat部署的工程多(30-50个),大量动态的生成反射类。</p>
<p>关闭JVM就会释放这个区域的内存。</p>
<hr>
<p>HotSpot中方法区的演进:</p>
<p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>
<p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。</p>
<p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过<code>-XX:MaxPermsize</code>上限）</p>
<p><img src="/2021/07/22/JVM/image-20210727193041713.png" alt="image-20210727193041713"></p>
<p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src="/2021/07/22/JVM/image-20210727193102354.png" alt="image-20210727193102354"></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
<h2 id="3-设置方法区大小与OOM"><a href="#3-设置方法区大小与OOM" class="headerlink" title="3. 设置方法区大小与OOM"></a>3. 设置方法区大小与OOM</h2><p>设置方法区内存的大小</p>
<p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<p><strong>jdk7及以前</strong></p>
<ul>
<li><p>==通过来设置永久代初始分配空间。默认值是20.75M==<code>-XX:Permsize</code></p>
</li>
<li><p>==通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M==<code>-XX:MaxPermsize</code></p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</p>
</li>
</ul>
<p><img src="/2021/07/22/JVM/image-20210727193408965.png" alt="image-20210727193408965"></p>
<p><strong>JDK8以后</strong></p>
<ul>
<li><p>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</p>
</li>
<li><p>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</p>
</li>
<li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></p>
</li>
<li><p><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的<code>-XX:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m-XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                <span class="comment">//创建Classwriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, nu1l, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">//CLass对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>解决:</p>
<ol>
<li>要解决OOM异常或者heap space的异常,一般的手段是首先通过内存印象分析工具对dump出来的堆转储快照进行分析,重点是确认内存中的对象是否是必要的,也就是要先分清楚到底是出现了内存泄露(Memory Leak)还是内存溢出(Memory Overflow)。</li>
<li>如果是内存泄露,可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息,以及GC Roots引用链的信息,就可以比较准确地定位出泄露代码的位置。</li>
<li>如果不存在内存泄露,换句话说就是内存中的对象确实都还必须存活着,那就应当检查虚拟机的堆参数(-Xmx与-Xmx),与机器物理内存对比看是否还可以调大,从优化代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况,尝试减少程序运行期间的内存消耗。</li>
</ol>
<h2 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4. 方法区的内部结构"></a>4. 方法区的内部结构</h2><p><img src="/2021/07/22/JVM/8a5fcba10ccb773f185288ac22bde206.png" alt="image-20200708161728320"></p>
<p>方法区(Method Area)中存储什么?</p>
<p>《深入理解Java虚拟机》中对方法区(Method Area)存储内容描述如下:<br>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><img src="/2021/07/22/JVM/fbe3915506e7979c7d591d17c216fbb1.png" alt="image-20200708161856504"></p>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构:"></a>方法区的内部结构:</h3><p>类型信息:</p>
<p>对每个加载的类型(类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储以下类型信息:</p>
<ol>
<li>这个类型的完整有效名称(全类名=包名.类名)</li>
<li>这个类型直接父亲的完整有效名(对于interface或者是java.lang.object,都没有父类)</li>
<li>这个类型的修饰符(public,abstract,final的某个子集)</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<p>域(Field)信息:</p>
<p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。域的相关信息包括:域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集)</p>
<p>方法(Method)信息:</p>
<p>JVM必须保存所有的方法的以下信息,同域信息一样包括声明顺序:</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">stary</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://stary1999.github.io/2021/07/22/JVM/">https://stary1999.github.io/2021/07/22/JVM/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stary1999.github.io">繁星点点</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/07/22/SQL-2021-07-22-Redis6/"><i class="fas fa-angle-left">&nbsp;</i><span>Redis6</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/07/14/java-2021-07-14-JavaWebBookCity/"><span>javaWeb书城项目传统版</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By stary</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>