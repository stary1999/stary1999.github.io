<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis6"><meta name="keywords" content="Redis,数据库"><meta name="author" content="stary,undefined"><meta name="copyright" content="stary"><title>Redis6【繁星点点】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: false,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="繁星点点" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、NoSQL数据库简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.技术发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2.NoSQL数据库概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">常见的NoSQL数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text">3.行式存储数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9B%BE%E5%85%B3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.</span> <span class="toc-text">4.图关型数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%92%E5%90%8D"><span class="toc-number">1.5.</span> <span class="toc-text">5.数据库排名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redis6%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">二、Redis6概述和安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">1. 应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">2.安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%88redis%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">介绍（redis）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">三、常用五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis%E9%94%AE%EF%BC%88key%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. Redis键（key）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2. Redis字符串（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">简介：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">Redis列表（List）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B%EF%BC%9A-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">简介：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">Redis集合（Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">3.4.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%93%88%E5%B8%8C%EF%BC%88Hash%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">Redis哈希（Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">3.5.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="toc-number">3.5.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88Zset%EF%BC%88sorted-set"><span class="toc-number">3.6.</span> <span class="toc-text">Redis有序集合Zset（sorted set)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">3.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">3.6.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"><span class="toc-number">3.6.3.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%88%E8%B7%B3%E8%A1%A8%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">跳跃表（跳表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">3.7.1.</span> <span class="toc-text">简介</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Redis6%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">四、Redis6配置文件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Units-%E5%8D%95%E4%BD%8D"><span class="toc-number">4.1.</span> <span class="toc-text">1. ###Units 单位###</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-INCLUDES-%E5%8C%85%E5%90%AB"><span class="toc-number">4.2.</span> <span class="toc-text">2. ###INCLUDES 包含###</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text">3. ###网络相关配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bind"><span class="toc-number">4.3.1.</span> <span class="toc-text">1.bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-protected-mode"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.protected-mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Port"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.Port</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-tcp-backlog"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.tcp-backlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-timeout"><span class="toc-number">4.3.5.</span> <span class="toc-text">5.timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-tcp-keepalive"><span class="toc-number">4.3.6.</span> <span class="toc-text">6.tcp-keepalive</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-GENERAL-%E9%80%9A%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">4. ###GENERAL 通用###</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-daemonize"><span class="toc-number">4.4.1.</span> <span class="toc-text">1.daemonize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-pidfile"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.pidfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-loglevel"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.loglevel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-logfile"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">4.logfile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-databases-16"><span class="toc-number">4.4.4.</span> <span class="toc-text">5.databases 16</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-SECURITY-%E5%AE%89%E5%85%A8"><span class="toc-number">4.5.</span> <span class="toc-text">5. ###SECURITY 安全###</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="toc-number">4.5.1.</span> <span class="toc-text">1.设置密码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-LIMITS-%E9%99%90%E5%88%B6"><span class="toc-number">4.6.</span> <span class="toc-text">6. #### LIMITS 限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-maxclients"><span class="toc-number">4.6.1.</span> <span class="toc-text">1.maxclients</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-maxmemory"><span class="toc-number">4.6.2.</span> <span class="toc-text">2.maxmemory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-maxmemory-policy"><span class="toc-number">4.6.3.</span> <span class="toc-text">3.maxmemory-policy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-maxmemory-samples"><span class="toc-number">4.6.4.</span> <span class="toc-text">4.maxmemory-samples</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Redis6%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.</span> <span class="toc-text">五、Redis6的发布和订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.1.</span> <span class="toc-text">1. 什么是发布和订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis-%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.2.</span> <span class="toc-text">2. Redis 的发布和订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">3. 发布订阅命令行实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Redis6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">六、Redis6新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Bitmaps"><span class="toc-number">6.1.</span> <span class="toc-text">1. Bitmaps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">6.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps-%E4%B8%8E-set-%E5%AF%B9%E6%AF%94"><span class="toc-number">6.1.3.</span> <span class="toc-text">Bitmaps 与 set 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HyperLogLog"><span class="toc-number">6.2.</span> <span class="toc-text">2. HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">6.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Geospatial"><span class="toc-number">6.3.</span> <span class="toc-text">3. Geospatial</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">6.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-2"><span class="toc-number">6.3.2.</span> <span class="toc-text">命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Jedis%E6%93%8D%E4%BD%9CRedis6"><span class="toc-number">7.</span> <span class="toc-text">七、Jedis操作Redis6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">7.1.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis-%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84-jar-%E5%8C%85%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">Jedis 所需要的 jar 包：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-Redis-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.1.2.</span> <span class="toc-text">连接 Redis 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.3.</span> <span class="toc-text">Jedis 常用操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Redis6%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">九、Redis6的事务操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Redis6%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB"><span class="toc-number">9.</span> <span class="toc-text">十、Redis6持久化之RDB</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF"><span class="toc-number">10.</span> <span class="toc-text">十一、Redis持久化之AOF</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Redis6%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">十二、Redis6的主从复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81Redis6%E9%9B%86%E7%BE%A4"><span class="toc-number">12.</span> <span class="toc-text">十三、Redis6集群</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81Redis6%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">13.</span> <span class="toc-text">十四、Redis6应用问题解决</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81Redis6%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">14.</span> <span class="toc-text">十五、Redis6新功能</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">stary</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/stary1999" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="mailto:stary2020@163.com" target="_blank">E-Mail<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1497447121&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color10"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">23</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">27</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">6</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/home">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">繁星点点</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Redis6</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2021-07-22 | 更新于 2021-07-24</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Redis/">Redis</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div></div></div><div class="main-content"><ul>
<li>NoSQL数据库简介</li>
<li>Redis6概述和安装</li>
<li>常用五大数据类型</li>
<li>Redis6配置文件详解</li>
<li>Redis6的发布和订阅</li>
<li>Redis6新数据类型</li>
<li>Jedis操作Redis6</li>
<li>Redis6与Spring Boot整合</li>
<li>Redis6的事务操作</li>
<li>Redis6持久化之RDB</li>
<li>Redis持久化之AOF</li>
<li>Redis6的主从复制</li>
<li>Redis6集群</li>
<li>Redis6应用问题解决</li>
<li>Redis6新功能</li>
</ul>
<h1 id="一、NoSQL数据库简介"><a href="#一、NoSQL数据库简介" class="headerlink" title="一、NoSQL数据库简介"></a>一、NoSQL数据库简介</h1><ul>
<li>技术发展</li>
<li>NoSQL数据库概述</li>
<li>行式存储数据库</li>
<li>图关型数据库</li>
<li>数据库排名</li>
</ul>
<h2 id="1-技术发展"><a href="#1-技术发展" class="headerlink" title="1.技术发展"></a>1.技术发展</h2><p>技术的分类：</p>
<ol>
<li>解决功能性的问题：java、jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li>
<li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li>
<li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li>
</ol>
<ul>
<li>web 1.0 时代：<br>数据访问量有限，用高性能的单点服务器可以解决大部分问题</li>
<li>web 2.0 时代：<br>用户访问量大幅度提升，同时产生了大量的用户数据。加之移动设备普及，所有的互联网平台面临巨大的性能挑战，包括：CPU及内存压力、IO压力</li>
<li>解决CPU及内存压力——多台服务器条件下session存放问题<ul>
<li>方案一：存在cookie中<ol>
<li>不安全</li>
<li>网络负担效率低</li>
</ol>
</li>
<li>方案二：存在文件服务器或者数据库里<ol>
<li>大量的IO效率问题</li>
</ol>
</li>
<li>方案三：session复制<ol>
<li>session数据冗余，节点越多，浪费越大</li>
</ol>
</li>
<li>方案四：缓存数据库<ol>
<li>完全在内存中，速度快，数据结构简单</li>
</ol>
</li>
</ul>
</li>
<li>解决IO压力<ul>
<li>缓存数据库：减少IO的读操作</li>
<li>水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</li>
<li>文档数据库</li>
<li>列式数据库</li>
<li>打破了传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能为最优的存储方式</li>
</ul>
</li>
</ul>
<h2 id="2-NoSQL数据库概述"><a href="#2-NoSQL数据库概述" class="headerlink" title="2.NoSQL数据库概述"></a>2.NoSQL数据库概述</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>NoSQL（NoSQL=Not Only SQL），意味：不仅仅是SQL，指==非关系型的数据库==。NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>不遵循SQL标准</li>
<li>不支持ACID（事务中的原子性、一致性、隔离性和持久性）</li>
<li>远超于SQL的性能</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>NoSQL适用场景：</p>
<ul>
<li>对数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的读写</li>
</ul>
<p>NoSQL不适用的场景：</p>
<ul>
<li>需要事务支持</li>
<li>基于sql的结构化查询存储，处理复杂的关系，需要即席查询<br>即席查询：（Ad Hoc）是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表。</li>
</ul>
<p>==用不着sql和用了SQL也不行的情况下，考虑使用NoSQL==</p>
<h3 id="常见的NoSQL数据库"><a href="#常见的NoSQL数据库" class="headerlink" title="常见的NoSQL数据库"></a>常见的NoSQL数据库</h3><ul>
<li>Memcache<ul>
<li>很==早==出现的NoSQL数据库</li>
<li>数据都在内存中，一般==不支持持久化==</li>
<li>支持简单的key-value模式，==支持类型单一==</li>
<li>一般是作为==缓存数据库==辅助持久化的数据库</li>
</ul>
</li>
<li>Redis<ul>
<li>几乎覆盖了Memcache的绝大部分功能</li>
<li>数据都在内存，==支持持久化==，主要用作备份恢复</li>
<li>除了支持简单的key-value模式，还==支持多种数据结构的存储==，比如list、set、hash、zset等</li>
<li>一般是作为==缓存数据库==辅助持久化的数据库</li>
</ul>
</li>
<li>MongoDB<ul>
<li>高性能、开源、模式自由（schema free）的==文档型数据库==</li>
<li>数据都在内存中，如果内存不足，把不常用的数据保存到硬盘</li>
<li>虽然是key-value模式，但是对value（尤其是==json==）提供了丰富的查询功能</li>
<li>支持二进制数据及大型对象</li>
<li>开源根据数据的特点==替代RDBMS==，成为独立的数据库。或者配合RDBMS，存储特定的数据。<br>RDBMS：关系数据库管理系统。</li>
</ul>
</li>
</ul>
<h2 id="3-行式存储数据库"><a href="#3-行式存储数据库" class="headerlink" title="3.行式存储数据库"></a>3.行式存储数据库</h2><ul>
<li>行式数据库</li>
<li>列式数据库</li>
</ul>
<p>常见的数据库：</p>
<ul>
<li>HBase：<ul>
<li>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</li>
<li>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可以处理有百万列元素的数据表</li>
</ul>
</li>
<li>Cassandra：<ul>
<li>Apache Cassandra 是一款免费的开源 NoSQL 数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到 PB 级别)。在众多显著特性当中，Cassandra 最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">计算机存储单位 计算机存储单位一般用 B，KB，MB，GB，TB，PB，EB，ZB，YB，BB</span><br><span class="line">来表示，它们之间的关系是：</span><br><span class="line">位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</span><br><span class="line">字节 byte：8 个二进制位为一个字节(B)，最常用的单位。</span><br><span class="line">1KB (Kilobyte 千字节)=1024B，</span><br><span class="line">1MB (Megabyte 兆字节 简称“兆”)=1024KB，</span><br><span class="line">1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</span><br><span class="line">1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中 1024=2^10 ( 2 的 10 次方)，</span><br><span class="line">1PB（Petabyte 千万亿字节 拍字节）=1024TB，</span><br><span class="line">1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</span><br><span class="line">1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</span><br><span class="line">1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</span><br><span class="line">1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</span><br><span class="line">注：“兆”为百万级数量单位。</span><br></pre></td></tr></table></figure>

<h2 id="4-图关型数据库"><a href="#4-图关型数据库" class="headerlink" title="4.图关型数据库"></a>4.图关型数据库</h2><p>Neo4j：</p>
<p>主要应用：社会关系、公共交通网络、地图及网络拓扑</p>
<h2 id="5-数据库排名"><a href="#5-数据库排名" class="headerlink" title="5.数据库排名"></a>5.数据库排名</h2><p>网址：<a target="_blank" rel="noopener" href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></p>
<p><img src="/2021/07/22/Redis6/image-20210723084537486.png" alt="image-20210723084537486"></p>
<h1 id="二、Redis6概述和安装"><a href="#二、Redis6概述和安装" class="headerlink" title="二、Redis6概述和安装"></a>二、Redis6概述和安装</h1><ul>
<li>Redis 是一个开源的 key-value 存储系统。</li>
<li>和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string(字符串)、<br>list(链表)、set(集合)、zset(sorted set –有序集合)和 hash（哈希类型）。</li>
<li>这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li>
<li>在此基础上，Redis 支持各种不同方式的排序。</li>
<li>与 memcached 一样，为了保证效率，数据都是缓存在内存中。</li>
<li>区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记<br>录文件。</li>
<li>并且在此基础上实现了 master-slave(主从)同步。</li>
</ul>
<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><ol>
<li>配合关系型数据库做高速缓存<ul>
<li>高频次，热门访问的数据，降低数据库IO</li>
<li>分布式架构，做session共享</li>
</ul>
</li>
<li>多样的数据结构存储持久化数据<br><img src="/2021/07/22/Redis6/image-20210723084938403.png" alt="image-20210723084938403"></li>
</ol>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><p>官网：<a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io/</a></p>
<p>中文官网：<a target="_blank" rel="noopener" href="http://redis.cn/">http://redis.cn/</a></p>
<p>安装时，不考虑windows版本</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>准备工作：</p>
<ul>
<li><p>下载安装gcc编译器</p>
<ul>
<li><p>安装c语言的编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure></li>
<li><p>测试gcc版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>安装redis：</p>
<ul>
<li>下载Redis安装包到opt目录下</li>
<li>解压：<code>tar -zxvf redis-6.2.1.tar.gz</code></li>
<li>进入解压后的目录</li>
<li>在目录下再次执行make命令，若报错，运行：<code>make distclean</code>，再次执行：<code>make</code>命令</li>
<li>编译成功后，跳过<code>make test</code>，继续执行：<code>make install</code>，完成安装</li>
</ul>
<p>安装目录：/usr/local/bin查看默认安装目录：</p>
<ul>
<li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li>
<li>redis-check-aof：修复有问题的 AOF 文件，rdb 和 aof 后面讲</li>
<li>redis-check-dump：修复有问题的 dump.rdb 文件</li>
<li>redis-sentinel：Redis 集群使用</li>
<li>redis-server：Redis 服务器启动命令</li>
<li>redis-cli：客户端，操作入口</li>
</ul>
<p>启动：</p>
<ul>
<li><p>前台启动：<code>redis.server</code>，不推荐使用，命令窗口不能关闭，否则服务器停止</p>
</li>
<li><p>后台启动：推荐</p>
<ul>
<li><p>备份redis.conf配置文件到其他目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-3.2.5/redis.conf /myredis</span><br></pre></td></tr></table></figure></li>
<li><p>后台启动设置 daemonize no 改成 yes：修改 redis.conf(128 行)文件将里面的 daemonize no 改成 yes，让服务在后台启动</p>
</li>
<li><p>启动：<code>redis-server/myredis/redis.conf</code></p>
</li>
<li><p>客户端访问：<code>redis-cli</code></p>
</li>
<li><p>多端口情况下：<code>redis-cli -p6379</code></p>
</li>
<li><p>测试验证：<code>ping</code></p>
</li>
<li><p>关闭：</p>
<ul>
<li>单实例关闭：<code>redis-cli shutdown</code></li>
<li>进入终端后关闭：<code>shutdown</code></li>
<li>多实例关闭：<code>redis-cli -p 6379 shutdown</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="介绍（redis）"><a href="#介绍（redis）" class="headerlink" title="介绍（redis）"></a>介绍（redis）</h3><ul>
<li>默认 16 个数据库，类似数组下标从 0 开始，初始默认使用 0 号库</li>
<li>使用命令 <code>select &lt;dbid&gt;</code>来切换数据库。如: select 8</li>
<li>统一密码管理，所有库同样密码。</li>
<li><code>dbsize</code> 查看当前数据库的 key 的数量</li>
<li><code>flushdb</code> 清空当前库</li>
<li><code>flushall</code> 通杀全部库</li>
</ul>
<p>==端口号：6379==</p>
<ul>
<li>Redis==是单线程+多路IO复用技术==<ul>
<li>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</li>
</ul>
</li>
<li>串行 vs 多线程+锁（memcached） vs 单线程+多路 IO 复用(Redis）<ul>
<li>与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用</li>
</ul>
</li>
</ul>
<h1 id="三、常用五大数据类型"><a href="#三、常用五大数据类型" class="headerlink" title="三、常用五大数据类型"></a>三、常用五大数据类型</h1><p>redis常见数据类型操作指令： <a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h2 id="1-Redis键（key）"><a href="#1-Redis键（key）" class="headerlink" title="1. Redis键（key）"></a>1. Redis键（key）</h2><table>
<thead>
<tr>
<th>命令</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>keys *</td>
<td>查看当前库所有 key (匹配：keys *1)</td>
</tr>
<tr>
<td>exists key</td>
<td>判断某个 key 是否存在</td>
</tr>
<tr>
<td>type key</td>
<td>查看你的 key 是什么类型</td>
</tr>
<tr>
<td>del key</td>
<td>删除指定的 key 数据</td>
</tr>
<tr>
<td>unlink key</td>
<td>根据 value 选择非阻塞删除。仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作。</td>
</tr>
<tr>
<td>expire key 10</td>
<td>10 秒钟：为给定的 key 设置过期时间</td>
</tr>
<tr>
<td>ttl key</td>
<td>查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</td>
</tr>
<tr>
<td>select</td>
<td>命令切换数据库</td>
</tr>
<tr>
<td>dbsize</td>
<td>查看当前数据库的 key 的数量</td>
</tr>
<tr>
<td>flushdb</td>
<td>清空当前库</td>
</tr>
<tr>
<td>flushall</td>
<td>通杀全部库</td>
</tr>
</tbody></table>
<h2 id="2-Redis字符串（String）"><a href="#2-Redis字符串（String）" class="headerlink" title="2. Redis字符串（String）"></a>2. Redis字符串（String）</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>String是Redis最基本的类型，一个key对应一个value</li>
<li>String类型是二进制安全的。意味着Redis的String可以包含任何数据。比如jpg图片或者序列化对象</li>
<li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p>
<p><img src="/2021/07/22/Redis6/image-20210723092330892.png" alt="image-20210723092330892"></p>
<ul>
<li>*NX：当数据库中 key 不存在时，可以将 key-value 添加数据库</li>
<li>*XX：当数据库中 key 存在时，可以将 key-value 添加数据库，与 NX 参数互斥</li>
<li>*EX：key 的超时秒数</li>
<li>*PX：key 的超时毫秒数，与 EX 互斥</li>
</ul>
</li>
<li><p><code>get &lt;key&gt;</code>：查询对应键值</p>
</li>
<li><p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的<value> 追加到原值的末尾</value></p>
</li>
<li><p><code>strlen &lt;key&gt;</code>：获得值的长度</p>
</li>
<li><p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 key 不存在时 设置 key 的值</p>
</li>
<li><p><code>incr &lt;key&gt;</code>：将 key 中储存的数字值增 1。只能对数字值操作，如果为空，新增值为 1</p>
</li>
<li><p><code>decr &lt;key&gt;</code>：将 key 中储存的数字值减 1只能对数字值操作，如果为空，新增值为-1</p>
</li>
<li><p><code>incrby / decrby &lt;key&gt;&lt;步长&gt;</code>：将 key 中储存的数字值增减。自定义步长。</p>
</li>
<li><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>：同时设置一个或多个 key-value 对</p>
</li>
<li><p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....</code>：同时获取一个或多个 value</p>
</li>
<li><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
</li>
<li><p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围，类似 java 中的 substring，前包，后包</p>
</li>
<li><p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从 0 开始)。</key></value></p>
</li>
<li><p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p>
</li>
<li><p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值</p>
</li>
</ul>
<p>原子性：</p>
<ul>
<li>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<ul>
<li>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li>
<li>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis 单命令的原子性主要得益于 Redis 的单线程</li>
</ul>
</li>
<li>案例：<br>java 中的 i++是否是原子操作？==不是==<br>i=0;两个线程分别对 i 进行++100 次,值是多少？==2-200==</li>
<li>==原子性，有一个失败则都失败==</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>String 的数据结构为简单动态字符串(Simple Dynamic String,缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p>内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>
<h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p>单键多值：</p>
<ul>
<li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li>
<li>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</li>
</ul>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code></td>
<td>从左边/右边插入一个或多个值。</td>
</tr>
<tr>
<td><code>lpop/rpop &lt;key&gt;</code></td>
<td>从左边/右边吐出一个值。值在键在，值光键亡。</td>
</tr>
<tr>
<td><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code></td>
<td>从<key1>列表右边吐出一个值，插到<key2>列表左边。</key2></key1></td>
</tr>
<tr>
<td><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td><code>lrange mylist 0 -1</code></td>
<td>0 左边第一个，-1 右边第一个，（0-1 表示获取所有）</td>
</tr>
<tr>
<td><code>lindex &lt;key&gt;&lt;index&gt;</code></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td><code>llen &lt;key&gt;</code></td>
<td>获得列表长度</td>
</tr>
<tr>
<td><code>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</code></td>
<td>在<value>的后面插入<newvalue>插入值</newvalue></value></td>
</tr>
<tr>
<td><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code></td>
<td>从左边删除 n 个 value(从左到右)</td>
</tr>
<tr>
<td><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code></td>
<td>将列表 key 下标为 index 的值替换成 value</td>
</tr>
</tbody></table>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>List 的数据结构为快速链表 quickList。</p>
<ul>
<li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。</li>
<li>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li>
<li>当数据量比较多的时候才会改成 quicklist。</li>
<li>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</li>
<li>Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li>
</ul>
<h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以==自动排重==的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p>
</li>
<li><p>Redis 的 Set 是 string 类型的==无序集合。它底层其实是一个 value 为 null 的 hash 表==，所以添加，删除，查找的==复杂度都是 O(1)。==</p>
</li>
<li><p>一个算法，随着数据的增加，执行时间的长短，如果是 O(1)，数据增加，查找数据的时间不变</p>
</li>
</ul>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code></td>
<td>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略。smembers <key>取出该集合的所有值。</key></td>
</tr>
<tr>
<td><code>sismember &lt;key&gt;&lt;value&gt;</code></td>
<td>判断集合<key>是否为含有该<value>值，有 1，没有 0</value></key></td>
</tr>
<tr>
<td><code>scard&lt;key&gt;</code></td>
<td>返回该集合的元素个数。</td>
</tr>
<tr>
<td><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code></td>
<td>删除集合中的某个元素。</td>
</tr>
<tr>
<td><code>spop &lt;key&gt;</code></td>
<td>随机从该集合中吐出一个值。</td>
</tr>
<tr>
<td><code>srandmember &lt;key&gt;&lt;n&gt;</code></td>
<td>随机从该集合中取出 n 个值。不会从集合中删除 。</td>
</tr>
<tr>
<td><code>smove &lt;source&gt;&lt;destination&gt;value </code></td>
<td>把集合中一个值从一个集合移动到另一个集合</td>
</tr>
<tr>
<td><code>sinter &lt;key1&gt;&lt;key2&gt;</code></td>
<td>返回两个集合的交集元素。</td>
</tr>
<tr>
<td><code>sunion &lt;key1&gt;&lt;key2&gt;</code></td>
<td>返回两个集合的并集元素。</td>
</tr>
<tr>
<td><code>sdiff &lt;key1&gt;&lt;key2&gt;</code></td>
<td>返回两个集合的差集元素(key1 中的，不包含 key2 中的)</td>
</tr>
</tbody></table>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>Set 数据结构是 dict 字典，字典是用哈希表实现的。</li>
<li>Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。</li>
<li>Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向一个内部值。</li>
</ul>
<h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>Redis hash 是一个键值对集合。</li>
<li>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</li>
<li>类似 Java 里面的 Map&lt;String,Object&gt;</li>
<li>用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用</li>
<li>普通的 key/value 结构来存储<br>主要有以下 2 种存储方式：<ul>
<li>每次修改用户的某个属性需要，先反序列化<br>改好后再序列化回去。开销较大<br><img src="/2021/07/22/Redis6/image-20210723094835460.png" alt="image-20210723094835460"></li>
<li>用户 ID 数据冗余<br><img src="/2021/07/22/Redis6/image-20210723094853915.png" alt="image-20210723094853915"></li>
<li>通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题<br><img src="/2021/07/22/Redis6/image-20210723095032787.png" alt="image-20210723095032787"></li>
</ul>
</li>
</ul>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code></td>
<td>给<key>集合中的 <field>键赋值<value></value></field></key></td>
</tr>
<tr>
<td><code>hget &lt;key1&gt;&lt;field&gt;</code></td>
<td>从<key1>集合<field>取出 value</field></key1></td>
</tr>
<tr>
<td><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code></td>
<td>批量设置 hash 的值</td>
</tr>
<tr>
<td><code>hexists&lt;key1&gt;&lt;field&gt;</code></td>
<td>查看哈希表 key 中，给定域 field 是否存在。</td>
</tr>
<tr>
<td><code>hkeys &lt;key&gt;</code></td>
<td>列出该 hash 集合的所有 field</td>
</tr>
<tr>
<td><code>hvals &lt;key&gt;</code></td>
<td>列出该 hash 集合的所有 value</td>
</tr>
<tr>
<td><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code></td>
<td>为哈希表 key 中的域 field 的值加上增量 1 -1</td>
</tr>
<tr>
<td><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code></td>
<td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在</td>
</tr>
</tbody></table>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p>Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p>
<h2 id="Redis有序集合Zset（sorted-set"><a href="#Redis有序集合Zset（sorted-set" class="headerlink" title="Redis有序集合Zset（sorted set)"></a>Redis有序集合Zset（sorted set)</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。</p>
</li>
<li><p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
</li>
<li><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
</li>
<li><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
</li>
</ul>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code></td>
<td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</td>
</tr>
<tr>
<td><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code></td>
<td>返回有序集 key 中，下标在<start><stop></stop>之间的元素。带 WITHSCORES，可以让分数一起和值返回到结果集。</start></td>
</tr>
<tr>
<td><code>zrangebyscore key minmax [withscores] [limit offset count]</code></td>
<td>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</td>
</tr>
<tr>
<td><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code></td>
<td>同上，改为从大到小排列。</td>
</tr>
<tr>
<td><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt; </code></td>
<td>为元素的 score 加上增量</td>
</tr>
<tr>
<td><code>zrem &lt;key&gt;&lt;value&gt;</code></td>
<td>删除该集合下，指定值的元素</td>
</tr>
<tr>
<td><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code></td>
<td>统计该集合，分数区间内的元素个数</td>
</tr>
<tr>
<td><code>zrank &lt;key&gt;&lt;value&gt;</code></td>
<td>返回该值在集合中的排名，从 0 开始。</td>
</tr>
</tbody></table>
<h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>SortedSet(zset)是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java<br>的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</li>
<li>zset 底层使用了两个数据结构<ul>
<li>（1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li>
<li>（2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表</li>
</ul>
</li>
</ul>
<h2 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<h1 id="四、Redis6配置文件详解"><a href="#四、Redis6配置文件详解" class="headerlink" title="四、Redis6配置文件详解"></a>四、Redis6配置文件详解</h1><h2 id="1-Units-单位"><a href="#1-Units-单位" class="headerlink" title="1. ###Units 单位###"></a>1. ###Units 单位###</h2><ul>
<li>配置大小单位,开头定义了一些基本的度量单位，只支持 bytes，不支持 bit</li>
<li>大小写不敏感</li>
</ul>
<h2 id="2-INCLUDES-包含"><a href="#2-INCLUDES-包含" class="headerlink" title="2. ###INCLUDES 包含###"></a>2. ###INCLUDES 包含###</h2><ul>
<li>类似 jsp 中的 include，多实例的情况可以把公用的配置文件提取出来</li>
</ul>
<h2 id="3-网络相关配置"><a href="#3-网络相关配置" class="headerlink" title="3. ###网络相关配置"></a>3. ###网络相关配置</h2><h3 id="1-bind"><a href="#1-bind" class="headerlink" title="1.bind"></a>1.bind</h3><ul>
<li>默认情况 bind=127.0.0.1 只能接受本机的访问请求</li>
<li>不写的情况下，无限制接受任何 ip 地址的访问</li>
<li>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</li>
<li>==如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis只允许接受本机的响应==</li>
<li>保存配置，停止服务，重启启动查看进程，配置生效</li>
</ul>
<h3 id="2-protected-mode"><a href="#2-protected-mode" class="headerlink" title="2.protected-mode"></a>2.protected-mode</h3><ul>
<li>将本机访问保护模式设置 no</li>
</ul>
<h3 id="3-Port"><a href="#3-Port" class="headerlink" title="3.Port"></a>3.Port</h3><ul>
<li>端口号，默认 6379</li>
</ul>
<h3 id="4-tcp-backlog"><a href="#4-tcp-backlog" class="headerlink" title="4.tcp-backlog"></a>4.tcp-backlog</h3><ul>
<li>设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和=未完成三次握手队列 + 已经完成三次握手队列。</li>
<li>在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。</li>
<li>注意 Linux 内核会将这个值减小到/proc/sys/net/core/somaxconn 的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</li>
</ul>
<h3 id="5-timeout"><a href="#5-timeout" class="headerlink" title="5.timeout"></a>5.timeout</h3><ul>
<li>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</li>
</ul>
<h3 id="6-tcp-keepalive"><a href="#6-tcp-keepalive" class="headerlink" title="6.tcp-keepalive"></a>6.tcp-keepalive</h3><ul>
<li>对访问客户端的一种心跳检测，每个 n 秒检测一次。</li>
<li>单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60</li>
</ul>
<h2 id="4-GENERAL-通用"><a href="#4-GENERAL-通用" class="headerlink" title="4. ###GENERAL 通用###"></a>4. ###GENERAL 通用###</h2><h3 id="1-daemonize"><a href="#1-daemonize" class="headerlink" title="1.daemonize"></a>1.daemonize</h3><ul>
<li>是否为后台进程，设置为 yes</li>
<li>守护进程，后台启动</li>
</ul>
<h3 id="2-pidfile"><a href="#2-pidfile" class="headerlink" title="2.pidfile"></a>2.pidfile</h3><ul>
<li>存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件</li>
</ul>
<h3 id="3-loglevel"><a href="#3-loglevel" class="headerlink" title="3.loglevel"></a>3.loglevel</h3><ul>
<li>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</li>
<li>四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning</li>
</ul>
<h4 id="4-logfile"><a href="#4-logfile" class="headerlink" title="4.logfile"></a>4.logfile</h4><ul>
<li>日志文件名称</li>
</ul>
<h3 id="5-databases-16"><a href="#5-databases-16" class="headerlink" title="5.databases 16"></a>5.databases 16</h3><ul>
<li>设定库的数量 默认 16，默认数据库为 0，可以使用 SELECT <dbid>命令在连接上指定数据库 id</dbid></li>
</ul>
<h2 id="5-SECURITY-安全"><a href="#5-SECURITY-安全" class="headerlink" title="5. ###SECURITY 安全###"></a>5. ###SECURITY 安全###</h2><h3 id="1-设置密码"><a href="#1-设置密码" class="headerlink" title="1.设置密码"></a>1.设置密码</h3><ul>
<li>访问密码的查看、设置和取消</li>
<li>在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。</li>
<li>永久设置，需要再配置文件中进行设置。<br><img src="/2021/07/22/Redis6/image-20210723102644227.png" alt="image-20210723102644227"></li>
</ul>
<h2 id="6-LIMITS-限制"><a href="#6-LIMITS-限制" class="headerlink" title="6. #### LIMITS 限制"></a>6. #### LIMITS 限制</h2><h3 id="1-maxclients"><a href="#1-maxclients" class="headerlink" title="1.maxclients"></a>1.maxclients</h3><ul>
<li>设置 redis 同时可以与多少个客户端进行连接。</li>
<li>默认情况下为 10000 个客户端。</li>
<li>如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出<br>“max number of clients reached”以作回应。</li>
</ul>
<h3 id="2-maxmemory"><a href="#2-maxmemory" class="headerlink" title="2.maxmemory"></a>2.maxmemory</h3><ul>
<li>建议==必须设置==，否则，将内存占满，造成服务器宕机</li>
<li>设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数<br>据，移除规则可以通过 maxmemory-policy 来指定。</li>
<li>如果 redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等。</li>
<li>但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 redis 是主<br>redis（说明你的 redis 有从 redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不<br>用考虑这个因素。</li>
</ul>
<h3 id="3-maxmemory-policy"><a href="#3-maxmemory-policy" class="headerlink" title="3.maxmemory-policy"></a>3.maxmemory-policy</h3><ul>
<li>volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；（最近最少使用）</li>
<li>allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key</li>
<li>volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</li>
<li>allkeys-random：在所有集合 key 中，移除随机的 key</li>
<li>volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key</li>
<li>noeviction：不进行移除。针对写操作，只是返回错误信息</li>
</ul>
<h3 id="4-maxmemory-samples"><a href="#4-maxmemory-samples" class="headerlink" title="4.maxmemory-samples"></a>4.maxmemory-samples</h3><ul>
<li>设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所<br>以你可以设置样本的大小，redis 默认会检查这么多个 key 并选择其中 LRU 的那个。</li>
<li>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</li>
</ul>
<h1 id="五、Redis6的发布和订阅"><a href="#五、Redis6的发布和订阅" class="headerlink" title="五、Redis6的发布和订阅"></a>五、Redis6的发布和订阅</h1><h2 id="1-什么是发布和订阅"><a href="#1-什么是发布和订阅" class="headerlink" title="1. 什么是发布和订阅"></a>1. 什么是发布和订阅</h2><ul>
<li>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者<br>(sub) 接收消息。</li>
<li>Redis 客户端可以订阅任意数量的频道。</li>
</ul>
<h2 id="2-Redis-的发布和订阅"><a href="#2-Redis-的发布和订阅" class="headerlink" title="2. Redis 的发布和订阅"></a>2. Redis 的发布和订阅</h2><ul>
<li>客户端可以订阅频道</li>
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li>
</ul>
<h2 id="3-发布订阅命令行实现"><a href="#3-发布订阅命令行实现" class="headerlink" title="3. 发布订阅命令行实现"></a>3. 发布订阅命令行实现</h2><ol>
<li>打开一个客户端订阅 channel1<br><code>SUBSCRIBE channel1</code></li>
<li>打开另一个客户端，给 channel1 发布消息 hello<br><code>publish channel1 hello</code><br>返回的值是订阅者数量</li>
<li>打开第一个客户端可以看到发送的消息</li>
</ol>
<p>注：发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布<br>的消息</p>
<h1 id="六、Redis6新数据类型"><a href="#六、Redis6新数据类型" class="headerlink" title="六、Redis6新数据类型"></a>六、Redis6新数据类型</h1><h2 id="1-Bitmaps"><a href="#1-Bitmaps" class="headerlink" title="1. Bitmaps"></a>1. Bitmaps</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul>
<li>现代计算机用二进制（位） 作为信息的基础单位， 1 个字节等于 8 位， 例如“abc”<br>字符串是由 3 个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别<br>对应的 ASCII 码分别是 97、 98、 99， 对应的二进制分别是 01100001、01100010和 01100011，</li>
<li>合理地使用操作位能够有效地提高内存使用率和开发效率。</li>
<li>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：<ul>
<li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。</li>
<li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</li>
</ul>
</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;</code>设置 Bitmaps 中某个偏移量的值（0 或 1）<br>*offset:偏移量从 0 开始</li>
<li><code>getbit&lt;key&gt;&lt;offset&gt;</code>获取 Bitmaps 中某个偏移量的值<br>获取键的第 offset 位的值（从 0 开始算）</li>
<li>bitcount<br>统计字符串被设置为 1 的 bit 数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指 bit 组的字节的下标数，二者皆包含。<ul>
<li><code>bitcount&lt;key&gt;[start end]</code> 统计字符串从 start 字节到 end 字节比特值为 1 的数量</li>
</ul>
</li>
<li>bitop<br><code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code><br>bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。</li>
</ul>
<h3 id="Bitmaps-与-set-对比"><a href="#Bitmaps-与-set-对比" class="headerlink" title="Bitmaps 与 set 对比"></a>Bitmaps 与 set 对比</h3><ul>
<li>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和<br>Bitmaps 分别存储活跃用户。</li>
<li>这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</li>
<li>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10<br>万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</li>
</ul>
<h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2. HyperLogLog"></a>2. HyperLogLog</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul>
<li>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV<br>（PageView 页面访问量）,可以使用 Redis 的 incr、incrby 轻松实现。</li>
<li>但像 UV（UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</li>
<li>解决基数问题有很多种方案：<ul>
<li>（1）数据存储在 MySQL 表中，使用 distinct count 计算不重复个数</li>
<li>（2）使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li>
<li>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非<br>常大的数据集是不切实际的。</li>
</ul>
</li>
<li>能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog</li>
<li>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</li>
<li>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li>
<li>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</li>
<li>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8},基数(不重复元素)为 5。 基数估计就是在误差可接受的范围内，快速计算基数。</li>
</ul>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li>pfadd <key>&lt; element&gt; [element …]<br> 添加指定元素到 HyperLogLog 中将所有元素添加到指定 HyperLogLog 数据结构中。如果执行命令后 HLL 估计的近似基数发生变化，则返回 1，否则返回 0。</key></li>
<li>pfcount<key> [key …]<br>计算 HLL 的近似基数，可以计算多个 HLL，比如用 HLL 存储每天的 UV，计算一周的 UV 可以使用 7 天的 UV 合并计算即可</key></li>
<li>pfmerge<destkey><sourcekey> [sourcekey …]<br>将一个或多个 HLL 合并后的结果存储在另一个 HLL 中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</sourcekey></destkey></li>
</ul>
<h2 id="3-Geospatial"><a href="#3-Geospatial" class="headerlink" title="3. Geospatial"></a>3. Geospatial</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]<br>添加地理位置（经度，纬度，名称）<ul>
<li>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</li>
<li>有 效 的 经 度 从 -180 度 到 180 度 。 有 效 的 纬 度 从 -85.05112878 度 到<br>85.05112878 度。</li>
<li>当坐标位置超出指定范围时，该命令将会返回一个错误。</li>
<li>已经添加的数据，是无法再次往里面添加的。</li>
</ul>
</member></latitude></key></li>
<li>geopos <key><member> [member…]<br>获得指定地区的坐标值</member></key></li>
<li>geodist<key><member1><member2> [m|km|ft|mi ]<br> 获取两个位置之间的直线距离<br>单位：<ul>
<li>m 表示单位为米[默认值]。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英里。</li>
<li>ft 表示单位为英尺。</li>
<li>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</li>
</ul>
</member2></member1></key></li>
<li>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi<br>以给定的经纬度为中心，找出某一半径内的元素</latitude></key></li>
</ul>
<h1 id="七、Jedis操作Redis6"><a href="#七、Jedis操作Redis6" class="headerlink" title="七、Jedis操作Redis6"></a>七、Jedis操作Redis6</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="Jedis-所需要的-jar-包："><a href="#Jedis-所需要的-jar-包：" class="headerlink" title="Jedis 所需要的 jar 包："></a>Jedis 所需要的 jar 包：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="连接-Redis-注意事项"><a href="#连接-Redis-注意事项" class="headerlink" title="连接 Redis 注意事项"></a>连接 Redis 注意事项</h3><ul>
<li>禁用 Linux 的防火墙：<br>Linux(CentOS7)里执行命令<br><code>systemctl stop/disable firewalld.service</code></li>
<li>redis.conf 中注释掉 bind 127.0.0.1 ,然后 protected-mode no</li>
</ul>
<h3 id="Jedis-常用操作"><a href="#Jedis-常用操作" class="headerlink" title="Jedis 常用操作"></a>Jedis 常用操作</h3><p>测试程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.137.3&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">		String pong = jedis.ping();</span><br><span class="line">		System.out.println(<span class="string">&quot;连接成功：&quot;</span>+pong);</span><br><span class="line">		jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据读写测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key</span></span><br><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">	System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br><span class="line"><span class="comment">//List</span></span><br><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">	System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">	System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line"><span class="comment">//hash</span></span><br><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">	System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zset</span></span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">	System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>要求：<br>1、输入手机号，点击发送后随机生成 6 位数字码，2 分钟有效<br>2、输入验证码，点击验证，返回成功或失败<br>3、每个手机号每天只能输入 3 次</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 八、Redis6与Spring Boot整合</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  在 pom.xml 文件中引入 redis 相关依赖</span><br><span class="line"></span><br><span class="line">   ~~~xml</span><br><span class="line">   &lt;!-- redis --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- spring2.X 集成 redis 所需 common-pool2--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> application.properties 配置 redis 配置</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis 服务器地址</span><br><span class="line">spring.redis.host=192.168.140.136</span><br><span class="line">#Redis 服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">#Redis 数据库索引（默认为 0）</span><br><span class="line">spring.redis.database= 0</span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=1800000</span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=20</span><br><span class="line">#最大阻塞等待时间(负数表示没限制)</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1</span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=5</span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 添加 redis 配置类</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; 				<span class="title">redisTemplate</span><span class="params">(RedisConnectionFactoryfactory)</span> </span>&#123;</span><br><span class="line">	RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">	RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span>;</span><br><span class="line">    StringRedisSerializer();</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    om.setVisibility(PropertyAccessor.ALL,</span><br><span class="line">                     JsonAutoDetect.Visibility.ANY);</span><br><span class="line">   om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">	<span class="comment">//key 序列化方式</span></span><br><span class="line">	template.setKeySerializer(redisSerializer);</span><br><span class="line">	<span class="comment">//value 序列化</span></span><br><span class="line">	template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">	<span class="comment">//value hashmap 序列化</span></span><br><span class="line">	template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">	RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">	Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">	<span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">	ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">	om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">	om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">	jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">	<span class="comment">// 配置序列化（解决乱码的问题）,过期时间 600 秒</span></span><br><span class="line">	RedisCacheConfiguration config =</span><br><span class="line">RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">.entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">.serializeKeysWith(RedisSerializationContext.SerializationPair.</span><br><span class="line">fromSerializer(redisSerializer))</span><br><span class="line">.serializeValuesWith(RedisSerializationContext.SerializationPai</span><br><span class="line">r.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">.disableCachingNullValues();</span><br><span class="line">	RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">.cacheDefaults(config)</span><br><span class="line">.build();</span><br><span class="line">	<span class="keyword">return</span> cacheManager;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>RedisTestController 中添加测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置值到 redis</span></span><br><span class="line">	redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">	<span class="comment">//从 redis 获取值</span></span><br><span class="line">	String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="九、Redis6的事务操作"><a href="#九、Redis6的事务操作" class="headerlink" title="九、Redis6的事务操作"></a>九、Redis6的事务操作</h1><h1 id="十、Redis6持久化之RDB"><a href="#十、Redis6持久化之RDB" class="headerlink" title="十、Redis6持久化之RDB"></a>十、Redis6持久化之RDB</h1><h1 id="十一、Redis持久化之AOF"><a href="#十一、Redis持久化之AOF" class="headerlink" title="十一、Redis持久化之AOF"></a>十一、Redis持久化之AOF</h1><h1 id="十二、Redis6的主从复制"><a href="#十二、Redis6的主从复制" class="headerlink" title="十二、Redis6的主从复制"></a>十二、Redis6的主从复制</h1><h1 id="十三、Redis6集群"><a href="#十三、Redis6集群" class="headerlink" title="十三、Redis6集群"></a>十三、Redis6集群</h1><h1 id="十四、Redis6应用问题解决"><a href="#十四、Redis6应用问题解决" class="headerlink" title="十四、Redis6应用问题解决"></a>十四、Redis6应用问题解决</h1><h1 id="十五、Redis6新功能"><a href="#十五、Redis6新功能" class="headerlink" title="十五、Redis6新功能"></a>十五、Redis6新功能</h1></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">stary</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://stary1999.github.io/2021/07/22/Redis6/">https://stary1999.github.io/2021/07/22/Redis6/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://stary1999.github.io">繁星点点</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/07/23/faceQuestions/"><i class="fas fa-angle-left">&nbsp;</i><span>面试题</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2021/07/22/JVM/"><span>JVM入门</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By stary</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>