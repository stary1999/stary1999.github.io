<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>设计模式 | Hexo</title>
  <meta name="description" content="1.概述1.经典面试题原型设计模式 有请使用UML类图画出原型模式核心角色   原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写 clone方法实现深拷贝、使用序列化来实现深拷贝)   在Spring框架中哪里使用到原型模式，并对源码进行分析 beans.xml  Spring中原型bean的创建，就是原型模式的应用   代码分析+Debug源码 设计模式的七大原则: 要求：">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.概述1.经典面试题原型设计模式 有请使用UML类图画出原型模式核心角色   原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写 clone方法实现深拷贝、使用序列化来实现深拷贝)   在Spring框架中哪里使用到原型模式，并对源码进行分析 beans.xml  Spring中原型bean的创建，就是原型模式的应用   代码分析+Debug源码 设计模式的七大原则: 要求：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140553369.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140913112.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711144757978.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714090836038.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714093947025.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714174633658.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714183617841.png">
<meta property="og:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714190551112.png">
<meta property="article:published_time" content="2021-07-11T01:37:47.000Z">
<meta property="article:modified_time" content="2021-08-27T10:26:22.692Z">
<meta property="article:author" content="stary">
<meta property="article:tag" content="java">
<meta property="article:tag" content="工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140553369.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://stary1999.github.io" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">stary</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">愿启明星照亮信仰，照进现实</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Jiangsu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/stary" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p> </br> <p>博客迁移，功能尚未完善，评论无效</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/default/">default</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E8%AE%BE/">课设</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDN/" rel="tag">SDN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot2/" rel="tag">SpringBoot2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/default/" rel="tag">default</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/" rel="tag">idea</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsp/" rel="tag">jsp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springCloud/" rel="tag">springCloud</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BE%A4%E9%9B%86/" rel="tag">群集</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/MyBatis/" style="font-size: 13px;">MyBatis</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/SDN/" style="font-size: 13px;">SDN</a> <a href="/tags/SpringBoot/" style="font-size: 13px;">SpringBoot</a> <a href="/tags/SpringBoot2/" style="font-size: 13px;">SpringBoot2</a> <a href="/tags/SpringCloud/" style="font-size: 13px;">SpringCloud</a> <a href="/tags/android/" style="font-size: 13px;">android</a> <a href="/tags/default/" style="font-size: 14px;">default</a> <a href="/tags/docker/" style="font-size: 13px;">docker</a> <a href="/tags/git/" style="font-size: 13px;">git</a> <a href="/tags/github/" style="font-size: 13px;">github</a> <a href="/tags/hexo/" style="font-size: 13px;">hexo</a> <a href="/tags/idea/" style="font-size: 13px;">idea</a> <a href="/tags/java/" style="font-size: 13.75px;">java</a> <a href="/tags/jsp/" style="font-size: 13px;">jsp</a> <a href="/tags/jvm/" style="font-size: 13px;">jvm</a> <a href="/tags/markdown/" style="font-size: 13px;">markdown</a> <a href="/tags/springCloud/" style="font-size: 13px;">springCloud</a> <a href="/tags/ubuntu/" style="font-size: 13px;">ubuntu</a> <a href="/tags/vue/" style="font-size: 13px;">vue</a> <a href="/tags/web/" style="font-size: 13px;">web</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 13px;">前端</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 13.25px;">实践</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.5px;">工具</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13px;">数据库</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 13.25px;">框架</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 13.25px;">笔记</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 13px;">网络</a> <a href="/tags/%E7%BE%A4%E9%9B%86/" style="font-size: 13px;">群集</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.5px;">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 13.5px;">项目</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/2021/08/26/project-2021-08-26-EVENGOfNetwork/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
              </p>
              <p class="item-title">
                <a href="/2021/08/26/project-2021-08-26-EVENGOfNetwork/" class="title">EVE-NG仿真路由组网与交换机配置</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-26T05:40:34.000Z" itemprop="datePublished">2021-08-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/2021/08/26/project-2021-08-26-windowsServerHyperV/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
              </p>
              <p class="item-title">
                <a href="/2021/08/26/project-2021-08-26-windowsServerHyperV/" class="title">基于windows server搭建的故障群集转移</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-26T05:31:28.000Z" itemprop="datePublished">2021-08-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/2021/08/26/project-2021-08-26-dockerOfDeploy/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
              </p>
              <p class="item-title">
                <a href="/2021/08/26/project-2021-08-26-dockerOfDeploy/" class="title">docker实现企业服务负载均衡架构</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-26T05:31:04.000Z" itemprop="datePublished">2021-08-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/2021/08/26/project-2021-08-26-PerceptionAndControl/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
              </p>
              <p class="item-title">
                <a href="/2021/08/26/project-2021-08-26-PerceptionAndControl/" class="title">感知与控制（快递柜）</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-26T05:29:47.000Z" itemprop="datePublished">2021-08-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/2021/08/26/project-2021-08-26-androidAndIoT/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
              </p>
              <p class="item-title">
                <a href="/2021/08/26/project-2021-08-26-androidAndIoT/" class="title">远程数据采集控制（android）</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-26T05:28:03.000Z" itemprop="datePublished">2021-08-26</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">1.经典面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">原型设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">解释器设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">单例设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A6%82%E8%BF%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.概述设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">设计模式的重要性 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">设计原则核心思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-UML%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">3.UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">2.七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%AE%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">1.设计模式目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-1"><span class="toc-number">2.2.</span> <span class="toc-text">2.七大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">3. 单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">基本介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">代码示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">注意事项与细节：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">2.4.</span> <span class="toc-text">接口隔离原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">基本介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-number">2.5.</span> <span class="toc-text">依赖倒转原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">2.5.0.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.0.2.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-number">2.5.0.3.</span> <span class="toc-text">细节说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.</span> <span class="toc-text">里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">基本介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">2.7.</span> <span class="toc-text">开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">2.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.7.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-number">2.8.</span> <span class="toc-text">迪米特原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">2.8.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E6%B3%A8%E6%84%8F"><span class="toc-number">2.8.2.</span> <span class="toc-text">细节注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">2.9.</span> <span class="toc-text">合成复用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">2.9.1.</span> <span class="toc-text">基本介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">3.二十三种设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">设计模式介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">设计模式类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">3.3.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">饿汉式（静态常量）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">应用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">饿汉式（静态代码块）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">应用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">懒汉式（线程不安全）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-2"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">懒汉式（线程安全，同步方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-3"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="toc-number">3.3.5.</span> <span class="toc-text">懒汉式（线程安全，同步代码块）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-2"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-4"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5"><span class="toc-number">3.3.6.</span> <span class="toc-text">双重检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-3"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-5"><span class="toc-number">3.3.6.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.3.7.</span> <span class="toc-text">静态内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-4"><span class="toc-number">3.3.7.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-6"><span class="toc-number">3.3.7.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.3.8.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-5"><span class="toc-number">3.3.8.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-7"><span class="toc-number">3.3.8.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8JDK%E5%BA%94%E7%94%A8%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.3.9.</span> <span class="toc-text">单例模式在JDK应用的源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.10.</span> <span class="toc-text">单例模式说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-6"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-7"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-number">3.4.3.</span> <span class="toc-text">工厂模式小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">传统模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">3.5.3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E-8"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-8"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.4.</span> <span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-9"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">3.5.4.3.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">3.5.5.</span> <span class="toc-text">对象适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-10"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-1"><span class="toc-number">3.5.6.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">装饰者设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.6.2.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">原理：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-11"><span class="toc-number">3.6.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2"><span class="toc-number">3.7.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">3.7.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-12"><span class="toc-number">3.7.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-2"><span class="toc-number">3.7.4.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.8.</span> <span class="toc-text">外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-3"><span class="toc-number">3.8.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">3.8.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-13"><span class="toc-number">3.8.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-3"><span class="toc-number">3.8.4.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.9.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-4"><span class="toc-number">3.9.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.9.2.</span> <span class="toc-text">传统解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-12"><span class="toc-number">3.9.3.</span> <span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E5%92%8C%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">内部状态和外部状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-14"><span class="toc-number">3.9.4.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.9.4.1.</span> <span class="toc-text">分析静态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.9.5.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">3.9.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-15"><span class="toc-number">3.9.5.2.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%8F%98%E4%BD%93"><span class="toc-number">3.9.6.</span> <span class="toc-text">代理变体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.10.</span> <span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-5"><span class="toc-number">3.10.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">3.10.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-16"><span class="toc-number">3.10.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-4"><span class="toc-number">3.10.4.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.10.5.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-6"><span class="toc-number">3.10.6.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-13"><span class="toc-number">3.10.7.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-17"><span class="toc-number">3.10.8.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.10.9.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.11.</span> <span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-7"><span class="toc-number">3.11.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">3.11.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-18"><span class="toc-number">3.11.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.12.</span> <span class="toc-text">中介者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-8"><span class="toc-number">3.12.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">3.12.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-19"><span class="toc-number">3.12.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">3.12.4.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-9"><span class="toc-number">3.13.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-14"><span class="toc-number">3.13.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-20"><span class="toc-number">3.13.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">3.13.4.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.14.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-10"><span class="toc-number">3.14.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">3.14.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-21"><span class="toc-number">3.14.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-5"><span class="toc-number">3.14.4.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">3.15.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">3.15.1.</span> <span class="toc-text">说明：</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-tools-2021-07-11-DesignPatterns" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/07/11/tools-2021-07-11-DesignPatterns/" class="article-date">
	  <time datetime="2021-07-11T01:37:47.000Z" itemprop="datePublished">2021-07-11</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/default/">default</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/java/" rel="tag">java</a>, <a class="article-tag-link-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/07/11/tools-2021-07-11-DesignPatterns/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 22.5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 79(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-经典面试题"><a href="#1-经典面试题" class="headerlink" title="1.经典面试题"></a>1.经典面试题</h2><h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><ol>
<li>有请使用UML类图画出原型模式核心角色 </li>
<li> 原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写 clone方法实现深拷贝、使用序列化来实现深拷贝) </li>
<li> 在Spring框架中哪里使用到原型模式，并对源码进行分析 beans.xml </li>
<li>Spring中原型bean的创建，就是原型模式的应用 </li>
<li> 代码分析+Debug源码</li>
<li>设计模式的七大原则: 要求：<ol>
<li>七大设计原则核心思想 </li>
<li> 能够以类图的说明设计原则</li>
<li> 在项目实际开发中，你在哪里使用到了ocp原则</li>
</ol>
</li>
</ol>
<p>金融借贷平台项目：借贷平台的订单，有审核发布-抢单 等等 步骤，随着操作的不同，会改 变订单的状态, 项目中的这个模块实现就会使用 到状态模式，请你使用状态模式进行设计，并 完成实际代码<br>问题分析 ： 这类代码难以应对变化，在添加一种状态时， 我们需要手动添加if/else，在添加一种功能时， 要对所有的状态进行判断。因此代码会变得越 来越臃肿，并且一旦没有处理某个状态，便会 发生极其严重的BUG，难以维护</p>
<h3 id="解释器设计模式"><a href="#解释器设计模式" class="headerlink" title="解释器设计模式"></a>解释器设计模式</h3><ol>
<li>介绍解释器设计模式是什么? </li>
<li>画出解释器设计模式的UML类图, 分析设计模式中的各个角色是什 么? </li>
<li> 请说明Spring的框架中，哪里 使用到了解释器设计模式，并 做源码级别的分析</li>
<li>解释器模式在Spring框架应用的源码剖析 <ol>
<li>Spring框架中 SpelExpressionParser就使用到解释器模式 </li>
<li> 代码分析+Debug源码+模式角色分析说明</li>
</ol>
</li>
</ol>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>单例设计模式一共有几种实现方式？请分别用代码实现，并说明各个实现方式的 优点和缺点? </p>
<p>单例设计模式一共有8种写法，</p>
<ol>
<li>饿汉式 两种 </li>
<li>懒汉式 三种 </li>
<li>双重检查</li>
<li> 静态内部类</li>
<li>枚举</li>
</ol>
<h2 id="2-概述设计模式"><a href="#2-概述设计模式" class="headerlink" title="2.概述设计模式"></a>2.概述设计模式</h2><h3 id="设计模式的重要性-："><a href="#设计模式的重要性-：" class="headerlink" title="设计模式的重要性 ："></a>设计模式的重要性 ：</h3><ol>
<li>软件工程中，设计模式（design pattern）是对软件设计中<strong>普遍存在（反复出现）</strong> 的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人 在1990年代从建筑设计领域引入到计算机科学的</li>
<li>大厦 VS 简易房</li>
<li>拿实际工作经历来说, 当一个项目开发完后，如果<strong>客户提出增新功能</strong>，怎么办?。</li>
<li>如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (<strong>维护性</strong>[可读性、 规范性]) </li>
<li>目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中　<font color="red"> <strong>使用过什么 设计模式，怎样使用的，解决了什么问题。</strong></font></li>
<li>设计模式在软件中哪里？面向对象(oo)=&gt;功能模块[设计模式+算法(数据结构)]=&gt;框 架[使用到多种设计模式]=&gt;架构 [服务器集群] </li>
<li>如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的.</li>
</ol>
<h3 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h3><ol>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>为了交互对象之间的<strong>松耦合设计而努力</strong></li>
</ol>
<h2 id="3-UML类图"><a href="#3-UML类图" class="headerlink" title="3.UML类图"></a>3.UML类图</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>UML——Unified modeling language UML  (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果 </li>
<li> UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: </li>
<li>使用UML来建模，常用的工具有 Rational  Rose , 也可以使用一些插件来建模</li>
</ol>
<p>画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理， </p>
<p>UML图分类：</p>
<ol>
<li>用例图(use case) </li>
<li>静态结构图：类图、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li>
</ol>
<p>UML类图：</p>
<ol>
<li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li>
<li> 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合</li>
<li>依赖：只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编 绎都通过不了<br>小结<ol>
<li>类中用到了对方</li>
<li>如果是类的成员属性 </li>
<li> 如果是方法的返回类型</li>
<li>是方法接收的参数类型 </li>
<li>方法中使用到</li>
</ol>
</li>
<li>泛化：泛化关系实际上就是继承关系，他是依赖关系的特例<br>小结：<ol>
<li>泛化关系实际上就是继承关系</li>
<li> 如果A类继承了B类，我们就说A和B存在泛化关系</li>
</ol>
</li>
<li>实现：实现关系实际上就是A类实现B接口，他是依赖关系的特例</li>
<li>关联：关联关系实际上就是类与类之间的联系，他是依赖关系的特例 关联具有导航性：即双向关系或单向关系 关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个）， “0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m 个）。 </li>
<li>聚合：聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。<br>聚 合关系是关联关系的特例，所以他具有关联的导航性与多重性。 如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个 配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</li>
<li>组合：组合关系：也是整体与部分的关系，但是整体与部分不可以分开。<br>再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</li>
</ol>
<h1 id="2-七大原则"><a href="#2-七大原则" class="headerlink" title="2.七大原则"></a>2.七大原则</h1><h2 id="1-设计模式目的"><a href="#1-设计模式目的" class="headerlink" title="1.设计模式目的"></a>1.设计模式目的</h2><p>编写软件过程中，程序员面临着来自<strong>耦合性、内聚性以及可维护性、可拓展性、重用性、灵活性</strong>等多方面的挑战，设计模式是为了让程序（软件）具有更好的：</p>
<ol>
<li>代码重用性 (即：相同功能的代码，不用多次编写) </li>
<li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解) </li>
<li> 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>使程序呈现高内聚，低耦合的特性</li>
</ol>
<p>分享金句： </p>
<ol>
<li>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计 （OOA/D）的精要”</li>
<li> Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是 前者手背上有很多伤疤</li>
</ol>
<h2 id="2-七大原则-1"><a href="#2-七大原则-1" class="headerlink" title="2.七大原则"></a>2.七大原则</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据）</p>
<p>七大原则：</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转（倒置）原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特原则</li>
<li>合成复用原则</li>
</ol>
<h2 id="3-单一职责原则"><a href="#3-单一职责原则" class="headerlink" title="3. 单一职责原则"></a>3. 单一职责原则</h2><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><p>对类来说的，即<strong>一个类应该只负责一项职责</strong>。如类A负责两个不同的职责：职责1、职责2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1、A2</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>略</p>
<h4 id="注意事项与细节："><a href="#注意事项与细节：" class="headerlink" title="注意事项与细节："></a>注意事项与细节：</h4><ol>
<li>降低类的复杂度，一个类只负责一项职责</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则，只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>
<li><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140553369.png" alt="image-20210711140553369"></li>
<li>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法</li>
<li>按隔离原则优化：将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。</li>
<li><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140913112.png" alt="image-20210711140913112"></li>
</ol>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则是指：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li>
<li>依赖倒转的中心思想是面向接口编程</li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定得多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类的目的是制定好规范，而不设计任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">		</span><br><span class="line">		person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h4><p>依赖关系传递的三种方式：</p>
<ol>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ol>
<p>注意：</p>
<ol>
<li>低层模块尽量有抽象类或接口，或者两者都有，程序稳定性更好</li>
<li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象之间，就存在一个缓冲层，利于程序的拓展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>OO中的继承性：</p>
<ol>
<li>继承包含这样的一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</li>
<li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承类会给程序带来<strong>侵入性</strong>，程序的可移植性降低，增加对象之间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到的子类的功能都有可能产生故障</li>
<li>问题提出：<strong>在编程中，如何正确的使用继承？====》里氏替换原则</strong></li>
</ol>
<p>基本介绍：</p>
<ol>
<li>里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的</li>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，<strong>所有引用积累的地方必须能透明底使用其子类的对象</strong></li>
<li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li>
<li>里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过　<font color="red"> 聚合，组合，依赖 </font>来解决问题</li>
</ol>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>开闭原则是编程中<strong>最基础、最重要</strong>的设计原则</li>
<li>一个软件实体如类、模块和函数，应该<strong>对拓展开放（对提供方）</strong>，对<strong>修改关闭（对使用方）</strong>。用抽象构建框架，用实现拓展细节</li>
<li>当软件需要变化时，尽量通过拓展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>
<li>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则</li>
</ol>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用看看存在的问题</span></span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_type;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Rectangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Triangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	OtherGraphic() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类与类的关系越密切，耦合度越大</li>
<li>迪米特原则也叫<strong>最少知道原则</strong>，即一个类<strong>对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息</li>
<li>迪米特原则还有个更简单的定义：只与直接的朋友通信</li>
<li><strong>直接的朋友</strong>：每个对象都会与其他的对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现<strong>成员变量、方法参数】方法返回值</strong>中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li>
</ol>
<h3 id="细节注意"><a href="#细节注意" class="headerlink" title="细节注意"></a>细节注意</h3><ol>
<li>迪米特原则的核心是降低类之间的耦合</li>
<li>注意：由于每个类都减少了不必要的依赖，依次迪米特原则只是要求降低类间（对象间）的耦合关系，并不是要求完全没有依赖。</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>原则是尽量使用合成、聚合的方式，而不是使用聚合</p>
<p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711144757978.png" alt="image-20210711144757978"></p>
<h1 id="3-二十三种设计模式"><a href="#3-二十三种设计模式" class="headerlink" title="3.二十三种设计模式"></a>3.二十三种设计模式</h1><h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， 模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern） 代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时 间的试验和错误总结出来的。</li>
<li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂 度。 </li>
<li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph  Johnson 和 John Vlissides Design（俗称 “四人组 GOF”） </li>
<li> 设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li>
</ol>
<h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><p>设计模式分为三种类型，共23种 </p>
<ol>
<li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。 </li>
<li> 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。</li>
</ol>
<h2 id="单例设计模式-1"><a href="#单例设计模式-1" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类==只能存在一个对象实例==，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<p>比如Hibernate的SessionFactory，它充当数据存储源的代理，并且负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFanctory就够，这就是单例模式</p>
<p>单例模式的八种方式：</p>
<ol>
<li>==饿汉式（静态常量）==</li>
<li>==饿汉式（静态代码块）==</li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li>==双重检查==</li>
<li>==静态内部类==</li>
<li>==枚举==</li>
</ol>
<h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>步骤：</p>
<ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法。getInstance</li>
</ol>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>优点：这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步的问题</li>
<li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终未使用过这个实例，则会造成内存的浪费</li>
<li>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或其他的静态方法）导致类装载，这时候初始化instance就没有达到Lazy Loading的效果</li>
<li>结论：这种单例模式==可用，但可能造成内存浪费==。</li>
</ol>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ol>
<li>和和饿汉式（静态常量）类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点同饿汉式（静态常量）</li>
<li>结论：这种单例模式可用，但是可能造成内存浪费</li>
</ol>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ol>
<li>起到了Lazy Loading的效果，但是只能在单线程下使用</li>
<li>如果在多线程下，一个线程进入了if（singleton==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li>
<li>结论：在实际开发中，不要使用这种方式</li>
</ol>
<h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol>
<li>解决了线程不安全的问题</li>
<li>效率太低，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得的该类实例，直接return就行了。方法进行同步效率太低</li>
<li>结论：在实际开发中，不推荐使用这种方式</li>
</ol>
<h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步代码块)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol>
<li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的代码块</li>
<li>==但是这种同步并不能起到线程同步的作用==。跟第三种实现方式遇到的情形一直，加入一个线程进入if（singleton==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</li>
<li>结论：在实际开发中，不能使用这种方式</li>
</ol>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><ol>
<li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if（singleton==null）检查，这样就可以保证线程安全了</li>
<li>这样，实例化代码只用执行一次，后面再次进行访问时，判断if（singleton==null），直接return实例化对象，也避免反复进行方法同步</li>
<li>线程安全，延迟加载，效率较高</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><ol>
<li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程</li>
<li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化</li>
<li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的</li>
<li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li>
<li>结论：推荐使用</li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	INSTANCE; <span class="comment">//属性</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ok~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><ol>
<li>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程的同步问题，而且还能防止反序列化重新创建新的对象</li>
<li>这种方式是Effective Java作者Josh Bloch提倡的方式</li>
<li>结论：推荐使用</li>
</ol>
<h3 id="单例模式在JDK应用的源码分析"><a href="#单例模式在JDK应用的源码分析" class="headerlink" title="单例模式在JDK应用的源码分析"></a>单例模式在JDK应用的源码分析</h3><ol>
<li>在JDK中，java.lang.Runtime就是经典的单例模式（饿汉式）</li>
<li></li>
</ol>
<h3 id="单例模式说明"><a href="#单例模式说明" class="headerlink" title="单例模式说明"></a>单例模式说明</h3><ol>
<li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</li>
<li>单例模式使用的场景：<ul>
<li>需要频繁的进行创建和销毁的对象</li>
<li>创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象</li>
<li>工具类对象</li>
<li>频繁访问数据库或文件的对象（比如数据源、Session工厂等）</li>
</ul>
</li>
</ol>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护 </p>
<ol>
<li>披萨的种类很多(比如 GreekPizz、CheesePizz 等) </li>
<li>披萨的制作有 prepare，bake, cut, box  </li>
<li>完成披萨店订购功能。</li>
</ol>
<p>传统方式的优缺点：</p>
<ol>
<li>优点是比较好理解，简单易操作。 </li>
<li>缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增 加新功能的时候，尽量不修改代码，或者尽可能少修改代码. </li>
<li>比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做修改</li>
<li>改进：<br>分析：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味 着，也需要修改，而创建Pizza的代码，往往有多处。<br>思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该 类就可，其它有创建到Pizza对象的代码就不需要修改了.-&gt; 简单工厂模式</li>
</ol>
<h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>简单工厂模式是属于创建型模式，是工厂模式的一种。==简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例==。简单工厂模式是工厂模式家族中最简单实用的模式</li>
<li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）</li>
<li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。</li>
</ol>
<h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><ol>
<li><p>简单工厂模式的设计方案：定义一个可以实例化对象的类，封装创建对象的代码</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式~~&quot;</span>);</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">            <span class="keyword">return</span> pizza;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。</p>
<p>思路1：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory等，但是考虑到项目规模扩大、以及软件的可维护性、可拓展性，这种方式不是太好</p>
<p>思路2：使用工厂方法模式</p>
<h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现</li>
<li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将<strong>对象的实例化推迟到子类</strong></li>
</ol>
<h4 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### 抽象工厂模式</span><br><span class="line"></span><br><span class="line">#### 基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 抽象工厂模式：定义了一个<span class="class"><span class="keyword">interface</span>用于创建相关或有依赖关系的对象簇，而无需指明具体的类</span></span><br><span class="line"><span class="class">2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合</span></span><br><span class="line"><span class="class">3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或称为进一步抽象）</span></span><br><span class="line"><span class="class">4. 将工厂抽象成两层，<span class="title">AbsFactory</span>和具体实现的工厂子类。程序员可以根据创建对象使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#### 应用</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">~~~<span class="title">java</span></span></span><br></pre></td></tr></table></figure>

<h3 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a>工厂模式小结</h3><p>工厂模式在JdK-Calendar中的应用：</p>
<ul>
<li>应用了简单工厂模式</li>
</ul>
<p>工厂模式意义：</p>
<ul>
<li>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的拓展和维护性</li>
</ul>
<p>三种工厂模式：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<p>设计模式的抽象原则：</p>
<ul>
<li>创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li>
<li>不要让类继承具体类，而是继承抽象类或者是实现interface接口</li>
<li>不要覆盖基类中已经实现的方法</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>现有一只羊tom，姓名为tom，年龄为1，颜色为白，请编写程序创建和tom羊属性完全相同的10只羊</p>
<h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><p>分析：</p>
<ol>
<li>优点是容易理解，简单易操作</li>
<li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li>
<li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活</li>
<li>改进思路：<br>java中Object类是所有类的根类，Object类提供了一个clone（）方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制能力===》原型模式</li>
</ol>
<h3 id="原型模式-1"><a href="#原型模式-1" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li>
<li>原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节</li>
<li>工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实现创建，即：对象.clone()</li>
</ol>
<h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><p>uml图：</p>
<p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714090836038.png" alt="image-20210714090836038"></p>
<ol>
<li>Prototype：原型类，声明一个克隆自己的接口</li>
<li>ConcretePrototype：具体的原型类，实现一个克隆自己的操作</li>
<li>Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）</li>
</ol>
<h4 id="应用-8"><a href="#应用-8" class="headerlink" title="应用"></a>应用</h4><p>使用原型模式改进传统方式，让程序具有更高的效率和拓展性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 实际应用</span><br><span class="line"></span><br><span class="line">Spring中原型bean的创建，就是 原型模式的应用</span><br><span class="line"></span><br><span class="line">#### 拷贝</span><br><span class="line"></span><br><span class="line">浅拷贝介绍：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象</span><br><span class="line"><span class="number">2.</span> 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</span><br><span class="line"><span class="number">3.</span> 浅拷贝使用默认的clone()方法来实现，例如：sheep=（Sheep）<span class="keyword">super</span>.clone()；</span><br><span class="line"></span><br><span class="line">深拷贝介绍：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 复制对象的所有基本数据类型的成员变量值</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 深拷贝的实现方式<span class="number">1</span>：重写clone方法实现深拷贝</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>深拷贝的实现方式2：通过对象序列化实现深拷贝（推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   ~~~</span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</span><br><span class="line"><span class="number">2.</span> 不用重新初始化对象，而是动态地获得对象运行时的状态</span><br><span class="line"><span class="number">3.</span> 如果原始对象发生变化（增加或者减少属性），其他克隆的对象也会发生相应的变化，无需修改代码</span><br><span class="line"><span class="number">4.</span> 在实现深克隆的时候可能需要比较复杂的代码</span><br><span class="line"><span class="number">5.</span> **缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改器源代码，违背了OCP原则。</span><br><span class="line">   OCP原则：开闭原则，Open Closed Principle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 建造者模式</span><br><span class="line"></span><br><span class="line">### 需求</span><br><span class="line"></span><br><span class="line">盖房项目需求：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 需要建房子：这一过程为打桩、砌墙、封顶</span><br><span class="line"><span class="number">2.</span> 房子有各种各样的，比如普通房、高楼、别墅，各种房子的建造过程虽然一样，但是要求不要相同的</span><br><span class="line"></span><br><span class="line">### 传统方式</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure></li>
</ol>
<ol>
<li>优点是比较好理解，简单易操作</li>
<li>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，也就是说，这种设计方案，把产品（房子）和创建产品的过程（建造房子的流程）封装在一起，耦合性增强了</li>
<li>解决方案：将产品和产品建造的过程解耦==》建造者模式</li>
</ol>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>建造者模式（Builder Pattern），又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构建出不同表现（属性）的对象</li>
<li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</li>
</ol>
<p>建造者模式的四个角色：</p>
<ol>
<li>Product，产品角色：衣蛾具体的产品对象</li>
<li>Builder，抽象建造者：创建一个Product对象的各个部件指定的接口/抽象类。</li>
<li>ConcreteBuilder，具体建造者：实现接口，构建和装配各个部件</li>
<li>Director，指挥者：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</li>
</ol>
<p>建造者模式的原理图：</p>
<p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714093947025.png" alt="image-20210714093947025"></p>
<h4 id="应用-9"><a href="#应用-9" class="headerlink" title="应用"></a>应用</h4><p>解决盖房子需求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">源码应用：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> java.lang.StringBuilder中的建造者模式：</span><br><span class="line">   源码中建造者模式角色分析 ：</span><br><span class="line">   * Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建 造者, 定义了抽象方法 </span><br><span class="line">   *  AbstractStringBuilder 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化 </span><br><span class="line">   *  StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的 实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder</span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 客户端（使用程序）==不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象==</span><br><span class="line"><span class="number">2.</span> 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以方便地替换具体建造者或增加新的具体建造者，==用户使用不同的具体建造者即可得到不同的产品对象==</span><br><span class="line"><span class="number">3.</span> ==可以更加精细地控制产品的创建过程==。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</span><br><span class="line"><span class="number">4.</span> ==增加新的具体建造者无需修改原有库类的代码==，指挥者类针对抽象建造者类编程，系统拓展方便，符合开闭原则。</span><br><span class="line"><span class="number">5.</span> 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，==如果产品之间的差异性很大，则不适合使用建造者模式==，因此其使用范围受到一定的限制</span><br><span class="line"><span class="number">6.</span> 如果产品发内部变化复制，可能会导致需要定义很多具体建造类来实现这种变化，导致系统变得很庞大，因此在这种情况下，需要考虑是否选择建造者模式</span><br><span class="line"><span class="number">7.</span> ==抽象工厂模式VS建造者模式==</span><br><span class="line">   抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而生产一个新产品</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 适配器模式</span><br><span class="line"></span><br><span class="line">#### 基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）</span><br><span class="line"><span class="number">2.</span> 适配器模式属于结构型模式</span><br><span class="line"><span class="number">3.</span> 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</span><br><span class="line"></span><br><span class="line">#### 工作原理</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</span><br><span class="line"><span class="number">2.</span> 从用户的角度看不到被适配者，是解耦的</span><br><span class="line"><span class="number">3.</span> 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</span><br><span class="line"><span class="number">4.</span> 用户收到反馈结果，感觉只是和目标接口交互</span><br><span class="line"></span><br><span class="line">### 类适配器模式</span><br><span class="line"></span><br><span class="line">Adapter类，通过继承src类，实现dst类接口，完成src-》dst的适配</span><br><span class="line"></span><br><span class="line">#### 应用</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol>
<li>java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定的局限性</li>
<li>src类的方法在Adapter中都会暴露出来，也增加了使用成本</li>
<li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了</li>
</ol>
<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ol>
<li>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题，即：持有src类，实现dst接口，完成src=》dst的适配</li>
<li>根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系</li>
<li>对象适配器模式是适配器模式常用的一种</li>
</ol>
<h4 id="应用-10"><a href="#应用-10" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口</span><br><span class="line"><span class="number">2.</span> 使用成本更低，更灵活</span><br><span class="line"></span><br><span class="line">### 接口适配器</span><br><span class="line"></span><br><span class="line">#### 介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一些书籍成为：适配器模式（Default Adapter Pattern）或缺省适配器模式</span><br><span class="line"><span class="number">2.</span> 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每一个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</span><br><span class="line"><span class="number">3.</span> 适用于一个接口不想使用其所有的方法的情况</span><br><span class="line"></span><br><span class="line">#### 应用</span><br><span class="line"></span><br><span class="line">应用实例：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Android中的属性动画ValueAnimator类可以 通过addListener(AnimatorListener listener)方 法添加监听器， 那么常规写法如下：</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br><span class="line">   ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">   valueAnimator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   valueAnimator.start();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>有时候我们不想实现 Animator.AnimatorListener接口的全部方法， 我们只想监听onAnimationStart，我们会如 下写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">valueAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"><span class="comment">//xxxx具体实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">valueAnimator.start();</span><br></pre></td></tr></table></figure></li>
<li><p> AnimatorListenerAdapter类，就是一个 接口适配器，代码如下:它空实现了 Animator.AnimatorListener类(src)的所 有方法. </p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Animator</span>.<span class="title">AnimatorListener</span></span></span><br><span class="line"><span class="class"><span class="title">Animator</span>.<span class="title">AnimatorPauseListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">//默认实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationPause</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationResume</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>AnimatorListener是一个接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimatorListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>程序里的匿名内部类就是Listener 具体实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"><span class="comment">//xxxx具体实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>源码应用：</p>
<ul>
<li><p>适配器模式在SpringMVC框架中的应用</p>
<ol>
<li><p>SpringMvc中的HandlerAdapter, 就使用了适配器模式</p>
</li>
<li><p>SpringMVC处理请求的流程</p>
</li>
<li><p>使用HandlerAdapter的原因分析：<br>可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么 如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则</p>
</li>
<li><p>代码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">     ~~~</span><br><span class="line"></span><br><span class="line">  <span class="number">5.</span> SpringMVC通过适配器设计模式获取到对应的Controller的源码</span><br><span class="line"></span><br><span class="line">  <span class="number">6.</span> 说明</span><br><span class="line"></span><br><span class="line">     * Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</span><br><span class="line">     * 适配器代替controller执行相应的方法</span><br><span class="line">     * 扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 三种命名方式，是根据src是以怎样的形式给到Adapter来命名的</span><br><span class="line"><span class="number">2.</span> 类适配器：以类给到，在Adapter里，就是将src当作类，继承</span><br><span class="line">   对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有</span><br><span class="line">   接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</span><br><span class="line"><span class="number">3.</span> Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作</span><br><span class="line"><span class="number">4.</span> 实际开发中，实现起来不拘泥这三种经典模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 桥接模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">传统方案解决手机操作问题分析：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 拓展性问题（类爆炸），如果我们增加手机的样式，则需要增加各个品牌手机的类。同理，如果增加一个手机品牌，也要在各个手机样式类下增加。</span><br><span class="line"><span class="number">2.</span> 违反了单一职责原则，当我们增加手机样式时，需要同时增加所有品牌的手机，这样增加了代码维护成本</span><br><span class="line"><span class="number">3.</span> 解决方案：使用桥接模式</span><br><span class="line"></span><br><span class="line">### 基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 桥接模式（Bridge模式）是指：将实现与抽象放在两个不同的类层中，使两个层次可以独立改变</span><br><span class="line"><span class="number">2.</span> 是一种结构型设计模式</span><br><span class="line"><span class="number">3.</span> Bridge模式基于类的最小设计原则通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是吧抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line">![image-<span class="number">20210714124346974</span>](<span class="number">2021</span>-<span class="number">07</span>-<span class="number">11</span>-DesignPatterns/image-<span class="number">20210714124346974.</span>png)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Client类：桥接模式的调用者</span><br><span class="line"><span class="number">2.</span> 抽象类（abstraction）：维护了Implementor，即它的实现类ConcreteImplemenetorA……，二者是聚合关系，Abstraction充当桥接类</span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">解决手机问题：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>桥接模式在JDBC源码应用</p>
<ol>
<li>jdbc的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle得到Driver，这些就可以当作实现接口类</li>
</ol>
<h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol>
<li>桥接模式实现了抽象和实现部分的分离，从而极大提高了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li>
<li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他部分有具体业务来完成。</li>
<li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li>
<li>桥接模式的引入增加了系统的理解和设计难度由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样发应用场景。</li>
</ol>
<p>桥接模式的其他应用场景：</p>
<ol>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</li>
<li>常见的应用场景<ul>
<li>JDBC驱动程序</li>
<li>银行转账系统<br>转账分类、转账用户类型</li>
<li>消息管理<br>消息类型、消息分类</li>
</ul>
</li>
</ol>
<h2 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>星巴克咖啡订单项目（咖啡馆）：</p>
<ol>
<li>咖啡种类</li>
<li>调料</li>
<li>要求在拓展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li>
<li>使用OO来计算不同种类咖啡的费用，可以单点，也可以咖啡+调料</li>
</ol>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>装饰者模式：动态将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><h3 id="应用-11"><a href="#应用-11" class="headerlink" title="应用"></a>应用</h3><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h3 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系</li>
<li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次</li>
<li>这种类型的设计模式属于结构型模式</li>
<li>组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</li>
</ol>
<h3 id="应用-12"><a href="#应用-12" class="headerlink" title="应用"></a>应用</h3><h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol>
<li>简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题</li>
<li>具有较强的扩展性，当我们需要更改组合对象时，我们只需要调整内部的层次关系，客户端不需要作出任何改动</li>
<li>方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构</li>
<li>需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式</li>
<li>要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</li>
</ol>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>外观模式（Facade)，也叫“过程模式”，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li>
<li>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节</li>
</ol>
<h3 id="应用-13"><a href="#应用-13" class="headerlink" title="应用"></a>应用</h3><h3 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h3><ol>
<li>外观模式对外屏蔽了子系统的细节，因此外观模式降低利率客户端对子系统的复杂性</li>
<li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li>
<li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li>
<li>当系统需要进行分层设计时，可以考虑使用Facade模式</li>
<li>在维护一个遗留的大型项目时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</li>
<li>不能过多的或不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要让系统有层次，利于维护为目的</li>
</ol>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>小型外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p>
<ol>
<li>有客户要求以新闻的形式发布</li>
<li>有客户要求以博客的形式发布</li>
<li>有客户希望以微信公众号的形式发布</li>
</ol>
<h3 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h3><ol>
<li>直接复制粘贴一份，然后根据不同的要求，进行定制修改</li>
<li>给每一个网站租用一个空间</li>
<li>方案设计示意图</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器资源的浪费</li>
<li>解决思路：整合到一个网站中，共享器相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都是可以达成共享，减少服务器资源</li>
<li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li>
<li>即：享元模式</li>
</ol>
<h3 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象</li>
<li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li>
<li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似的对象，需要缓冲池时。不需要总是创建新的对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li>
<li>享元模式经典的应用场景就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li>
</ol>
<p>原理图：</p>
<h4 id="内部状态和外部状态"><a href="#内部状态和外部状态" class="headerlink" title="内部状态和外部状态"></a>内部状态和外部状态</h4><ol>
<li>享元模式提出了两个需求：细粒度和共享对象。即将对象的信息分为两个部分：内部状态和外部状态</li>
<li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li>
<li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li>
</ol>
<h3 id="应用-14"><a href="#应用-14" class="headerlink" title="应用"></a>应用</h3><p>解决网站问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">享元模式在JDK-Interger中的应用：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 在享元模式这样理解，“享”就表示共享，“元”表示对象</span><br><span class="line"><span class="number">2.</span> 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</span><br><span class="line"><span class="number">3.</span> 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储</span><br><span class="line"><span class="number">4.</span> 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</span><br><span class="line"><span class="number">5.</span> 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是使用享元模式时需要注意的</span><br><span class="line"><span class="number">6.</span> 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</span><br><span class="line"><span class="number">7.</span> 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 代理模式</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能</span><br><span class="line"><span class="number">2.</span> 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</span><br><span class="line"><span class="number">3.</span> 代理模式有不同发形式，主要有三种：静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态创建对象，而不需要实现接口，它是属于动态代理的范畴）</span><br><span class="line"><span class="number">4.</span> 代理模式示意图</span><br><span class="line"></span><br><span class="line">### 静态代理</span><br><span class="line"></span><br><span class="line">静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象与代理对象一起实现相同的接口或者是继承相同父类</span><br><span class="line"></span><br><span class="line">#### 应用实例：</span><br><span class="line"></span><br><span class="line">具体要求：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 定义一个接口：ITeacherDao</span><br><span class="line"><span class="number">2.</span> 目标对象TeacherDao实现接口ITeacherDao</span><br><span class="line"><span class="number">3.</span> 使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao</span><br><span class="line"><span class="number">4.</span> 调用的时候，通过调用代理对象的方法来调用目标对象</span><br><span class="line"><span class="number">5.</span> 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<h4 id="分析静态代理"><a href="#分析静态代理" class="headerlink" title="分析静态代理"></a>分析静态代理</h4><ol>
<li>优点：在不修改目标对象的功能前提下，能通过dialing对象实现对目标功能扩展</li>
<li>缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类</li>
<li>一旦接口增加方法，目标对象与代理对象都需要维护</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>动态代理模式的基本介绍</p>
<ol>
<li>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li>
<li>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li>
<li>动态代理也叫做：JDK代理、接口代理</li>
</ol>
<p>JDK中生成代理对象的API</p>
<ol>
<li><p>代理类所在的包：java.lang.reflect.Proxy</p>
</li>
<li><p>JDK实现代理只需要使用newProxyInstence方法，但是该方法需要接受三个参数，完整的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] </span></span></span><br><span class="line"><span class="params"><span class="function">interfaces,InvocationHandler h )</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="应用-15"><a href="#应用-15" class="headerlink" title="应用"></a>应用</h4><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### Cglib代理</span><br><span class="line"></span><br><span class="line">#### 介绍</span><br><span class="line"></span><br><span class="line">Cglib代理模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理</span><br><span class="line"><span class="number">2.</span> Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展，有些书也将Cglib代理归属到动态代理</span><br><span class="line"><span class="number">3.</span> Cglib是一个强大的高性能代码生成包，它可以运行期扩展java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP ，实现方法拦截</span><br><span class="line"><span class="number">4.</span> 在AOP编程中如何选择代理模式：</span><br><span class="line">   * 目标对象需要实现接口，用JDK代理</span><br><span class="line">   * 目标对象不需要实现接口，用Cglib代理</span><br><span class="line"><span class="number">5.</span> Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</span><br><span class="line"></span><br><span class="line">#### 实现</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 需要引入Cglib的jar文件</span><br><span class="line"><span class="number">2.</span> 在内存中动态构建子类，注意代理的类不能为<span class="keyword">final</span>，否则报错。因为<span class="keyword">final</span>类不能被继承，也就没有子类</span><br><span class="line"><span class="number">3.</span> 目标对象的方法如果为<span class="keyword">final</span>、<span class="keyword">static</span>，那么就不会被拦截，即不会执行目标对象额外的业务方法</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<h3 id="代理变体"><a href="#代理变体" class="headerlink" title="代理变体"></a>代理变体</h3><p>几种常见的代理模式变体</p>
<ol>
<li>防火墙代理：内网通过代理穿透防火墙，实现对公网的访问</li>
<li>缓存代理：比如，当请求图片文件等资源时，先到缓存代理取，如果取到资源则OK，如果取不到资源，再到公网或者数据库取，然后缓存</li>
<li>远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</li>
<li>同步代理：主要使用在多线程编程中，完成多线程间同步工作</li>
</ol>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><p>编写制作豆浆的程序：</p>
<ol>
<li> 制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li>
<li> 通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li> 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li>
</ol>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>模板方法模式（Template Method Pattern），又叫模板方法模式（Template Pattern），在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需求重写方法实现，但调用将以抽象类中定义的方式进行</li>
<li>简单来说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li>
<li>这种类型的设计模式属于行为型模式</li>
</ol>
<p>原理：</p>
<p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714174633658.png" alt="image-20210714174633658"></p>
<p>说明：</p>
<ul>
<li>AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨 架，具体子类需要去实现 其它的抽象方法operationr2,3,4 </li>
<li> ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步 骤</li>
</ul>
<h3 id="应用-16"><a href="#应用-16" class="headerlink" title="应用"></a>应用</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 模板方法模式中的钩子方法</span><br><span class="line"></span><br><span class="line">* 在模板方法模式的父类中，我们可定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<p>模板方法模式在Spring框架中的应用：</p>
<p>Spring IOC容器初始化时运行用到的模板方法模式</p>
<h3 id="细节-4"><a href="#细节-4" class="headerlink" title="细节"></a>细节</h3><p>模板方法模式的注意事项和细节</p>
<ol>
<li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li>
<li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用</li>
<li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现</li>
<li>该模式的不足之处：每一个不同的实现类都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li>
<li>一般模板方法都加上final关键字，防止子类重写模板方法</li>
<li>模板方法的使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤方法基本相同，但其个别步骤在实现时，可能不同。通常考虑模板方法模式来处理</li>
</ol>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><ol>
<li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就 可以控制对这些家电工作。 2</li>
<li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个App，分别控制，我 们希望只要一个app就可以控制全部智能家电。 </li>
<li>要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口 给app调用，这时 就可以考虑使用命令模式。</li>
<li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li>
<li> 在我们的例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品</li>
</ol>
<h3 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>命令模式基本介绍</p>
<ol>
<li>命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪一个<br>我们只知道在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li>
<li>命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦</li>
<li>在命令模式中会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作</li>
<li>通俗易懂的理解：将军发布命令，士兵去执行，其中将军就是命令发布者，士兵便是具体执行者，其中命令连接了将军和士兵</li>
</ol>
<p>原理图：<br><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714183617841.png" alt="image-20210714183617841"></p>
<p>说明：</p>
<ol>
<li> Invoker 是调用者角色 </li>
<li> Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类 </li>
<li>Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作</li>
<li>ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute</li>
</ol>
<h3 id="应用-17"><a href="#应用-17" class="headerlink" title="应用"></a>应用</h3><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">* 命令模式在Spring框架JdbcTemplate中使用</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">命令模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的excute（）方法就可以让接受者工作，而不必知道具体的接受者对象是谁、是如何实现的，命令对象起到了纽带桥梁的作用</span><br><span class="line"><span class="number">2.</span> 容易设计一个命令队列，只要把命令对象放到队列就可以多线程的执行命令</span><br><span class="line"><span class="number">3.</span> 容易实现对请求的销毁和重做</span><br><span class="line"><span class="number">4.</span> 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候需要注意</span><br><span class="line"><span class="number">5.</span> 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们没按下一个按键都需要判空，这给我们编码带来了一定的麻烦</span><br><span class="line"><span class="number">6.</span> 命令模式经典的应用场景：界面的每一个按钮都是一条命令、模拟CMD（DOS命令）、订单的撤销/恢复、触发-反馈机制</span><br><span class="line"></span><br><span class="line">## 访问者模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">测评系统：</span><br><span class="line"></span><br><span class="line">* 将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对 该歌手不同的评价(评价 有不同的种类，比如 成功、失败 等)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">访问者模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</span><br><span class="line"><span class="number">2.</span> 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</span><br><span class="line"><span class="number">3.</span> 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口</span><br><span class="line"><span class="number">4.</span> 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210714185223773</span>](<span class="number">2021</span>-<span class="number">07</span>-<span class="number">11</span>-DesignPatterns/image-<span class="number">20210714185223773.</span>png)</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作 </span><br><span class="line"><span class="number">2.</span> ConcreteVisitor ：是一个具体的访问值 实现每个有Visitor 声明的操作，是每个操作实现的部分. </span><br><span class="line"><span class="number">3.</span>  ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素 </span><br><span class="line"><span class="number">4.</span>  Element 定义一个accept 方法，接收一个访问者对象</span><br><span class="line"><span class="number">5.</span> ConcreteElement 为具体元素，实现了accept 方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>上面提到了双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。 双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型 </li>
<li> 以上述实例为例，假设我们要添加一个Wait的状态类，考察Man类和Woman类的反 应，由于使用了双分派，只需增加一个Action子类即可在客户端调用即可，不 需要改动任何其他类的代码。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>访问者模式的注意事项和细节</p>
<p>优点：</p>
<ol>
<li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常该</li>
<li>访问者模式可以对功能进行统一，可以做报表、UI、拦截器和过滤器，适用于数据结构相对稳定的系统</li>
</ol>
<p>缺点：</p>
<ol>
<li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难</li>
<li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li>
</ol>
<p>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><p>编写程序展示一个学校院系结构：</p>
<ul>
<li>要在一个页面中展示出学校的院系组成</li>
<li>一个学校有一个学院</li>
<li>一个学院有多个系</li>
</ul>
<h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>迭代器模式基本介绍</p>
<ol>
<li>迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式</li>
<li>如果我们的集合元素是用不同的方法实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候，就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑用迭代器模式解决</li>
<li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构</li>
</ol>
<p>原理图：</p>
<p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714190551112.png" alt="image-20210714190551112"></p>
<p>说明：</p>
<ol>
<li>Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove</li>
<li>ConcreteIterator : 具体的迭代器类，管理迭代 </li>
<li>Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦</li>
</ol>
<h3 id="应用-18"><a href="#应用-18" class="headerlink" title="应用"></a>应用</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体实例：</span><br><span class="line"></span><br><span class="line">迭代器模式在JDK-ArrayList集合中的应用</span><br><span class="line"></span><br><span class="line">* JDK的ArrayList集合中就使用了迭代器模式</span><br><span class="line"></span><br><span class="line">分析</span><br><span class="line"></span><br><span class="line">* 内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类 </span><br><span class="line">* List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象 </span><br><span class="line">* ArrayList 是实现聚合接口List 的子类，实现了iterator() </span><br><span class="line">* Iterator 接口系统提供 </span><br><span class="line">*  迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">迭代器模式的注意事项和细节</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了</span><br><span class="line"><span class="number">2.</span> 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成</span><br><span class="line"><span class="number">3.</span> 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做==单一责任原则==）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来，集合改变的话，只会影响到聚合对象。如果遍历方式改变的话，只影响到了迭代器</span><br><span class="line"><span class="number">4.</span> 当要展示一组相似的对象，或者遍历一组相同对象时使用，适合使用迭代器模式</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 每个聚合对象都要一个迭代器，会产生多个迭代器，不好管理类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 观察者模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">天气预报项目需求,：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如 发布到自己的网站或第三方)。 </span><br><span class="line"><span class="number">2.</span> 需要设计开放型API，便于其他第三方也能接入气象站获取数据。 </span><br><span class="line"><span class="number">3.</span>  提供温度、气压和湿度的接口</span><br><span class="line"><span class="number">4.</span> 测量数据更新时，要能实时的通知给第三方</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject， 依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是 Subject，是<span class="number">1</span>的一方。用户时Observer，是多的一方</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除 和通知。 </span><br><span class="line"><span class="number">2.</span>  这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核 心类WeatherData不会修改代码，遵守了ocp原则。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<p>实例应用：</p>
<ul>
<li>jdk的Observable类就使用了观察者模式</li>
</ul>
<p>分析：</p>
<ol>
<li>Observable 的作用和地位等价于 我们前面讲过Subject </li>
<li> Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer 的方法 add.. delete .. notify… </li>
<li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有update </li>
<li>Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是 类，通过继承来实现观察者模式</li>
</ol>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h3><p>智能家庭项目： </p>
<ol>
<li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等 </li>
<li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流 程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li>
</ol>
<p>传统的方式的问题分析 ：</p>
<ol>
<li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂 </li>
<li> 各个电器对象彼此联系，你中有我，我中有你，不利于松耦合. </li>
<li> 各个电器对象之间所传递的消息(参数)，容易混乱 </li>
<li> 当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性 都不理想  考虑中介者模式</li>
</ol>
<h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>中介模式基本介绍</p>
<ol>
<li>中介模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互性</li>
<li>中介者模式属于行为模式，使代码易于维护</li>
<li>比如MVC模式，C(Controller控制器)是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用</li>
</ol>
<p>原理图：</p>
<p>说明：</p>
<ol>
<li>Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口 </li>
<li> Colleague 是抽象同事类</li>
</ol>
<h3 id="应用-19"><a href="#应用-19" class="headerlink" title="应用"></a>应用</h3><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">中介者模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 多个类相互耦合，会形成网状结构，使用中介者模式，将网状结构分离为星型结构，进行解耦</span><br><span class="line"><span class="number">2.</span> 减少类间依赖，降低了耦合，符合迪米特原则</span><br><span class="line"><span class="number">3.</span> 中介者承担了较多的责任，一旦中介者出了问题，整个系统都会受到影响</span><br><span class="line"><span class="number">4.</span> 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</span><br><span class="line"></span><br><span class="line">## 备忘录模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">游戏角色状态恢复问题： </span><br><span class="line"></span><br><span class="line">游戏角色有攻击力和防御力，在大战Boss前保存自身的状态(攻击力和防御力)，当大 战Boss后攻击力和防御力下降，从备忘录对象恢复到大战前的状态</span><br><span class="line"></span><br><span class="line">传统的方式的问题分析 ：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不 利于管理，开销也很大. </span><br><span class="line"><span class="number">2.</span>  传统的方式是简单地做备份，<span class="keyword">new</span>出另外一个对象出来，再把需要备份的数据放到 这个新对象，但这就暴露了对象内部的细节 </span><br><span class="line"><span class="number">3.</span>  解决方案： =&gt; 备忘录模式</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">备忘录模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持这个状态。这样以后就可以将该对象恢复到原先保存的状态</span><br><span class="line"><span class="number">2.</span> 理解：现实生活中备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</span><br><span class="line"><span class="number">3.</span> 备忘录模式属于行为模式</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> originator : 对象(需要保存 状态的对象) </span><br><span class="line"><span class="number">2.</span>  Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态 </span><br><span class="line"><span class="number">3.</span> Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效 率 </span><br><span class="line"><span class="number">4.</span> 说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要 要 HashMap  </span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>备忘录模式注意事项和细节</p>
<ol>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不必关系状态的保存细节</li>
<li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意</li>
<li>适用的场景：<ul>
<li>后悔药</li>
<li>打游戏时的存档</li>
<li>windows里的ctrl+z</li>
<li>ie中的后退</li>
<li>数据库的事务管理</li>
</ul>
</li>
<li>为了节约内存，备忘录模式可以和原型模式配合适用</li>
</ol>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h3><p>通过解释器模式来实现四则运算</p>
<ol>
<li>先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复</li>
<li>在分别输入a ,b, c, d, e 的值 </li>
<li> 最后求出结果</li>
</ol>
<p>传统方案解决四则运算问题分析 ：</p>
<ol>
<li>编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果 </li>
<li>问题分析：如果加入新的运算符，比如 * / ( 等等，不利于扩展，另外让一个方法来 解析会造成程序结构混乱，不够清晰. </li>
<li> 解决方案：可以考虑使用解释器模式， 即： 表达式 -&gt; 解释器(可以有多种) -&gt; 结 果</li>
</ol>
<h3 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li>
<li>解释器模式（Interpreter Pattern）：是指给一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）</li>
<li>应用场景：<ul>
<li>应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来表示</li>
<li>一个简单语法需要解释的场景</li>
</ul>
</li>
<li>更多：编译器、运算表达式、正则表达式、机器人等</li>
</ol>
<p>原理图：</p>
<p>说明：</p>
<ol>
<li>Context: 是环境角色,含有解释器之外的全局信息. </li>
<li> AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所 共享</li>
<li>TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作</li>
<li>NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作. </li>
<li>说明： 输入Context he TerminalExpression 信息通过Client 输入即可</li>
</ol>
<h3 id="应用-20"><a href="#应用-20" class="headerlink" title="应用"></a>应用</h3><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实际应用：</span><br><span class="line"></span><br><span class="line">* Spring框架中SpelExpressionParser就使用到解释器模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">解释器模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 当有一个语言需要解释器执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，这让程序具有良好的扩展性</span><br><span class="line"><span class="number">2.</span> 应用场景：编译器、运算表达式计算、正则表达式、机器人等</span><br><span class="line"><span class="number">3.</span> 使用解释器可能会带来的问题：</span><br><span class="line">   * 解释器模式会引起类膨胀</span><br><span class="line">   * 解释器模式采用递归调用方法，将会导致调试非常复杂</span><br><span class="line">   * 效率可能降低</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 状态模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">APP抽奖活动问题</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 假如每参加一次这个活动要 扣除用户<span class="number">50</span>积分，中奖概率 是<span class="number">10</span>% </span><br><span class="line"><span class="number">2.</span>  奖品数量固定，抽完就不能 抽奖 </span><br><span class="line"><span class="number">3.</span> 活动有四个状态: 可以抽奖、 不能抽奖、发放奖品和奖品 领完 </span><br><span class="line"><span class="number">4.</span> 活动的四个状态转换关系图</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210714200011180</span>](<span class="number">2021</span>-<span class="number">07</span>-<span class="number">11</span>-DesignPatterns/image-<span class="number">20210714200011180.</span>png)</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">状态模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以互相转换</span><br><span class="line"><span class="number">2.</span> 当一个对象的内在状态发生改变时，允许改变其行为，这个对象看起来好像是改变了其类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Context 类为环境角色, 用于维护State实例,这个实例定义当前状态 </span><br><span class="line"><span class="number">2.</span> State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为</span><br><span class="line"><span class="number">3.</span> ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<p>应用实例：</p>
<p>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的 状态, 项目中的这个模块实现就会使用到状态模式</p>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>状态模式的注意事项和细节</p>
<ol>
<li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li>
<li>方便维护。将容易产生问题的if-else的语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li>
<li>符合开闭原则。容易增删状态</li>
<li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多的类，加大维护难度</li>
<li>应用场景：当一个事件或者对象有很多种状态，状态之间会互相转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式</li>
</ol>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h3><p>鸭子项目：</p>
<ol>
<li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等) </li>
<li>显示鸭子的信息</li>
</ol>
<p>传统方式：</p>
<ol>
<li>其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的</li>
<li>上面说的1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改 动，会影响其他部分。会有溢出效应 </li>
<li> 为了改进1问题，我们可以通过覆盖fly 方法来解决 =&gt; 覆盖解决 </li>
<li> 问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要ToyDuck去覆盖Duck 的所有实现的方法 </li>
<li>解决思路 策略模式 (strategy pattern)</li>
</ol>
<h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>策略模式基本介绍</p>
<ol>
<li>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</li>
<li>这种算法体现了几个设计原则：<ol>
<li>把变化的代码从不变的代码中分离出来</li>
<li>针对接口编程而不是具体类（定义了策略接口）</li>
<li>多用组合/聚合，少用继承（客户通过组合方式使用策略）</li>
</ol>
</li>
</ol>
<p>原理图：</p>
<h3 id="应用-21"><a href="#应用-21" class="headerlink" title="应用"></a>应用</h3><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">* JDK的Arrays的Comparator就使用了策略模式</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">策略模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 策略模式的关键是：分析项目中变化部分与不变部分</span><br><span class="line"><span class="number">2.</span> 策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性</span><br><span class="line"><span class="number">3.</span> 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或行为）即可，避免了使用多重转移语句（<span class="keyword">if</span>-<span class="keyword">else</span>）</span><br><span class="line"><span class="number">4.</span> 提供了可以替换继承关系的办法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使他易于切换、易于理解、易于扩展</span><br><span class="line"><span class="number">5.</span> 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 职责链模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">学校OA系统的采购审批项目：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 采购员采购教学器材 </span><br><span class="line"><span class="number">2.</span> 如果金额 小于等于<span class="number">5000</span>, 由教学主任审批 （<span class="number">0</span>&lt;=x&lt;=<span class="number">5000</span>）</span><br><span class="line"><span class="number">3.</span> 如果金额 小于等于<span class="number">10000</span>, 由院长审批 (<span class="number">5000</span>）</span><br><span class="line"><span class="number">4.</span> 如果金额 小于等于<span class="number">30000</span>, 由副校长审批 (<span class="number">10000</span>&lt;x&lt;=<span class="number">30000</span>)</span><br><span class="line"><span class="number">5.</span> 如果金额 超过<span class="number">30000</span>以上，有校长审批 ( <span class="number">30000</span>&lt;x）</span><br><span class="line"></span><br><span class="line">传统方案解决OA系统审批问题分析：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 传统方式是：接收到一个采购请求后，根据采购金额来调用对应的Approver (审批 人)完成审批。</span><br><span class="line"><span class="number">2.</span> 传统方式的问题分析 : 客户端这里会使用到 分支判断(比如 <span class="keyword">switch</span>) 来对不同的采 购请求处理， 这样就存在如下问题 ：</span><br><span class="line">   <span class="number">1.</span> 如果各个级别的人员审批金额发生变化，在 客户端的也需要变化</span><br><span class="line">   <span class="number">2.</span>  客户端必须明确的知道 有多少个审批级别和访问</span><br><span class="line"><span class="number">3.</span> 这样 对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代 码的扩展和维护</span><br><span class="line"><span class="number">4.</span> 解决方案 =》 职责链模式</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">职责链模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 责任链模式（Chain Of Responsibility Pattern），又叫责任链模式，为请求创建了一个接受者对象的链。这种模式对请求的发送者和接受者进行解耦</span><br><span class="line"><span class="number">2.</span> 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接受者，依此类推</span><br><span class="line"><span class="number">3.</span> 这种类型的设计模式属于行为型模式</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler </span><br><span class="line"><span class="number">2.</span> ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处 理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链 </span><br><span class="line"><span class="number">3.</span> Request ， 含义很多属性，表示一个请求</span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<ul>
<li>SpringMVC-HandlerExecutionChain 类就使用到职责链模式</li>
</ul>
<p>说明：</p>
<ol>
<li>springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等 </li>
<li>在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式</li>
<li>HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不 处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责 链本身与处理逻辑之间的耦合,规范了处理流程 </li>
<li>HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应 的拦截器.</li>
</ol>
<h3 id="细节-5"><a href="#细节-5" class="headerlink" title="细节"></a>细节</h3><p>职责链模式的注意事项和细节</p>
<ol>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
<li>性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext（）方法中判断是否已经超过阈值，超过则不允许该链的建立，避免出现超长链无意识地破坏系统性能</li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、java Web中tomcat对encoding的处理、拦截器</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul>
<li>有一点需要说明：设计模式是程序员在编程中，有意或者是无意使用到的(也不是 所有的程序员都学习过设计模式)，并且同一种设计模式实现方式也不是100%的一 样，设计模式主要是提高程序的扩展性，可读性，可维护性、规范性。</li>
<li> 对于框架源码，源码中部分使用了A设计模式，还部分使用了B设计模式，也是有 可能的，也就是说设计模式是可以结合使用的</li>
<li>因为设计模式主要是一种编程思想，既然是思想，具体实现方式，就不可能100% 的一样(当然，程序的设计结构基本是一样的)</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/" title="设计模式" target="_blank" rel="external">http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://stary1999.github.io" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://stary1999.github.io" target="_blank"><span class="text-dark">stary</span><small class="ml-1x">愿启明星照亮信仰，照进现实</small></a></h3>
        <div>成长中的程序员，半个极客，伪文艺青年</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/07/14/java-2021-07-14-JavaWebBookCity/" title="javaWeb书城项目传统版"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/07/10/language-2021-07-10-vue/" title="vue的使用(入门)"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/stary" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2021 stary
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>