<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>繁星点点</title>
  
  
  <link href="https://stary1999.github.io/atom.xml" rel="self"/>
  
  <link href="https://stary1999.github.io/"/>
  <updated>2021-07-29T11:06:18.207Z</updated>
  <id>https://stary1999.github.io/</id>
  
  <author>
    <name>stary</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手机、电脑配置</title>
    <link href="https://stary1999.github.io/2021/07/29/phoneAndCloud/"/>
    <id>https://stary1999.github.io/2021/07/29/phoneAndCloud/</id>
    <published>2021-07-29T10:54:09.000Z</published>
    <updated>2021-07-29T11:06:18.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="设备协调"><a href="#设备协调" class="headerlink" title="设备协调"></a>设备协调</h1><h2 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h2><p>平板，华为账号</p><p>手机，华为账号(荣耀)</p><p>笔记本，联想系</p><h1 id="手机重置"><a href="#手机重置" class="headerlink" title="手机重置"></a>手机重置</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>XyKey，</p><p>备忘录，</p><p>便签，</p><p>nian，</p><p>华为主题，</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="第一屏"><a href="#第一屏" class="headerlink" title="第一屏:"></a>第一屏:</h3><p>网易云，网易账号同步</p><p>微信，电脑备份</p><p>QQ，无需备份，(说说导出待，整理QQ收藏)，注意三个号</p><p>系统工具:需要备份主题文件::备份至华为云空间”备份”目录</p><p>常用:图库开启自动备份，</p><p>彩云天气，使用7037账号登录</p><p>一键锁屏功能，</p><p>支付宝，无需备份，注意三个账号。</p><p>起点读书，无需备份，2517304640账号登录</p><h3 id="第二屏"><a href="#第二屏" class="headerlink" title="第二屏:"></a>第二屏:</h3><h4 id="必须"><a href="#必须" class="headerlink" title="必须:"></a>必须:</h4><p>PU口袋校园，账号:147</p><p>WPS，账号:同微信</p><p>百度网盘，账号147</p><p>学习通，账号XyKey</p><p>==XyKey，无账号，备份至华为云空间”备份”目录==</p><p>==nian，无账号，备份至华为云空间”备份”目录==</p><p>==便签，账号XyKey，备份至坚果云==</p><p>==阅读，账号XyKey，备份至坚果云==</p><p>ES文件浏览器，无账号，P版，备份至华为云空间”备份”目录</p><p>YES PDF，无账号，阅读器</p><p>哔哩哔哩，账号，147，密码不详</p><p>酷安，账号XyKey</p><h4 id="非必须"><a href="#非必须" class="headerlink" title="非必须"></a>非必须</h4><p>建设银行，手机登录，</p><p>钉钉，现阶段不怎么用，支付宝账号，</p><p>学小易，账号随意</p><p>交管12123，账号XyKey</p><p>微博，QQ账号登录</p><p>墨墨背单词，微信账号</p><p>每日英语听力，华为账号</p><p>云闪付，账号XyKey</p><p>知乎，微信账号</p><p>Code+，坚果云备份</p><p>牛客，账号XyKey</p><h3 id="第三屏"><a href="#第三屏" class="headerlink" title="第三屏"></a>第三屏</h3><h4 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱:"></a>工具箱:</h4><p>QMD，下载音乐，备份至华为云空间”备份”目录</p><p>手机性能排行榜，备份至华为云空间”备份”目录</p><p>坚果云，账号XyKey</p><p>IDM+，下载器，备份至华为云空间”备份”目录</p><p>v2ray，备份至华为云空间”备份”目录</p><p>人工桌面，酷安取</p><p>李跳跳，酷安取</p><p>古典诗词，微信账号登录</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h4><p>腾讯地图，QQ登录</p><p>掌上营业厅，中国移动，手机认证登录</p><p>白马地图，无需登录，</p><p>VMOS pro，??P版，备份至华为云空间”备份”目录</p><p>Mx，无账号</p><p>携程，账号XyKey</p><p>淘宝，账号支付宝，</p><p>腾讯视频，QQ登录，PS:25</p><p>央视频，微信登录</p><p>Edge，账号XyKey，微软账号</p><p>京东，微信登录</p><p>实习僧，手机认证登录</p><p>应用宝，不登录</p><p>饿了么，手机认证</p><p>TapTap，微信登录</p><h3 id="第四屏"><a href="#第四屏" class="headerlink" title="第四屏"></a>第四屏</h3><p>想不想修真，华为账号</p><p>王者荣耀</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>图片，自动同步</p><p>音乐，电脑+U盘+百度网盘+华为云空间，以云空间数据为主</p><p>文档，文档存于电脑，定期备份至百度网盘，</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>备忘录自动备份，</p><h1 id="电脑重置"><a href="#电脑重置" class="headerlink" title="电脑重置"></a>电脑重置</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h2 id="软件-1"><a href="#软件-1" class="headerlink" title="软件"></a>软件</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>浏览器：Chrome，装c盘，打开v2，链接，然后登录Chrome账号，自动同步，将预先备份的tampermonkey从Google云盘恢复，<br>浏览器部分OK，附加：更新edge，下载firefox</p><p>解压软件：Bandizip，必需，重新安装，删除旧文件夹</p><p>视频播放软件：potplayer，非必需，</p><p>office：2016合集+2019visio<br>wps可替代，</p><p>编辑器：notepad++，或editplus</p><p>输入法：搜狗？</p><p>安全：火绒</p><p>VMware：必需</p><p>腾讯系：tim，微信，软件管家？</p><p>下载：Xdown，迅雷，百度网盘</p><h3 id="辅助，非必需，"><a href="#辅助，非必需，" class="headerlink" title="辅助，非必需，"></a>辅助，非必需，</h3><p>格式工厂，<br>护眼宝<br>translucentTB<br>软媒魔方设置大师<br>cclean<br>ocam<br>everything<br>eDiary<br>w3cschool<br>trays<br>截屏：Snipaste</p><h3 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h3><p>远程连接：xshell，mobaxterm</p><p>开发环境：<br>java8<br>java14<br>Python<br>微软常用库</p><p>开发ide<br>idea 2021<br>eclipse<br>vscode<br>MATLAB<br>mysql</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h1 id=&quot;设备协调&quot;&gt;&lt;a href=&quot;#设备协调&quot; class=&quot;headerlink&quot; title=&quot;设备协调&quot;&gt;&lt;/a&gt;设备协调&lt;/h</summary>
      
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="效率" scheme="https://stary1999.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="手机" scheme="https://stary1999.github.io/tags/%E6%89%8B%E6%9C%BA/"/>
    
    <category term="云盘" scheme="https://stary1999.github.io/tags/%E4%BA%91%E7%9B%98/"/>
    
    <category term="互联" scheme="https://stary1999.github.io/tags/%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title>keySoon</title>
    <link href="https://stary1999.github.io/2021/07/27/keySoon/"/>
    <id>https://stary1999.github.io/2021/07/27/keySoon/</id>
    <published>2021-07-27T02:52:59.000Z</published>
    <updated>2021-07-27T03:04:15.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h1><p>半角&amp;全角设置，中文输入法下使用英文字符（对编程极度友好），但是在英文字符中打不出顿号。</p><p><img src="/2021/07/27/keySoon/image-20210727105746358.png" alt="image-20210727105746358"></p><p>折中方案，设置自定义标点设置，将需要的、常用的设置成英文标点，保留部分。注意区分全角半角。</p><p>将常用的双引号、方括号和反引号、逗号设置成英文半角,编程常用,保留顿号,句号。在中文里常用。</p><h1 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h1><p>配置全局快捷键:</p><p>仅保留播放上一曲,下一曲三个操作</p><p><img src="/2021/07/27/keySoon/image-20210727105417193.png" alt="image-20210727105417193"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搜狗输入法&quot;&gt;&lt;a href=&quot;#搜狗输入法&quot; class=&quot;headerlink&quot; title=&quot;搜狗输入法&quot;&gt;&lt;/a&gt;搜狗输入法&lt;/h1&gt;&lt;p&gt;半角&amp;amp;全角设置，中文输入法下使用英文字符（对编程极度友好），但是在英文字符中打不出顿号。&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://stary1999.github.io/2021/07/23/faceQuestions/"/>
    <id>https://stary1999.github.io/2021/07/23/faceQuestions/</id>
    <published>2021-07-23T12:56:06.000Z</published>
    <updated>2021-07-23T13:20:48.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img src="/2021/07/23/faceQuestions/image-20210723205708900.png" alt="image-20210723205708900"></p><p><img src="/2021/07/23/faceQuestions/image-20210723205836953.png" alt="image-20210723205836953"></p><ul><li>IO<ul><li>面向字符的IO流：保证字符的呈现形式相同，不管什么编码，输出的“汉字”保持不变。</li><li>面向字节的IO流：不改变IO过程中的0、1顺序，适合于图片、音频等文件</li></ul></li></ul><h2 id="i"><a href="#i" class="headerlink" title="i++"></a>i++</h2><p><img src="/2021/07/23/faceQuestions/image-20210723210326305.png" alt="image-20210723210326305"></p><p><img src="/2021/07/23/faceQuestions/image-20210723210339982.png" alt="image-20210723210339982"></p><p><img src="/2021/07/23/faceQuestions/image-20210723210711986.png" alt="image-20210723210711986"></p><p><img src="/2021/07/23/faceQuestions/image-20210723210832047.png" alt="image-20210723210832047"></p><p><img src="/2021/07/23/faceQuestions/image-20210723210842154.png" alt="image-20210723210842154"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211033136.png" alt="image-20210723211033136"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211221437.png" alt="image-20210723211221437"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211324454.png" alt="image-20210723211324454"></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><img src="/2021/07/23/faceQuestions/image-20210723211629052.png" alt="image-20210723211629052"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211642353.png" alt="image-20210723211642353"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211855017.png" alt="image-20210723211855017"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211905260.png" alt="image-20210723211905260"></p><p><img src="/2021/07/23/faceQuestions/image-20210723211941127.png" alt="image-20210723211941127"></p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p><img src="/2021/07/23/faceQuestions/image-20210723212035539.png" alt="image-20210723212035539"></p><p><img src="/2021/07/23/faceQuestions/image-20210723212046330.png" alt="image-20210723212046330"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、&quot;&gt;&lt;a href=&quot;#五、&quot; class=&quot;headerlink&quot; title=&quot;五、&quot;&gt;&lt;/a&gt;五、&lt;/h1&gt;&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="java" scheme="https://stary1999.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://stary1999.github.io/tags/java/"/>
    
    <category term="面试" scheme="https://stary1999.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis6</title>
    <link href="https://stary1999.github.io/2021/07/22/Redis6/"/>
    <id>https://stary1999.github.io/2021/07/22/Redis6/</id>
    <published>2021-07-22T13:46:18.000Z</published>
    <updated>2021-07-24T08:55:44.258Z</updated>
    
    <content type="html"><![CDATA[<ul><li>NoSQL数据库简介</li><li>Redis6概述和安装</li><li>常用五大数据类型</li><li>Redis6配置文件详解</li><li>Redis6的发布和订阅</li><li>Redis6新数据类型</li><li>Jedis操作Redis6</li><li>Redis6与Spring Boot整合</li><li>Redis6的事务操作</li><li>Redis6持久化之RDB</li><li>Redis持久化之AOF</li><li>Redis6的主从复制</li><li>Redis6集群</li><li>Redis6应用问题解决</li><li>Redis6新功能</li></ul><h1 id="一、NoSQL数据库简介"><a href="#一、NoSQL数据库简介" class="headerlink" title="一、NoSQL数据库简介"></a>一、NoSQL数据库简介</h1><ul><li>技术发展</li><li>NoSQL数据库概述</li><li>行式存储数据库</li><li>图关型数据库</li><li>数据库排名</li></ul><h2 id="1-技术发展"><a href="#1-技术发展" class="headerlink" title="1.技术发展"></a>1.技术发展</h2><p>技术的分类：</p><ol><li>解决功能性的问题：java、jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li><li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li><li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li></ol><ul><li>web 1.0 时代：<br>数据访问量有限，用高性能的单点服务器可以解决大部分问题<br><img src="/2021/07/22/Redis6/image-20210724165350486.png" alt="image-20210724165350486"></li><li>web 2.0 时代：<br>用户访问量大幅度提升，同时产生了大量的用户数据。加之移动设备普及，所有的互联网平台面临巨大的性能挑战，包括：CPU及内存压力、IO压力<br><img src="/2021/07/22/Redis6/image-20210724165405829.png" alt="image-20210724165405829"></li><li>解决CPU及内存压力——多台服务器条件下session存放问题<br><img src="/2021/07/22/Redis6/image-20210724165423009.png" alt="image-20210724165423009"><ul><li>方案一：存在cookie中<ol><li>不安全</li><li>网络负担效率低</li></ol></li><li>方案二：存在文件服务器或者数据库里<ol><li>大量的IO效率问题</li></ol></li><li>方案三：session复制<ol><li>session数据冗余，节点越多，浪费越大</li></ol></li><li>方案四：缓存数据库<ol><li>完全在内存中，速度快，数据结构简单</li></ol></li></ul></li><li>解决IO压力<br><img src="/2021/07/22/Redis6/image-20210724165437606.png" alt="image-20210724165437606"><ul><li>缓存数据库：减少IO的读操作</li><li>水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</li><li>文档数据库</li><li>列式数据库</li><li>打破了传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能为最优的存储方式</li></ul></li></ul><h2 id="2-NoSQL数据库概述"><a href="#2-NoSQL数据库概述" class="headerlink" title="2.NoSQL数据库概述"></a>2.NoSQL数据库概述</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>NoSQL（NoSQL=Not Only SQL），意味：不仅仅是SQL，指==非关系型的数据库==。NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID（事务中的原子性、一致性、隔离性和持久性）</li><li>远超于SQL的性能</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>NoSQL适用场景：</p><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的读写</li></ul><p>NoSQL不适用的场景：</p><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系，需要即席查询<br>即席查询：（Ad Hoc）是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表。</li></ul><p>==用不着sql和用了SQL也不行的情况下，考虑使用NoSQL==</p><h3 id="常见的NoSQL数据库"><a href="#常见的NoSQL数据库" class="headerlink" title="常见的NoSQL数据库"></a>常见的NoSQL数据库</h3><ul><li>Memcache<ul><li>很==早==出现的NoSQL数据库</li><li>数据都在内存中，一般==不支持持久化==</li><li>支持简单的key-value模式，==支持类型单一==</li><li>一般是作为==缓存数据库==辅助持久化的数据库</li></ul></li><li>Redis<ul><li>几乎覆盖了Memcache的绝大部分功能</li><li>数据都在内存，==支持持久化==，主要用作备份恢复</li><li>除了支持简单的key-value模式，还==支持多种数据结构的存储==，比如list、set、hash、zset等</li><li>一般是作为==缓存数据库==辅助持久化的数据库</li></ul></li><li>MongoDB<ul><li>高性能、开源、模式自由（schema free）的==文档型数据库==</li><li>数据都在内存中，如果内存不足，把不常用的数据保存到硬盘</li><li>虽然是key-value模式，但是对value（尤其是==json==）提供了丰富的查询功能</li><li>支持二进制数据及大型对象</li><li>开源根据数据的特点==替代RDBMS==，成为独立的数据库。或者配合RDBMS，存储特定的数据。<br>RDBMS：关系数据库管理系统。</li></ul></li></ul><h2 id="3-行式存储数据库"><a href="#3-行式存储数据库" class="headerlink" title="3.行式存储数据库"></a>3.行式存储数据库</h2><ul><li>行式数据库</li><li>列式数据库</li></ul><p>常见的数据库：</p><ul><li>HBase：<ul><li>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</li><li>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可以处理有百万列元素的数据表</li></ul></li><li>Cassandra：<ul><li>Apache Cassandra 是一款免费的开源 NoSQL 数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到 PB 级别)。在众多显著特性当中，Cassandra 最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">计算机存储单位 计算机存储单位一般用 B，KB，MB，GB，TB，PB，EB，ZB，YB，BB</span><br><span class="line">来表示，它们之间的关系是：</span><br><span class="line">位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</span><br><span class="line">字节 byte：8 个二进制位为一个字节(B)，最常用的单位。</span><br><span class="line">1KB (Kilobyte 千字节)=1024B，</span><br><span class="line">1MB (Megabyte 兆字节 简称“兆”)=1024KB，</span><br><span class="line">1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</span><br><span class="line">1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中 1024=2^10 ( 2 的 10 次方)，</span><br><span class="line">1PB（Petabyte 千万亿字节 拍字节）=1024TB，</span><br><span class="line">1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</span><br><span class="line">1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</span><br><span class="line">1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</span><br><span class="line">1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</span><br><span class="line">注：“兆”为百万级数量单位。</span><br></pre></td></tr></table></figure><h2 id="4-图关型数据库"><a href="#4-图关型数据库" class="headerlink" title="4.图关型数据库"></a>4.图关型数据库</h2><p>Neo4j：</p><p>主要应用：社会关系、公共交通网络、地图及网络拓扑<br><img src="/2021/07/22/Redis6/image-20210724165524619.png" alt="image-20210724165524619"></p><h2 id="5-数据库排名"><a href="#5-数据库排名" class="headerlink" title="5.数据库排名"></a>5.数据库排名</h2><p>网址：<a href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></p><p><img src="/2021/07/22/Redis6/image-20210723084537486.png" alt="image-20210723084537486"></p><h1 id="二、Redis6概述和安装"><a href="#二、Redis6概述和安装" class="headerlink" title="二、Redis6概述和安装"></a>二、Redis6概述和安装</h1><ul><li>Redis 是一个开源的 key-value 存储系统。</li><li>和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string(字符串)、<br>list(链表)、set(集合)、zset(sorted set –有序集合)和 hash（哈希类型）。</li><li>这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis 支持各种不同方式的排序。</li><li>与 memcached 一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记<br>录文件。</li><li>并且在此基础上实现了 master-slave(主从)同步。</li></ul><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><ol><li>配合关系型数据库做高速缓存<ul><li>高频次，热门访问的数据，降低数据库IO</li><li>分布式架构，做session共享<br><img src="/2021/07/22/Redis6/image-20210724165543974.png" alt="image-20210724165543974"></li></ul></li><li>多样的数据结构存储持久化数据<br><img src="/2021/07/22/Redis6/image-20210723084938403.png" alt="image-20210723084938403"></li></ol><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><p>官网：<a href="http://redis.io/">http://redis.io/</a></p><p>中文官网：<a href="http://redis.cn/">http://redis.cn/</a></p><p>安装时，不考虑windows版本</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>准备工作：</p><ul><li><p>下载安装gcc编译器</p><ul><li><p>安装c语言的编译环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure></li><li><p>测试gcc版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>安装redis：</p><ul><li>下载Redis安装包到opt目录下</li><li>解压：<code>tar -zxvf redis-6.2.1.tar.gz</code></li><li>进入解压后的目录</li><li>在目录下再次执行make命令，若报错，运行：<code>make distclean</code>，再次执行：<code>make</code>命令</li><li>编译成功后，跳过<code>make test</code>，继续执行：<code>make install</code>，完成安装</li></ul><p>安装目录：/usr/local/bin查看默认安装目录：</p><ul><li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li><li>redis-check-aof：修复有问题的 AOF 文件，rdb 和 aof 后面讲</li><li>redis-check-dump：修复有问题的 dump.rdb 文件</li><li>redis-sentinel：Redis 集群使用</li><li>redis-server：Redis 服务器启动命令</li><li>redis-cli：客户端，操作入口</li></ul><p>启动：</p><ul><li><p>前台启动：<code>redis.server</code>，不推荐使用，命令窗口不能关闭，否则服务器停止</p></li><li><p>后台启动：推荐</p><ul><li><p>备份redis.conf配置文件到其他目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-3.2.5/redis.conf /myredis</span><br></pre></td></tr></table></figure></li><li><p>后台启动设置 daemonize no 改成 yes：修改 redis.conf(128 行)文件将里面的 daemonize no 改成 yes，让服务在后台启动</p></li><li><p>启动：<code>redis-server/myredis/redis.conf</code></p></li><li><p>客户端访问：<code>redis-cli</code></p></li><li><p>多端口情况下：<code>redis-cli -p6379</code></p></li><li><p>测试验证：<code>ping</code></p></li><li><p>关闭：</p><ul><li>单实例关闭：<code>redis-cli shutdown</code></li><li>进入终端后关闭：<code>shutdown</code></li><li>多实例关闭：<code>redis-cli -p 6379 shutdown</code></li></ul></li></ul></li></ul><h3 id="介绍（redis）"><a href="#介绍（redis）" class="headerlink" title="介绍（redis）"></a>介绍（redis）</h3><ul><li>默认 16 个数据库，类似数组下标从 0 开始，初始默认使用 0 号库</li><li>使用命令 <code>select &lt;dbid&gt;</code>来切换数据库。如: select 8</li><li>统一密码管理，所有库同样密码。</li><li><code>dbsize</code> 查看当前数据库的 key 的数量</li><li><code>flushdb</code> 清空当前库</li><li><code>flushall</code> 通杀全部库</li></ul><p>==端口号：6379==</p><ul><li>Redis==是单线程+多路IO复用技术==<ul><li>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</li></ul></li><li>串行 vs 多线程+锁（memcached） vs 单线程+多路 IO 复用(Redis）<ul><li>与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用</li></ul></li></ul><h1 id="三、常用五大数据类型"><a href="#三、常用五大数据类型" class="headerlink" title="三、常用五大数据类型"></a>三、常用五大数据类型</h1><p>redis常见数据类型操作指令： <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h2 id="1-Redis键（key）"><a href="#1-Redis键（key）" class="headerlink" title="1. Redis键（key）"></a>1. Redis键（key）</h2><table><thead><tr><th>命令</th><th>使用</th></tr></thead><tbody><tr><td>keys *</td><td>查看当前库所有 key (匹配：keys *1)</td></tr><tr><td>exists key</td><td>判断某个 key 是否存在</td></tr><tr><td>type key</td><td>查看你的 key 是什么类型</td></tr><tr><td>del key</td><td>删除指定的 key 数据</td></tr><tr><td>unlink key</td><td>根据 value 选择非阻塞删除。仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作。</td></tr><tr><td>expire key 10</td><td>10 秒钟：为给定的 key 设置过期时间</td></tr><tr><td>ttl key</td><td>查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</td></tr><tr><td>select</td><td>命令切换数据库</td></tr><tr><td>dbsize</td><td>查看当前数据库的 key 的数量</td></tr><tr><td>flushdb</td><td>清空当前库</td></tr><tr><td>flushall</td><td>通杀全部库</td></tr></tbody></table><h2 id="2-Redis字符串（String）"><a href="#2-Redis字符串（String）" class="headerlink" title="2. Redis字符串（String）"></a>2. Redis字符串（String）</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul><li>String是Redis最基本的类型，一个key对应一个value</li><li>String类型是二进制安全的。意味着Redis的String可以包含任何数据。比如jpg图片或者序列化对象</li><li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p><p><img src="/2021/07/22/Redis6/image-20210723092330892.png" alt="image-20210723092330892"></p><ul><li>*NX：当数据库中 key 不存在时，可以将 key-value 添加数据库</li><li>*XX：当数据库中 key 存在时，可以将 key-value 添加数据库，与 NX 参数互斥</li><li>*EX：key 的超时秒数</li><li>*PX：key 的超时毫秒数，与 EX 互斥</li></ul></li><li><p><code>get &lt;key&gt;</code>：查询对应键值</p></li><li><p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的<value> 追加到原值的末尾</value></p></li><li><p><code>strlen &lt;key&gt;</code>：获得值的长度</p></li><li><p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 key 不存在时 设置 key 的值</p></li><li><p><code>incr &lt;key&gt;</code>：将 key 中储存的数字值增 1。只能对数字值操作，如果为空，新增值为 1</p></li><li><p><code>decr &lt;key&gt;</code>：将 key 中储存的数字值减 1只能对数字值操作，如果为空，新增值为-1</p></li><li><p><code>incrby / decrby &lt;key&gt;&lt;步长&gt;</code>：将 key 中储存的数字值增减。自定义步长。</p></li><li><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>：同时设置一个或多个 key-value 对</p></li><li><p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....</code>：同时获取一个或多个 value</p></li><li><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p></li><li><p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围，类似 java 中的 substring，前包，后包</p></li><li><p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从 0 开始)。</key></value></p></li><li><p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p></li><li><p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值</p></li></ul><p>原子性：</p><ul><li>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<ul><li>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li><li>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis 单命令的原子性主要得益于 Redis 的单线程</li></ul></li><li>案例：<br>java 中的 i++是否是原子操作？==不是==<br>i=0;两个线程分别对 i 进行++100 次,值是多少？==2-200==</li><li>==原子性，有一个失败则都失败==</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>String 的数据结构为简单动态字符串(Simple Dynamic String,缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p><p>内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p>单键多值：</p><ul><li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li><li>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code></td><td>从左边/右边插入一个或多个值。</td></tr><tr><td><code>lpop/rpop &lt;key&gt;</code></td><td>从左边/右边吐出一个值。值在键在，值光键亡。</td></tr><tr><td><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code></td><td>从<key1>列表右边吐出一个值，插到<key2>列表左边。</key2></key1></td></tr><tr><td><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code></td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td><code>lrange mylist 0 -1</code></td><td>0 左边第一个，-1 右边第一个，（0-1 表示获取所有）</td></tr><tr><td><code>lindex &lt;key&gt;&lt;index&gt;</code></td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td><code>llen &lt;key&gt;</code></td><td>获得列表长度</td></tr><tr><td><code>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</code></td><td>在<value>的后面插入<newvalue>插入值</newvalue></value></td></tr><tr><td><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code></td><td>从左边删除 n 个 value(从左到右)</td></tr><tr><td><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code></td><td>将列表 key 下标为 index 的值替换成 value</td></tr></tbody></table><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>List 的数据结构为快速链表 quickList。</p><ul><li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。</li><li>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li><li>当数据量比较多的时候才会改成 quicklist。</li><li>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</li><li>Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li></ul><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以==自动排重==的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p></li><li><p>Redis 的 Set 是 string 类型的==无序集合。它底层其实是一个 value 为 null 的 hash 表==，所以添加，删除，查找的==复杂度都是 O(1)。==</p></li><li><p>一个算法，随着数据的增加，执行时间的长短，如果是 O(1)，数据增加，查找数据的时间不变</p></li></ul><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>使用</th></tr></thead><tbody><tr><td><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code></td><td>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略。smembers <key>取出该集合的所有值。</key></td></tr><tr><td><code>sismember &lt;key&gt;&lt;value&gt;</code></td><td>判断集合<key>是否为含有该<value>值，有 1，没有 0</value></key></td></tr><tr><td><code>scard&lt;key&gt;</code></td><td>返回该集合的元素个数。</td></tr><tr><td><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code></td><td>删除集合中的某个元素。</td></tr><tr><td><code>spop &lt;key&gt;</code></td><td>随机从该集合中吐出一个值。</td></tr><tr><td><code>srandmember &lt;key&gt;&lt;n&gt;</code></td><td>随机从该集合中取出 n 个值。不会从集合中删除 。</td></tr><tr><td><code>smove &lt;source&gt;&lt;destination&gt;value </code></td><td>把集合中一个值从一个集合移动到另一个集合</td></tr><tr><td><code>sinter &lt;key1&gt;&lt;key2&gt;</code></td><td>返回两个集合的交集元素。</td></tr><tr><td><code>sunion &lt;key1&gt;&lt;key2&gt;</code></td><td>返回两个集合的并集元素。</td></tr><tr><td><code>sdiff &lt;key1&gt;&lt;key2&gt;</code></td><td>返回两个集合的差集元素(key1 中的，不包含 key2 中的)</td></tr></tbody></table><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>Set 数据结构是 dict 字典，字典是用哈希表实现的。</li><li>Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。</li><li>Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向一个内部值。</li></ul><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis hash 是一个键值对集合。</li><li>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</li><li>类似 Java 里面的 Map&lt;String,Object&gt;</li><li>用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用</li><li>普通的 key/value 结构来存储<br>主要有以下 2 种存储方式：<ul><li>每次修改用户的某个属性需要，先反序列化<br>改好后再序列化回去。开销较大<br><img src="/2021/07/22/Redis6/image-20210723094835460.png" alt="image-20210723094835460"></li><li>用户 ID 数据冗余<br><img src="/2021/07/22/Redis6/image-20210723094853915.png" alt="image-20210723094853915"></li><li>通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题<br><img src="/2021/07/22/Redis6/image-20210723095032787.png" alt="image-20210723095032787"></li></ul></li></ul><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>使用</th></tr></thead><tbody><tr><td><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code></td><td>给<key>集合中的 <field>键赋值<value></value></field></key></td></tr><tr><td><code>hget &lt;key1&gt;&lt;field&gt;</code></td><td>从<key1>集合<field>取出 value</field></key1></td></tr><tr><td><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code></td><td>批量设置 hash 的值</td></tr><tr><td><code>hexists&lt;key1&gt;&lt;field&gt;</code></td><td>查看哈希表 key 中，给定域 field 是否存在。</td></tr><tr><td><code>hkeys &lt;key&gt;</code></td><td>列出该 hash 集合的所有 field</td></tr><tr><td><code>hvals &lt;key&gt;</code></td><td>列出该 hash 集合的所有 value</td></tr><tr><td><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code></td><td>为哈希表 key 中的域 field 的值加上增量 1 -1</td></tr><tr><td><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code></td><td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在</td></tr></tbody></table><h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p>Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p><h2 id="Redis有序集合Zset（sorted-set"><a href="#Redis有序集合Zset（sorted-set" class="headerlink" title="Redis有序集合Zset（sorted set)"></a>Redis有序集合Zset（sorted set)</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。</p></li><li><p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p></li><li><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p></li><li><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p></li></ul><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>使用</th></tr></thead><tbody><tr><td><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code></td><td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</td></tr><tr><td><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code></td><td>返回有序集 key 中，下标在<start><stop></stop>之间的元素。带 WITHSCORES，可以让分数一起和值返回到结果集。</start></td></tr><tr><td><code>zrangebyscore key minmax [withscores] [limit offset count]</code></td><td>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</td></tr><tr><td><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code></td><td>同上，改为从大到小排列。</td></tr><tr><td><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt; </code></td><td>为元素的 score 加上增量</td></tr><tr><td><code>zrem &lt;key&gt;&lt;value&gt;</code></td><td>删除该集合下，指定值的元素</td></tr><tr><td><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code></td><td>统计该集合，分数区间内的元素个数</td></tr><tr><td><code>zrank &lt;key&gt;&lt;value&gt;</code></td><td>返回该值在集合中的排名，从 0 开始。</td></tr></tbody></table><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>SortedSet(zset)是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java<br>的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</li><li>zset 底层使用了两个数据结构<ul><li>（1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li><li>（2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表</li></ul></li></ul><h2 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><h1 id="四、Redis6配置文件详解"><a href="#四、Redis6配置文件详解" class="headerlink" title="四、Redis6配置文件详解"></a>四、Redis6配置文件详解</h1><h2 id="1-Units-单位"><a href="#1-Units-单位" class="headerlink" title="1. ###Units 单位###"></a>1. ###Units 单位###</h2><ul><li>配置大小单位,开头定义了一些基本的度量单位，只支持 bytes，不支持 bit</li><li>大小写不敏感</li></ul><h2 id="2-INCLUDES-包含"><a href="#2-INCLUDES-包含" class="headerlink" title="2. ###INCLUDES 包含###"></a>2. ###INCLUDES 包含###</h2><ul><li>类似 jsp 中的 include，多实例的情况可以把公用的配置文件提取出来</li></ul><h2 id="3-网络相关配置"><a href="#3-网络相关配置" class="headerlink" title="3. ###网络相关配置"></a>3. ###网络相关配置</h2><h3 id="1-bind"><a href="#1-bind" class="headerlink" title="1.bind"></a>1.bind</h3><ul><li>默认情况 bind=127.0.0.1 只能接受本机的访问请求</li><li>不写的情况下，无限制接受任何 ip 地址的访问</li><li>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</li><li>==如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis只允许接受本机的响应==</li><li>保存配置，停止服务，重启启动查看进程，配置生效</li></ul><h3 id="2-protected-mode"><a href="#2-protected-mode" class="headerlink" title="2.protected-mode"></a>2.protected-mode</h3><ul><li>将本机访问保护模式设置 no</li></ul><h3 id="3-Port"><a href="#3-Port" class="headerlink" title="3.Port"></a>3.Port</h3><ul><li>端口号，默认 6379</li></ul><h3 id="4-tcp-backlog"><a href="#4-tcp-backlog" class="headerlink" title="4.tcp-backlog"></a>4.tcp-backlog</h3><ul><li>设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和=未完成三次握手队列 + 已经完成三次握手队列。</li><li>在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。</li><li>注意 Linux 内核会将这个值减小到/proc/sys/net/core/somaxconn 的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</li></ul><h3 id="5-timeout"><a href="#5-timeout" class="headerlink" title="5.timeout"></a>5.timeout</h3><ul><li>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</li></ul><h3 id="6-tcp-keepalive"><a href="#6-tcp-keepalive" class="headerlink" title="6.tcp-keepalive"></a>6.tcp-keepalive</h3><ul><li>对访问客户端的一种心跳检测，每个 n 秒检测一次。</li><li>单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60</li></ul><h2 id="4-GENERAL-通用"><a href="#4-GENERAL-通用" class="headerlink" title="4. ###GENERAL 通用###"></a>4. ###GENERAL 通用###</h2><h3 id="1-daemonize"><a href="#1-daemonize" class="headerlink" title="1.daemonize"></a>1.daemonize</h3><ul><li>是否为后台进程，设置为 yes</li><li>守护进程，后台启动</li></ul><h3 id="2-pidfile"><a href="#2-pidfile" class="headerlink" title="2.pidfile"></a>2.pidfile</h3><ul><li>存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件</li></ul><h3 id="3-loglevel"><a href="#3-loglevel" class="headerlink" title="3.loglevel"></a>3.loglevel</h3><ul><li>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</li><li>四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning</li></ul><h4 id="4-logfile"><a href="#4-logfile" class="headerlink" title="4.logfile"></a>4.logfile</h4><ul><li>日志文件名称</li></ul><h3 id="5-databases-16"><a href="#5-databases-16" class="headerlink" title="5.databases 16"></a>5.databases 16</h3><ul><li>设定库的数量 默认 16，默认数据库为 0，可以使用 SELECT <dbid>命令在连接上指定数据库 id</dbid></li></ul><h2 id="5-SECURITY-安全"><a href="#5-SECURITY-安全" class="headerlink" title="5. ###SECURITY 安全###"></a>5. ###SECURITY 安全###</h2><h3 id="1-设置密码"><a href="#1-设置密码" class="headerlink" title="1.设置密码"></a>1.设置密码</h3><ul><li>访问密码的查看、设置和取消</li><li>在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。</li><li>永久设置，需要再配置文件中进行设置。<br><img src="/2021/07/22/Redis6/image-20210723102644227.png" alt="image-20210723102644227"></li></ul><h2 id="6-LIMITS-限制"><a href="#6-LIMITS-限制" class="headerlink" title="6. #### LIMITS 限制"></a>6. #### LIMITS 限制</h2><h3 id="1-maxclients"><a href="#1-maxclients" class="headerlink" title="1.maxclients"></a>1.maxclients</h3><ul><li>设置 redis 同时可以与多少个客户端进行连接。</li><li>默认情况下为 10000 个客户端。</li><li>如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出<br>“max number of clients reached”以作回应。</li></ul><h3 id="2-maxmemory"><a href="#2-maxmemory" class="headerlink" title="2.maxmemory"></a>2.maxmemory</h3><ul><li>建议==必须设置==，否则，将内存占满，造成服务器宕机</li><li>设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数<br>据，移除规则可以通过 maxmemory-policy 来指定。</li><li>如果 redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等。</li><li>但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 redis 是主<br>redis（说明你的 redis 有从 redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不<br>用考虑这个因素。</li></ul><h3 id="3-maxmemory-policy"><a href="#3-maxmemory-policy" class="headerlink" title="3.maxmemory-policy"></a>3.maxmemory-policy</h3><ul><li>volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；（最近最少使用）</li><li>allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key</li><li>volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合 key 中，移除随机的 key</li><li>volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ul><h3 id="4-maxmemory-samples"><a href="#4-maxmemory-samples" class="headerlink" title="4.maxmemory-samples"></a>4.maxmemory-samples</h3><ul><li>设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所<br>以你可以设置样本的大小，redis 默认会检查这么多个 key 并选择其中 LRU 的那个。</li><li>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</li></ul><h1 id="五、Redis6的发布和订阅"><a href="#五、Redis6的发布和订阅" class="headerlink" title="五、Redis6的发布和订阅"></a>五、Redis6的发布和订阅</h1><h2 id="1-什么是发布和订阅"><a href="#1-什么是发布和订阅" class="headerlink" title="1. 什么是发布和订阅"></a>1. 什么是发布和订阅</h2><ul><li>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者<br>(sub) 接收消息。</li><li>Redis 客户端可以订阅任意数量的频道。</li></ul><h2 id="2-Redis-的发布和订阅"><a href="#2-Redis-的发布和订阅" class="headerlink" title="2. Redis 的发布和订阅"></a>2. Redis 的发布和订阅</h2><ul><li>客户端可以订阅频道</li><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ul><h2 id="3-发布订阅命令行实现"><a href="#3-发布订阅命令行实现" class="headerlink" title="3. 发布订阅命令行实现"></a>3. 发布订阅命令行实现</h2><ol><li>打开一个客户端订阅 channel1<br><code>SUBSCRIBE channel1</code></li><li>打开另一个客户端，给 channel1 发布消息 hello<br><code>publish channel1 hello</code><br>返回的值是订阅者数量</li><li>打开第一个客户端可以看到发送的消息</li></ol><p>注：发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布<br>的消息</p><h1 id="六、Redis6新数据类型"><a href="#六、Redis6新数据类型" class="headerlink" title="六、Redis6新数据类型"></a>六、Redis6新数据类型</h1><h2 id="1-Bitmaps"><a href="#1-Bitmaps" class="headerlink" title="1. Bitmaps"></a>1. Bitmaps</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>现代计算机用二进制（位） 作为信息的基础单位， 1 个字节等于 8 位， 例如“abc”<br>字符串是由 3 个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别<br>对应的 ASCII 码分别是 97、 98、 99， 对应的二进制分别是 01100001、01100010和 01100011，</li><li>合理地使用操作位能够有效地提高内存使用率和开发效率。</li><li>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：<ul><li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。</li><li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</li></ul></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;</code>设置 Bitmaps 中某个偏移量的值（0 或 1）<br>*offset:偏移量从 0 开始</li><li><code>getbit&lt;key&gt;&lt;offset&gt;</code>获取 Bitmaps 中某个偏移量的值<br>获取键的第 offset 位的值（从 0 开始算）</li><li>bitcount<br>统计字符串被设置为 1 的 bit 数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指 bit 组的字节的下标数，二者皆包含。<ul><li><code>bitcount&lt;key&gt;[start end]</code> 统计字符串从 start 字节到 end 字节比特值为 1 的数量</li></ul></li><li>bitop<br><code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code><br>bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。</li></ul><h3 id="Bitmaps-与-set-对比"><a href="#Bitmaps-与-set-对比" class="headerlink" title="Bitmaps 与 set 对比"></a>Bitmaps 与 set 对比</h3><ul><li>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和<br>Bitmaps 分别存储活跃用户。</li><li>这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</li><li>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10<br>万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</li></ul><h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2. HyperLogLog"></a>2. HyperLogLog</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV<br>（PageView 页面访问量）,可以使用 Redis 的 incr、incrby 轻松实现。</li><li>但像 UV（UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</li><li>解决基数问题有很多种方案：<ul><li>（1）数据存储在 MySQL 表中，使用 distinct count 计算不重复个数</li><li>（2）使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li><li>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非<br>常大的数据集是不切实际的。</li></ul></li><li>能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog</li><li>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</li><li>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li><li>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</li><li>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8},基数(不重复元素)为 5。 基数估计就是在误差可接受的范围内，快速计算基数。</li></ul><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul><li>pfadd <key>&lt; element&gt; [element …]<br> 添加指定元素到 HyperLogLog 中将所有元素添加到指定 HyperLogLog 数据结构中。如果执行命令后 HLL 估计的近似基数发生变化，则返回 1，否则返回 0。</key></li><li>pfcount<key> [key …]<br>计算 HLL 的近似基数，可以计算多个 HLL，比如用 HLL 存储每天的 UV，计算一周的 UV 可以使用 7 天的 UV 合并计算即可</key></li><li>pfmerge<destkey><sourcekey> [sourcekey …]<br>将一个或多个 HLL 合并后的结果存储在另一个 HLL 中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</sourcekey></destkey></li></ul><h2 id="3-Geospatial"><a href="#3-Geospatial" class="headerlink" title="3. Geospatial"></a>3. Geospatial</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul><li>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]<br>添加地理位置（经度，纬度，名称）<ul><li>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</li><li>有 效 的 经 度 从 -180 度 到 180 度 。 有 效 的 纬 度 从 -85.05112878 度 到<br>85.05112878 度。</li><li>当坐标位置超出指定范围时，该命令将会返回一个错误。</li><li>已经添加的数据，是无法再次往里面添加的。</li></ul></member></latitude></key></li><li>geopos <key><member> [member…]<br>获得指定地区的坐标值</member></key></li><li>geodist<key><member1><member2> [m|km|ft|mi ]<br> 获取两个位置之间的直线距离<br>单位：<ul><li>m 表示单位为米[默认值]。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li><li>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</li></ul></member2></member1></key></li><li>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi<br>以给定的经纬度为中心，找出某一半径内的元素</latitude></key></li></ul><h1 id="七、Jedis操作Redis6"><a href="#七、Jedis操作Redis6" class="headerlink" title="七、Jedis操作Redis6"></a>七、Jedis操作Redis6</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="Jedis-所需要的-jar-包："><a href="#Jedis-所需要的-jar-包：" class="headerlink" title="Jedis 所需要的 jar 包："></a>Jedis 所需要的 jar 包：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="连接-Redis-注意事项"><a href="#连接-Redis-注意事项" class="headerlink" title="连接 Redis 注意事项"></a>连接 Redis 注意事项</h3><ul><li>禁用 Linux 的防火墙：<br>Linux(CentOS7)里执行命令<br><code>systemctl stop/disable firewalld.service</code></li><li>redis.conf 中注释掉 bind 127.0.0.1 ,然后 protected-mode no</li></ul><h3 id="Jedis-常用操作"><a href="#Jedis-常用操作" class="headerlink" title="Jedis 常用操作"></a>Jedis 常用操作</h3><p>测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.137.3&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">String pong = jedis.ping();</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功：&quot;</span>+pong);</span><br><span class="line">jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据读写测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key</span></span><br><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br><span class="line"><span class="comment">//List</span></span><br><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line"><span class="comment">//hash</span></span><br><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zset</span></span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>要求：<br>1、输入手机号，点击发送后随机生成 6 位数字码，2 分钟有效<br>2、输入验证码，点击验证，返回成功或失败<br>3、每个手机号每天只能输入 3 次</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 八、Redis6与Spring Boot整合</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  在 pom.xml 文件中引入 redis 相关依赖</span><br><span class="line"></span><br><span class="line">   ~~~xml</span><br><span class="line">   &lt;!-- redis --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- spring2.X 集成 redis 所需 common-pool2--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> application.properties 配置 redis 配置</li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis 服务器地址</span><br><span class="line">spring.redis.host=192.168.140.136</span><br><span class="line">#Redis 服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">#Redis 数据库索引（默认为 0）</span><br><span class="line">spring.redis.database= 0</span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=1800000</span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=20</span><br><span class="line">#最大阻塞等待时间(负数表示没限制)</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1</span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=5</span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br></pre></td></tr></table></figure><ol start="3"><li> 添加 redis 配置类</li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactoryfactory)</span> </span>&#123;</span><br><span class="line">RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span>;</span><br><span class="line">    StringRedisSerializer();</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    om.setVisibility(PropertyAccessor.ALL,</span><br><span class="line">                     JsonAutoDetect.Visibility.ANY);</span><br><span class="line">   om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key 序列化方式</span></span><br><span class="line">template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value 序列化</span></span><br><span class="line">template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap 序列化</span></span><br><span class="line">template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间 600 秒</span></span><br><span class="line">RedisCacheConfiguration config =</span><br><span class="line">RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">.entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">.serializeKeysWith(RedisSerializationContext.SerializationPair.</span><br><span class="line">fromSerializer(redisSerializer))</span><br><span class="line">.serializeValuesWith(RedisSerializationContext.SerializationPai</span><br><span class="line">r.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">.disableCachingNullValues();</span><br><span class="line">RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">.cacheDefaults(config)</span><br><span class="line">.build();</span><br><span class="line"><span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>RedisTestController 中添加测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置值到 redis</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"><span class="comment">//从 redis 获取值</span></span><br><span class="line">String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="九、Redis6的事务操作"><a href="#九、Redis6的事务操作" class="headerlink" title="九、Redis6的事务操作"></a>九、Redis6的事务操作</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送过来的命令请求所打断。</li><li>Redis事务的主要作用就是串联多个命令防止别的命令插队</li></ul><h2 id="2-Multi、Exec、discard"><a href="#2-Multi、Exec、discard" class="headerlink" title="2. Multi、Exec、discard"></a>2. Multi、Exec、discard</h2><p>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec 后，Redis 会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过 discard 来放弃组队。</p><p><img src="/2021/07/22/Redis6/image-20210724140128703.png" alt="image-20210724140128703"></p><p>示例：<br><img src="/2021/07/22/Redis6/image-20210724140248465.png" alt="image-20210724140248465"></p><p>组队成功，提交成功</p><p><img src="/2021/07/22/Redis6/image-20210724140305123.png" alt="image-20210724140305123"></p><p>组队阶段报错，提交失败</p><p><img src="/2021/07/22/Redis6/image-20210724140324840.png" alt="image-20210724140324840"></p><p>组队成功，提交有成功有失败情况</p><h2 id="3-事务的错误处理"><a href="#3-事务的错误处理" class="headerlink" title="3. 事务的错误处理"></a>3. 事务的错误处理</h2><ul><li>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</li><li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li></ul><h2 id="4-为什么要做成事务"><a href="#4-为什么要做成事务" class="headerlink" title="4. 为什么要做成事务"></a>4. 为什么要做成事务</h2><p>满足高并发需求等</p><h2 id="5-事务冲突"><a href="#5-事务冲突" class="headerlink" title="5. 事务冲突"></a>5. 事务冲突</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>一个请求想给金额减8000</p><p>一个请求想给金额减5000</p><p>一个请求想给金额减1000</p><p><img src="/2021/07/22/Redis6/image-20210724140617945.png" alt="image-20210724140617945"></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p><img src="/2021/07/22/Redis6/image-20210724140652155.png" alt="image-20210724140652155"></p><p>==<strong>悲观锁(Pessimistic Lock)</strong>,== 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。**==传统的关系型数据库里边就用到了很多这种锁机制==<strong>，比如</strong>行锁<strong>，</strong>表锁<strong>等，</strong>读锁<strong>，</strong>写锁**等，都是在做操作之前先上锁。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><img src="/2021/07/22/Redis6/image-20210724140747554.png" alt="image-20210724140747554"></p><p><strong>==乐观锁(Optimistic Lock)==,</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。==<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。==</p><h3 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a><strong>WATCH</strong> <strong>key</strong> <strong>[key …]</strong></h3><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务**执行之前这个(**<strong>或这些) key</strong> <strong>被其他命令所改动，那么事务将被打断。</strong></p><p><img src="/2021/07/22/Redis6/image-20210724140848516.png" alt="image-20210724140848516"></p><h3 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a><strong>unwatch</strong></h3><p>取消 WATCH 命令对所有 key 的监视。</p><p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p><p><a href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p><h2 id="6-Redis事务三特性"><a href="#6-Redis事务三特性" class="headerlink" title="6. Redis事务三特性"></a>6. Redis事务三特性</h2><ul><li><p> 单独的隔离操作 </p></li><li><p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p></li><li><p>没有隔离级别的概念 </p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li><p>不保证原子性 </p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </li></ul></li></ul><h2 id="7-秒杀案例"><a href="#7-秒杀案例" class="headerlink" title="7.秒杀案例"></a>7.秒杀案例</h2><h3 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a>解决计数器和人员记录的事务操作</h3><p><img src="/2021/07/22/Redis6/image-20210724141220521.png" alt="image-20210724141220521"></p><h3 id="Redis事务，秒杀并发模拟"><a href="#Redis事务，秒杀并发模拟" class="headerlink" title="Redis事务，秒杀并发模拟"></a>Redis事务，秒杀并发模拟</h3><ul><li>使用工具ab模拟测试</li><li>CentOS6 默认安装</li><li>CentOS7需要手动安装<ul><li>命令：<code>yum install httpd-tools</code></li></ul></li></ul><p>无网络情况下：</p><ul><li><p> 进入cd /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同）</p></li><li><p> 顺序安装</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apr-1.4.8-3.el7.x86_64.rpm</span><br><span class="line">apr-util-1.5.2-6.el7.x86_64.rpm</span><br><span class="line">httpd-tools-2.4.6-67.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure><p>测试：</p><p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。</p><p>内容：prodid=0101&amp;</p><p>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p><p>超卖：</p><p><img src="/2021/07/22/Redis6/image-20210724141707910.png" alt="image-20210724141707910"></p><h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><p><img src="/2021/07/22/Redis6/image-20210724141731284.png" alt="image-20210724141731284"></p><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p><img src="/2021/07/22/Redis6/image-20210724141809526.png" alt="image-20210724141809526"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加乐观锁</span></span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.判断库存</span></span><br><span class="line">String qtkeystr = jedis.get(qtkey);</span><br><span class="line"><span class="keyword">if</span>(qtkeystr==<span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未初始化库存&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> qt = Integer.parseInt(qtkeystr);</span><br><span class="line"><span class="keyword">if</span>(qt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已经秒光&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/22/Redis6/image-20210724141909480.png" alt="image-20210724141909480"></p><p>增加事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.减少库存</span></span><br><span class="line"><span class="comment">//jedis.decr(qtkey);</span></span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5.加人</span></span><br><span class="line"><span class="comment">//jedis.sadd(usrkey, uid);</span></span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行事务</span></span><br><span class="line">List&lt;Object&gt; list = multi.exec();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断事务提交是否失败</span></span><br><span class="line"><span class="keyword">if</span>(list==<span class="keyword">null</span> || list.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/07/22/Redis6/image-20210724141952138.png" alt="image-20210724141952138"></p><h3 id="增加并发"><a href="#增加并发" class="headerlink" title="增加并发"></a>增加并发</h3><h4 id="连接有限制"><a href="#连接有限制" class="headerlink" title="连接有限制"></a>连接有限制</h4><p>b -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p><p><img src="/2021/07/22/Redis6/image-20210724142055178.png" alt="image-20210724142055178"></p><p>增加-r参数，-r  Don’t exit on socket receive errors.</p><p><strong>ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’</strong> <a href="http://192.168.140.1:8080/seckill/doseckill"><strong>http://192.168.140.1:8080/seckill/doseckill</strong></a></p><h4 id="秒光还有库存"><a href="#秒光还有库存" class="headerlink" title="秒光还有库存"></a>秒光还有库存</h4><p>已经秒光，可是还有库存</p><p>ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a></p><p>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p><h4 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h4><p>连接超时，通过连接池解决</p><p><img src="/2021/07/22/Redis6/image-20210724142323355.png" alt="image-20210724142323355"></p><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p><p>通过参数管理连接的行为</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">poolConfig.setMaxWaitMillis(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">poolConfig.setBlockWhenExhausted(<span class="keyword">true</span>);</span><br><span class="line">poolConfig.setTestOnBorrow(<span class="keyword">true</span>);  <span class="comment">// ping  PONG</span></span><br><span class="line"> </span><br><span class="line">jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;192.168.44.168&quot;</span>, <span class="number">6379</span>, <span class="number">60000</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jedisPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">jedisPool.returnResource(jedis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接池参数</p><ul><li><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p></li><li><p> maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p></li><li><p> MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p></li><li><p> testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</p></li></ul><h3 id="解决库存遗留"><a href="#解决库存遗留" class="headerlink" title="解决库存遗留"></a>解决库存遗留</h3><h4 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h4><ul><li>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</li><li>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</li><li>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</li><li><a href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></li></ul><hr><p>LUA脚本在Redis中的优势：</p><ul><li><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p></li><li><p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p></li><li><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p></li><li><p>利用lua脚本淘汰用户，解决超卖问题。</p></li><li><p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p></li></ul><p><img src="/2021/07/22/Redis6/image-20210724143222339.png" alt="image-20210724143222339"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure><h3 id="秒杀实现"><a href="#秒杀实现" class="headerlink" title="秒杀实现"></a>秒杀实现</h3><p>项目结构：</p><p><img src="/2021/07/22/Redis6/image-20210724143708081.png" alt="image-20210724143708081"></p><h4 id="第一版，普通实现"><a href="#第一版，普通实现" class="headerlink" title="第一版，普通实现"></a>第一版，普通实现</h4><p>少量访问的情况下，秒杀正常，此时未达到并发效果。</p><p>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p><h4 id="第二版，增加事务-乐观锁"><a href="#第二版，增加事务-乐观锁" class="headerlink" title="第二版，增加事务-乐观锁"></a>第二版，增加事务-乐观锁</h4><p>增加事务-乐观锁解决超卖问题，但出现遗留库存和连接超时</p><h4 id="第三版，连接池解决超时问题"><a href="#第三版，连接池解决超时问题" class="headerlink" title="第三版，连接池解决超时问题"></a>第三版，连接池解决超时问题</h4><h4 id="第四版，LUA脚本解决库存遗留问题"><a href="#第四版，LUA脚本解决库存遗留问题" class="headerlink" title="第四版，LUA脚本解决库存遗留问题"></a>第四版，LUA脚本解决库存遗留问题</h4><p>代码实现：</p><p>JedisPoolUtil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">poolConfig.setMaxWaitMillis(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">poolConfig.setBlockWhenExhausted(<span class="keyword">true</span>);</span><br><span class="line">poolConfig.setTestOnBorrow(<span class="keyword">true</span>);  <span class="comment">// ping  PONG</span></span><br><span class="line"> </span><br><span class="line">jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;192.168.44.168&quot;</span>, <span class="number">6379</span>, <span class="number">60000</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jedisPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">jedisPool.returnResource(jedis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecKill_redis.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.rolling.helper.IntegerTokenConverter;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ShardedJedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill_redis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Jedis jedis =<span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.44.168&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒杀过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1 uid和prodid非空判断</span></span><br><span class="line"><span class="keyword">if</span>(uid == <span class="keyword">null</span> || prodid == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 连接redis</span></span><br><span class="line"><span class="comment">//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span></span><br><span class="line"><span class="comment">//通过连接池得到jedis对象</span></span><br><span class="line">JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">Jedis jedis = jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 拼接key</span></span><br><span class="line"><span class="comment">// 3.1 库存key</span></span><br><span class="line">String kcKey = <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line">String userKey = <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监视库存</span></span><br><span class="line">jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 获取库存，如果库存null，秒杀还没有开始</span></span><br><span class="line">String kc = jedis.get(kcKey);</span><br><span class="line"><span class="keyword">if</span>(kc == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀还没有开始，请等待&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 判断用户是否重复秒杀操作</span></span><br><span class="line"><span class="keyword">if</span>(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 判断如果商品数量，库存数量小于1，秒杀结束</span></span><br><span class="line"><span class="keyword">if</span>(Integer.parseInt(kc)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7 秒杀过程</span></span><br><span class="line"><span class="comment">//使用事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"></span><br><span class="line"><span class="comment">//组队操作</span></span><br><span class="line">multi.decr(kcKey);</span><br><span class="line">multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(results == <span class="keyword">null</span> || results.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败了....&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.1 库存-1</span></span><br><span class="line"><span class="comment">//jedis.decr(kcKey);</span></span><br><span class="line"><span class="comment">//7.2 把秒杀成功用户添加清单里面</span></span><br><span class="line"><span class="comment">//jedis.sadd(userKey,uid);</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;秒杀成功了..&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecKill_redisByScript.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.joran.conditional.ElseAction;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ShardedJedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill_redisByScript</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  org.slf4j.Logger logger =LoggerFactory.getLogger(SecKill_redisByScript.class) ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line"> </span><br><span class="line">Jedis jedis=jedispool.getResource();</span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line"></span><br><span class="line">Set&lt;HostAndPort&gt; set=<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//doSecKill(&quot;201&quot;,&quot;sk:0101&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String secKillScript =<span class="string">&quot;local userid=KEYS[1];\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;local prodid=KEYS[2];\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;local qtkey=&#x27;sk:&#x27;..prodid..\&quot;:qt\&quot;;\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;local usersKey=&#x27;sk:&#x27;..prodid..\&quot;:usr\&quot;;\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;local userExists=redis.call(\&quot;sismember\&quot;,usersKey,userid);\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;if tonumber(userExists)==1 then \r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;   return 2;\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;end\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;local num= redis.call(\&quot;get\&quot; ,qtkey);\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;if tonumber(num)&lt;=0 then \r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;   return 0;\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;else \r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;   redis.call(\&quot;decr\&quot;,qtkey);\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;   redis.call(\&quot;sadd\&quot;,usersKey,userid);\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;end\r\n&quot;</span> + </span><br><span class="line"><span class="string">&quot;return 1&quot;</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> String secKillScript2 = </span><br><span class="line"><span class="string">&quot;local userExists=redis.call(\&quot;sismember\&quot;,\&quot;&#123;sk&#125;:0101:usr\&quot;,userid);\r\n&quot;</span> +</span><br><span class="line"><span class="string">&quot; return 1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">Jedis jedis=jedispool.getResource();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//String sha1=  .secKillScript;</span></span><br><span class="line">String sha1=  jedis.scriptLoad(secKillScript);</span><br><span class="line">Object result= jedis.evalsha(sha1, <span class="number">2</span>, uid,prodid);</span><br><span class="line"></span><br><span class="line">  String reString=String.valueOf(result);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals( reString )  ) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已抢空！！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals( reString )  )  &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;抢购成功！！！！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals( reString )  )  &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;该用户已抢过！！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;抢购异常！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SecKillServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.soap.AddressingFeature.Responses;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecKillServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">String userid = <span class="keyword">new</span> Random().nextInt(<span class="number">50000</span>) +<span class="string">&quot;&quot;</span> ;</span><br><span class="line">String prodid =request.getParameter(<span class="string">&quot;prodid&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean isSuccess=SecKill_redis.doSecKill(userid,prodid);</span></span><br><span class="line"><span class="keyword">boolean</span> isSuccess= SecKill_redisByScript.doSecKill(userid,prodid);</span><br><span class="line">response.getWriter().print(isSuccess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十、Redis6持久化"><a href="#十、Redis6持久化" class="headerlink" title="十、Redis6持久化"></a>十、Redis6持久化</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><img src="/2021/07/22/Redis6/image-20210724144454924.png" alt="image-20210724144454924"></p><p>Redis 提供了2个不同形式的持久化方式。</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append OfFile）</li></ul><h2 id="2-RDB"><a href="#2-RDB" class="headerlink" title="2. RDB"></a>2. RDB</h2><p><img src="/2021/07/22/Redis6/image-20210724144602456.png" alt="image-20210724144602456"></p><hr><ul><li>RDB是什么？<ul><li>在指定的==时间间隔==内将内存中的数据集==快照==写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</li></ul></li><li>执行<ul><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。==<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>==。</li></ul></li><li>Fork<ul><li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li> 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul></li></ul><hr><p>RDB持久化：</p><p><img src="/2021/07/22/Redis6/image-20210724144922596.png" alt="image-20210724144922596"></p><hr><h3 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a><strong>dump.rdb文件</strong></h3><p>在redis.conf中配置文件名称，默认为dump.rdb</p><p><img src="/2021/07/22/Redis6/image-20210724145004782.png" alt="image-20210724145004782"></p><p>配置：</p><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p>dir “/myredis/“</p><p><img src="/2021/07/22/Redis6/image-20210724145035673.png" alt="image-20210724145035673"></p><h3 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a><strong>如何触发RDB快照；保持策略</strong></h3><p> 配置文件中默认的快照配置</p><p><img src="/2021/07/22/Redis6/image-20210724145127453.png" alt="image-20210724145127453"></p><p>命令save VS bgsave</p><ul><li><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p></li><li><p>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p></li><li><p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p></li></ul><p>flushall命令：</p><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><hr><p><strong>###SNAPSHOTTING快照###</strong></p><p>Save：</p><ul><li><p>格式：save 秒钟 写操作次数</p></li><li><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p></li><li><p>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p></li><li><p>禁用</p></li><li><p>不设置save指令，或者给save传入空字符串</p></li></ul><p><strong>stop-writes-on-bgsave-error</strong></p><p><img src="/2021/07/22/Redis6/image-20210724145802515.png" alt="image-20210724145802515"></p><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><p><strong>rdbcompression</strong> <strong>压缩文件</strong></p><p><img src="/2021/07/22/Redis6/image-20210724145854277.png" alt="image-20210724145854277"></p><ul><li><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p></li><li><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p></li></ul><p><strong>rdbchecksum</strong> <strong>检查完整性</strong></p><p><img src="/2021/07/22/Redis6/image-20210724145941821.png" alt="image-20210724145941821"></p><ul><li><p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p></li><li><p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p></li><li><p>推荐yes.</p></li></ul><hr><p>rdb的备份</p><ul><li><p>先通过config get dir 查询rdb文件的目录 </p></li><li><p>将*.rdb的文件拷贝到别的地方</p></li><li><p>rdb的恢复</p><ul><li>关闭Redis</li><li>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</li><li> 启动Redis, 备份数据会直接加载</li></ul></li></ul><h3 id="RDB优势"><a href="#RDB优势" class="headerlink" title="RDB优势"></a>RDB优势</h3><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高更适合使用</p></li><li><p>节省磁盘空间</p></li><li><p>恢复速度快</p></li></ul><p><img src="/2021/07/22/Redis6/image-20210724150220032.png" alt="image-20210724150220032"></p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p></li><li><p>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</p></li><li><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p></li></ul><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2021/07/22/Redis6/image-20210724150348015.png" alt="image-20210724150348015"></p><h2 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3. AOF"></a>3. AOF</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li></ul><h3 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h3><ol><li>客户端的请求写命令会被append追加到AOF缓冲区内；</li><li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li><li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li><li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li></ol><p><img src="/2021/07/22/Redis6/image-20210724151327478.png" alt="image-20210724151327478"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a>AOF默认不开启</h4><ul><li><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof</p></li><li><p>AOF文件的保存路径，同RDB的路径一致。</p></li></ul><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul><li>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</li></ul><h4 id="AOF启动、修复、恢复"><a href="#AOF启动、修复、恢复" class="headerlink" title="AOF启动、修复、恢复"></a>AOF启动、修复、恢复</h4><ul><li><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p></li><li><p>正常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ul></li><li><p> 异常恢复</p></li><li><p> 修改默认的appendonly no，改为yes</p></li><li><p> 如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</p></li><li><p>备份被写坏的AOF文件</p></li><li><p>恢复：重启redis，然后重新加载</p></li></ul><h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><ul><li><p>appendfsync always</p><ul><li>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</li></ul></li><li><p>appendfsync everysec</p><ul><li>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li></ul></li><li><p>appendfsync no</p><ul><li>redis不主动进行同步，把同步时机交给操作系统。</li></ul></li></ul><h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a><strong>Rewrite压缩</strong></h4><ul><li><p>是什么：</p><ul><li>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</li></ul></li><li><p>重写原理，如何实现重写</p><ul><li>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</li></ul></li></ul><p>no-appendfsync-on-rewrite：</p><ul><li><p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p></li><li><p>如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p></li></ul><p>触发机制，何时重写</p><ul><li><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p></li><li><p>==重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写==。 </p></li><li><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p></li><li><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p></li></ul><hr><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p><p>重写流程</p><ol><li><p>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p></li><li><p>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p></li><li><p>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p></li><li><ol><li>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。</li><li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li></ol></li><li><p>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p></li></ol><p><img src="/2021/07/22/Redis6/image-20210724152004141.png" alt="image-20210724152004141"></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><img src="/2021/07/22/Redis6/image-20210724152018815.png" alt="image-20210724152018815"></p><ul><li><p>备份机制更稳健，丢失数据概率更低。</p></li><li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p></li></ul><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ul><li><p>比起RDB占用更多的磁盘空间。</p></li><li><p>恢复备份速度要慢。</p></li><li><p>每次读写都同步的话，有一定的性能压力。</p></li><li><p>存在个别Bug，造成恢复不能。</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="/2021/07/22/Redis6/image-20210724152119153.png" alt="image-20210724152119153"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><strong>用哪个好</strong></p><ul><li><p>官方推荐两个都启用。</p></li><li><p>如果对数据不敏感，可以选单独用RDB。</p></li><li><p>不建议单独用 AOF，因为可能会出现Bug。</p></li><li><p>如果只是做纯内存缓存，可以都不用。</p></li></ul><hr><p>官方：</p><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p> AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </p></li><li><p> Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p></li><li><p> 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式</p></li><li><p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p> RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p></li><li><p> 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li><li><p> 性能建议</p></li><li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p></li><li><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</p></li><li><p>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p></li><li><p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p></li><li><p>默认超过原大小100%大小时重写可以改到适当的数值。</p></li></ul><h1 id="十一、Redis6的主从复制"><a href="#十一、Redis6的主从复制" class="headerlink" title="十一、Redis6的主从复制"></a>十一、Redis6的主从复制</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li>是什么<ul><li>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master</strong>以写为主，Slave以读为主</li></ul></li><li>能干什么<ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul></li></ul><p><img src="/2021/07/22/Redis6/image-20210724152612945.png" alt="image-20210724152612945"></p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><ul><li><p>拷贝多个redis.conf文件include(写绝对路径)</p></li><li><p>开启daemonize yes</p></li><li><p>Pid文件名字pidfile</p></li><li><p>指定端口port</p></li><li><p>Log文件名字</p></li><li><p>dump.rdb名字dbfilename</p></li><li><p>Appendonly 关掉或者换名字</p></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p> <strong>新建redis6379.conf，填写以下内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure><p><strong>新建redis6380.conf，填写以下内容</strong></p><p><strong>新建redis6381.conf，填写以下内容</strong></p><hr><p><code>slave-priority 10</code></p><p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><hr><p><strong>启动三台redis服务器</strong></p><p><img src="/2021/07/22/Redis6/image-20210724152948970.png" alt="image-20210724152948970"></p><p><strong>查看三台主机运行情况</strong></p><p><img src="/2021/07/22/Redis6/image-20210724153008873.png" alt="image-20210724153008873"></p><p><img src="/2021/07/22/Redis6/image-20210724153015610.png" alt="image-20210724153015610"></p><hr><p><code>info replication</code></p><p>打印主从复制的相关信息</p><hr><p><strong>配从(库)不配主(库)</strong></p><p><code>slaveof &lt;ip&gt;&lt;port&gt;</code></p><p>成为某个实例的从服务器</p><ul><li><p>在6380和6381上执行: slaveof 127.0.0.1 6379<br><img src="/2021/07/22/Redis6/image-20210724153125404.png" alt="image-20210724153125404"></p></li><li><p>在主机上写，在从机上可以读取数据。在从机上写数据报错</p></li><li><p>主机挂掉，重启就行，一切如初</p></li><li><p>从机重启需重设：slaveof 127.0.0.1 6379</p></li><li><p>可以将配置增加到文件中。永久生效。</p></li></ul><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h4><p>切入点问题：</p><ul><li><p>slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p></li><li><p>从机是否可以写？set可否？ </p></li><li><p>主机shutdown后情况如何？从机是上位还是原地待命？</p></li><li><p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p></li><li><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p></li></ul><h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><ul><li><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p></li><li><p>用 <code>slaveof &lt;ip&gt;&lt;port&gt;</code></p></li><li><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p></li><li><p>风险是一旦某个slave宕机，后面的slave都没法备份</p></li><li><p>主机挂了，从机还是从机，无法写数据了</p></li></ul><h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><ul><li><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p></li><li><p>用 slaveof no one  将从机变为主机。</p></li></ul><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul><li><p>Slave启动成功连接到master后会发送一个sync命令</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</p></li><li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</p></li><li><p>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</p></li></ul><p><img src="/2021/07/22/Redis6/image-20210724155322508.png" alt="image-20210724155322508"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p><img src="/2021/07/22/Redis6/image-20210724155349919.png" alt="image-20210724155349919"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>调整为一主二仆模式，6379带着6380、6381<br><img src="/2021/07/22/Redis6/image-20210724155452122.png" alt="image-20210724155452122"></li><li><strong>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</strong></li><li> <strong>配置哨兵,填写内容</strong></li><li><code>sentinel monitor mymaster 127.0.0.1 6379 1</code></li><li>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </li><li>启动哨兵<ul><li>/usr/local/bin</li><li>redis做压测可以用自带的redis-benchmark工具</li><li>执行<code>redis-sentinel /myredis/sentinel.conf</code> </li></ul></li><li>当主机挂掉，从机选举中产生新的主机<ul><li>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</li><li>哪个从机会被选举为主机呢？根据优先级别：slave-priority </li><li>原主机重启后会变为从机。</li></ul></li><li>复制延时<ul><li>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul></li></ul><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p><img src="/2021/07/22/Redis6/image-20210724155832383.png" alt="image-20210724155832383"></p><ul><li><p>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高</p></li><li><p>偏移量是指获得原主机数据最全的</p></li><li><p>每个redis实例启动后都会随机生成一个40位的runid</p></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title">getJedisFromSentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(jedisSentinelPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line"></span><br><span class="line">            JedisPoolConfig jedisPoolConfig =<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">            jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">jedisPoolConfig.setBlockWhenExhausted(<span class="keyword">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line"></span><br><span class="line">jedisSentinelPool=<span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line"><span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十二、Redis6集群"><a href="#十二、Redis6集群" class="headerlink" title="十二、Redis6集群"></a>十二、Redis6集群</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>容量不够，redis如何进行扩容？</p></li><li><p>并发写操作， redis如何分摊？</p></li></ul><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><h3 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h3><ul><li><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p></li><li><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p></li></ul><h2 id="2-配置集群"><a href="#2-配置集群" class="headerlink" title="2. 配置集群"></a>2. 配置集群</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>删除持久化数据：将rdb,aof文件都删除掉。</p><p>制作六个实例，<strong>6379,6380,6381,6389,6390,6391</strong>。包括一主二从及对应的备份主机。</p><p>配置基本信息：</p><ul><li><p>开启daemonize yes</p></li><li><p>Pid文件名字</p></li><li><p>指定端口</p></li><li><p>Log文件名字</p></li><li><p>Dump.rdb名字</p></li><li><p>Appendonly 关掉或者换名字</p></li></ul><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Redis cluster配置修改：</p><p>cluster-enabled yes  打开集群模式</p><p>cluster-config-file nodes-6379.conf 设定节点配置文件名</p><p>cluster-node-timeout 15000  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include /home/bigdata/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line">dbfilename &quot;dump6379.rdb&quot;</span><br><span class="line">dir &quot;/home/bigdata/redis_cluster&quot;</span><br><span class="line">logfile &quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><p>修改好redis6379.conf文件，拷贝多个redis.conf文件<br><img src="/2021/07/22/Redis6/image-20210724160651124.png" alt="image-20210724160651124"></p><p>修改另外的五个文件<br>查找替换使用：:%s/6379/6380 </p><hr><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动6个redis服务</p><p><img src="/2021/07/22/Redis6/image-20210724160837553.png" alt="image-20210724160837553"></p><p>将六个节点合成一个集群</p><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。<br><img src="/2021/07/22/Redis6/image-20210724161017207.png" alt="image-20210724161017207"></p><p>组合：</p><p>cd /opt/redis-6.2.1/src</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</span><br></pre></td></tr></table></figure><p>此处不要用127.0.0.1， 请用真实IP地址</p><p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>普通方式登录</p><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p><p>  <strong>-c</strong> <strong>采用集群策略连接，设置数据会自动切换到相应的写主机</strong></p><p><img src="/2021/07/22/Redis6/image-20210724161251072.png" alt="image-20210724161251072"></p><p>通过 cluster nodes 命令查看集群信息<br><img src="/2021/07/22/Redis6/image-20210724161315326.png" alt="image-20210724161315326"></p><p><strong>redis cluster</strong> <strong>如何分配这六个节点?</strong></p><p>一个集群至少要有三个主节点。</p><p>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><p><strong>什么是slots</strong></p><p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， </p><p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p><hr><p><strong>在集群中录入值</strong></p><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p><p>redis-cli客户端提供了 –c 参数实现自动重定向。</p><p>如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个slot下的键值，是不能使用mget,mset等多键操作。<br><img src="/2021/07/22/Redis6/image-20210724161617057.png" alt="image-20210724161617057"></p><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。<br><img src="/2021/07/22/Redis6/image-20210724161629056.png" alt="image-20210724161629056"></p><hr><p><strong>查询集群中的值</strong></p><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。<br><img src="/2021/07/22/Redis6/image-20210724161709591.png" alt="image-20210724161709591"></count></slot></p><hr><p><strong>故障恢复</strong></p><p>如果主节点下线？从节点能否自动升为主节点？注意：15秒超时<br><img src="/2021/07/22/Redis6/image-20210724161758060.png" alt="image-20210724161758060"></p><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h2 id="3-集群的Jedis开发"><a href="#3-集群的Jedis开发" class="headerlink" title="3. 集群的Jedis开发"></a>3. 集群的Jedis开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-评价"><a href="#4-评价" class="headerlink" title="4. 评价"></a>4. 评价</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>实现扩容</p></li><li><p>分摊压力</p></li><li><p>无中心配置相对简单</p></li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li><p>多键操作是不被支持的 </p></li><li><p>多键的Redis事务是不被支持的。lua脚本不被支持</p></li><li><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p></li></ul><h1 id="十三、Redis6应用问题解决"><a href="#十三、Redis6应用问题解决" class="headerlink" title="十三、Redis6应用问题解决"></a>十三、Redis6应用问题解决</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p><img src="/2021/07/22/Redis6/image-20210724162127252.png" alt="image-20210724162127252"></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决方案：</p><ol><li> <strong>对空值缓存：</strong></li></ol><ul><li>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li></ul><ol start="2"><li><p><strong>设置可访问的名单（白名单）：</strong></p><ul><li>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</li></ul></li><li><p> <strong>采用布隆过滤器</strong>：</p></li></ol><ul><li>(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</li><li>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</li><li>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</li></ul><p>4。 <strong>进行实时监控：</strong></p><ul><li>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li></ul><h2 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><img src="/2021/07/22/Redis6/image-20210724162346641.png" alt="image-20210724162346641"></p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>解决问题：</p><ol><li><p>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p></li><li><p>实时调整：现场监控哪些数据热门，实时调整key的过期时长</p></li><li><p>使用锁：</p><ol><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li><li>  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li> 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ol></li></ol><p><img src="/2021/07/22/Redis6/image-20210724162525787.png" alt="image-20210724162525787"></p><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p><p>正常访问<br><img src="/2021/07/22/Redis6/image-20210724162608772.png" alt="image-20210724162608772"></p><p>缓存失效瞬间<br><img src="/2021/07/22/Redis6/image-20210724162627340.png" alt="image-20210724162627340"></p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><p>解决方案：</p><ol><li><p><strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p></li><li><p> <strong>使用锁或队列：</strong></p></li></ol><ul><li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li></ul><ol start="3"><li><p><strong>设置过期标志更新缓存：</strong></p><ul><li>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li></ul></li><li><p> <strong>将缓存失效时间分散开：</strong></p></li></ol><ul><li>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li></ul><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper</p></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高</p></li></ol><p>这里，我们就基于redis实现分布式锁。</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>redis:命令</p><p># set sku:1:info “OK” NX PX 10000</p><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p><p><img src="/2021/07/22/Redis6/image-20210724162844897.png" alt="image-20210724162844897"></p><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Redis:set num 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setne</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务集群，通过网关压力测试：<br><code>ab -n 1000 -c 100 http://192.168.140.1:8080/test/testLock</code><br><img src="/2021/07/22/Redis6/image-20210724163028906.png" alt="image-20210724163028906"></p><p>查看redis中num的值：<br><img src="/2021/07/22/Redis6/image-20210724163053387.png" alt="image-20210724163053387"></p><p>基本实现。</p><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p>解决：设置过期时间，自动释放锁。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h4><p>设置过期时间有两种方式：</p><ol><li><p>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</p></li><li><p>在set时指定过期时间（推荐）</p></li></ol><p><img src="/2021/07/22/Redis6/image-20210724163216881.png" alt="image-20210724163216881"></p><p>设置过期时间：<br><img src="/2021/07/22/Redis6/image-20210724163237082.png" alt="image-20210724163237082"></p><p>压力测试肯定也没有问题。自行测试</p><p>问题：可能会释放其他服务器的锁。</p><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p></li><li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p></li><li><p>index3获取到锁，执行业务逻辑</p></li><li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p></li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><h4 id="UUID防误删"><a href="#UUID防误删" class="headerlink" title="UUID防误删"></a>UUID防误删</h4><p><img src="/2021/07/22/Redis6/image-20210724163336647.png" alt="image-20210724163336647"></p><p><img src="/2021/07/22/Redis6/image-20210724163342740.png" alt="image-20210724163342740"></p><p>问题：删除操作缺乏原子性。</p><p>场景：</p><ol><li><p>index1执行删除时，查询到的lock值确实和uuid相等<br>uuid=v1<br>set(lock,uuid)；<br><img src="/2021/07/22/Redis6/image-20210724163440362.png" alt="image-20210724163440362"></p></li><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放<br>在redis中没有了lock，没有了锁。<br><img src="/2021/07/22/Redis6/image-20210724163452545.png" alt="image-20210724163452545"></p></li><li><p>index2获取了lock<br>index2线程获取到了cpu的资源，开始执行方法<br>uuid=v2<br>set(lock,uuid)；</p></li><li><p>index1执行删除，此时会把index2的lock删除<br>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行<br><img src="/2021/07/22/Redis6/image-20210724163532764.png" alt="image-20210724163532764"><br>删除的index2的锁！</p></li></ol><h4 id="LUA脚本保证删除的原子性"><a href="#LUA脚本保证删除的原子性" class="headerlink" title="LUA脚本保证删除的原子性"></a>LUA脚本保证删除的原子性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLockLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">    String skuId = <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">    String locKey = <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取锁</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">    <span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">    <span class="comment">// 如果true</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">        <span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">        <span class="comment">/*使用lua脚本来锁*/</span></span><br><span class="line">        <span class="comment">// 定义lua 脚本</span></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用redis执行lua执行</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        <span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">        <span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">        <span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua 脚本详解：<br><img src="/2021/07/22/Redis6/image-20210724163702282.png" alt="image-20210724163702282"></p><p>项目中正确使用：</p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String locKey =&quot;lock:&quot;+skuId; // 锁住的是每个商品的数据</span><br><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/22/Redis6/image-20210724163733577.png" alt="image-20210724163733577"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span></span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">Boolean lock = <span class="keyword">this</span>.redisTemplate.opsForValue()</span><br><span class="line">      .setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>使用lua释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 释放锁 del</span></span><br><span class="line">String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 设置lua脚本返回的数据类型</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置lua脚本返回类型为Long</span></span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br></pre></td></tr></table></figure><p>重试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">testLock();</span><br></pre></td></tr></table></figure><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p><p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p><p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p><p>- 加锁和解锁必须具有原子性。</p><h1 id="十四、Redis6-0新功能"><a href="#十四、Redis6-0新功能" class="headerlink" title="十四、Redis6.0新功能"></a>十四、Redis6.0新功能</h1><h2 id="1-ACL"><a href="#1-ACL" class="headerlink" title="1. ACL"></a>1. ACL</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p><p>（1）接入权限:用户名和密码 </p><p>（2）可以执行的命令 </p><p>（3）可以操作的 KEY</p><p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><p>1、使用acl list命令展现用户权限列表</p><p>（1）数据说明<br><img src="/2021/07/22/Redis6/image-20210724164048831.png" alt="image-20210724164048831"></p><p>2、使用acl cat命令</p><p>（1）查看添加权限指令类别<br><img src="/2021/07/22/Redis6/image-20210724164107855.png" alt="image-20210724164107855"></p><p>（2）加参数类型名可以查看类型下具体命令<br><img src="/2021/07/22/Redis6/image-20210724164124540.png" alt="image-20210724164124540"></p><p>3、使用acl whoami命令查看当前用户<br><img src="/2021/07/22/Redis6/image-20210724164140268.png" alt="image-20210724164140268"></p><p>4、使用aclsetuser命令创建和编辑用户ACL</p><p>（1）ACL规则</p><p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><p>  ACL规则  ：</p><table><thead><tr><th>类型</th><th>参数</th><th></th></tr></thead><tbody><tr><td>启动和禁用用户</td><td>on</td><td>激活某用户账号</td></tr><tr><td></td><td>off</td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td></tr><tr><td>权限的添加删除</td><td><code>+&lt;command&gt;</code></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td></td><td><code>-&lt;command&gt;</code></td><td>从用户可执行指令列表移除指令</td></tr><tr><td></td><td><code>+@&lt;category&gt;</code></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td></tr><tr><td></td><td><code>-@&lt;actegory&gt;  </code></td><td>从用户可调用指令中移除类别</td></tr><tr><td></td><td><code>allcommands</code></td><td>+@all的别名</td></tr><tr><td></td><td><code>nocommand</code></td><td>-@all的别名</td></tr><tr><td>可操作键的添加或删除</td><td><code>~&lt;pattern&gt;</code></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限</p><p>acl setuser user1<br><img src="/2021/07/22/Redis6/image-20210724164851893.png" alt="image-20210724164851893"></p><p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p><p>（3）设置有用户名、密码、ACL权限、并启用的用户</p><p>acl setuser user2 on &gt;password ~cached:* +get|<br><img src="/2021/07/22/Redis6/image-20210724164912130.png" alt="image-20210724164912130"></p><p>(4)切换用户，验证权限<br><img src="/2021/07/22/Redis6/image-20210724164933886.png" alt="image-20210724164933886"></p><h2 id="2-IO多线程"><a href="#2-IO多线程" class="headerlink" title="2. IO多线程"></a>2. IO多线程</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>Redis6终于支撑多线程了，告别单线程了吗？</p><p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:<br><img src="/2021/07/22/Redis6/image-20210724165036380.png" alt="image-20210724165036380"></p><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p><p>io-threads-do-reads yes </p><p>io-threads 4</p><h2 id="3-工具支持Cluster"><a href="#3-工具支持Cluster" class="headerlink" title="3. 工具支持Cluster"></a>3. 工具支持Cluster</h2><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p><p><img src="/2021/07/22/Redis6/image-20210724165122703.png" alt="image-20210724165122703"></p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><p>Redis6新功能还有：</p><p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p><p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p><p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p><p>4、Modules API</p><p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;NoSQL数据库简介&lt;/li&gt;
&lt;li&gt;Redis6概述和安装&lt;/li&gt;
&lt;li&gt;常用五大数据类型&lt;/li&gt;
&lt;li&gt;Redis6配置文件详解&lt;/li&gt;
&lt;li&gt;Redis6的发布和订阅&lt;/li&gt;
&lt;li&gt;Redis6新数据类型&lt;/li&gt;
&lt;li&gt;Jedis操作</summary>
      
    
    
    
    <category term="工具" scheme="https://stary1999.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Redis" scheme="https://stary1999.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://stary1999.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM入门</title>
    <link href="https://stary1999.github.io/2021/07/22/JVM/"/>
    <id>https://stary1999.github.io/2021/07/22/JVM/</id>
    <published>2021-07-22T01:25:34.000Z</published>
    <updated>2021-07-27T11:55:02.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、jvm概述"><a href="#一、jvm概述" class="headerlink" title="一、jvm概述"></a>一、jvm概述</h1><p>jvm与java体系结构</p><ul><li>前言</li><li>面向人群及参考书目</li><li>java及jvm简介</li><li>java发展的重大事件</li><li>虚拟机与java虚拟机</li><li>jvm的整体结构</li><li>java代码执行流程</li><li>jvm发架构模型</li><li>jvm的生命周期</li><li>jvm的发展历程</li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>问题：</p><ul><li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM==（ OOM，全称“Out Of Memory”==，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。）</li><li>想解决线上jvm GC问题，但却无从下手</li><li>新项目上线，对各种jvm参数设置不了解</li><li>面试：实际项目中如何调优jvm参数，如何解决GC、OOM等问题</li></ul><p>应用程序–》框架–》java API–》jvm</p><p>架构师：</p><ul><li>应该如何让系统更快</li><li>如何避免系统出现瓶颈</li></ul><p>高年薪：</p><ul><li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li><li>根据业务场景和需求，决定技术方向，做技术选型</li><li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li><li>解决各类潜在系统风险，核心功能的架构与代码编写</li><li>分析系统瓶颈。解决各种疑难杂症，性能调优等</li></ul><p>GC（Garbage Collection）：</p><ul><li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构，工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是java工程师进阶的必备技能。</li></ul><h2 id="2-面向人群"><a href="#2-面向人群" class="headerlink" title="2.面向人群"></a>2.面向人群</h2><ul><li>拥有一定开发经验的java平台开发人员</li><li>软件设计师、架构师</li><li>系统调优人员</li><li>有一定的java编程基础并希望进一步理解java的程序员</li><li>虚拟机爱好者，jvm实践者</li></ul><p>参考书目：</p><p>《The java Virtual Machine Specification》</p><p>中文版：《深入理解Java虚拟机》第三版</p><h2 id="3-java及jvm简介"><a href="#3-java及jvm简介" class="headerlink" title="3.java及jvm简介"></a>3.java及jvm简介</h2><h4 id="java生态圈"><a href="#java生态圈" class="headerlink" title="java生态圈"></a>java生态圈</h4><ul><li>平台</li><li>文化</li><li>社区</li></ul><h4 id="跨平台的语言：java"><a href="#跨平台的语言：java" class="headerlink" title="跨平台的语言：java"></a>跨平台的语言：java</h4><p>java程序–》字节码文件–》win版JVM、Linux版JVM、Mac版JVM</p><p>java程序可以在多个平台上运行，“一次编译，四处运行”</p><h4 id="跨语言的平台：JVM"><a href="#跨语言的平台：JVM" class="headerlink" title="跨语言的平台：JVM"></a>跨语言的平台：JVM</h4><p>不同种类的语言，编译成字节码文件后，都可以在JVM上运行</p><p>字节码：</p><ul><li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说，任何能在JVM平台上执行的字节码格式都是一样的。所以应该统称为：JVM字节码</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行</li><li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了java虚拟机指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。</li></ul><p>多语言混合编程：</p><ul><li>java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向</li><li>例如：一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己的语言的原生API一样方便，因为他们最终都运行在一个虚拟机之上。</li><li>对这些运行与java虚拟机之上、java之外的语言，来自系统级的、底层的支持正在快速增强，以JSR-292为核心的一系列项目和功能改进，推动Java虚拟机从“java语言的虚拟机”向“多语言虚拟机”的方向发展</li></ul><h2 id="4-java发展的重大事件"><a href="#4-java发展的重大事件" class="headerlink" title="4.java发展的重大事件"></a>4.java发展的重大事件</h2><ul><li>1990年，在Sun计算机公司中，由Patrick Naughton、 MikeSheridan及James Gosling 领导的小组Green Team,开发出的新的程序语言，命名为0ak,后期命名为Java</li><li>1995年，Sun正式发 布Java和HotJava产品，Java 首次公开亮相。</li><li>1996年1月23日Sun Microsystems发布 了JDK 1.0。</li><li>1998年，JDK 1.2版本发布。同时，Sun发布了JSP/Servlet、 EJB规范，以及将Java分成了J2EE、 J2SE和J2ME。这 表明了Java开始向企业、 桌面应用和移动设备应用3大领域挺进。</li><li>2000年，JDK 1.3发布，Java HotSpot Virtual Machinei正式发布，成为Java的默认虚拟机。</li><li>2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台。</li><li>2003年年底，Java平台的Scalai正式发布，同年Groovy也加入了Java阵营。</li><li>2004年，JDK 1.5发布。同时JDK 1.5改 名为JavaSE 5.0。</li><li>2006年，JDK 6发布。同年，Java开源并建立了OpenJDK。 顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li><li>2007年，Java平台迎来了新伙伴Clojure。</li><li>2008年，Oracle收购了BEA, 得到了JRockit 虚拟机。</li><li>2009年，Twitter宜布把后台大部分程序从Ruby迁移到Scala,这是Java平台的又一次大规模应用。.</li><li>2010年，oracle收购了Sun,获得Java商标和最具价值的Hotspot虚拟机。此时，0racle拥有市场占用率最高的两款虚拟机Hotspot和JRockit,并计划在未来对它们进行整合: HotRockit</li><li>2011年，JDK7发布。在JDK 1.7u4中，正式启用了新的垃圾回收器G1。</li><li>2014年三月，JDK8发布。历史性版本。</li><li>2017年，JDK9发布。将G1设置为默认GC，替代CHS</li><li>同年，IBM的J9开源，形成了现在的open J9社区</li><li>2018年，Android的Java侵权案判决，Google赔偿oracleit88亿美元</li><li>同年，Oracle宣告JavaEE成为历史名词，JDBC、 JMS、Servlet赠了Eclipse基金会</li><li>同年，JDK11发布， LTS版木的JDK, 发布革命性的zGC,调整JDK授权许可</li><li>2019年，JDK12发布， 加入RedHat领导开发的Shenandoah GC<br>A</li></ul><h2 id="5-虚拟机与java虚拟机"><a href="#5-虚拟机与java虚拟机" class="headerlink" title="5.虚拟机与java虚拟机"></a>5.虚拟机与java虚拟机</h2><ul><li>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机，它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机<ul><li>Visual Box，VMware就属于系统虚拟机，他们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台</li><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令</li></ul></li><li>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中</li><li>JVM是运行在操作系统之上的，它与硬件没有直接的交互</li></ul><h2 id="6-jvm的整体结构"><a href="#6-jvm的整体结构" class="headerlink" title="6.jvm的整体结构"></a>6.jvm的整体结构</h2><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一</li><li>它采用解释器与即时编译器并存的架构</li><li>在今天，Java程序的运行性能已经渐渐达到了可以和C、C++一较高下的地步</li></ul><p><img src="/2021/07/22/JVM/image-20210722191927638.png" alt="image-20210722191927638"></p><h2 id="7-java代码执行流程"><a href="#7-java代码执行流程" class="headerlink" title="7.java代码执行流程"></a>7.java代码执行流程</h2><ul><li>java源码</li><li>java编译器<ul><li>词法分析</li><li>语法分析</li><li>语法、抽象语法树</li><li>语义分析</li><li>注解抽象语法树</li><li>字节码生成器</li></ul></li><li>字节码</li><li>Java虚拟机<ul><li>类加载器</li><li>字节码校验器</li><li>翻译字节码</li><li>JIT编译器（编译执行）</li></ul></li><li>操作系统</li></ul><p>注意：</p><ul><li>java编译器编译过程中，任何一个节点执行失败就会造成编译失败</li><li>虽然各个平台的Java虚拟机内部实现细节不尽相同，但是他们共同执行的字节码内容却是一样的</li><li>JVM的主要任务就是负责将字节码装载到其内部，解释、编译为对应平台上的机器指令。即：汇编语言，执行。</li><li>Java虚拟机使用类加载器（Class Loader）装载class文件</li><li>类加载完成之后，会进行字节码校验，字节码校验通过之后，JVM解释器会把字节码翻译成机器码，即汇编语言，交由操作系统执行</li><li>但不是所有的代码都是解释执行的，JVM对此做了优化，比如，以HotSpot虚拟机来说，它本身提供了JIT（Just In Time）</li></ul><h2 id="8-jvm发架构模型"><a href="#8-jvm发架构模型" class="headerlink" title="8.jvm发架构模型"></a>8.jvm发架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集结构则是基于寄存器的指令集架构</p><p>具体来说，这两种架构之间的区别：</p><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题，使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令。其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li><li>指令集架构则完全依赖硬件，可移植差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ul></li></ul><p>举例，同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p>基于栈式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istor_l</span><br><span class="line">iconst_3  <span class="comment">//常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2、3出栈，执行相加</span></span><br><span class="line">istore_0<span class="comment">//结果5入栈</span></span><br></pre></td></tr></table></figure></li><li><p>基于寄存器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为2</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值+3</span></span><br></pre></td></tr></table></figure></li></ul><p>总结</p><ul><li>==由于跨平台性的设计，Java的指令都是根据栈来设计的==。不同平台的CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样功能需要更多的指令。</li></ul><p>栈：</p><ul><li>跨平台性能，指令集小，指令多，执行性能比寄存器差</li></ul><h2 id="9-jvm的生命周期"><a href="#9-jvm的生命周期" class="headerlink" title="9.jvm的生命周期"></a>9.jvm的生命周期</h2><p>虚拟机的启动：</p><ul><li>Java虚拟机的启动是通过引导类加载器（BootStrap class loader）创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的</li></ul><p>虚拟机的执行</p><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时它才运行，程序结束时他就停止</li><li>==执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程==</li></ul><h2 id="10-jvm的发展历程"><a href="#10-jvm的发展历程" class="headerlink" title="10.jvm的发展历程"></a>10.jvm的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为Sun Classic VM的Java虚拟机，它同时也是世界上第- -款商用Java虚拟机，JDK1 . 4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在hotspot内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决 上一个虚拟机问题，jdk1.2时, sun提供了此虚拟机。</li><li>Exact Memory Management: 准确式内存管理<ul><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li></ul></li><li>具备现代高性能虚拟机的雏形<ul><li>热点探测</li><li>编译器与解释器混合工.作模式</li><li>只在Solaris平台短暂使用， 其他平台上还是classic vm .</li><li>英雄气短，终被Hotspot虚拟机替换</li></ul></li></ul><h3 id="SUN公司的HotSpot-VM"><a href="#SUN公司的HotSpot-VM" class="headerlink" title="SUN公司的HotSpot VM"></a>SUN公司的HotSpot VM</h3><ul><li>HotSpot历史<ul><li>最初由一家名为”Longview tchnologies”的小公司设计</li><li>1997年, 此公司被Sun收购:;2009年, Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VIM成为默认虚拟机</li></ul></li><li>目前Hotspot占有绝对的市场地位，称霸武林。<ul><li>不管是现在仍在广泛使用的JDK6,还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和OpenJDK的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是HotSpot,相关机制也主要是指HotSpot的GC机制。(比如其他两个商用虚拟机都没有方法区的概念)</li></ul></li><li>从服务器、桌而到移动端、嵌入式都有应用。</li><li>名称中的HotSpot指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上:替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="BEA的JRockit"><a href="#BEA的JRockit" class="headerlink" title="BEA的JRockit"></a>BEA的JRockit</h3><ul><li><p>专注于服务器端应用</p><ul><li>它可以不太关注程序启动速度，囚此JRockit内部不包含解析器实现， 全部代码<br>都靠即时编译器编译后执行。|</li></ul></li><li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p><ul><li>使用JRockit产品，客户已经体验到了显著的性能提高(一些超过了70号)和硬件成本的减少(达50%)。</li></ul></li><li><p>优势:全面的Java运行时解决方案组合</p><ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或 微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 </li><li>MissionContro1服务套件，它是一组以极低的开销来监控、管理和分析生产 环境中的应用程序的L具。 </li></ul></li><li><p>2008年，BEA被Oracle收购，</p></li><li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在 HotSpot的基础上,移JRockit的优秀特性。 </p></li><li><p>高斯林:目前就职于谷歌，研究人工智能和水下机器人 </p></li></ul><h3 id="KVM和ICDC-CLDC-Hotspot"><a href="#KVM和ICDC-CLDC-Hotspot" class="headerlink" title="KVM和ICDC/CLDC Hotspot"></a>KVM和ICDC/CLDC Hotspot</h3><ul><li>Oracle在Java ME产品线上:的两款虚拟机为: CDC/CLDC HotSpot Implementation VM</li><li>KVM (Kilobyte) 是CLDC-HI早期产品</li><li>目前移动领域地位尴尬，智能手机被Android和ios.二分天下。</li><li>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场<ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li><li>所有的虚拟机的原则:一次编译,到处运行。</li></ul><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul><li>前面三大“高性能Java虚拟机”使用在通用硬件平台上</li><li>这里Azul VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机<ul><li>高性能Java虚拟机中的战斗机。</li></ul></li><li>Azul VM是Azul Systems公司在Hotspot基础上进行大量改进，运行于 Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li><li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的C时间的垃圾收集器、传有硬件优化的线程调度等优秀特性。</li><li>2010年，Azul systems公司开始从硬件转向软件， 发布了自己的zing JVM，可以在通用x86平台 上提供接近于Vega系统的特性。</li></ul><h3 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h3><ul><li><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司， 覆盖云计算，金融、物流、电商等众多领城，需要解决高并发、 高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p>基于OpenJDK开发了自己的定制版本AlibabaJDK, 简称AJDK. 是整个阿里Java体<br>系的基石。</p></li><li><p>基于OpenfDK HotSpot VM发布的国内第一 个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>创新的GCIH (GC invisible heap ) 技术实现了off-heap ,即将生命周期较长的Java对象Wheap中移到heap之外，并ALGC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JVM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场录的ZenGC</li></ul></li><li><p>taobao vm应用在阿里产品上:性能高， 硬件严重依赖intel的cpu, 损失了兼容性,但<br>提高了性能</p><ul><li>目前已经在淘宝、天猫上线， 把oracle 官方JVM版本全部替换了。</li></ul></li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM:"></a>Dalvik VM:</h3><ul><li><p>谷歌开发的，应用于FAndroid系统，并在Android2.2中提供了JIT, 发展迅猛。</p></li><li><p>Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循Java虚拟机规范</p></li><li><p>不能直接执行Java 的Class文件</p></li><li><p>基于寄存器架构,不是jvm的栈架构。</p></li><li><p>执行的是编译以后的dex (Dalvik Executable) 文件。执行效率比较高。</p><ul><li>它执行的dex (Dalvik Executable)文件可以通过Class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul></li><li><p>Android 5.0使用支持提前编译(Ahead Of Time Compilation, AOT)的ART VM替换Dalvik WM。</p></li></ul><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul><li><p>2018年4月，Oracle Labs公开了Graal VM,号称”Run Programs Faster Anywhere”,勃勃野心。与1995年java的” write once, run anywhere” 遏相呼应。</p></li><li><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”<br>的运行平台使用。语言包括: Java、 Scala, Groovy, Kotlin; C. C++.JavaScript、Ruby、 Python、 R等</p></li><li><p>支持不同语言中混用对方的接口和对象， 支持这些语言使用已经编写好的木地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p>如果说HotSpot有一天 真的被取代，Graal VM希 望最大。但是Java的软件生态没有丝毫变化。</p></li></ul><h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><ul><li>内存结构概述</li><li>类加载器与类的加载过程</li><li>类加载器分类</li><li>ClassLoader的使用说明</li><li>双亲委派机制</li><li>其他</li></ul><h2 id="1-内存结构概述"><a href="#1-内存结构概述" class="headerlink" title="1.内存结构概述"></a>1.内存结构概述</h2><p><img src="/2021/07/22/JVM/image-20210722112228303.png" alt="image-20210722112228303"></p><p><img src="/2021/07/22/JVM/image-20210722112240202.png" alt="image-20210722112240202"></p><p>如果自己动手写一个java虚拟机，主要考虑结构：类加载器、执行引擎</p><h2 id="2-类加载器与类的加载过程"><a href="#2-类加载器与类的加载过程" class="headerlink" title="2.类加载器与类的加载过程"></a>2.类加载器与类的加载过程</h2><h3 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h3><p><img src="/2021/07/22/JVM/image-20210722112816870.png" alt="image-20210722112816870"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件所在问价开头有特定的文件标识</li><li>ClassLoader只负责class文件的加载，至于文件是否可运行，则由Execution Engine决定</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li></ul><h3 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h3><ol><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</li><li>class file加载到jvm中，被称为DNA元数据模板，放在方法区</li><li>在.class文件–》JVM–》最终成为元数据模板，此过程就需要一个运输工具（类装载器Class Loader），扮演一个快递员的角色</li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li>加载</li><li>链接<ul><li>验证</li><li>准备</li><li>解析</li></ul></li><li>初始化</li></ul><p><img src="/2021/07/22/JVM/image-20210722113355272.png" alt="image-20210722113355272"></p><p>加载：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li><li>加载.class文件的方式：<ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础、</li><li>运行时计算生成，使用得最多的是：动态代理技术</li><li>由其他文件生成，典型场景：jsp应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul></li></ol><p>验证：</p><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul><p>准备：</p><ul><li>为类变量分配内存并设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译时就会自动分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li></ul><p>解析：</p><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上没解析操作往往会伴随着jvm在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_indo、CONSTANT_Methodref_info等。</li></ul><h2 id="3-类加载器的分类"><a href="#3-类加载器的分类" class="headerlink" title="3.类加载器的分类"></a>3.类加载器的分类</h2><ul><li>jvm支持两种类型的类加载器，分别为引导类加载器（Bootstrap Classloader）和自定义类加载器（User-Defined Classloader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范将所有派生于抽象类Classloader的类加载器都划分为自定义类加载器</li><li>程序中常见的类加载器只有三个：Bootstrap Classloader、Extension Classloader、System Classloader。都是继承于Classloader。</li></ul><p><img src="/2021/07/22/JVM/image-20210722094252090.png" alt="image-20210722094252090"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机自带的加载器</p><ul><li>启动类加载器（引导类加载器，Bootstrap Classloader）<ul><li>这个类加载使用c/c++语言实现，嵌套在jvm内部</li><li>它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar、resource.jar或sun.boot.class.path路径下的内容），用于提供自身需要的类</li><li>并不继承自java.lang.Classloader，没有父加载器</li><li>加载拓展类和程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun、等开头的类</li></ul></li><li>拓展类加载器（Extension Classloader)<ul><li>java语言编写，由sun.misc.Launcher$ExtClassloader实现</li><li>派生与Classloader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（拓展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载。</li></ul></li><li>应用程序类加载器（系统类加载器，AppClassloader）<ul><li>java语言编写，由sun.misc.launcher$AppClassloader实现</li><li>派生与ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性：java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载</li><li>通过Classloader#getSystemClassloader（）方法可以获取到该类加载器</li></ul></li></ul><p>用户自定义类加载器</p><ul><li>在java的日常应用程序开发中，类加载几乎是由上述三种类加载器互相配合执行的，在必要时，用户可以自定义类加载器，来定制类的加载方式</li><li>原因：<ul><li>隔离加载类</li><li>修改类的加载方式</li><li>扩展加载源</li><li>放置源码泄露</li></ul></li><li>实现<ol><li>继承抽象类java.lang.ClassLoader类</li><li>在jdk1.2之前，在自定义类加载器时，总会去继承Classloader类并重写loadClass（）方法，从而实现自定义的类加载类。在jdk1.2之后，建议吧自定义的类加载逻辑写在findClass（）方法中</li><li>在编写自定义类加载类时，如果没有太多过于复杂的需求，可以直接继承URLClassloader类，避免自己编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ol></li></ul><h2 id="4-ClassLoader的使用说明"><a href="#4-ClassLoader的使用说明" class="headerlink" title="4.ClassLoader的使用说明"></a>4.ClassLoader的使用说明</h2><p>ClassLoader：一个抽象类，其后所有的类加载器都继承自Classloader（不包括启动类加载器Bootstrap ClassLoader）</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent（）</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass（String name)</td><td>加载名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>findClass(String name)</td><td>查找名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>findLoadClass(String name)</td><td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>defineClass(String name,byte[] b,int off,int len)</td><td>把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例</td></tr><tr><td>resloveClass(Class&lt;?&gt; c)</td><td>连接指定的一个java类</td></tr></tbody></table><p>sun.misc,Launcher是一个java虚拟机的入口应用</p><h3 id="获取Classloader"><a href="#获取Classloader" class="headerlink" title="获取Classloader"></a>获取Classloader</h3><ol><li>获取当前类的ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ol><h2 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.双亲委派机制</h2><p>java虚拟机对class文件采用的是按需加载的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式</p><ul><li><p>工作原理</p><ol><li>如果一个类加载器收到了类加载的请求，它不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，则成功返回，否则，其子类加载器尝试自己去加载</li></ol><p><img src="/2021/07/22/JVM/image-20210722110502837.png" alt="image-20210722110502837"></p></li><li><p>优势</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ul></li></ul><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类，这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><ul><li>在JVM中表示两个class对象是否为同一个了存在的两个必要条件：<ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的ClassLoader必须相同</li></ul></li><li>在JVM中，即使两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</li><li>对类加载器的引用：JVM必须要知道一个类型是由启动加载器加载还是由用户类加载器加载的。如果一个类型是由用户加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li><li>类的主动使用和被动使用：<ul><li>主动使用：<ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>java虚拟机启动时被标明为启动类的类</li><li>jdk7开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果<br>REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol></li><li>除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化</li></ul></li></ul><h1 id="三、运行时数据区概述及线程"><a href="#三、运行时数据区概述及线程" class="headerlink" title="三、运行时数据区概述及线程"></a>三、运行时数据区概述及线程</h1><ul><li>概述</li><li>线程</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2021/07/22/JVM/image-20210723135417340.png" alt="image-20210723135417340"></p><p><img src="/2021/07/22/JVM/image-20210723135453262.png" alt="image-20210723135453262"></p><ul><li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对内存的划分方式和管理机制存在着部分差异。</li></ul><p><img src="/2021/07/22/JVM/image-20210723135831346.png" alt="image-20210723135831346"></p><p><img src="/2021/07/22/JVM/image-20210723135839778.png" alt="image-20210723135839778"></p><ul><li>java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而自动创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li><li>下图中，灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ul><p><img src="/2021/07/22/JVM/image-20210723140233739.png" alt="image-20210723140233739"></p><p>关于线程间共享的说明：</p><p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的部分：运行时环境。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。<ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul></li><li>操作系统负责所有的线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</li></ul><p>守护线程、普通线程：</p><ul><li>如果使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用pubic static void main（String[] args)的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-word”的垃圾收集，线程收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul></li></ul><h1 id="四、程序计数器（PC寄存器）"><a href="#四、程序计数器（PC寄存器）" class="headerlink" title="四、程序计数器（PC寄存器）"></a>四、程序计数器（PC寄存器）</h1><ul><li>PC Register 介绍</li><li>举例说明</li><li>两个常见问题</li></ul><h2 id="1-PC-Register-介绍"><a href="#1-PC-Register-介绍" class="headerlink" title="1. PC Register 介绍"></a>1. PC Register 介绍</h2><ul><li>JVm中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能运行。</li><li>这里，并非是广义上所指的物理寄存器，将之称为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中PC寄存器是对物理PC寄存器的一种抽象模拟。</li><li>作用：<ul><li>PC寄存器用来存储向下一条指令的地址，也即将要执行的指令的代码。由执行引擎读取下一条指令。</li></ul></li><li>说明：<ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有他自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果实在执行native方法，则是未知的值（underfined）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域</li></ul></li></ul><h2 id="2-举例说明"><a href="#2-举例说明" class="headerlink" title="2. 举例说明"></a>2. 举例说明</h2><p><img src="/2021/07/22/JVM/image-20210723142904937.png" alt="image-20210723142904937"></p><p><img src="/2021/07/22/JVM/image-20210723163819844.png" alt="image-20210723163819844"></p><h2 id="3-两个常见问题"><a href="#3-两个常见问题" class="headerlink" title="3. 两个常见问题"></a>3. 两个常见问题</h2><ul><li><p>使用PC寄存器存储字节码指令地址有什么用？</p></li><li><p>为什么使用PC寄存器记录当前线程的执行地址？</p><ul><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li></ul></li><li><p>PC寄存器为什么会被设定为线程私有？</p><ul><li>所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复。为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法便是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复。如何保证分毫不差？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ul></li><li><p>CPU时间片</p><ul><li>CPU时间片，即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片</li><li>在宏观上，PC上可以打开多个应用程序，每个程序并行不悖，同时运行。</li><li>在微观上，，由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法是引入时间片，每个程序轮流执行。</li></ul></li><li><p>==并行和并发==</p><ul><li>并行：vs串行</li><li>并发：cpu快速切换以达到模拟并行的效果</li></ul></li></ul><h1 id="五、虚拟机栈"><a href="#五、虚拟机栈" class="headerlink" title="五、虚拟机栈"></a>五、虚拟机栈</h1><ul><li>1.虚拟机栈概述</li><li>2.栈的存储单位</li><li>3.局部变量表</li><li>4.操作数栈</li><li>5.代码追踪</li><li>6.栈顶缓存技术</li><li>7.动态链接</li><li>8.方法的调用：解析与分派</li><li>9.方法返回地址</li><li>10.一些附加信息</li><li>11.栈的相关面试题</li></ul><h2 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1.虚拟机栈概述"></a>1.虚拟机栈概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</li><li>==优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令==。</li></ul><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul><li>栈是运行时的单位，堆是存储的单位。<ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储问题，即数据怎么放、放在哪。</li></ul></li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li>Java虚拟机栈是什么？<ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</li><li>是线程私有的</li></ul></li><li>生命周期<ul><li>生命周期与线程一致</li></ul></li><li>作用<ul><li>主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址【对象实际存储在堆空间中】、部分结果，并参与方法的调用和返回。</li><li>局部变量：vs成员变量（或属性）</li><li>基本数据变量：vs引用类型变量（类、数组、接口）</li></ul></li><li>特点<ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行：伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾收集的问题<ul><li>==栈可能存在OOM，但是不存在GC==</li></ul></li></ul></li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>面试题：开发中遇到的异常有哪些？</p><p>栈中可能出现的异常：</p><ul><li>Java虚拟机规范允许Java栈的大小是动态的或者固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出一个==StackOverflowError异常==。</li><li>如果Java虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个==OutOfMemoryError异常==</li><li><img src="/2021/07/22/JVM/image-20210723151032215.png" alt="image-20210723151032215"></li></ul></li><li>设置栈内存大小<ul><li>我们可以使用参数-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</li><li><img src="/2021/07/22/JVM/image-20210723151235829.png" alt="image-20210723151235829"></li></ul></li></ul><p><img src="/2021/07/22/JVM/image-20210723182611919.png" alt="image-20210723182611919"></p><p><img src="/2021/07/22/JVM/2021-06-29-hexoInstallAndUse/image-20210723182652414.png" alt="image-20210723182652414"></p><p><img src="/2021/07/22/JVM/image-20210723182728027.png" alt="image-20210723182728027"></p><h2 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2.栈的存储单位"></a>2.栈的存储单位</h2><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><p>复习：</p><ul><li>OOP（Object Oriented Programming）的基本概念：类、对象</li><li>类中的基本结构：field（属性、字段、域）、method</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>JVM直接对Java栈的操作只有两个，就是对栈帧的==压栈==和==出栈==，遵循==“先进后出”/“后进先出”原则==</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为==当前栈帧（Current Frame）==，与当前栈帧对应的方法就是==当前方法（Current Method）==，定义这个方法的类就是==当前类（Current Class)==。</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前帧。</li></ul><p><img src="/2021/07/22/JVM/image-20210723152139975.png" alt="image-20210723152139975"></p><ul><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java方法有两种返回函数的方式，==一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。==</li></ul><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>==局部变量表（Local Variables）==</li><li>==操作数栈（Operand Stack）（或表达式栈）==</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="/2021/07/22/JVM/image-20210723152831789.png" alt="image-20210723152831789"></p><h2 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3.局部变量表"></a>3.局部变量表</h2><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>==定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量==，这些数据类型包括各类基本数据类型、对象引用（Reference)，以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此==不存在数据安全问题==</li><li>==局部变量表所需要的容量大小是在编译期确定下来的==，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>==方法嵌套调用的次数由栈的大小决定==。一般来说，==栈越大，方法嵌套调用次数越多==。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数会减少。</li><li>==局部变量表中的变量只在当前方法调用中有效==。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。==当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。==</li></ul><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><ul><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>局部变量中存放编译器可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量</li><li>在局部变量里，==32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。==<ul><li>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会==按照顺序被复制==到局部变量表中的每一个slot上</li><li>==如果需要访问局部变量中一个64bit的局部变量值，只需要使用前一个索引即可==</li><li>如果当前帧是由构造方法或者实例方法创建的，那么==该对象引用this将会存放在index为0的slot处==，其余的参数按照参数表顺序继续排列</li></ul><p>Slot的重复利用</p><ul><li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</li></ul><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li><li>我们知道类变量表有两次初始化的机会，第一次是在“==准备阶段==”，执行系统初始化，对类变量设置零值，来一次则是在“==初始化==”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</li><li><img src="/2021/07/22/JVM/image-20210723155347082.png" alt="image-20210723155347082"></li></ul><p>变量的分类：</p><ul><li>按照数据类型分：<ul><li>基本数据类型</li><li>引用数据类型</li></ul></li><li>按照在类中声明的位置分：<ul><li>成员变量：在使用前，都经历过默认初始化赋值<ul><li>类变量：linking的prepare阶段，给类变量赋默认值—》initial阶段，给类变量显式赋值即静态代码赋值</li><li>实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</li></ul></li><li>局部变量：在使用前，必须进行显式赋值，否则编译不通过</li></ul></li></ul><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul><li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li>==局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。==</li></ul><h2 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4.操作数栈"></a>4.操作数栈</h2><ul><li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个==后进先出==的操作数栈，也可以称之为==表达式栈==</li><li>==操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop)==<ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用他们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ul><hr><ul><li>操作数栈，==主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。==</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，==这个方法的操作数栈是空的==</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值</li><li>栈中任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈==并非采用访问索引的方式来进行数据访问==的，而是只能通过标准的入栈（push）和出栈（pop)操作来完成一次数据访问</li></ul><hr><ul><li>==如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中==，并更新PC寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说Java虚拟机的==解释引擎是基于栈的执行引擎==，其中的栈指的就是操作数栈。</li></ul><h2 id="5-代码追踪"><a href="#5-代码追踪" class="headerlink" title="5.代码追踪"></a>5.代码追踪</h2><p><img src="/2021/07/22/JVM/image-20210723195639171.png" alt="image-20210723195639171"></p><p><img src="/2021/07/22/JVM/2021-06-29-hexoInstallAndUse/image-20210723195646274.png" alt="image-20210723195646274"></p><p><img src="/2021/07/22/JVM/image-20210723195701605.png" alt="image-20210723195701605"></p><p><img src="/2021/07/22/JVM/image-20210723195719108.png" alt="image-20210723195719108"></p><p><img src="/2021/07/22/JVM/image-20210723195728664.png" alt="image-20210723195728664"></p><p>常见i++和++i的区别</p><h2 id="6-栈顶缓存技术"><a href="#6-栈顶缓存技术" class="headerlink" title="6.栈顶缓存技术"></a>6.栈顶缓存技术</h2><ul><li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，Hotspot JVM的设计者们提出了栈顶缓存技术，==将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。==</li></ul><h2 id="7-动态链接"><a href="#7-动态链接" class="headerlink" title="7.动态链接"></a>7.动态链接</h2><ul><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如invokedynamic指令</li><li>在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li></ul><hr><p>为什么需要常量池？</p><p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p><h2 id="8-方法的调用：解析与分派"><a href="#8-方法的调用：解析与分派" class="headerlink" title="8.方法的调用：解析与分派"></a>8.方法的调用：解析与分派</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li>==静态链接==<ul><li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li></ul></li><li>==动态链接==<ul><li>如果被调用的方法在编译期间无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li></ul></li></ul><hr><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li>==早期绑定==<ul><li>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li></ul></li><li>==晚期绑定==<ul><li>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li></ul></li></ul><hr><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然==这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。==</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><hr><h3 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h3><p>非虚方法：</p><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法</li></ul><p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例<br><img src="/2021/07/22/JVM/image-20210724102300938.png" alt="image-20210724102300938"></p><p>虚拟机中提供了以下几条方法调用指令：</p><ul><li>普通调用指令：<ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用&lt;init&gt;方法，私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用所有接口方法</li></ol></li><li>动态调用指令：<ol start="5"><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h3 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h3><ul><li>JVM字节码指令集一直比较稳定，知道Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。知道Java8的Lambda表达式出现，invokedynamic指令的生成在Java中才有了直接的生成方式。</li><li>Java7中增加对动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言编译器。</li></ul><p>动态类型语言和静态类型语言：</p><ul><li>动态类型语言和静态类型语言两者的区别就在于对类型的检查是编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ul><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>Java语言中方法重写的本质：</p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><p>IllegalAccessError：</p><ul><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li></ul><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ul><li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（Virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li><li>虚方法表的创建：<ul><li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li></ul></li></ul><h2 id="9-方法返回地址"><a href="#9-方法返回地址" class="headerlink" title="9.方法返回地址"></a>9.方法返回地址</h2><ul><li>存放调用该方法的PC寄存器的值</li><li>一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，==调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址==。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li></ul><hr><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>==正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。==</p><hr><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口。<ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是Boolean、byte、char、short和int类型时使用、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li></ul></li><li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口</li></ol><p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><hr><p>本质上，方法的退出就是当前栈帧出栈的过程。，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值</p><h2 id="10-一些附加信息"><a href="#10-一些附加信息" class="headerlink" title="10.一些附加信息"></a>10.一些附加信息</h2><p><img src="/2021/07/22/JVM/image-20210724111024676.png" alt="image-20210724111024676"></p><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p><h2 id="11-栈的相关面试题"><a href="#11-栈的相关面试题" class="headerlink" title="11.栈的相关面试题"></a>11.栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError)<ul><li>通过-Xss设置栈的大小；OOM</li></ul></li><li>调整栈大小，就能保证不出现溢出吗？不能</li><li>分配的栈内存越大越好吗？不是</li><li>垃圾回收是否会设计到虚拟机栈？不会的</li><li>方法中定义的局部变量是否线程安全？具体问题具体分析。</li></ul><h1 id="六、本地方法接口"><a href="#六、本地方法接口" class="headerlink" title="六、本地方法接口"></a>六、本地方法接口</h1><p><img src="/2021/07/22/JVM/image-20210724123523449.png" alt="image-20210724123523449"></p><h2 id="什么是本地方法？"><a href="#什么是本地方法？" class="headerlink" title="什么是本地方法？"></a>什么是本地方法？</h2><ul><li>简单地讲，一个Native Method 就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法；该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这样一个机制，比如在C++中，你可以使用extern “C”告知C++编译器去调用C的一个函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java所用，它的初衷是融合C/C++程序。</li></ul><p>例子：</p><p><img src="/2021/07/22/JVM/image-20210724125029029.png" alt="image-20210724125029029"></p><p>==标识符native可以与所有其它的java标识符连用，但是abstract除外==</p><h2 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li>与Java环境外交互：<ul><li>==有时候Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。==你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li></ul></li><li>与操作系统交互<ul><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。==通过使用本地方法，我们得以用Java实现了jre的域底层系统的交互，甚至JVM的一些部分就是用C写的。==还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</li></ul></li><li>sun’s Java<ul><li>S==un的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互==。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriorty（）。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法啊最终将调用win32 SetPriority（） API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul></li></ul><p>现状：</p><ul><li>==目前该方法的使用越来越少了，除非是与硬件有关的应用，==比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以在使用Socket通信，也可以使用Web Service等等。</li></ul><h1 id="七、本地方法栈"><a href="#七、本地方法栈" class="headerlink" title="七、本地方法栈"></a>七、本地方法栈</h1><ul><li>==Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。==</li><li>本地方法栈，也是线程私有的</li><li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常</li></ul></li><li>本地方法是使用C语言实现的</li><li>它的具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载本地方法库</li></ul><hr><ul><li>==当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。==<ul><li>本地方法可以通过本地方法接口来==访问虚拟机内部的运行时数据区==</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul></li><li>==并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等==。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ul><h1 id="八、堆"><a href="#八、堆" class="headerlink" title="八、堆"></a>八、堆</h1><ul><li>堆的核心概述</li><li>设置堆内存大小与OOM</li><li>年轻代与老年代</li><li>图解对象分配过程</li><li>Minor GC、Major GC、Full GC</li><li>堆空间分代思想</li><li>内存分配策略</li><li>为对象分配内存：TLAB</li><li>小结堆空间的参数设置</li><li>堆是分配对象的唯一选择吗</li></ul><h2 id="1-堆的核心概述"><a href="#1-堆的核心概述" class="headerlink" title="1. 堆的核心概述"></a>1. 堆的核心概述</h2><p><img src="/2021/07/22/JVM/image-20210724184900268.png" alt="image-20210724184900268"></p><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。<ul><li>堆内存的大小是可以调节的。</li></ul></li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li><li>《Java虚拟机规范》中对堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。<ul><li>从实际使用角度看，应该是“几乎”所有的对象实例都在这里分配内存。</li></ul></li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ul><p><img src="/2021/07/22/JVM/image-20210724185643895.png" alt="image-20210724185643895"></p><p>现代垃圾收集器大部分都是基于分代收集理论设计，堆空间细分为：</p><p>Java7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区 Young/New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Tenure Generation Space 养老区 Old/Tenure</li><li>Permanent Space  永久区  Perm</li></ul><p>Java8及之后堆内存逻辑上分为三个部分：新生区+养老区+元空间</p><ul><li>Young Generation Space 新生区 Young/New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Tenure Generation Space 养老区 Old/Tenure</li><li>Meta Space 元空间  Meta</li></ul><p>约定：</p><ul><li>新生区=新生代=年轻代</li><li>养老区=老年区=老年代</li><li>永久区=永久代</li></ul><p><img src="/2021/07/22/JVM/image-20210724190408530.png" alt="image-20210724190408530"></p><h2 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2. 设置堆内存大小与OOM"></a>2. 设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xmx”用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li><li>“-Xms”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过”-Xms”所指定的最大内存时，将会抛出OutOfMemoryError异常</p><p>通常会将”-Xmx”和”-Xms”两个参数配置相同的值，其==目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。==</p><p>默认情况下，初始内存大小：物理电脑内存大小/64。最大内存大小：物理电脑内存大小/4。</p><p>OOM举例</p><p><img src="/2021/07/22/JVM/image-20210724191238285.png" alt="image-20210724191238285"></p><h2 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3. 年轻代与老年代"></a>3. 年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代和老年代</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）<br><img src="/2021/07/22/JVM/image-20210724191604855.png" alt="image-20210724191604855"></p><p>下面这些参数开发中一般不会调：<br><img src="/2021/07/22/JVM/image-20210724191702658.png" alt="image-20210724191702658"></p><p>新时代与老年代在堆结构的占比：</p><ul><li>默认-XX:NewRatio=2，表示新时代占1，老年代占2，新时代占整个堆的1/3</li><li>可以修改-XX:NewRatio=4，表示新时代占1，老年代占4，新时代占整个堆的1/5</li></ul><p>在Hotspot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</p><p>开发人员可以通过选项”-XX:SurvivorRatio”调整这个空间比例。比如”-XX:SurvivorRatio=8”</p><p>==几乎所有的==Java对象都是在Eden区被New出来的</p><p>绝大部分的Java对象的销毁都在新时代进行了。</p><ul><li>IBM公司的专门研究表明，新时代中80%的对象都是“朝生暮死”的</li></ul><p>可以使用选项”-Xmn”设置新时代的最大内存大小</p><ul><li>这个参数一般使用默认值就可以了</li></ul><h2 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4. 图解对象分配过程"></a>4. 图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new的对象先放在伊甸园区，此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾收集器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li><li>然后将伊甸园中的剩余对象移动到幸存者0区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存区0的，如果没有回收，就会放到幸存者1区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区</li><li>啥时候能去养老区？可以设置次数，默认是15次。<ul><li>==可以设置参数：-XX:MaxTenuringThreshold=&lt;N&gt;进行设置==</li></ul></li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</li><li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</li></ol><p><img src="/2021/07/22/JVM/image-20210724193456788.png" alt="image-20210724193456788"></p><hr><p>总结：</p><ul><li>针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集</li></ul><p><img src="/2021/07/22/JVM/image-20210724193543173.png" alt="image-20210724193543173"></p><hr><p>常用调优工具：</p><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>VisualVM</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>GCViewer</li><li>GC Easy</li></ul><h2 id="5-Minor-GC、Major-GC、Full-GC"><a href="#5-Minor-GC、Major-GC、Full-GC" class="headerlink" title="5. Minor GC、Major GC、Full GC"></a>5. Minor GC、Major GC、Full GC</h2><p>JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代：方法区）区域一起回收的，大部分时候回收都是指新生代。</p><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分手机（Partial GC），一种是整堆收集（Full GC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集器。其中又分为：</p><ul><li>新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC /old GC）：只是老年代的垃圾收集器。<ul><li>目前，只有CMS GC会有单独收集老年代的行为</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<br>目前，只有G1 GC会有这种行为</li></ul><p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集</p><p>年轻代GC（Minor GC）触发机制：当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）。因为Java对象大多具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也会比较快。这一定义既清晰又易于理解。Minor GC会引发STW，暂停其他用户的进程，等待垃圾回收结束，用户线程才恢复运行。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><h4 id="老年代GC（Major-GC-Full-GC）触发机制"><a href="#老年代GC（Major-GC-Full-GC）触发机制" class="headerlink" title="老年代GC（Major GC/Full GC）触发机制:"></a>老年代GC（Major GC/Full GC）触发机制:</h4><p>指发生在老年代的GC,对象从老年代消失时,我们说”Major GC” 或”Full GC”发生了.</p><p>出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对,在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。也就是在老年代空间不足时,会先尝试触发Minor GC</p><p>Major GC的速度一般会比Minor GC慢10倍以上,STW的时间更长</p><p>如果Major GC后,内存还不足,就报爆OOM了,</p><p>Major GC的速度一般会比Minor GC慢10倍以上。</p><h4 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h4><p>触发Full GC执行的情况有如下五种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.调用System.gc()时,系统建议执行Full GC,但是不必然执行</span><br><span class="line">2.老年代空间不足</span><br><span class="line">3.方法区空间不足</span><br><span class="line">4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span><br><span class="line">5. 由于Eden区,survivor Space0(From)区向survivor Space1(To)区复制时,对象大小小于To Space可用内存,则把该对象转存到老年代,且老年代的可用内存小于该对象的大小。</span><br></pre></td></tr></table></figure><p>说明:Full GC是开发或调优中尽量要避免的,这样暂停时间会短一些</p><h2 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6. 堆空间分代思想"></a>6. 堆空间分代思想</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p><p>经研究,不同对象的生命周期不同。70%-99%的对象都是临时对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新生代:有Eden、两块大小相同的Survivor(又称为from/to,s0/s1)构成,to总为空。</span><br><span class="line">老年代:存放新生代中经历多次GC仍然存活的对象。</span><br></pre></td></tr></table></figure><p>其实不分代完全可以,分代的唯一理由就是优化GC性能。如果没有分代,那所有的对象都在一块,就如同把一个学校的人都关在一个教室。GC的时候就要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生暮死的,如果分代的话,把新创建的对象放到某一地方,当GC的时候先把这块存储朝生暮死对象的区域进行回收,这样就会腾出很大的空间出来</p><h2 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7. 内存分配策略"></a>7. 内存分配策略</h2><p>如果对象在Eden出生并经历第一次Minor GC后任然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄设为1.对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认是15岁,其实每个GC都有所不同)时,就会被晋升到老年代中。</p><p>对象那个晋升到老年代的年龄阈值,可以通过选项:-XX:MaxTenuringThreshold来设置。</p><p>针对不同年龄段的对象分配原则如下所示:</p><ul><li>优先分配到Eden</li><li>打对象直接分配到老年代——尽量避免程序中出现过多的大对象</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断:如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象可以直接进入老年代,无需等到MaxTenuringThreshold中要求的年龄</li><li>空间分配担保:-XX:HandlePromotionFailure</li></ul><h2 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8. 为对象分配内存：TLAB"></a>8. 为对象分配内存：TLAB</h2><p>为什么有TLAB(Thread Local Allocation Buffer)?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆区是线程共享区域,任何线程都可以访问到堆区中的共享数据</span><br><span class="line">由于对象实例的创建在JVM中非常频繁,因此在并发环境下从堆区中划分内存空间是线程不安全的</span><br><span class="line">为避免多个线程操作同一地址,需要使用加锁等机制,进而影响分配速度。</span><br></pre></td></tr></table></figure><p>什么是TLAB?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从内存模型而不是垃圾收集的角度,对Eden区域继续进行划分,JVM为每个线程分配了一个私有缓存区域,它包含在Eden空间内。</span><br><span class="line">多线程同时分配内存时,使用TALB可以避免一系列的非线程安全问题,同时还能够提升内存分配的吞吐量,因此我们可以将这种内存分配方式称之为快速分配策略。</span><br><span class="line">(据说)所有的OpenJDK衍生出来的JVM都提供了TLAB的设计。</span><br></pre></td></tr></table></figure><p>说明:</p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存,但是==JVM确实是将TLAB作为内存分配的首选==<br>在程序中,开发人员可以通过选项”-XX:UserTLAB”设置是否开启TLAB空间</p><p>默认情况下,TLAB空间的内存非常小,仅占整个Eden空间的1%,当然我们可以通过选项”-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时,JVM就会尝试通过==使用加锁机制==确保数据操作的原子性,从而直接在Eden空间中分配内存。</p><h2 id="9-小结堆空间的参数设置"><a href="#9-小结堆空间的参数设置" class="headerlink" title="9. 小结堆空间的参数设置"></a>9. 小结堆空间的参数设置</h2><p><img src="/2021/07/22/JVM/image-20210727131541260.png" alt="image-20210727131541260"></p><p><img src="/2021/07/22/JVM/image-20210727131555702.png" alt="image-20210727131555702"></p><p>在发生Minor GC之前,==虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。==</p><p>如果大于,则此次Minor GC是安全的</p><p>如果小于,则虚拟机会查看-XX:HandlePromotionFailure设置是否允许担保失败。</p><ul><li>如果HandlePromotionFailure=true,那么会继续==检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。==<ul><li>如果大于,则尝试进行一次Minor GC,但这次Minor GC依然是有风险的,</li><li>如果小于,则改为进行一次Full GC</li></ul></li><li>如果HandlePromotionFailure=false,则改进为进行一次Full GC</li></ul><p>在JDK6 update=24之后,HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略,观察OpenJDK中的源码变化,虽然源码中还定义了HandlePromotionFailure参数,但是在代码中已经不会再使用它。==JDK6 update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC==。</p><h2 id="10-堆是分配对象的唯一选择吗"><a href="#10-堆是分配对象的唯一选择吗" class="headerlink" title="10. 堆是分配对象的唯一选择吗"></a>10. 堆是分配对象的唯一选择吗</h2><p>《深入理解Java虚拟机》中关于堆内存的描述:随着JIT编译期的发展与==逃逸分析技术==逐渐成熟,==栈上分配、标量替换优化技术==将会导致一些微妙的变化,所有的对象都分配到堆上也渐渐变得不那么”绝对”了。</p><p>在Java虚拟机中,对象是在Java堆中分配内存的,这是一个普遍的常识。但是,有一种特殊的情况,那就是==如果经过逃逸分析(Escape Analysis)后发现,一个对象并没有逃逸出方法的话,那么就可能被优化成栈上分配==。这样就无需在堆上分配内存,也无须进行垃圾回收了,这也是最常见的堆外存储技术。</p><p>此外,前面提到的基于OpenJDK深度定制的TaoBaoVM,其中创新的GCIH(GC invisible heap)技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外,并且GC不能管理GCIH内部的Java对象,以此达到降低GC的回收频率和提升GC回收效率的目的。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>如何将堆上的对象分配到栈,需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p><p>通过逃逸分析,Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域:</p><ul><li>当一个对象在方法中被定义后,对象只在方法内部使用,则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后,它被外部方法所 引用,则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><p><img src="/2021/07/22/JVM/image-20210727134156197.png" alt="image-20210727134156197"></p><p>参数设置:</p><ul><li>在JDK 6u23版本之后,HotSpot中默认就已经开启了逃逸分析。</li><li>如果使用的是较早的版本,开发人员则可通过:<ul><li>选项”-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项”-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ul><p>==结论:开发中能使用局部变量的,就不要使用在方法外定义==</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析,编译器可以对代码做如下优化:</p><p>一、栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配,要使指向该对象的指针永远不会逃逸,对象可以是栈分配的候选,而不是堆分配。</p><p>二、同步省略。如果一个对象被发现只能从一个线程访问到,那么对于这个对象的操作可以不考虑同步</p><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到,那么对象的部分(或全部)可以不存储在内部,而是存储在CPU寄存器中。</p><p>JIT编译器在编译期间根据逃逸分析的结果,发现如果一个对象并没有逃逸出方法的话,就可能被优化成栈上分配。分配完成之后,继续在调用栈内执行,最后线程结束,栈空间被回收,局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配场景:给成员变量赋值、方法返回值]实例引用传递。</p><h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><p>线程同步的代价是相当高的,同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候,JIT编译器可以借助逃逸分析来==判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程==。如果没有,那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略,也叫==锁消除==。</p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>==标量(Scalar)==是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的,那些还可以分解的数据叫做==聚合量(Aggregate)==,Java中的对象就是聚合量,因为它可以分解成其他聚合量和标量。</p><p>在JIT阶段,如果经过逃逸分析,发现一个对象不会被外界访问的话,那么经过JIT优化,就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p>==标量替换后,可以大大减少堆内存的占用==。因为一旦不需要创建对象了,那么久不需要分配堆内存了</p><p>标量替换为栈上分配提供了很好的基础。</p><p>标量替换参数设置:-XX:+EliminateAllocations:开启了标量替换(默认打开),允许将对象打散分配在栈上。</p><p><img src="/2021/07/22/JVM/image-20210727140819791.png" alt="image-20210727140819791"></p><h4 id="逃逸分析小结"><a href="#逃逸分析小结" class="headerlink" title="逃逸分析小结"></a>逃逸分析小结</h4><p>==逃逸分析并不成熟==</p><p>关于逃逸分析的论文在1999年就已经发表了,但是直到JDK1.6才有实现,而且这项技术到如今也不是十分成熟。</p><p>其根本原因就是==无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的,这其实也是一个相对耗时的过程。==</p><p>一个极端的例子,就是经过逃逸分析 之后,发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然项技术并不十分成熟,但是它也是==即时编译器优化技术中一个十分重要的手段。==</p><p>注意到一些观点,认为通过逃逸分析,JVM会在栈上分配那些不会逃逸的对象,这在理论上是可行的,但是取决于JVM设计者的选择。(据说)Oracle HotSpot JVM中并没有这么做,所有的对象实例都是创建在堆上的</p><p>==!!==</p><p>目前很多书籍都还是基于JDK7以前的版本,但是JDK以及发生了很大的变化,intern字符串的缓存和静态变量曾经都被分配在永久代上,而永久代已经被元数据区取代。但是,intern字符串缓存和静态变量并不是转移到元数据区,而是直接在堆上分配,所以这一点同样符合前面的结论;==对象实例都是分配在堆上。==</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域,一个对象在这里产生、应用,最后被垃圾回收器收集,结束生命。</p><p>老年代 放置长生命周期的对象,通常都是从Survivor区域筛选拷贝过来的Java对象。当然,也有特殊情况,我们知道普通的对象会被分配在TLAB上,如果对象较大,JVM会试图直接分配在Eden其他位置上,如果对象太大,完全无法再新时代找到足够长的连续空闲空间,JVM就会直接分配到老年代。</p><p>当GC只发生在年轻代中,回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时,则被称为Major GC,或者Full GC。一般的,Minor GC的发送频率要比Major GC高很多,即老年代中垃圾回收发送的频率大大低于年轻代。</p><h1 id="九、方法区"><a href="#九、方法区" class="headerlink" title="九、方法区"></a>九、方法区</h1><p>栈、堆、方法区的交互关系</p><p>方法区的理解</p><p>设置方法区大小与OOM</p><p>方法区的内部结构</p><p>方法区的使用举例</p><p>方法区的演进细节</p><p>方法区的垃圾回收</p><p>总结</p><h2 id="1-栈、堆、方法区的交互关系"><a href="#1-栈、堆、方法区的交互关系" class="headerlink" title="1. 栈、堆、方法区的交互关系"></a>1. 栈、堆、方法区的交互关系</h2><p>运行时数据区结构图</p><p><img src="/2021/07/22/JVM/image-20210727172018327.png" alt="image-20210727172018327"></p><p><img src="/2021/07/22/JVM/image-20210727172128638.png" alt="image-20210727172128638"></p><p><img src="/2021/07/22/JVM/image-20210727172143017.png" alt="image-20210727172143017"></p><h2 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2. 方法区的理解"></a>2. 方法区的理解</h2><p><img src="/2021/07/22/JVM/image-20210727172216547.png" alt="image-20210727172216547"></p><p>《Java虚拟机规范》中明确说明:”尽管所有的方法区在逻辑上是属于堆的一部分,但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言,方法区还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开。所以,==方法区看做是一块独立于Java堆的内存空间。==</p><hr><p>基本理解:</p><p>方法区(Method Area)与Java堆一样,是各个线程共享的内存区域。</p><p>方法区在JVM启动的时候被创建,并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。</p><p>方法区的大小,根堆空间一样,可以选择固定大小或者可拓展。</p><p>方法区的大小决定了系统可以保存多少个类,如果系统定义了太多的类,导致方法区溢出,虚拟机同样会抛出内存溢出错误:java.lang.OutOfMemoryError:PermGen space或者java.lang.OutOfMemoryError:Metespace。加载大量的第三方的jar包:Tomcat部署的工程多(30-50个),大量动态的生成反射类。</p><p>关闭JVM就会释放这个区域的内存。</p><hr><p>HotSpot中方法区的演进:</p><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。</p><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过<code>-XX:MaxPermsize</code>上限）</p><p><img src="/2021/07/22/JVM/image-20210727193041713.png" alt="image-20210727193041713"></p><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="/2021/07/22/JVM/image-20210727193102354.png" alt="image-20210727193102354"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="3-设置方法区大小与OOM"><a href="#3-设置方法区大小与OOM" class="headerlink" title="3. 设置方法区大小与OOM"></a>3. 设置方法区大小与OOM</h2><p>设置方法区内存的大小</p><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><p><strong>jdk7及以前</strong></p><ul><li><p>==通过来设置永久代初始分配空间。默认值是20.75M==<code>-XX:Permsize</code></p></li><li><p>==通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M==<code>-XX:MaxPermsize</code></p></li><li><p>当JVM加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</p></li></ul><p><img src="/2021/07/22/JVM/image-20210727193408965.png" alt="image-20210727193408965"></p><p><strong>JDK8以后</strong></p><ul><li><p>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</p></li><li><p>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</p></li><li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></p></li><li><p><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的<code>-XX:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</p></li><li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m-XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                <span class="comment">//创建Classwriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, nu1l, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">//CLass对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>解决:</p><ol><li>要解决OOM异常或者heap space的异常,一般的手段是首先通过内存印象分析工具对dump出来的堆转储快照进行分析,重点是确认内存中的对象是否是必要的,也就是要先分清楚到底是出现了内存泄露(Memory Leak)还是内存溢出(Memory Overflow)。</li><li>如果是内存泄露,可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息,以及GC Roots引用链的信息,就可以比较准确地定位出泄露代码的位置。</li><li>如果不存在内存泄露,换句话说就是内存中的对象确实都还必须存活着,那就应当检查虚拟机的堆参数(-Xmx与-Xmx),与机器物理内存对比看是否还可以调大,从优化代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况,尝试减少程序运行期间的内存消耗。</li></ol><h2 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4. 方法区的内部结构"></a>4. 方法区的内部结构</h2><p><img src="/2021/07/22/JVM/8a5fcba10ccb773f185288ac22bde206.png" alt="image-20200708161728320"></p><p>方法区(Method Area)中存储什么?</p><p>《深入理解Java虚拟机》中对方法区(Method Area)存储内容描述如下:<br>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="/2021/07/22/JVM/fbe3915506e7979c7d591d17c216fbb1.png" alt="image-20200708161856504"></p><h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构:"></a>方法区的内部结构:</h3><p>类型信息:</p><p>对每个加载的类型(类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储以下类型信息:</p><ol><li>这个类型的完整有效名称(全类名=包名.类名)</li><li>这个类型直接父亲的完整有效名(对于interface或者是java.lang.object,都没有父类)</li><li>这个类型的修饰符(public,abstract,final的某个子集)</li><li>这个类型直接接口的一个有序列表</li></ol><p>域(Field)信息:</p><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。域的相关信息包括:域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集)</p><p>方法(Method)信息:</p><p>JVM必须保存所有的方法的以下信息,同域信息一样包括声明顺序:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、jvm概述&quot;&gt;&lt;a href=&quot;#一、jvm概述&quot; class=&quot;headerlink&quot; title=&quot;一、jvm概述&quot;&gt;&lt;/a&gt;一、jvm概述&lt;/h1&gt;&lt;p&gt;jvm与java体系结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;面向人群及参考书目&lt;/l</summary>
      
    
    
    
    <category term="java" scheme="https://stary1999.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://stary1999.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://stary1999.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>javaWeb书城项目传统版</title>
    <link href="https://stary1999.github.io/2021/07/14/JavaWebBookCity/"/>
    <id>https://stary1999.github.io/2021/07/14/JavaWebBookCity/</id>
    <published>2021-07-14T13:57:09.000Z</published>
    <updated>2021-07-16T07:30:20.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>javaWeb书城项目传统版是在尚硅谷的web培训教程的基础上，进一步完善的，具体资源以及教程都来自/参考尚硅谷课程。</p><p>本次复盘，是在老师原有上课的基础上，补充一些未完成的细节，完善功能，使整个项目看起来更合理一些。因时间原因，项目仍有很多缺点不足，有待改进。加之jsp技术过于老旧，后面可能采取SpringBoot的方式实现类似功能的项目。</p><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p>整个项目主要由以下几个部分组成：</p><ul><li>注册登录</li><li>图书模块</li><li>订单模块</li><li>数据库交互</li><li>MVC架构</li></ul><h3 id="注册登录"><a href="#注册登录" class="headerlink" title="注册登录"></a>注册登录</h3><p>注册登录模块主要是实现用户的管理，用户应该分为两种类型，即：常规买家用户和管理员用户，二者权限不同，对于非管理员用户，登录后，应该只能查看自己的订单，与执行签收操作，后台管理部分对其而言应该是隐藏的。</p><p>普通用户的操作有：查看商品，加入购物车，下单付款，确认收货。</p><p>管理员用户还需要维护图书模块和订单模块（发货等操作），所有的权限对管理员开放</p><p>注册与登录的实现：</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册的时候需要用户输入用户名称、用户密码、确认密码、电子邮箱以及验证码等信息，如下图</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210716132522512.png" alt="image-20210716132522512"></p><p>其中，用户名和密码、邮箱等，采用正则表达式在前端jsp页面进行检测，验证码使用的是google提供的验证码生成包。</p><p>若注册时用户名已存在，则采用ajax的形式部分刷新前端页面，重新注册。</p><p>注册成功后，将注册数据写入数据库表</p><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>登录的凭据是用户名和密码，采用cookie缓存登录信息（待补充），经由servlet处理后，返回登录结果</p><h3 id="图书模块"><a href="#图书模块" class="headerlink" title="图书模块"></a>图书模块</h3><p>图书模块主要是向用户展示图书商品项</p><h4 id="后台图书管理"><a href="#后台图书管理" class="headerlink" title="后台图书管理"></a>后台图书管理</h4><p>首先，在后台图书管理模块，需要实现以下功能：图书修改、图书删除、图书添加、以及最重要的图书查询。</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210716133230918.png" alt="image-20210716133230918"></p><p>这部分主要是与数据库进行交互，基于CRUD实现</p><h4 id="图书信息展示"><a href="#图书信息展示" class="headerlink" title="图书信息展示"></a>图书信息展示</h4><p>不管是在后台还是在首页，都需要将图书信息展示出来，并且采用分页的形式输出</p><p>分页部分需要新建一个page对象，里面存储分页的相关信息，然后根据分页情况进行查询并返回查询结果到展示页面。</p><p>注意分页条的设计实现</p><p>也可以利用其它分页插件实现</p><p>此外，在首页，还需要设计一个根据价格区间查询图书的功能，底层原理是SQL的条件查询</p><h3 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h3><p>订单模块包括了订单查询、订单管理、以及购物车几个部分，底层也是数据库</p><h4 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h4><p>购物车部分采用的是session域来保存数据，避免页面跳转、重定向时丢失数据，理论上应该将数据存到数据库。这部分功能有待完善。</p><h4 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h4><p>用户将商品添加到购物车后，可以选择付款，付款后，会由系统自动生成一个订单号，并将订单数据保存到数据库</p><p>用户可以在“我的订单”处查看已有的订单，并执行“签收”操作</p><p>管理员可以在后台查看所有的订单，并执行“发货”操作</p><h4 id="订单查询"><a href="#订单查询" class="headerlink" title="订单查询"></a>订单查询</h4><p>订单查询类似图书查询功能，但对普通用户而言，只能查看自己的订单项。</p><p>需要采用分页设计，待改进</p><h3 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h3><p>使用Druid数据库连接池服务。通过jdbcUtils连接数据库，所有的SQL操作类都继承自BaseDao类，所有的CRUD都归结于update和“查询”两个操作。考虑到查询的特殊性，查询又分为返回单个值的和返回对象列表两个种类。这三个基本类几乎涵盖了所有的基础的dao操作。后续需要实现的所有数据库操作，都可以由此得到。</p><h4 id="jdbcUtils"><a href="#jdbcUtils" class="headerlink" title="jdbcUtils"></a>jdbcUtils</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DataSourceClosedException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> JdbcUtils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> stary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/29 21:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; conns=<span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line"></span><br><span class="line">            dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"><span class="comment">//            com.mysql.cj.jdbc.ConnectionImpl@4f9a3314</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn=conns.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="comment">//从数据库连接池获取连接</span></span><br><span class="line">                conn = dataSource.getConnection();</span><br><span class="line">                <span class="comment">//保存到ThreadLocal对象中，供后面的jdbc操作使用</span></span><br><span class="line">                conns.set(conn);</span><br><span class="line">                <span class="comment">//设置为手动管理</span></span><br><span class="line">                conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务，并关闭释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitAndClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection=conns.get();</span><br><span class="line">        <span class="comment">//说明使用过连接操作过数据库</span></span><br><span class="line">        <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.commit();<span class="comment">//提交事务</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();<span class="comment">//关闭连接</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行remove操作（因为tomcat服务器底层使用了线程池）</span></span><br><span class="line">        conns.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚事务，并关闭释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollbackAndClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection=conns.get();</span><br><span class="line">        <span class="comment">//说明使用过连接操作过数据库</span></span><br><span class="line">        <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();<span class="comment">//提交事务</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();<span class="comment">//关闭连接</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行remove操作（因为tomcat服务器底层使用了线程池）</span></span><br><span class="line">        conns.remove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*   public static void close(Connection conn)&#123;</span></span><br><span class="line"><span class="comment">        if(conn!=null)</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                conn.close();</span></span><br><span class="line"><span class="comment">            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BaseDao"><a href="#BaseDao" class="headerlink" title="BaseDao"></a>BaseDao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.proxy.jdbc.JdbcParameter;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.utils.JdbcUtils;</span><br><span class="line"><span class="keyword">import</span> com.mysql.cj.QueryResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BaseDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> stary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/30 13:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用dbUtils操作数据库</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner=<span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object ...args)</span></span>&#123;</span><br><span class="line">        Connection connection= JdbcUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.update(connection,sql,args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryForOne</span><span class="params">(Class&lt;T&gt;type,String sql,Object ...args)</span></span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">new</span> JdbcUtils().getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.query(connection,sql,<span class="keyword">new</span> BeanHandler&lt;T&gt;(type),args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(Class&lt;T&gt;type, String sql, Object ...args)</span></span>&#123;</span><br><span class="line">        Connection connection=<span class="keyword">new</span> JdbcUtils().getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.query(connection,sql,<span class="keyword">new</span> BeanListHandler&lt;T&gt;(type),args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">queryForSingleValue</span><span class="params">(String sql,Object...args)</span></span>&#123;</span><br><span class="line">        Connection connection=JdbcUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.query(connection,sql,<span class="keyword">new</span> ScalarHandler(),args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h3><p>mvc三层架构：dao、service、servlet，三层。dao层负责数据库交互，service层负责业务处理，servlet层负责页面分发。</p><p>基本逻辑是：前端页面访问servlet获取服务。servlet通过service处理请求。service调用dao层获取数据。</p><p>dao层与数据库保持一致，service层负责需要处理的各项业务，实现例如查询全部图书、修改订单状态之类的功能。而servlet层从前端获取数据，调用service获得返回值，然后将结果以页面的形式展现</p><h4 id="BaseServlet"><a href="#BaseServlet" class="headerlink" title="BaseServlet"></a>BaseServlet</h4><p>BaseServlet是servlet层最核心的一个类，其他子类通过继承他，可以简化其他类的操作。通过反射实现对前端请求的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BaseServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> stary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/7 20:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      <span class="comment">//解决中文乱码</span></span><br><span class="line">       req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">       resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String action = req.getParameter(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">        <span class="comment">//反射实现</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = <span class="keyword">this</span>.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">            method.invoke(<span class="keyword">this</span>, req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);<span class="comment">//把异常抛给servlet程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       doPost(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="WebUtils"><a href="#WebUtils" class="headerlink" title="WebUtils"></a>WebUtils</h4><p>WebUtils是一个工具类，其主要具有两项功能：</p><ul><li>包装，即将前端传输过来的数据包装成bean类</li><li>转换，将前端传送过来的String类型变量转化为Integer类型，并设置默认值（0），避免空指针异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.pojo.User;</span><br><span class="line"><span class="comment">//import com.sun.deploy.net.HttpResponse;</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WebUtils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> stary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/7 20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copyParamToBean</span><span class="params">(Map values, T bean)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanUtils.populate(bean,values);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String strInt,<span class="keyword">int</span> defaultValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(strInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="过滤器与事务处理"><a href="#过滤器与事务处理" class="headerlink" title="过滤器与事务处理"></a>过滤器与事务处理</h4><p>在实际应用中，考虑到会出现许多问题，所以在对数据库进行操作的时候，需要进行事务管理，避免因为意外导致数据库错误，出现脏读、幻读等</p><p>其次，采用过滤器对权限进行管理。</p><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>打开idea，新建一个项目，注意命名方式，任何时候，命名方式都尽量保持无空格无中文</p><p>在新的项目下，新建一个模块，作为开发的主体</p><p>右键模块名，为模块添加框架支持</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715155654832.png" alt="image-20210715155654832"></p><p>勾选web application ，为模块添加web支持。记得勾选创建 web.xml，这是web工程的配置文件，点击OK完成</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715155824642.png" alt="image-20210715155824642"></p><p>导入前端文件，前端文件包括了页面（存储在page目录下），静态资源（jQuery、css、image等，存储在static下），首页index</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715161929147.png" alt="image-20210715161929147"></p><p>至此，前端准备工作基本完成，后期根据需求进行修改</p><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>接下来需要配置运行环境，用的是tomcat</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715162125997.png" alt="image-20210715162125997"></p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715162302557.png" alt="image-20210715162302557"></p><p>先配置artifact，修改项目名称</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715162553300.png" alt="image-20210715162553300"></p><p>接下来配置服务器，根据需求配置，建议修改为热部署，其他默认就好。</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715162659632.png" alt="image-20210715162659632"></p><h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><p>本次是在之前的基础上复盘，这里直接导入所有需要使用的jar包，在WEB-INF目录下，新建lib文件夹，导入需要使用的jar包，这里包括了后端前端所需要使用的jar包</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715163056095.png" alt="image-20210715163056095"></p><p>选中全体jar包，右键，添加到库</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715163303721.png" alt="image-20210715163303721"></p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715163331348.png" alt="image-20210715163331348"></p><p>最后，jar包出现可以展开的符号，表示添加成功</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715163408118.png" alt="image-20210715163408118"></p><p>也可以使用File、Project Structure的方式导入jar包<img src="/2021/07/14/JavaWebBookCity/image-20210715163449343.png" alt="image-20210715163449343"></p><p>运行tomcat，浏览器正确打开首页，</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715163637421.png" alt="image-20210715163637421"></p><p>至此，前期准备工作完成</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>前期准备基本完成，但是考虑到后面需要使用到数据库，也一并配置数据库</p><p>包括一个用户表和商品表</p><p>sql参考</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_book</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_book`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_book`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">11</span>, <span class="number">2</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `author` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sales` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stock` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `img_path` <span class="type">varchar</span>(<span class="number">200</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">30</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of t_book</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_book` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;java从入门到放弃&#x27;</span>, <span class="number">80.00</span>, <span class="string">&#x27;国哥&#x27;</span>, <span class="number">10009</span>, <span class="number">9</span>, <span class="string">&#x27;static/img/default.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_book` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;数据结构与算法&#x27;</span>, <span class="number">78.50</span>, <span class="string">&#x27;严敏君&#x27;</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="string">&#x27;static/img/default.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for t_user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">200</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `username`(`username`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of t_user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_user` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin@atguigu.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此外还需要存储购物车和订单等的数据表，此处略，后面添加</p><h2 id="2-登录与注册"><a href="#2-登录与注册" class="headerlink" title="2. 登录与注册"></a>2. 登录与注册</h2><p>登录注册功能，当前端点击登录、注册的按钮时，会触发相应的功能，详情见总体设计</p><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>User类的主要字段，后期需要修改增加权限控制字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>数据库中存在相同的表单项，保存用户的信息。注册是将前端传来的数据写入，登录则是比较前端数据与数据库是否一致。</p><p>Dao层需要实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByUsernameAndPassword</span><span class="params">(String username,String password)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>service层需要实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existsUsername</span><span class="params">(String username)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><p>servlet层，对于UserServlet，继承自BaseDao，提供三个服务，regist、login、loginOut。注意servlet需要在web.xml中注册。</p><p>判断验证码是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取并删除验证码</span></span><br><span class="line">       String token=(String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);</span><br><span class="line">       req.getSession().removeAttribute(KAPTCHA_SESSION_KEY);</span><br><span class="line">       String code = req.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;code=&quot;</span>+code);</span><br><span class="line">           System.out.println(<span class="string">&quot;token=&quot;</span>+token);</span><br></pre></td></tr></table></figure><p>注意登录成功后，需要将数据回传给前端，登录注册失败、登录错误也需要回传数据</p><h2 id="3-页面优化"><a href="#3-页面优化" class="headerlink" title="3. 页面优化"></a>3. 页面优化</h2><p>将前端的页面进行优化，抽取相同的页面元素放在common，便于后期维护</p><p>这部分主要是前端的工作，目前对前端技术掌握不是太好，只是有个基本了解，此处就不再具体赘述</p><h2 id="4-图书管理"><a href="#4-图书管理" class="headerlink" title="4. 图书管理"></a>4. 图书管理</h2><h3 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h3><p>Book的pojo类，数据库中同样要存在类似的表，用来存储图书信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer sales;</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="keyword">private</span> String imgPath=<span class="string">&quot;static/img/default.jpg&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Page的pojo类，用来实现分页功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer page_size=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="comment">//总页码</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageTotal;</span><br><span class="line">    <span class="comment">//当前页显示数量</span></span><br><span class="line">    <span class="keyword">private</span>  Integer pageSize=page_size;</span><br><span class="line">    <span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageTotalCount;</span><br><span class="line">    <span class="comment">//当前页数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items;</span><br><span class="line">    <span class="comment">//分页条地址</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现的dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.pojo.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加图书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="comment">//删除图书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">//更新书籍信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">queryBookById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">//查询所有图书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">queryBooks</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查询分页数</span></span><br><span class="line">    <span class="function">Integer <span class="title">queryForPageTotalCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查询指定区间的图书</span></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">queryForPageItems</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> pageSize)</span></span>;</span><br><span class="line">    <span class="comment">//按价格区间查询分页数</span></span><br><span class="line">    <span class="function">Integer <span class="title">queryForPageTotalCountByPrice</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询指定价格区间中指定分页区间的图书</span></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">queryForPageItemsByPrice</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">queryBookById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">queryBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;Book&gt; <span class="title">page</span><span class="params">(<span class="keyword">int</span> pageNo, <span class="keyword">int</span> pageSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;Book&gt; <span class="title">pageByPrice</span><span class="params">(<span class="keyword">int</span> pageNo, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="servlet-1"><a href="#servlet-1" class="headerlink" title="servlet"></a>servlet</h3><p>add、update、delete、list、getBook、page几个功能。其中page实现分页功能，实际应用的过程中，会替换掉list（查询全部书籍），getBook是获取要修改的图书的信息。</p><p>分页实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">page</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求参数pageNo、pageSize</span></span><br><span class="line">        <span class="keyword">int</span> pageNo= WebUtils.parseInt(req.getParameter(<span class="string">&quot;pageNo&quot;</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pageSize=WebUtils.parseInt(req.getParameter(<span class="string">&quot;pageSize&quot;</span>), Page.page_size);</span><br><span class="line">        <span class="comment">//调用bookservice。page</span></span><br><span class="line">        Page&lt;Book&gt; page=bookService.page(pageNo,pageSize);</span><br><span class="line">        page.setUrl(<span class="string">&quot;client/clientbookServlet?action=page&quot;</span>);</span><br><span class="line">        <span class="comment">//保存page对象到request域中</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;page&quot;</span>,page);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/pages/client/index.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pageByPrice</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求参数pageNo、pageSize</span></span><br><span class="line">        <span class="keyword">int</span> pageNo= WebUtils.parseInt(req.getParameter(<span class="string">&quot;pageNo&quot;</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pageSize=WebUtils.parseInt(req.getParameter(<span class="string">&quot;pageSize&quot;</span>), Page.page_size);</span><br><span class="line">        <span class="keyword">int</span> min=WebUtils.parseInt(req.getParameter(<span class="string">&quot;min&quot;</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> max=WebUtils.parseInt(req.getParameter(<span class="string">&quot;max&quot;</span>),Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用bookservice。page</span></span><br><span class="line">        Page&lt;Book&gt; page=bookService.pageByPrice(pageNo,pageSize,min,max);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;client/clientbookServlet?action=pageByPrice&quot;</span>);</span><br><span class="line">        <span class="comment">//若有min请求参数，追加到分页条地址请求参数中</span></span><br><span class="line">        <span class="keyword">if</span>(req.getParameter(<span class="string">&quot;min&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;&amp;min=&quot;</span>).append(req.getParameter(<span class="string">&quot;min&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若有min请求参数，追加到分页条地址请求参数中</span></span><br><span class="line">        <span class="keyword">if</span>(req.getParameter(<span class="string">&quot;max&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;&amp;max=&quot;</span>).append(req.getParameter(<span class="string">&quot;max&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        page.setUrl(sb.toString());</span><br><span class="line">        <span class="comment">//保存page对象到request域中</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;page&quot;</span>,page);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/pages/client/index.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-订单管理"><a href="#5-订单管理" class="headerlink" title="5. 订单管理"></a>5. 订单管理</h2><p>订单管理模块又细分为购物车和订单管理</p><h3 id="dao-1"><a href="#dao-1" class="headerlink" title="dao"></a>dao</h3><p>dao层有四个pojp类，分别归属于购物车和订单。</p><p>其中Cart记录购物车的基础信息，CartItem保存购物车中的详细商品项。</p><p>同理，Order记录订单基础信息，OrderItem保存订单中的详细商品项。</p><p>Cart</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer totalCount;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalPrice;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,CartItem&gt; items=<span class="keyword">new</span> LinkedHashMap&lt;Integer,CartItem&gt;();</span><br></pre></td></tr></table></figure><p>CartItem</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Order</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="comment">//0未发货，1已发货，2表示已签收</span></span><br><span class="line">    <span class="keyword">private</span> Integer status=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br></pre></td></tr></table></figure><p>OrderItem</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> Integer count;</span><br><span class="line">   <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">   <span class="keyword">private</span> BigDecimal totalPrice;</span><br><span class="line">   <span class="keyword">private</span> String orderId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现的接口：</p><p>由于购物车模块没有保存到数据库中，所以这里的购物车就不需要与数据库进行交互</p><p>OrderDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">queryOrders</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">changeOrderStatus</span><span class="params">(String status,String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">queryOrdersByUserId</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderItemDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderItemDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrderItem</span><span class="params">(OrderItem orderItem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;OrderItem&gt; <span class="title">queryOrderItemByOrderId</span><span class="params">(String orderId)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h3><p>service层也只有订单项一种服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成订单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Cart cart,Integer userId)</span></span>;</span><br><span class="line">    <span class="comment">//查询全部订单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">showAllOrders</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//发货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="comment">//查看订单详情</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;OrderItem&gt; <span class="title">showOrderDetail</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="comment">//查看我的订单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">showMyOrders</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">//签收订单、确认收货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveOrder</span><span class="params">(String orderId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意生成订单的服务：</p><p>生成订单项，需要将购物车中的数据，转化为订单项的数据，保存到数据库后，清空购物车。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Cart cart, Integer userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String orderId=System.currentTimeMillis()+<span class="string">&quot;&quot;</span>+userId;</span><br><span class="line">       Order order=<span class="keyword">new</span> Order(orderId,<span class="keyword">new</span> Date(),cart.getTotalPrice(),<span class="number">0</span>,userId);</span><br><span class="line">       orderDao.saveOrder(order);</span><br><span class="line">       <span class="comment">//遍历购物车中每一个商品项，转化为订单项保存到数据库</span></span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123;</span><br><span class="line">           <span class="comment">//获取每个购物车中的商品项</span></span><br><span class="line">           CartItem cartItem=entry.getValue();</span><br><span class="line">           <span class="comment">//转换为每一个订单项</span></span><br><span class="line">           OrderItem orderItem=<span class="keyword">new</span> OrderItem(<span class="keyword">null</span>,cartItem.getName(),cartItem.getCount(),cartItem.getPrice(),cartItem.getTotalPrice(),orderId);</span><br><span class="line">           <span class="comment">//保存订单项到数据库</span></span><br><span class="line">           orderItemDao.saveOrderItem(orderItem);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//更新库存和销量</span></span><br><span class="line">           Book book = bookDao.queryBookById(cartItem.getId());</span><br><span class="line">           book.setSales(book.getSales()+cartItem.getCount());</span><br><span class="line">           book.setStock(book.getStock()-cartItem.getCount());</span><br><span class="line">           bookDao.updateBook(book);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//清空购物车</span></span><br><span class="line">       cart.clear();</span><br><span class="line">       <span class="keyword">return</span> orderId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="servlet-2"><a href="#servlet-2" class="headerlink" title="servlet"></a>servlet</h3><p>OrderServlet和CartServlet两个servlet，分别处理购物车和订单的请求</p><ul><li>CartServlet：addItem添加（被ajaxAddItem替换）、deleteItem删除、clear清空、updateCount修改数量</li><li>OrderServlet：createOrder生成订单、showAllOrder查看所有订单、sendOrder发货、showOrderDetail查看订单详情、showMyOrder查看我的订单、receiveOrder签收订单</li></ul><p>ajaxAddItem：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ajaxAddItem</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取请求参数、商品编号</span></span><br><span class="line">    <span class="keyword">int</span> id= WebUtils.parseInt(req.getParameter(<span class="string">&quot;id&quot;</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//调用bookservice。queryBookById，得到图书信息</span></span><br><span class="line">    Book book = bookService.queryBookById(id);</span><br><span class="line">    <span class="comment">//把图书信息转换为cartItem信息</span></span><br><span class="line">    CartItem cartItem = <span class="keyword">new</span> CartItem(book.getId(), book.getName(), <span class="number">1</span>, book.getPrice(), book.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用cart。addItem，添加商品项</span></span><br><span class="line">    Cart cart=(Cart)req.getSession().getAttribute(<span class="string">&quot;cart&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(cart==<span class="keyword">null</span>)&#123;</span><br><span class="line">        cart=<span class="keyword">new</span> Cart();</span><br><span class="line">        req.getSession().setAttribute(<span class="string">&quot;cart&quot;</span>,cart);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cart.addItem(cartItem);</span><br><span class="line">    <span class="comment">//保存最后一次添加的商品名称到session域</span></span><br><span class="line">    req.getSession().setAttribute(<span class="string">&quot;lastName&quot;</span>,cartItem.getName());</span><br><span class="line">    <span class="comment">//ajax返回</span></span><br><span class="line">    Map&lt;String ,Object&gt; resultMap=<span class="keyword">new</span> HashMap&lt;String ,Object&gt;();</span><br><span class="line">    resultMap.put(<span class="string">&quot;totalCount&quot;</span>,cart.getTotalCount());</span><br><span class="line">    resultMap.put(<span class="string">&quot;lastName&quot;</span>,cartItem.getName());</span><br><span class="line">    Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">    String resultMapJsonString=gson.toJson(resultMap);</span><br><span class="line">    resp.getWriter().write(resultMapJsonString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>泛型的使用。</li><li>反射的应用。</li><li>面向接口编程</li><li>空指针异常</li><li>前后端交互。json数据流与对象</li><li>MVC三层架构</li><li>事务处理与权限管理（拦截器）</li><li>“导包”。使用功能前，必“导包”，包括jar包和html、jsp的引用</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="时区报错，"><a href="#时区报错，" class="headerlink" title="时区报错，"></a>时区报错，</h3><p>修改配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/book?serverTimezone=GMT%2B8</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/14/JavaWebBookCity/image-20210715181248446.png" alt="image-20210715181248446"></p><h3 id="tomcat乱码"><a href="#tomcat乱码" class="headerlink" title="tomcat乱码"></a>tomcat乱码</h3><p>修改配置文件。找到tomcat安装目录conf下logging.properties文件，打开后搜索：java.util.logging.ConsoleHandler.encoding修改为GBK</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715195227139.png" alt="image-20210715195227139"></p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715195419241.png" alt="image-20210715195419241"></p><h3 id="查询为空"><a href="#查询为空" class="headerlink" title="查询为空"></a>查询为空</h3><p>查询时出现查出数据为空的情况：大概率是pojo类与数据表项名字不一致，解决方式：在sql语句中添加别名</p><p><img src="/2021/07/14/JavaWebBookCity/image-20210715213802248.png" alt="image-20210715213802248"></p><p>foreach查询不出数据，在jsp中添加&lt;%@taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;%&gt;">http://java.sun.com/jsp/jstl/core&quot;%&gt;</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;javaWeb书城项目传统版是在尚硅谷的web培训教程的基础上，进一步完善的，具体资源以及教程都来自/参考尚硅谷课程。&lt;/p&gt;
&lt;p&gt;本次复</summary>
      
    
    
    
    <category term="java" scheme="https://stary1999.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://stary1999.github.io/tags/java/"/>
    
    <category term="web" scheme="https://stary1999.github.io/tags/web/"/>
    
    <category term="jsp" scheme="https://stary1999.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://stary1999.github.io/2021/07/11/tools-2021-07-11-DesignPatterns/"/>
    <id>https://stary1999.github.io/2021/07/11/tools-2021-07-11-DesignPatterns/</id>
    <published>2021-07-11T01:37:47.000Z</published>
    <updated>2021-07-16T11:45:38.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-经典面试题"><a href="#1-经典面试题" class="headerlink" title="1.经典面试题"></a>1.经典面试题</h2><h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><ol><li>有请使用UML类图画出原型模式核心角色 </li><li> 原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写 clone方法实现深拷贝、使用序列化来实现深拷贝) </li><li> 在Spring框架中哪里使用到原型模式，并对源码进行分析 beans.xml </li><li>Spring中原型bean的创建，就是原型模式的应用 </li><li> 代码分析+Debug源码</li><li>设计模式的七大原则: 要求：<ol><li>七大设计原则核心思想 </li><li> 能够以类图的说明设计原则</li><li> 在项目实际开发中，你在哪里使用到了ocp原则</li></ol></li></ol><p>金融借贷平台项目：借贷平台的订单，有审核发布-抢单 等等 步骤，随着操作的不同，会改 变订单的状态, 项目中的这个模块实现就会使用 到状态模式，请你使用状态模式进行设计，并 完成实际代码<br>问题分析 ： 这类代码难以应对变化，在添加一种状态时， 我们需要手动添加if/else，在添加一种功能时， 要对所有的状态进行判断。因此代码会变得越 来越臃肿，并且一旦没有处理某个状态，便会 发生极其严重的BUG，难以维护</p><h3 id="解释器设计模式"><a href="#解释器设计模式" class="headerlink" title="解释器设计模式"></a>解释器设计模式</h3><ol><li>介绍解释器设计模式是什么? </li><li>画出解释器设计模式的UML类图, 分析设计模式中的各个角色是什 么? </li><li> 请说明Spring的框架中，哪里 使用到了解释器设计模式，并 做源码级别的分析</li><li>解释器模式在Spring框架应用的源码剖析 <ol><li>Spring框架中 SpelExpressionParser就使用到解释器模式 </li><li> 代码分析+Debug源码+模式角色分析说明</li></ol></li></ol><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>单例设计模式一共有几种实现方式？请分别用代码实现，并说明各个实现方式的 优点和缺点? </p><p>单例设计模式一共有8种写法，</p><ol><li>饿汉式 两种 </li><li>懒汉式 三种 </li><li>双重检查</li><li> 静态内部类</li><li>枚举</li></ol><h2 id="2-概述设计模式"><a href="#2-概述设计模式" class="headerlink" title="2.概述设计模式"></a>2.概述设计模式</h2><h3 id="设计模式的重要性-："><a href="#设计模式的重要性-：" class="headerlink" title="设计模式的重要性 ："></a>设计模式的重要性 ：</h3><ol><li>软件工程中，设计模式（design pattern）是对软件设计中<strong>普遍存在（反复出现）</strong> 的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人 在1990年代从建筑设计领域引入到计算机科学的</li><li>大厦 VS 简易房</li><li>拿实际工作经历来说, 当一个项目开发完后，如果<strong>客户提出增新功能</strong>，怎么办?。</li><li>如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (<strong>维护性</strong>[可读性、 规范性]) </li><li>目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中　<font color="red"> <strong>使用过什么 设计模式，怎样使用的，解决了什么问题。</strong></font></li><li>设计模式在软件中哪里？面向对象(oo)=&gt;功能模块[设计模式+算法(数据结构)]=&gt;框 架[使用到多种设计模式]=&gt;架构 [服务器集群] </li><li>如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的.</li></ol><h3 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h3><ol><li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的<strong>松耦合设计而努力</strong></li></ol><h2 id="3-UML类图"><a href="#3-UML类图" class="headerlink" title="3.UML类图"></a>3.UML类图</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>UML——Unified modeling language UML  (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果 </li><li> UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: </li><li>使用UML来建模，常用的工具有 Rational  Rose , 也可以使用一些插件来建模</li></ol><p>画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理， </p><p>UML图分类：</p><ol><li>用例图(use case) </li><li>静态结构图：类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li></ol><p>UML类图：</p><ol><li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li><li> 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合</li><li>依赖：只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编 绎都通过不了<br>小结<ol><li>类中用到了对方</li><li>如果是类的成员属性 </li><li> 如果是方法的返回类型</li><li>是方法接收的参数类型 </li><li>方法中使用到</li></ol></li><li>泛化：泛化关系实际上就是继承关系，他是依赖关系的特例<br>小结：<ol><li>泛化关系实际上就是继承关系</li><li> 如果A类继承了B类，我们就说A和B存在泛化关系</li></ol></li><li>实现：实现关系实际上就是A类实现B接口，他是依赖关系的特例</li><li>关联：关联关系实际上就是类与类之间的联系，他是依赖关系的特例 关联具有导航性：即双向关系或单向关系 关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个）， “0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m 个）。 </li><li>聚合：聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。<br>聚 合关系是关联关系的特例，所以他具有关联的导航性与多重性。 如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个 配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</li><li>组合：组合关系：也是整体与部分的关系，但是整体与部分不可以分开。<br>再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。</li></ol><h1 id="2-七大原则"><a href="#2-七大原则" class="headerlink" title="2.七大原则"></a>2.七大原则</h1><h2 id="1-设计模式目的"><a href="#1-设计模式目的" class="headerlink" title="1.设计模式目的"></a>1.设计模式目的</h2><p>编写软件过程中，程序员面临着来自<strong>耦合性、内聚性以及可维护性、可拓展性、重用性、灵活性</strong>等多方面的挑战，设计模式是为了让程序（软件）具有更好的：</p><ol><li>代码重用性 (即：相同功能的代码，不用多次编写) </li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解) </li><li> 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li><li>使程序呈现高内聚，低耦合的特性</li></ol><p>分享金句： </p><ol><li>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计 （OOA/D）的精要”</li><li> Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是 前者手背上有很多伤疤</li></ol><h2 id="2-七大原则-1"><a href="#2-七大原则-1" class="headerlink" title="2.七大原则"></a>2.七大原则</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据）</p><p>七大原则：</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转（倒置）原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特原则</li><li>合成复用原则</li></ol><h2 id="3-单一职责原则"><a href="#3-单一职责原则" class="headerlink" title="3. 单一职责原则"></a>3. 单一职责原则</h2><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><p>对类来说的，即<strong>一个类应该只负责一项职责</strong>。如类A负责两个不同的职责：职责1、职责2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1、A2</p><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>略</p><h4 id="注意事项与细节："><a href="#注意事项与细节：" class="headerlink" title="注意事项与细节："></a>注意事项与细节：</h4><ol><li>降低类的复杂度，一个类只负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则，只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li><li><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140553369.png" alt="image-20210711140553369"></li><li>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法</li><li>按隔离原则优化：将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。</li><li><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711140913112.png" alt="image-20210711140913112"></li></ol><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>依赖倒转原则是指：</p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li><li>依赖倒转的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定得多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不设计任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//客户端无需改变</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">System.out.println(receiver.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h4><p>依赖关系传递的三种方式：</p><ol><li>接口传递</li><li>构造方法传递</li><li>setter方式传递</li></ol><p>注意：</p><ol><li>低层模块尽量有抽象类或接口，或者两者都有，程序稳定性更好</li><li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象之间，就存在一个缓冲层，利于程序的拓展和优化</li><li>继承时遵循里氏替换原则</li></ol><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>OO中的继承性：</p><ol><li>继承包含这样的一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</li><li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承类会给程序带来<strong>侵入性</strong>，程序的可移植性降低，增加对象之间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到的子类的功能都有可能产生故障</li><li>问题提出：<strong>在编程中，如何正确的使用继承？====》里氏替换原则</strong></li></ol><p>基本介绍：</p><ol><li>里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的</li><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，<strong>所有引用积累的地方必须能透明底使用其子类的对象</strong></li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li><li>里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过　<font color="red"> 聚合，组合，依赖 </font>来解决问题</li></ol><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>开闭原则是编程中<strong>最基础、最重要</strong>的设计原则</li><li>一个软件实体如类、模块和函数，应该<strong>对拓展开放（对提供方）</strong>，对<strong>修改关闭（对使用方）</strong>。用抽象构建框架，用实现拓展细节</li><li>当软件需要变化时，尽量通过拓展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li><li>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则</li></ol><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用看看存在的问题</span></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line"><span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">s.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Rectangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Circle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Triangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">OtherGraphic() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类的关系越密切，耦合度越大</li><li>迪米特原则也叫<strong>最少知道原则</strong>，即一个类<strong>对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息</li><li>迪米特原则还有个更简单的定义：只与直接的朋友通信</li><li><strong>直接的朋友</strong>：每个对象都会与其他的对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现<strong>成员变量、方法参数】方法返回值</strong>中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li></ol><h3 id="细节注意"><a href="#细节注意" class="headerlink" title="细节注意"></a>细节注意</h3><ol><li>迪米特原则的核心是降低类之间的耦合</li><li>注意：由于每个类都减少了不必要的依赖，依次迪米特原则只是要求降低类间（对象间）的耦合关系，并不是要求完全没有依赖。</li></ol><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>原则是尽量使用合成、聚合的方式，而不是使用聚合</p><p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210711144757978.png" alt="image-20210711144757978"></p><h1 id="3-二十三种设计模式"><a href="#3-二十三种设计模式" class="headerlink" title="3.二十三种设计模式"></a>3.二十三种设计模式</h1><h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， 模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern） 代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时 间的试验和错误总结出来的。</li><li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂 度。 </li><li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph  Johnson 和 John Vlissides Design（俗称 “四人组 GOF”） </li><li> 设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li></ol><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><p>设计模式分为三种类型，共23种 </p><ol><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。 </li><li> 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。</li></ol><h2 id="单例设计模式-1"><a href="#单例设计模式-1" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类==只能存在一个对象实例==，并且该类只提供一个取得其对象实例的方法（静态方法）。</p><p>比如Hibernate的SessionFactory，它充当数据存储源的代理，并且负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFanctory就够，这就是单例模式</p><p>单例模式的八种方式：</p><ol><li>==饿汉式（静态常量）==</li><li>==饿汉式（静态代码块）==</li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li>==双重检查==</li><li>==静态内部类==</li><li>==枚举==</li></ol><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>步骤：</p><ol><li>构造器私有化（防止new）</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。getInstance</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>优点：这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步的问题</li><li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或其他的静态方法）导致类装载，这时候初始化instance就没有达到Lazy Loading的效果</li><li>结论：这种单例模式==可用，但可能造成内存浪费==。</li></ol><h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ol><li>和和饿汉式（静态常量）类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点同饿汉式（静态常量）</li><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ol><h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ol><li>起到了Lazy Loading的效果，但是只能在单线程下使用</li><li>如果在多线程下，一个线程进入了if（singleton==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不要使用这种方式</li></ol><h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol><li>解决了线程不安全的问题</li><li>效率太低，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得的该类实例，直接return就行了。方法进行同步效率太低</li><li>结论：在实际开发中，不推荐使用这种方式</li></ol><h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步代码块)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol><li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的代码块</li><li>==但是这种同步并不能起到线程同步的作用==。跟第三种实现方式遇到的情形一直，加入一个线程进入if（singleton==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</li><li>结论：在实际开发中，不能使用这种方式</li></ol><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line"><span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><ol><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if（singleton==null）检查，这样就可以保证线程安全了</li><li>这样，实例化代码只用执行一次，后面再次进行访问时，判断if（singleton==null），直接return实例化对象，也避免反复进行方法同步</li><li>线程安全，延迟加载，效率较高</li><li>结论：在实际开发中，推荐使用这种单例设计模式</li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><ol><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程</li><li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li><li>结论：推荐使用</li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">INSTANCE; <span class="comment">//属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ok~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><ol><li>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程的同步问题，而且还能防止反序列化重新创建新的对象</li><li>这种方式是Effective Java作者Josh Bloch提倡的方式</li><li>结论：推荐使用</li></ol><h3 id="单例模式在JDK应用的源码分析"><a href="#单例模式在JDK应用的源码分析" class="headerlink" title="单例模式在JDK应用的源码分析"></a>单例模式在JDK应用的源码分析</h3><ol><li>在JDK中，java.lang.Runtime就是经典的单例模式（饿汉式）</li><li></li></ol><h3 id="单例模式说明"><a href="#单例模式说明" class="headerlink" title="单例模式说明"></a>单例模式说明</h3><ol><li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</li><li>单例模式使用的场景：<ul><li>需要频繁的进行创建和销毁的对象</li><li>创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象</li><li>工具类对象</li><li>频繁访问数据库或文件的对象（比如数据源、Session工厂等）</li></ul></li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护 </p><ol><li>披萨的种类很多(比如 GreekPizz、CheesePizz 等) </li><li>披萨的制作有 prepare，bake, cut, box  </li><li>完成披萨店订购功能。</li></ol><p>传统方式的优缺点：</p><ol><li>优点是比较好理解，简单易操作。 </li><li>缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增 加新功能的时候，尽量不修改代码，或者尽可能少修改代码. </li><li>比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做修改</li><li>改进：<br>分析：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味 着，也需要修改，而创建Pizza的代码，往往有多处。<br>思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该 类就可，其它有创建到Pizza对象的代码就不需要修改了.-&gt; 简单工厂模式</li></ol><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>简单工厂模式是属于创建型模式，是工厂模式的一种。==简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例==。简单工厂模式是工厂模式家族中最简单实用的模式</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）</li><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。</li></ol><h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><ol><li><p>简单工厂模式的设计方案：定义一个可以实例化对象的类，封装创建对象的代码</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式~~&quot;</span>);</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">            <span class="keyword">return</span> pizza;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。</p><p>思路1：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory等，但是考虑到项目规模扩大、以及软件的可维护性、可拓展性，这种方式不是太好</p><p>思路2：使用工厂方法模式</p><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现</li><li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将<strong>对象的实例化推迟到子类</strong></li></ol><h4 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### 抽象工厂模式</span><br><span class="line"></span><br><span class="line">#### 基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 抽象工厂模式：定义了一个<span class="class"><span class="keyword">interface</span>用于创建相关或有依赖关系的对象簇，而无需指明具体的类</span></span><br><span class="line"><span class="class">2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合</span></span><br><span class="line"><span class="class">3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或称为进一步抽象）</span></span><br><span class="line"><span class="class">4. 将工厂抽象成两层，<span class="title">AbsFactory</span>和具体实现的工厂子类。程序员可以根据创建对象使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#### 应用</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">~~~<span class="title">java</span></span></span><br></pre></td></tr></table></figure><h3 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a>工厂模式小结</h3><p>工厂模式在JdK-Calendar中的应用：</p><ul><li>应用了简单工厂模式</li></ul><p>工厂模式意义：</p><ul><li>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的拓展和维护性</li></ul><p>三种工厂模式：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>设计模式的抽象原则：</p><ul><li>创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现interface接口</li><li>不要覆盖基类中已经实现的方法</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>现有一只羊tom，姓名为tom，年龄为1，颜色为白，请编写程序创建和tom羊属性完全相同的10只羊</p><h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><p>分析：</p><ol><li>优点是容易理解，简单易操作</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活</li><li>改进思路：<br>java中Object类是所有类的根类，Object类提供了一个clone（）方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制能力===》原型模式</li></ol><h3 id="原型模式-1"><a href="#原型模式-1" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节</li><li>工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实现创建，即：对象.clone()</li></ol><h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><p>uml图：</p><p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714090836038.png" alt="image-20210714090836038"></p><ol><li>Prototype：原型类，声明一个克隆自己的接口</li><li>ConcretePrototype：具体的原型类，实现一个克隆自己的操作</li><li>Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）</li></ol><h4 id="应用-8"><a href="#应用-8" class="headerlink" title="应用"></a>应用</h4><p>使用原型模式改进传统方式，让程序具有更高的效率和拓展性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 实际应用</span><br><span class="line"></span><br><span class="line">Spring中原型bean的创建，就是 原型模式的应用</span><br><span class="line"></span><br><span class="line">#### 拷贝</span><br><span class="line"></span><br><span class="line">浅拷贝介绍：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象</span><br><span class="line"><span class="number">2.</span> 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</span><br><span class="line"><span class="number">3.</span> 浅拷贝使用默认的clone()方法来实现，例如：sheep=（Sheep）<span class="keyword">super</span>.clone()；</span><br><span class="line"></span><br><span class="line">深拷贝介绍：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 复制对象的所有基本数据类型的成员变量值</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 深拷贝的实现方式<span class="number">1</span>：重写clone方法实现深拷贝</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br></pre></td></tr></table></figure><ol start="4"><li><p>深拷贝的实现方式2：通过对象序列化实现深拷贝（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   ~~~</span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</span><br><span class="line"><span class="number">2.</span> 不用重新初始化对象，而是动态地获得对象运行时的状态</span><br><span class="line"><span class="number">3.</span> 如果原始对象发生变化（增加或者减少属性），其他克隆的对象也会发生相应的变化，无需修改代码</span><br><span class="line"><span class="number">4.</span> 在实现深克隆的时候可能需要比较复杂的代码</span><br><span class="line"><span class="number">5.</span> **缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改器源代码，违背了OCP原则。</span><br><span class="line">   OCP原则：开闭原则，Open Closed Principle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 建造者模式</span><br><span class="line"></span><br><span class="line">### 需求</span><br><span class="line"></span><br><span class="line">盖房项目需求：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 需要建房子：这一过程为打桩、砌墙、封顶</span><br><span class="line"><span class="number">2.</span> 房子有各种各样的，比如普通房、高楼、别墅，各种房子的建造过程虽然一样，但是要求不要相同的</span><br><span class="line"></span><br><span class="line">### 传统方式</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure></li></ol><ol><li>优点是比较好理解，简单易操作</li><li>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，也就是说，这种设计方案，把产品（房子）和创建产品的过程（建造房子的流程）封装在一起，耦合性增强了</li><li>解决方案：将产品和产品建造的过程解耦==》建造者模式</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>建造者模式（Builder Pattern），又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构建出不同表现（属性）的对象</li><li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</li></ol><p>建造者模式的四个角色：</p><ol><li>Product，产品角色：衣蛾具体的产品对象</li><li>Builder，抽象建造者：创建一个Product对象的各个部件指定的接口/抽象类。</li><li>ConcreteBuilder，具体建造者：实现接口，构建和装配各个部件</li><li>Director，指挥者：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</li></ol><p>建造者模式的原理图：</p><p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714093947025.png" alt="image-20210714093947025"></p><h4 id="应用-9"><a href="#应用-9" class="headerlink" title="应用"></a>应用</h4><p>解决盖房子需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">源码应用：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> java.lang.StringBuilder中的建造者模式：</span><br><span class="line">   源码中建造者模式角色分析 ：</span><br><span class="line">   * Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建 造者, 定义了抽象方法 </span><br><span class="line">   *  AbstractStringBuilder 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化 </span><br><span class="line">   *  StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的 实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder</span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 客户端（使用程序）==不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象==</span><br><span class="line"><span class="number">2.</span> 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以方便地替换具体建造者或增加新的具体建造者，==用户使用不同的具体建造者即可得到不同的产品对象==</span><br><span class="line"><span class="number">3.</span> ==可以更加精细地控制产品的创建过程==。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</span><br><span class="line"><span class="number">4.</span> ==增加新的具体建造者无需修改原有库类的代码==，指挥者类针对抽象建造者类编程，系统拓展方便，符合开闭原则。</span><br><span class="line"><span class="number">5.</span> 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，==如果产品之间的差异性很大，则不适合使用建造者模式==，因此其使用范围受到一定的限制</span><br><span class="line"><span class="number">6.</span> 如果产品发内部变化复制，可能会导致需要定义很多具体建造类来实现这种变化，导致系统变得很庞大，因此在这种情况下，需要考虑是否选择建造者模式</span><br><span class="line"><span class="number">7.</span> ==抽象工厂模式VS建造者模式==</span><br><span class="line">   抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而生产一个新产品</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 适配器模式</span><br><span class="line"></span><br><span class="line">#### 基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）</span><br><span class="line"><span class="number">2.</span> 适配器模式属于结构型模式</span><br><span class="line"><span class="number">3.</span> 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</span><br><span class="line"></span><br><span class="line">#### 工作原理</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</span><br><span class="line"><span class="number">2.</span> 从用户的角度看不到被适配者，是解耦的</span><br><span class="line"><span class="number">3.</span> 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</span><br><span class="line"><span class="number">4.</span> 用户收到反馈结果，感觉只是和目标接口交互</span><br><span class="line"></span><br><span class="line">### 类适配器模式</span><br><span class="line"></span><br><span class="line">Adapter类，通过继承src类，实现dst类接口，完成src-》dst的适配</span><br><span class="line"></span><br><span class="line">#### 应用</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol><li>java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定的局限性</li><li>src类的方法在Adapter中都会暴露出来，也增加了使用成本</li><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了</li></ol><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ol><li>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题，即：持有src类，实现dst接口，完成src=》dst的适配</li><li>根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系</li><li>对象适配器模式是适配器模式常用的一种</li></ol><h4 id="应用-10"><a href="#应用-10" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口</span><br><span class="line"><span class="number">2.</span> 使用成本更低，更灵活</span><br><span class="line"></span><br><span class="line">### 接口适配器</span><br><span class="line"></span><br><span class="line">#### 介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一些书籍成为：适配器模式（Default Adapter Pattern）或缺省适配器模式</span><br><span class="line"><span class="number">2.</span> 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每一个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</span><br><span class="line"><span class="number">3.</span> 适用于一个接口不想使用其所有的方法的情况</span><br><span class="line"></span><br><span class="line">#### 应用</span><br><span class="line"></span><br><span class="line">应用实例：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Android中的属性动画ValueAnimator类可以 通过addListener(AnimatorListener listener)方 法添加监听器， 那么常规写法如下：</span><br><span class="line"></span><br><span class="line">   ~~~java</span><br><span class="line">   ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">   valueAnimator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   valueAnimator.start();</span><br></pre></td></tr></table></figure><ol start="2"><li><p>有时候我们不想实现 Animator.AnimatorListener接口的全部方法， 我们只想监听onAnimationStart，我们会如 下写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">valueAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"><span class="comment">//xxxx具体实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">valueAnimator.start();</span><br></pre></td></tr></table></figure></li><li><p> AnimatorListenerAdapter类，就是一个 接口适配器，代码如下:它空实现了 Animator.AnimatorListener类(src)的所 有方法. </p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Animator</span>.<span class="title">AnimatorListener</span></span></span><br><span class="line"><span class="class"><span class="title">Animator</span>.<span class="title">AnimatorPauseListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">//默认实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationPause</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationResume</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>AnimatorListener是一个接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimatorListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序里的匿名内部类就是Listener 具体实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line"><span class="comment">//xxxx具体实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>源码应用：</p><ul><li><p>适配器模式在SpringMVC框架中的应用</p><ol><li><p>SpringMvc中的HandlerAdapter, 就使用了适配器模式</p></li><li><p>SpringMVC处理请求的流程</p></li><li><p>使用HandlerAdapter的原因分析：<br>可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么 如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则</p></li><li><p>代码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">     ~~~</span><br><span class="line"></span><br><span class="line">  <span class="number">5.</span> SpringMVC通过适配器设计模式获取到对应的Controller的源码</span><br><span class="line"></span><br><span class="line">  <span class="number">6.</span> 说明</span><br><span class="line"></span><br><span class="line">     * Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</span><br><span class="line">     * 适配器代替controller执行相应的方法</span><br><span class="line">     * 扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 三种命名方式，是根据src是以怎样的形式给到Adapter来命名的</span><br><span class="line"><span class="number">2.</span> 类适配器：以类给到，在Adapter里，就是将src当作类，继承</span><br><span class="line">   对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有</span><br><span class="line">   接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</span><br><span class="line"><span class="number">3.</span> Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作</span><br><span class="line"><span class="number">4.</span> 实际开发中，实现起来不拘泥这三种经典模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 桥接模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">传统方案解决手机操作问题分析：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 拓展性问题（类爆炸），如果我们增加手机的样式，则需要增加各个品牌手机的类。同理，如果增加一个手机品牌，也要在各个手机样式类下增加。</span><br><span class="line"><span class="number">2.</span> 违反了单一职责原则，当我们增加手机样式时，需要同时增加所有品牌的手机，这样增加了代码维护成本</span><br><span class="line"><span class="number">3.</span> 解决方案：使用桥接模式</span><br><span class="line"></span><br><span class="line">### 基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 桥接模式（Bridge模式）是指：将实现与抽象放在两个不同的类层中，使两个层次可以独立改变</span><br><span class="line"><span class="number">2.</span> 是一种结构型设计模式</span><br><span class="line"><span class="number">3.</span> Bridge模式基于类的最小设计原则通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是吧抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line">![image-<span class="number">20210714124346974</span>](<span class="number">2021</span>-<span class="number">07</span>-<span class="number">11</span>-DesignPatterns/image-<span class="number">20210714124346974.</span>png)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Client类：桥接模式的调用者</span><br><span class="line"><span class="number">2.</span> 抽象类（abstraction）：维护了Implementor，即它的实现类ConcreteImplemenetorA……，二者是聚合关系，Abstraction充当桥接类</span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">解决手机问题：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>桥接模式在JDBC源码应用</p><ol><li>jdbc的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle得到Driver，这些就可以当作实现接口类</li></ol><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol><li>桥接模式实现了抽象和实现部分的分离，从而极大提高了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他部分有具体业务来完成。</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li><li>桥接模式的引入增加了系统的理解和设计难度由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样发应用场景。</li></ol><p>桥接模式的其他应用场景：</p><ol><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</li><li>常见的应用场景<ul><li>JDBC驱动程序</li><li>银行转账系统<br>转账分类、转账用户类型</li><li>消息管理<br>消息类型、消息分类</li></ul></li></ol><h2 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>星巴克咖啡订单项目（咖啡馆）：</p><ol><li>咖啡种类</li><li>调料</li><li>要求在拓展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li><li>使用OO来计算不同种类咖啡的费用，可以单点，也可以咖啡+调料</li></ol><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>装饰者模式：动态将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><h3 id="应用-11"><a href="#应用-11" class="headerlink" title="应用"></a>应用</h3><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h3 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系</li><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次</li><li>这种类型的设计模式属于结构型模式</li><li>组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</li></ol><h3 id="应用-12"><a href="#应用-12" class="headerlink" title="应用"></a>应用</h3><h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol><li>简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题</li><li>具有较强的扩展性，当我们需要更改组合对象时，我们只需要调整内部的层次关系，客户端不需要作出任何改动</li><li>方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构</li><li>需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式</li><li>要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ol><li>外观模式（Facade)，也叫“过程模式”，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li><li>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节</li></ol><h3 id="应用-13"><a href="#应用-13" class="headerlink" title="应用"></a>应用</h3><h3 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h3><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低利率客户端对子系统的复杂性</li><li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li><li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li><li>当系统需要进行分层设计时，可以考虑使用Facade模式</li><li>在维护一个遗留的大型项目时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</li><li>不能过多的或不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要让系统有层次，利于维护为目的</li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>小型外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p><ol><li>有客户要求以新闻的形式发布</li><li>有客户要求以博客的形式发布</li><li>有客户希望以微信公众号的形式发布</li></ol><h3 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h3><ol><li>直接复制粘贴一份，然后根据不同的要求，进行定制修改</li><li>给每一个网站租用一个空间</li><li>方案设计示意图</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol><li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器资源的浪费</li><li>解决思路：整合到一个网站中，共享器相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都是可以达成共享，减少服务器资源</li><li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li><li>即：享元模式</li></ol><h3 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似的对象，需要缓冲池时。不需要总是创建新的对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>享元模式经典的应用场景就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li></ol><p>原理图：</p><h4 id="内部状态和外部状态"><a href="#内部状态和外部状态" class="headerlink" title="内部状态和外部状态"></a>内部状态和外部状态</h4><ol><li>享元模式提出了两个需求：细粒度和共享对象。即将对象的信息分为两个部分：内部状态和外部状态</li><li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li><li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li></ol><h3 id="应用-14"><a href="#应用-14" class="headerlink" title="应用"></a>应用</h3><p>解决网站问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">享元模式在JDK-Interger中的应用：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 在享元模式这样理解，“享”就表示共享，“元”表示对象</span><br><span class="line"><span class="number">2.</span> 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</span><br><span class="line"><span class="number">3.</span> 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储</span><br><span class="line"><span class="number">4.</span> 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</span><br><span class="line"><span class="number">5.</span> 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是使用享元模式时需要注意的</span><br><span class="line"><span class="number">6.</span> 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</span><br><span class="line"><span class="number">7.</span> 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 代理模式</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能</span><br><span class="line"><span class="number">2.</span> 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</span><br><span class="line"><span class="number">3.</span> 代理模式有不同发形式，主要有三种：静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态创建对象，而不需要实现接口，它是属于动态代理的范畴）</span><br><span class="line"><span class="number">4.</span> 代理模式示意图</span><br><span class="line"></span><br><span class="line">### 静态代理</span><br><span class="line"></span><br><span class="line">静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象与代理对象一起实现相同的接口或者是继承相同父类</span><br><span class="line"></span><br><span class="line">#### 应用实例：</span><br><span class="line"></span><br><span class="line">具体要求：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 定义一个接口：ITeacherDao</span><br><span class="line"><span class="number">2.</span> 目标对象TeacherDao实现接口ITeacherDao</span><br><span class="line"><span class="number">3.</span> 使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao</span><br><span class="line"><span class="number">4.</span> 调用的时候，通过调用代理对象的方法来调用目标对象</span><br><span class="line"><span class="number">5.</span> 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><h4 id="分析静态代理"><a href="#分析静态代理" class="headerlink" title="分析静态代理"></a>分析静态代理</h4><ol><li>优点：在不修改目标对象的功能前提下，能通过dialing对象实现对目标功能扩展</li><li>缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类</li><li>一旦接口增加方法，目标对象与代理对象都需要维护</li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>动态代理模式的基本介绍</p><ol><li>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li><li>动态代理也叫做：JDK代理、接口代理</li></ol><p>JDK中生成代理对象的API</p><ol><li><p>代理类所在的包：java.lang.reflect.Proxy</p></li><li><p>JDK实现代理只需要使用newProxyInstence方法，但是该方法需要接受三个参数，完整的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] </span></span></span><br><span class="line"><span class="params"><span class="function">interfaces,InvocationHandler h )</span></span></span><br></pre></td></tr></table></figure></li></ol><h4 id="应用-15"><a href="#应用-15" class="headerlink" title="应用"></a>应用</h4><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### Cglib代理</span><br><span class="line"></span><br><span class="line">#### 介绍</span><br><span class="line"></span><br><span class="line">Cglib代理模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理</span><br><span class="line"><span class="number">2.</span> Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展，有些书也将Cglib代理归属到动态代理</span><br><span class="line"><span class="number">3.</span> Cglib是一个强大的高性能代码生成包，它可以运行期扩展java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP ，实现方法拦截</span><br><span class="line"><span class="number">4.</span> 在AOP编程中如何选择代理模式：</span><br><span class="line">   * 目标对象需要实现接口，用JDK代理</span><br><span class="line">   * 目标对象不需要实现接口，用Cglib代理</span><br><span class="line"><span class="number">5.</span> Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</span><br><span class="line"></span><br><span class="line">#### 实现</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 需要引入Cglib的jar文件</span><br><span class="line"><span class="number">2.</span> 在内存中动态构建子类，注意代理的类不能为<span class="keyword">final</span>，否则报错。因为<span class="keyword">final</span>类不能被继承，也就没有子类</span><br><span class="line"><span class="number">3.</span> 目标对象的方法如果为<span class="keyword">final</span>、<span class="keyword">static</span>，那么就不会被拦截，即不会执行目标对象额外的业务方法</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><h3 id="代理变体"><a href="#代理变体" class="headerlink" title="代理变体"></a>代理变体</h3><p>几种常见的代理模式变体</p><ol><li>防火墙代理：内网通过代理穿透防火墙，实现对公网的访问</li><li>缓存代理：比如，当请求图片文件等资源时，先到缓存代理取，如果取到资源则OK，如果取不到资源，再到公网或者数据库取，然后缓存</li><li>远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</li><li>同步代理：主要使用在多线程编程中，完成多线程间同步工作</li></ol><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><p>编写制作豆浆的程序：</p><ol><li> 制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li><li> 通过添加不同的配料，可以制作出不同口味的豆浆</li><li> 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li></ol><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><ol><li>模板方法模式（Template Method Pattern），又叫模板方法模式（Template Pattern），在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需求重写方法实现，但调用将以抽象类中定义的方式进行</li><li>简单来说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li><li>这种类型的设计模式属于行为型模式</li></ol><p>原理：</p><p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714174633658.png" alt="image-20210714174633658"></p><p>说明：</p><ul><li>AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨 架，具体子类需要去实现 其它的抽象方法operationr2,3,4 </li><li> ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步 骤</li></ul><h3 id="应用-16"><a href="#应用-16" class="headerlink" title="应用"></a>应用</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">#### 模板方法模式中的钩子方法</span><br><span class="line"></span><br><span class="line">* 在模板方法模式的父类中，我们可定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><p>模板方法模式在Spring框架中的应用：</p><p>Spring IOC容器初始化时运行用到的模板方法模式</p><h3 id="细节-4"><a href="#细节-4" class="headerlink" title="细节"></a>细节</h3><p>模板方法模式的注意事项和细节</p><ol><li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li><li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用</li><li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现</li><li>该模式的不足之处：每一个不同的实现类都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li><li>一般模板方法都加上final关键字，防止子类重写模板方法</li><li>模板方法的使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤方法基本相同，但其个别步骤在实现时，可能不同。通常考虑模板方法模式来处理</li></ol><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><ol><li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就 可以控制对这些家电工作。 2</li><li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个App，分别控制，我 们希望只要一个app就可以控制全部智能家电。 </li><li>要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口 给app调用，这时 就可以考虑使用命令模式。</li><li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li><li> 在我们的例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品</li></ol><h3 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>命令模式基本介绍</p><ol><li>命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪一个<br>我们只知道在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li><li>命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦</li><li>在命令模式中会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作</li><li>通俗易懂的理解：将军发布命令，士兵去执行，其中将军就是命令发布者，士兵便是具体执行者，其中命令连接了将军和士兵</li></ol><p>原理图：<br><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714183617841.png" alt="image-20210714183617841"></p><p>说明：</p><ol><li> Invoker 是调用者角色 </li><li> Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类 </li><li>Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作</li><li>ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute</li></ol><h3 id="应用-17"><a href="#应用-17" class="headerlink" title="应用"></a>应用</h3><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">* 命令模式在Spring框架JdbcTemplate中使用</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">命令模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的excute（）方法就可以让接受者工作，而不必知道具体的接受者对象是谁、是如何实现的，命令对象起到了纽带桥梁的作用</span><br><span class="line"><span class="number">2.</span> 容易设计一个命令队列，只要把命令对象放到队列就可以多线程的执行命令</span><br><span class="line"><span class="number">3.</span> 容易实现对请求的销毁和重做</span><br><span class="line"><span class="number">4.</span> 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候需要注意</span><br><span class="line"><span class="number">5.</span> 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们没按下一个按键都需要判空，这给我们编码带来了一定的麻烦</span><br><span class="line"><span class="number">6.</span> 命令模式经典的应用场景：界面的每一个按钮都是一条命令、模拟CMD（DOS命令）、订单的撤销/恢复、触发-反馈机制</span><br><span class="line"></span><br><span class="line">## 访问者模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">测评系统：</span><br><span class="line"></span><br><span class="line">* 将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对 该歌手不同的评价(评价 有不同的种类，比如 成功、失败 等)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">访问者模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</span><br><span class="line"><span class="number">2.</span> 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</span><br><span class="line"><span class="number">3.</span> 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口</span><br><span class="line"><span class="number">4.</span> 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210714185223773</span>](<span class="number">2021</span>-<span class="number">07</span>-<span class="number">11</span>-DesignPatterns/image-<span class="number">20210714185223773.</span>png)</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作 </span><br><span class="line"><span class="number">2.</span> ConcreteVisitor ：是一个具体的访问值 实现每个有Visitor 声明的操作，是每个操作实现的部分. </span><br><span class="line"><span class="number">3.</span>  ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素 </span><br><span class="line"><span class="number">4.</span>  Element 定义一个accept 方法，接收一个访问者对象</span><br><span class="line"><span class="number">5.</span> ConcreteElement 为具体元素，实现了accept 方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>上面提到了双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。 双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型 </li><li> 以上述实例为例，假设我们要添加一个Wait的状态类，考察Man类和Woman类的反 应，由于使用了双分派，只需增加一个Action子类即可在客户端调用即可，不 需要改动任何其他类的代码。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>访问者模式的注意事项和细节</p><p>优点：</p><ol><li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常该</li><li>访问者模式可以对功能进行统一，可以做报表、UI、拦截器和过滤器，适用于数据结构相对稳定的系统</li></ol><p>缺点：</p><ol><li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难</li><li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li></ol><p>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><p>编写程序展示一个学校院系结构：</p><ul><li>要在一个页面中展示出学校的院系组成</li><li>一个学校有一个学院</li><li>一个学院有多个系</li></ul><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>迭代器模式基本介绍</p><ol><li>迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式</li><li>如果我们的集合元素是用不同的方法实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候，就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑用迭代器模式解决</li><li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构</li></ol><p>原理图：</p><p><img src="/2021/07/11/tools-2021-07-11-DesignPatterns/image-20210714190551112.png" alt="image-20210714190551112"></p><p>说明：</p><ol><li>Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove</li><li>ConcreteIterator : 具体的迭代器类，管理迭代 </li><li>Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦</li></ol><h3 id="应用-18"><a href="#应用-18" class="headerlink" title="应用"></a>应用</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体实例：</span><br><span class="line"></span><br><span class="line">迭代器模式在JDK-ArrayList集合中的应用</span><br><span class="line"></span><br><span class="line">* JDK的ArrayList集合中就使用了迭代器模式</span><br><span class="line"></span><br><span class="line">分析</span><br><span class="line"></span><br><span class="line">* 内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类 </span><br><span class="line">* List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象 </span><br><span class="line">* ArrayList 是实现聚合接口List 的子类，实现了iterator() </span><br><span class="line">* Iterator 接口系统提供 </span><br><span class="line">*  迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">迭代器模式的注意事项和细节</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了</span><br><span class="line"><span class="number">2.</span> 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成</span><br><span class="line"><span class="number">3.</span> 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做==单一责任原则==）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来，集合改变的话，只会影响到聚合对象。如果遍历方式改变的话，只影响到了迭代器</span><br><span class="line"><span class="number">4.</span> 当要展示一组相似的对象，或者遍历一组相同对象时使用，适合使用迭代器模式</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 每个聚合对象都要一个迭代器，会产生多个迭代器，不好管理类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 观察者模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">天气预报项目需求,：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如 发布到自己的网站或第三方)。 </span><br><span class="line"><span class="number">2.</span> 需要设计开放型API，便于其他第三方也能接入气象站获取数据。 </span><br><span class="line"><span class="number">3.</span>  提供温度、气压和湿度的接口</span><br><span class="line"><span class="number">4.</span> 测量数据更新时，要能实时的通知给第三方</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject， 依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是 Subject，是<span class="number">1</span>的一方。用户时Observer，是多的一方</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除 和通知。 </span><br><span class="line"><span class="number">2.</span>  这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核 心类WeatherData不会修改代码，遵守了ocp原则。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><p>实例应用：</p><ul><li>jdk的Observable类就使用了观察者模式</li></ul><p>分析：</p><ol><li>Observable 的作用和地位等价于 我们前面讲过Subject </li><li> Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer 的方法 add.. delete .. notify… </li><li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有update </li><li>Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是 类，通过继承来实现观察者模式</li></ol><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h3><p>智能家庭项目： </p><ol><li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等 </li><li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流 程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li></ol><p>传统的方式的问题分析 ：</p><ol><li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂 </li><li> 各个电器对象彼此联系，你中有我，我中有你，不利于松耦合. </li><li> 各个电器对象之间所传递的消息(参数)，容易混乱 </li><li> 当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性 都不理想  考虑中介者模式</li></ol><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>中介模式基本介绍</p><ol><li>中介模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互性</li><li>中介者模式属于行为模式，使代码易于维护</li><li>比如MVC模式，C(Controller控制器)是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用</li></ol><p>原理图：</p><p>说明：</p><ol><li>Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口 </li><li> Colleague 是抽象同事类</li></ol><h3 id="应用-19"><a href="#应用-19" class="headerlink" title="应用"></a>应用</h3><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">中介者模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 多个类相互耦合，会形成网状结构，使用中介者模式，将网状结构分离为星型结构，进行解耦</span><br><span class="line"><span class="number">2.</span> 减少类间依赖，降低了耦合，符合迪米特原则</span><br><span class="line"><span class="number">3.</span> 中介者承担了较多的责任，一旦中介者出了问题，整个系统都会受到影响</span><br><span class="line"><span class="number">4.</span> 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</span><br><span class="line"></span><br><span class="line">## 备忘录模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">游戏角色状态恢复问题： </span><br><span class="line"></span><br><span class="line">游戏角色有攻击力和防御力，在大战Boss前保存自身的状态(攻击力和防御力)，当大 战Boss后攻击力和防御力下降，从备忘录对象恢复到大战前的状态</span><br><span class="line"></span><br><span class="line">传统的方式的问题分析 ：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不 利于管理，开销也很大. </span><br><span class="line"><span class="number">2.</span>  传统的方式是简单地做备份，<span class="keyword">new</span>出另外一个对象出来，再把需要备份的数据放到 这个新对象，但这就暴露了对象内部的细节 </span><br><span class="line"><span class="number">3.</span>  解决方案： =&gt; 备忘录模式</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">备忘录模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持这个状态。这样以后就可以将该对象恢复到原先保存的状态</span><br><span class="line"><span class="number">2.</span> 理解：现实生活中备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</span><br><span class="line"><span class="number">3.</span> 备忘录模式属于行为模式</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> originator : 对象(需要保存 状态的对象) </span><br><span class="line"><span class="number">2.</span>  Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态 </span><br><span class="line"><span class="number">3.</span> Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效 率 </span><br><span class="line"><span class="number">4.</span> 说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要 要 HashMap  </span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>备忘录模式注意事项和细节</p><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li><li>实现了信息的封装，使得用户不必关系状态的保存细节</li><li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意</li><li>适用的场景：<ul><li>后悔药</li><li>打游戏时的存档</li><li>windows里的ctrl+z</li><li>ie中的后退</li><li>数据库的事务管理</li></ul></li><li>为了节约内存，备忘录模式可以和原型模式配合适用</li></ol><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h3><p>通过解释器模式来实现四则运算</p><ol><li>先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复</li><li>在分别输入a ,b, c, d, e 的值 </li><li> 最后求出结果</li></ol><p>传统方案解决四则运算问题分析 ：</p><ol><li>编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果 </li><li>问题分析：如果加入新的运算符，比如 * / ( 等等，不利于扩展，另外让一个方法来 解析会造成程序结构混乱，不够清晰. </li><li> 解决方案：可以考虑使用解释器模式， 即： 表达式 -&gt; 解释器(可以有多种) -&gt; 结 果</li></ol><h3 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li><li>解释器模式（Interpreter Pattern）：是指给一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）</li><li>应用场景：<ul><li>应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li><li>一些重复出现的问题可以用一种简单的语言来表示</li><li>一个简单语法需要解释的场景</li></ul></li><li>更多：编译器、运算表达式、正则表达式、机器人等</li></ol><p>原理图：</p><p>说明：</p><ol><li>Context: 是环境角色,含有解释器之外的全局信息. </li><li> AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所 共享</li><li>TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作</li><li>NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作. </li><li>说明： 输入Context he TerminalExpression 信息通过Client 输入即可</li></ol><h3 id="应用-20"><a href="#应用-20" class="headerlink" title="应用"></a>应用</h3><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实际应用：</span><br><span class="line"></span><br><span class="line">* Spring框架中SpelExpressionParser就使用到解释器模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">解释器模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 当有一个语言需要解释器执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，这让程序具有良好的扩展性</span><br><span class="line"><span class="number">2.</span> 应用场景：编译器、运算表达式计算、正则表达式、机器人等</span><br><span class="line"><span class="number">3.</span> 使用解释器可能会带来的问题：</span><br><span class="line">   * 解释器模式会引起类膨胀</span><br><span class="line">   * 解释器模式采用递归调用方法，将会导致调试非常复杂</span><br><span class="line">   * 效率可能降低</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 状态模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">APP抽奖活动问题</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 假如每参加一次这个活动要 扣除用户<span class="number">50</span>积分，中奖概率 是<span class="number">10</span>% </span><br><span class="line"><span class="number">2.</span>  奖品数量固定，抽完就不能 抽奖 </span><br><span class="line"><span class="number">3.</span> 活动有四个状态: 可以抽奖、 不能抽奖、发放奖品和奖品 领完 </span><br><span class="line"><span class="number">4.</span> 活动的四个状态转换关系图</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20210714200011180</span>](<span class="number">2021</span>-<span class="number">07</span>-<span class="number">11</span>-DesignPatterns/image-<span class="number">20210714200011180.</span>png)</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">状态模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以互相转换</span><br><span class="line"><span class="number">2.</span> 当一个对象的内在状态发生改变时，允许改变其行为，这个对象看起来好像是改变了其类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Context 类为环境角色, 用于维护State实例,这个实例定义当前状态 </span><br><span class="line"><span class="number">2.</span> State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为</span><br><span class="line"><span class="number">3.</span> ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><p>应用实例：</p><p>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的 状态, 项目中的这个模块实现就会使用到状态模式</p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>状态模式的注意事项和细节</p><ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li><li>方便维护。将容易产生问题的if-else的语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li><li>符合开闭原则。容易增删状态</li><li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多的类，加大维护难度</li><li>应用场景：当一个事件或者对象有很多种状态，状态之间会互相转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式</li></ol><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h3><p>鸭子项目：</p><ol><li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等) </li><li>显示鸭子的信息</li></ol><p>传统方式：</p><ol><li>其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的</li><li>上面说的1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改 动，会影响其他部分。会有溢出效应 </li><li> 为了改进1问题，我们可以通过覆盖fly 方法来解决 =&gt; 覆盖解决 </li><li> 问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要ToyDuck去覆盖Duck 的所有实现的方法 </li><li>解决思路 策略模式 (strategy pattern)</li></ol><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>策略模式基本介绍</p><ol><li>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</li><li>这种算法体现了几个设计原则：<ol><li>把变化的代码从不变的代码中分离出来</li><li>针对接口编程而不是具体类（定义了策略接口）</li><li>多用组合/聚合，少用继承（客户通过组合方式使用策略）</li></ol></li></ol><p>原理图：</p><h3 id="应用-21"><a href="#应用-21" class="headerlink" title="应用"></a>应用</h3><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">* JDK的Arrays的Comparator就使用了策略模式</span><br><span class="line"></span><br><span class="line">### 注意</span><br><span class="line"></span><br><span class="line">策略模式的注意事项和细节</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 策略模式的关键是：分析项目中变化部分与不变部分</span><br><span class="line"><span class="number">2.</span> 策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性</span><br><span class="line"><span class="number">3.</span> 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或行为）即可，避免了使用多重转移语句（<span class="keyword">if</span>-<span class="keyword">else</span>）</span><br><span class="line"><span class="number">4.</span> 提供了可以替换继承关系的办法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使他易于切换、易于理解、易于扩展</span><br><span class="line"><span class="number">5.</span> 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 职责链模式</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">学校OA系统的采购审批项目：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 采购员采购教学器材 </span><br><span class="line"><span class="number">2.</span> 如果金额 小于等于<span class="number">5000</span>, 由教学主任审批 （<span class="number">0</span>&lt;=x&lt;=<span class="number">5000</span>）</span><br><span class="line"><span class="number">3.</span> 如果金额 小于等于<span class="number">10000</span>, 由院长审批 (<span class="number">5000</span>）</span><br><span class="line"><span class="number">4.</span> 如果金额 小于等于<span class="number">30000</span>, 由副校长审批 (<span class="number">10000</span>&lt;x&lt;=<span class="number">30000</span>)</span><br><span class="line"><span class="number">5.</span> 如果金额 超过<span class="number">30000</span>以上，有校长审批 ( <span class="number">30000</span>&lt;x）</span><br><span class="line"></span><br><span class="line">传统方案解决OA系统审批问题分析：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 传统方式是：接收到一个采购请求后，根据采购金额来调用对应的Approver (审批 人)完成审批。</span><br><span class="line"><span class="number">2.</span> 传统方式的问题分析 : 客户端这里会使用到 分支判断(比如 <span class="keyword">switch</span>) 来对不同的采 购请求处理， 这样就存在如下问题 ：</span><br><span class="line">   <span class="number">1.</span> 如果各个级别的人员审批金额发生变化，在 客户端的也需要变化</span><br><span class="line">   <span class="number">2.</span>  客户端必须明确的知道 有多少个审批级别和访问</span><br><span class="line"><span class="number">3.</span> 这样 对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代 码的扩展和维护</span><br><span class="line"><span class="number">4.</span> 解决方案 =》 职责链模式</span><br><span class="line"></span><br><span class="line">### 介绍</span><br><span class="line"></span><br><span class="line">职责链模式基本介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 责任链模式（Chain Of Responsibility Pattern），又叫责任链模式，为请求创建了一个接受者对象的链。这种模式对请求的发送者和接受者进行解耦</span><br><span class="line"><span class="number">2.</span> 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接受者，依此类推</span><br><span class="line"><span class="number">3.</span> 这种类型的设计模式属于行为型模式</span><br><span class="line"></span><br><span class="line">原理图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler </span><br><span class="line"><span class="number">2.</span> ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处 理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链 </span><br><span class="line"><span class="number">3.</span> Request ， 含义很多属性，表示一个请求</span><br><span class="line"></span><br><span class="line">### 应用</span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"></span><br><span class="line">~~~java</span><br></pre></td></tr></table></figure><p>实例：</p><ul><li>SpringMVC-HandlerExecutionChain 类就使用到职责链模式</li></ul><p>说明：</p><ol><li>springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等 </li><li>在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式</li><li>HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不 处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责 链本身与处理逻辑之间的耦合,规范了处理流程 </li><li>HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应 的拦截器.</li></ol><h3 id="细节-5"><a href="#细节-5" class="headerlink" title="细节"></a>细节</h3><p>职责链模式的注意事项和细节</p><ol><li>将请求和处理分开，实现解耦，提高系统的灵活性</li><li>简化了对象，使对象不需要知道链的结构</li><li>性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext（）方法中判断是否已经超过阈值，超过则不允许该链的建立，避免出现超长链无意识地破坏系统性能</li><li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、java Web中tomcat对encoding的处理、拦截器</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul><li>有一点需要说明：设计模式是程序员在编程中，有意或者是无意使用到的(也不是 所有的程序员都学习过设计模式)，并且同一种设计模式实现方式也不是100%的一 样，设计模式主要是提高程序的扩展性，可读性，可维护性、规范性。</li><li> 对于框架源码，源码中部分使用了A设计模式，还部分使用了B设计模式，也是有 可能的，也就是说设计模式是可以结合使用的</li><li>因为设计模式主要是一种编程思想，既然是思想，具体实现方式，就不可能100% 的一样(当然，程序的设计结构基本是一样的)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;h2 id=&quot;1-经典面试题&quot;&gt;&lt;a href=&quot;#1-经典面试题&quot; class=&quot;headerlink&quot; title=&quot;1.经</summary>
      
    
    
    
    <category term="工具" scheme="https://stary1999.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="java" scheme="https://stary1999.github.io/tags/java/"/>
    
    <category term="工具" scheme="https://stary1999.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vue的使用(入门)</title>
    <link href="https://stary1999.github.io/2021/07/10/language-2021-07-10-vue/"/>
    <id>https://stary1999.github.io/2021/07/10/language-2021-07-10-vue/</id>
    <published>2021-07-10T13:09:01.000Z</published>
    <updated>2021-07-16T08:08:12.396Z</updated>
    
    
    
    
    <category term="框架" scheme="https://stary1999.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="https://stary1999.github.io/tags/vue/"/>
    
    <category term="前端" scheme="https://stary1999.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb</title>
    <link href="https://stary1999.github.io/2021/07/10/java-2021-07-10-JavaWeb/"/>
    <id>https://stary1999.github.io/2021/07/10/java-2021-07-10-JavaWeb/</id>
    <published>2021-07-10T13:07:37.000Z</published>
    <updated>2021-07-10T13:07:37.544Z</updated>
    
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE</title>
    <link href="https://stary1999.github.io/2021/07/10/java-2021-07-10-JavaSE/"/>
    <id>https://stary1999.github.io/2021/07/10/java-2021-07-10-JavaSE/</id>
    <published>2021-07-10T13:06:37.000Z</published>
    <updated>2021-07-26T03:17:00.227Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/07/10/java-2021-07-10-JavaSE/image-20210724210903383.png" alt="image-20210724210903383"></p><p>提示 短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，从而提高效率。在实际编程<br>时，应该优先考虑使用短路与和短路或。</p><p><img src="/2021/07/10/java-2021-07-10-JavaSE/image-20210724210936096.png" alt="image-20210724210936096"></p><p>其他运算符<br>除了前面介绍的主要运算符，Java还有一些其他运算符。<br>三元运算符（? :）。例如x?y:z;，其中x、y和z都为表达式。<br>小括号。起到改变表达式运算顺序的作用，它的优先级最高。<br>中括号。数组下标。<br>引用号（.）。对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作<br>符。<br>赋值号（=）。赋值是用等号运算符（=）进行的。<br>instanceof。判断某个对象是否为属于某个类。<br>new。对象内存分配运算符。<br>箭头（-&gt;）。Java 8新增加的，用来声明Lambda表达式。<br>双冒号（::）。Java 8新增加的，用于Lambda表达式中方法的引用。</p><p>二元运算符计算顺序从左向右，但是先级15的赋值运算符的计算顺序从右<br>向左的</p><p>不规则数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> intArray[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][]; <span class="comment">//先初始化高维数组为4</span></span><br><span class="line"><span class="comment">//逐一初始化低维数组</span></span><br><span class="line">intArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">intArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">intArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">intArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; intArray[i].length; j++) &#123;</span><br><span class="line">intArray[i][j] = i + j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for-each循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : intArray) &#123; ①</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> column : row) &#123; ②</span><br><span class="line">System.out.print(column);</span><br><span class="line"><span class="comment">//在元素之间添加制表符，</span></span><br><span class="line">System.out.print(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一行元素打印完成后换行</span></span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(intArray[0][2]); //发生运行期错误 ③</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空字符串不是null，空字符串是分配内存空间，而null是没有分配内存空间。</p><p>不可变字符串和可变字符串，它们区别在于当字符串进行拼接等修改操作时，不可变字符串会创建新的字符串对象，而可变字符串不会创建新对象。</p><p>Java中不可变字符串类是String</p><p>java.lang包中的类时不需要引入（import）该包，因为它是由解释器自动引入的。</p><p>==运算符比较的是两个引用是否指向相同的对象</p><p>Java中的不可变字符串String常量，采用字符串池（String Pool）管理技术，字符串池是一种字符串驻留技术。采用字符串常量赋值时，会字符串池中查<br>找”Hello”字符串常量，如果已经存在把引用赋值给s9，否则创建”Hello”字符串对象，并放到池中。但此原理并不适用于new所创建的字符串对象，代码运行到第①行后，会创建”Hello”字符串对象，而它并没有放到字符串池中。代码第②行又创建了一个新的”Hello”字符串对象，s7和s8是不同的引用，指向不同的对象。</p><p>String 拼接只是会产生一个新的对象</p><p>可变字符串在追加、删除、修改、插入和拼接等操作不会产生新的对象。Java提供了两个可变字符串类StringBuffer和StringBuilder，中文翻译为“字符串缓冲区”。</p><p>StringBuffer是线程安全的，它的方法是支持线程同步 ，线程同步会操作串行顺序执行，在单线程环境<br>下会影响效率。StringBuilder是StringBuffer单线程版本，Java 5之后发布的，它不是线程安全的，但它<br>的执行效率很高。</p><p>类体方法声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span> </span>&#123;</span><br><span class="line">[<span class="keyword">public</span> | <span class="keyword">protected</span> | <span class="keyword">private</span> ] [<span class="keyword">static</span>] [<span class="keyword">final</span> | <span class="keyword">abstract</span>] [<span class="keyword">native</span>] [<span class="keyword">synchronized</span>]</span><br><span class="line"><span class="function">type <span class="title">methodName</span><span class="params">([paramList])</span> [<span class="keyword">throws</span> exceptionList] </span>&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个引用变量没有通过new分配内存空间，这个对象就是空对象，</p><p>提示 产生空对象有两种可能性：第一是程序员自己忘记了实例化，第二是空对象是别人传递过来的。程序员必须防止第一种情况的发生，应该仔细检查自己的代码，为自己创建的所有对象进行实例化并初始化。第二种情况需要通过判断对象非null进行避免。</p><p>有时候需要在运行时判断一个对象是否属于某个引用类型，这时可以使用instanceof运算符，instanceof<br>运算符语法格式如下：<br>obj instanceof type</p><p>引用类型可以进行转换，但并不是所有的引用类型都能互相转换，<br>只有属于同一棵继承层次树中的引用类型才可以转换。</p><p>归纳抽象类与接口区别如下：</p><ol><li>接口支持多继承，而抽象类（包括具体类）只能继承一个父类。</li><li>接口中不能有实例成员变量，接口所声明的成员变量全部是静态常量，即便是变量不加public static final修饰符也是静态常量。抽象类与普通类一样各种形式的成员变量都可以声明。</li><li>接口中没有包含构造方法，由于没有实例成员变量，也就不需要构造方法了。抽象类中可以有实例成员变量，也需要构造方法。</li><li>抽象类中可以声明抽象方法和具体方法。Java 8之前接口中只有抽象方法，而Java 8之后接口中也可以声明具体方法，具体方法通过声明默认方法实现。</li></ol><p>提示 学习了接口默认方法后，有些读者还会有这样的疑问，Java 8之后接口可以声明抽象方法和具体方法，这就相当于抽象类一样了吗？在多数情况下接口不能替代抽象类，例如当需要维护一个对象的信息和状态时只能使用抽象类，而接口不行，因为维护一个对象的信息和状态需要存储在实例成员变量中，而接口中不能声明实例成员变量。</p><p>枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WeekDays.java文件</span></span><br><span class="line"><span class="keyword">package</span> com.a51work6;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> </span>&#123;</span><br><span class="line"><span class="comment">// 枚举常量列表</span></span><br><span class="line">MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="comment">//HelloWorld.java文件</span></span><br><span class="line"><span class="keyword">package</span> com.a51work6;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// day工作日变量</span></span><br><span class="line">WeekDays day = WeekDays.FRIDAY; </span><br><span class="line">System.out.println(day); </span><br><span class="line"><span class="keyword">switch</span> (day) &#123; </span><br><span class="line"><span class="keyword">case</span> MONDAY: </span><br><span class="line">System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TUESDAY:</span><br><span class="line">System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> THURSDAY:</span><br><span class="line">System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//case FRIDAY: </span></span><br><span class="line">System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WeekDays.java文件</span></span><br><span class="line"><span class="keyword">package</span> com.a51work6;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> </span>&#123;</span><br><span class="line"><span class="comment">// 枚举常量列表</span></span><br><span class="line">MONDAY(<span class="string">&quot;星期一&quot;</span>, <span class="number">0</span>), TUESDAY(<span class="string">&quot;星期二&quot;</span>, <span class="number">1</span>), WEDNESDAY(<span class="string">&quot;星期三&quot;</span>, <span class="number">2</span>),</span><br><span class="line">THURSDAY(<span class="string">&quot;星期四&quot;</span>, <span class="number">3</span>), FRIDAY(<span class="string">&quot;星期五&quot;</span>, <span class="number">4</span>); </span><br><span class="line"><span class="comment">// 实例变量</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WeekDays</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.index = index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 覆盖父类中的toString()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(name);</span><br><span class="line">sb.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">sb.append(index);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用父类中toString()方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStaticVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> staticVar;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java类引用类型进行比较时，有两种比较方法==和equals，==比较的是两个引用是否指<br>向同一个对象，equals是比较对象内容是否相同。但是，枚举引用类型中==和equals都是一样的，都是比较两个引用是否指向同一个实例，枚举类中每个枚举常量无论何时都只有一个实例</p><p>Java 5之后提供了拆箱(unboxing )功能，拆箱能够将包装类对象自动转换为基本数据类型的数值，而不需要使用intValue()或doubleValue()等方法。类似Java 5还提供了相反功能，自动装箱( autoboxing )，装箱能够自动地将基本数据类型的数值自动转换为包装类对象，而不需要使用构造方法。</p><p>在自动装箱和拆箱时，要避免空对象。试图访问空对象的方法和成员变量，就会抛出运行期NullPointerException异常。</p><p>上述代码第①行~第③行是声明或初始化三个输入流，三条语句放到在try语句后面小括号中，语句之间用分号“;”分隔，这就是自动资源管理技术了，采用了自动资源管理后不再需要finally代码块，不需要自己close这些资源，释放过程交给了JVM。<br>注意 所有可以自动管理的资源需要实现AutoCloseable接口，上述代码中三个输入流<br>FileInputStream、InputStreamReader和BufferedReader从Java 7之后实AutoCloseable接口，具体哪些资源实现AutoCloseable接口需要查询API文档。</p><p>自定义异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123; </span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示 使用join()方法的场景是，一个线程依赖于另外一个线程的运行结果，所以调用另一个线程<br>的join()方法等它运行完成。</p><p>程序员之间的语言之争又未尝不是如此。写系统语言的鄙视托管语言低下的执行效率；写托管语言的则取笑系统语言需要手动管理内存；写动态语言的不屑于静态语言那冗余的类型系统；写静态语言的则嘲讽动态语言里面各种光陆离的运行时错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/07/10/java-2021-07-10-JavaSE/image-20210724210903383.png&quot; alt=&quot;image-20210724210903383&quot;&gt;&lt;/p&gt;
&lt;p&gt;提示 短路与（&amp;amp;&amp;amp;）和短路或（||</summary>
      
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://stary1999.github.io/2021/07/10/tools-2021-07-10-MyBatis/"/>
    <id>https://stary1999.github.io/2021/07/10/tools-2021-07-10-MyBatis/</id>
    <published>2021-07-10T13:06:15.000Z</published>
    <updated>2021-07-10T13:06:15.088Z</updated>
    
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>Spring5</title>
    <link href="https://stary1999.github.io/2021/07/10/java-2021-07-10-Spring5/"/>
    <id>https://stary1999.github.io/2021/07/10/java-2021-07-10-Spring5/</id>
    <published>2021-07-10T13:05:59.000Z</published>
    <updated>2021-07-10T13:05:59.483Z</updated>
    
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="https://stary1999.github.io/2021/07/10/java-2021-07-10-SpringMVC/"/>
    <id>https://stary1999.github.io/2021/07/10/java-2021-07-10-SpringMVC/</id>
    <published>2021-07-10T13:04:41.000Z</published>
    <updated>2021-07-10T13:04:41.674Z</updated>
    
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>java学习路线</title>
    <link href="https://stary1999.github.io/2021/07/06/java-2021-07-06-JavaRoute/"/>
    <id>https://stary1999.github.io/2021/07/06/java-2021-07-06-JavaRoute/</id>
    <published>2021-07-06T00:10:35.000Z</published>
    <updated>2021-07-29T10:51:43.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英格版java全站培训"><a href="#英格版java全站培训" class="headerlink" title="英格版java全站培训"></a>英格版java全站培训</h1><h2 id="javaSE"><a href="#javaSE" class="headerlink" title="javaSE"></a>javaSE</h2><table><thead><tr><th>课程大纲</th><th>课程内容</th><th>备注</th></tr></thead><tbody><tr><td>java语言概述</td><td>1.java编程语言发展简史<br>2.java编程语言主要特性<br>3.java技术体系及开发平台介绍<br>4.java核心机制与JVM运行原理<br>5.搭建java开发环境<br>6.JDK的安装与配置<br>7.开发第一个Java程序<br>8.java程序的执行原理<br>9.字节码反编译（jd-gui.exe、javap）<br>10.变量的声明与使用<br>11.变量内存空间分配与原理<br>12.进制转换与位运算<br>13.八大基本数据类型<br>14.基本数据类型之间的转换<br>15.Eclipse使用<br>16.Idea使用<br>17.变量的运算与底层运算原理<br>18.常见面试题讲解</td><td></td></tr><tr><td>流程控制</td><td>1.java代码的执行流程介绍<br>2.if选择结构<br>3.Scanner键盘录入<br>4.switch选择结构<br>5.使用Random生成随机数<br>6.while循环结构<br>7.do-while循环结构<br>8.for训话结构及执行顺序<br>9.跳转语法：break、continue、return<br>10.多重循环及指定跳出循环<br>11.方法的声明与使用<br>12.方法调用的内存分析<br>13.方法重载Overload</td><td></td></tr><tr><td>数组</td><td>1.数组的创建与使用<br>2.一维数组与多维数组<br>3.数组的默认初始化与内存分析<br>4.数组作为方法形参传递<br>5.数组的遍历操作<br>6.数组的常见算法分析<br>7.操作数组的工具类array<br>8.理解main方法（args)<br>9.方法的可变参数<br>10.使用jar命令打包应用程序<br>11.数组数据结构的优势和劣势分析<br>12.常见的数组面试题讲解</td><td></td></tr><tr><td>面向对象编程（基础）</td><td>1.面向过程和面向对象的区别<br>2.类和对象的概述<br>3.类的属性和方法<br>4.构造方法（construtor）<br>5.创建对象内存分析<br>6.DataType数据类型传递<br>7.this关键字解析<br>8.static关键字详解<br>9.局部代码块、构造代码块和静态代码块<br>10.package和import详解</td><td></td></tr><tr><td>面向对象编程（进阶）</td><td>1.面向对象的三大特性<br>2.面向对象之-封装<br>3.访问权限修饰符<br>4.set和get方法<br>5.javaDoc生成API文档<br>6.面向对象之-继承<br>7.方法重写Override<br>8.supper关键字详解<br>9.继承中对象创建的内存分析<br>10.final关键字详解<br>11.Object类型详解<br>12.面向对象之多态(polymorphism)<br>13.向上转型和向下转型<br>14.instanceof运算符<br>15.编译时和运行时详解<br>16.抽象类和抽象方法<br>17.接口的定义与实现<br>18.接口与抽象类的区别<br>19.接口应用：内部比较器（comparable）<br>20.接口应用：外部比较器comparator<br>21.内部类详解<br>22.java的内存管理与垃圾回收</td><td></td></tr><tr><td>异常机制</td><td>1.异常的概述<br>2.异常的继承体系<br>3.error错误类<br>4.运行时异常和编译时异常<br>5.异常的原理分析<br>6.try-catch-finally捕捉异常<br>7.throw抛出异常<br>8.throws声明异常<br>9.自定义异常</td><td></td></tr><tr><td>java常用类</td><td>1.Wrapper包装类<br>2.自动装箱和自动拆箱<br>3.包装类的缓存分析<br>4.字符串处理类<br>5.java.long.String类的使用与内存原理<br>6.String类的算法分析<br>7.StringBuff与StringBuilder<br>8.java.long.System类<br>9.java.util.Data类<br>10.java.text.SimpleDateFormat类<br>11.java.util.Calendar类<br>12.java.long.Math类<br>13.BigInteger类和BigDecimal类<br>14.常见的面试题讲解与分析</td><td></td></tr><tr><td>集合（容器）</td><td>1.集合和数组的联系与区别<br>2.Collection框架（Set接口与List接口）<br>3.java.util.ArrayList源码与数据结构分析<br>4.java.util.LinkedList源码分析<br>5.java.util.HashSet内部原理<br>6.java.util.TreeSet数据结构分析<br>7.java7中Map系列集合与数据结构分析<br>8.Iterator与ListIterator讲解<br>9.java.util.Collections工具类<br>10.集合中使用泛型<br>11.自定义泛型<br>12.泛型通配<br>13.ArrayList、LinkedList、Vector的区别和联系<br>14.HashMap和Hashtable的区别于联系<br>15.使用集合实现商品和购物车<br>16.集合选择依据</td><td></td></tr><tr><td>IO流</td><td>1.IO流的概念<br>2.IO流的分类及其原理<br>3.文件流InputStream，OutputStream<br>4.缓冲流BufferedOutputStream、BufferedInputStream<br>5.转换流InputStreamReader、OutputStreamWrite<br>6.打印流PrintWrite<br>7.数组流ByteArrayOutputStream、ByteInputStream<br>8.数据流DataInputStream、DataOutputStream<br>9.对象流ObjectInputStream、ObjectOutputStream</td><td></td></tr><tr><td>多线程</td><td>1.线程原理<br>2.线程的创建与启动<br>3.创建线程的集中方式对比<br>4.线程控制<br>5.线程的调度<br>6.线程的优先级<br>7.线程的声明周期<br>8.多线程的安全问题与解决办法<br>9.线程的同步<br>10.互斥锁<br>11.线程的死锁问题<br>12.线程通信</td><td></td></tr><tr><td>XML&amp;正则表达式</td><td>1.XML定义和概述<br>2.XML特点和优势<br>3.XML验证和DTD验证<br>4.使用DTD解析XML<br>5.了解正则表达式的使用<br>6.熟悉正则表达式的规则<br>7.使用Java处理正则</td><td></td></tr><tr><td>反射技术</td><td>1.java反射机制的研究与应用<br>2.反射的原理分析<br>3.JVM与类<br>4.类的价值、连接、初始化<br>5.类的加载机制<br>6.开启反射的源头Class<br>7.获取Class实例的几种方式比较<br>8.从Class中获取类的结构信息<br>9.获取Constructor、Field和Method<br>10.泛型和Class类<br>11.使用反射模拟Servlet获取XML文件信息</td><td></td></tr><tr><td>设计模式</td><td>1.创建型模式（5）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式<br>2.结构型模式（7）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式<br>3.行为型模式（11）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</td><td></td></tr></tbody></table><h2 id="javaWeb基础（数据库"><a href="#javaWeb基础（数据库" class="headerlink" title="javaWeb基础（数据库)"></a>javaWeb基础（数据库)</h2><p>数据库在企业中使用频率极高，几乎每个项目都离不开，此阶段可以应聘DBA职位。数据库是java程序员必会的技术</p><table><thead><tr><th>课程大纲</th><th>课程内容</th><th>备注</th></tr></thead><tbody><tr><td>MySQL基础</td><td>1.MySQL服务器安装与配置<br>2.MySQL客户端使用<br>3.用户权限管理<br>4.SQL语句的类型<br>5.Select单表查询<br>6.排序，聚合查询</td><td></td></tr><tr><td>MySQL进阶</td><td>1.创建和管理表<br>2.约束管理<br>3.DML操作<br>4.内连接查询<br>5.外连接查询<br>6.自连接查询<br>7.子查询<br>8.常用函数<br>9.分页查询</td><td></td></tr><tr><td>连接查询和子查询</td><td>1.SQL92-笛卡尔积<br>2.SQL92-等值连接<br>3.SQL92-非等值连接<br>4.SQL92-外连接<br>5.SQL92-自连接<br>6.SQL99-交叉连接<br>7.SQL99-自然连接<br>8.SQL99-Using连接<br>9.SQL99-内连接<br>10.SQL99-外连接<br>11.单行子查询<br>12.多行子查询</td><td></td></tr><tr><td>数据库对象</td><td>1.用户和权限管理<br>2.数据库表管理<br>3.约束创建和管理<br>4.序列<br>5.索引<br>6.视图<br>7.事务<br>8.分页查询<br>9.导入导出数据<br>10.锁<br>11.事务隔离级别<br>12.游标</td><td></td></tr><tr><td>JDBC</td><td>1.JDBC概述<br>2.使用JDBC完成添加、更新、删除操作<br>3.使用JDBC完成查询操作<br>4.JDBC常用接口<br>5.使用preparedStatement<br>6.数据库访问DBUtils类<br>7.JDBC Template<br>8.连接池</td><td></td></tr><tr><td>JDBC进阶</td><td>1.使用事务执行批处理<br>2.MVC分层开发<br>3.使用properties文件抽取连接参数<br>4.DAO层开发<br>5.使用反射抽取BaseDao接口及实现类<br>6.基于MVC开发员工管理系统<br>7.jdbc template</td><td></td></tr><tr><td>MySQL优化</td><td>1.MySQL架构<br>2.存储引擎<br>3.SQL优化总体思路<br>4.通用查询日志<br>5.错误日志<br>6.二进制文件<br>7.慢查询日志<br>8.执行计划<br>9.索引及其优化策略</td><td></td></tr></tbody></table><h2 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h2><table><thead><tr><th>课程大纲</th><th>课程内容</th><th>备注</th></tr></thead><tbody><tr><td>HTML标签</td><td>1.HTML发展史<br>2.HTML基础标签<br>3.img标签和a标签<br>4.HTML表格标签<br>5.HTML表单标签<br>6.框架和字符实体</td><td></td></tr><tr><td>CSS层叠样式</td><td>1.CSS基础语法<br>2.CSS参考知识（长度单位、颜色单位和路径）<br>3.CSS常见选择器<br>4.CSS背景属性、文本属性和列表属性<br>5.CSS元素分类（块级、行级和行内块级）<br>6.CSS浮动和定位属性<br>7.CSS盒子模型</td><td></td></tr><tr><td>JavaScript</td><td>1.JavaScript概述和特点<br>2.JavaScript和ECMAScript联系<br>3.js基础语法，语句、注释、标识符<br>4.js变量和变量提升<br>5.js数据类型和数据类型转换<br>6.js运算符和流程控制语句<br>7.js数组和字符串<br>8.js函数和韩淑华编程思想<br>9.js对象和面向对象简介<br>10.js常见内置类：Math和Data<br>11.js定时器<br>12.正则表达式</td><td></td></tr><tr><td>jQuery</td><td>1.Jquery简介及快速入门<br>2.JQuery的入口函数<br>3.JQuery选择器<br>4.JQuery事件，事件、事件源和事件驱动程序<br>5.JQuery对象与DOM对象互相转换<br>6.JQuery内容节点操作<br>7.jQuery属性节点操作<br>8.jQuery样式<br>9.jQuery元素节点操作<br>10.jQuery遍历节点和each方法<br>11.jQuery链式语法<br>12.jQuery动画效果和自定义动画</td><td></td></tr><tr><td>bootstrap</td><td>1.bootstrap框架概述与引入<br>2.栅格系统<br>3.全局CSS样式<br>4.组件<br>5.bootstrap插件</td><td></td></tr><tr><td>Vue</td><td>1.Vue基本指令<br>2.Vue基本组件<br>3.Vue动画<br>4.Vue网络请求<br>5.Vue路由设置<br>6.VueX<br>7.Vue第三方组件</td><td></td></tr></tbody></table><h2 id="javaEE"><a href="#javaEE" class="headerlink" title="javaEE"></a>javaEE</h2><table><thead><tr><th>阶段</th><th>课程大纲</th><th>课程内容</th></tr></thead><tbody><tr><td>Tomcat、<br>HTTP</td><td>1.web开发概述<br>2.Tomcat服务器概述<br>3.Tomcat下载、安装、启动<br>4.手动创建静态web应用<br>5.Idea配置Tomcat<br>6.创建web应用及发布和访问<br>7.HTTP介绍<br>8.GET和POST请求的区别<br>9.HTTP请求消息，请求头参数说明<br>10.HTTP响应消息&amp;响应头参数说明&amp;响应码</td><td></td></tr><tr><td>JSP基础</td><td>1.JSP技术介绍<br>2.JSP的优势<br>3.JSP的结构，处理过程<br>4.JSP指令<br>5.JSP动作元素<br>6.JSP隐式对象<br>7.JSP表单处理<br>8.欢迎页配置</td><td></td></tr><tr><td>EL+JSTL</td><td>1.EL介绍与使用<br>2.EL取值原理<br>3.EL隐式对象<br>4.EL逻辑运算<br>5.JSTL核心标签库<br>6.JSTL函数标签库<br>7.JSTL-fmt标签库<br>8.自定义标签</td><td></td></tr><tr><td>Servlet基础</td><td>1.Servlet概述<br>2.Servlet快速入门<br>3.Servlet生命周期<br>4.HttpServletRequest<br>5.HttpServletResponse<br>6.请求转发与重定向的区别</td><td></td></tr><tr><td>会话技术与<br>Servlet域对象</td><td>1.cookie机制<br>2.cookie的创建域使用<br>3.Session原理<br>4.Session失效<br>5.Url重写<br>6.token令牌应用<br>7.Session活化、钝化<br>8.session四大作用域对象</td><td></td></tr><tr><td>文件上传/下载</td><td>1.文件上传原理<br>2.文件上传表单设计<br>3.Servlet3.0文件上传处理<br>4.文件下载原理<br>5.文件下载响应头<br>6.使用IO处理文件下载</td><td></td></tr><tr><td>JSON与Ajax</td><td>1.JSON盖帘及基本结构<br>2.JSON解析-Jsonlib库<br>3.JSON解析-FastJson库<br>4.JSON解析-Gson库<br>5.Ajax作用和技术组成及运用范围<br>6.jQuery-ajax方法<br>7.jQuery-post方法<br>8.jquery-get方法<br>9.Ajax实现用户名唯一性验证<br>10.Ajax实现搜索框自动补全</td><td></td></tr></tbody></table><h2 id="高级框架"><a href="#高级框架" class="headerlink" title="高级框架"></a>高级框架</h2><table><thead><tr><th>课程大纲</th><th>课程内容</th><th>备注</th></tr></thead><tbody><tr><td>MyBatis</td><td>1.Mybatis概述<br>2.Mybatis入门配置<br>3.基本的CRUD操作<br>4.核心配置文件详解<br>5.Mapper.xml基础详解<br>6.模糊查询<br>7.分页的实现及插件PageHelper的使用<br>8.动态sql+sql片段的使用<br>9.一对多、多对一的关系处理<br>10.注解的使用<br>11.一级缓存和二级缓存说明及使用<br>12.generator逆向工程使用</td><td></td></tr><tr><td>Spring</td><td>1.Spring框架介绍<br>2.IOC/DI解耦合及实现原理<br>3.Spring的入门配置<br>4.Spring相关配置详解<br>5.XML方式重构三层结构<br>6.注解方式重构三层结构<br>7.AOP的概述<br>8.代理模式深入理解<br>9.AOP开发（XML）<br>10.AOP开发（注解）<br>11.Spring-jdbc Template<br>12.声明式事务配置及嵌套事务处理</td><td></td></tr><tr><td>SpringMVC</td><td>1.SpringMVC框架介绍<br>2.……<br>13.Spring、SpringMVC和MyBatis整合</td><td></td></tr><tr><td>Git/GitLab</td><td>1.Git的下载与安装<br>2.Git与SVN对比<br>3.Git创建版本库<br>4.Git版本控制<br>5.Git远程仓库<br>6.Git、分支管理<br>7.Git标签管理<br>8.GitLba的下载和安装<br>9.使用GitLab管理版本</td><td></td></tr><tr><td>Maven</td><td>1.Maven的概述<br>2.Maven的下载安装<br>3.eclipse集成Maven插件<br>4.Idea集成maven插件<br>5.Maven常用命令介绍<br>6.Maven创建Java项目<br>7.Maven项目聚合的两种方式<br>8.Maven分项目聚合的设计方式<br>9.Maven创建Web项目<br>10.Maven项目的自动部署配置<br>11.Maven本地Jar包的依赖方式</td><td></td></tr><tr><td>Linux/CentOS</td><td>1.虚拟机介绍和应用场景<br>2.VMware的安装和使用<br>3.linux/centos系统简介<br>4.CentOS系统目录结构<br>5.centOS常用命令<br>6.CentOS安装java<br>7.CentOS安装Tomcat<br>8.CentOS安装MySQL，MySQL主从复制<br>9.linuxShell编程<br>10.linux运维指南</td><td></td></tr><tr><td>Nginx</td><td>1.Nginx的简介与安装<br>2.Nginx的原型图<br>3.Nginx架构模型<br>4.Nginx负载均衡<br>5.Nginx+Vsftpd文件服务器<br>6.Nginx日志切分，备份，分析</td><td></td></tr><tr><td>Zookeeper</td><td>1.Zoopeeper简介与安装<br>2.Zoopeeper概念解释<br>3.Zoopeeper数据模型<br>4.Zoopeeper原生API操作<br>5.ZClient操作Zoopeeper<br>6.使用Zoopeeper实现配置文件中心<br>7.Zoopeeper节点类型<br>8.Zoopeeper分布式锁</td><td></td></tr></tbody></table><h2 id="分布式-微服务"><a href="#分布式-微服务" class="headerlink" title="分布式/微服务"></a>分布式/微服务</h2><table><thead><tr><th>课程大纲</th><th>课程内容</th><th>备注</th></tr></thead><tbody><tr><td>RPC</td><td>1.RMI远程调用<br>2.webService+XML<br>3.HttpClient+JSON<br>4.OkHttpClient+JSON<br>5.JDK动态代理+Socket实现RPC<br>6.Cglib+Netty实现RPC<br>7.RestTemplate<br>8.protobuf序列化</td><td></td></tr><tr><td>Dubbo/<br>Dubbox</td><td>1.Dubbo简介<br>2.Dubbo架构分析<br>3.Dubbo的入门案例<br>4.Dubbo-admin的安装和使用<br>5.Dubbo注册中心<br>6.Dubbo提供者以及配置优化<br>7.Dubbo消费者和配置优化<br>8.Dubbo高可用、Dubbo负载均衡&lt;br /<br>9.Dubbox实现Restful<br>10.Dubbox启动Kryo和FST</td><td></td></tr><tr><td>RabbitMQ</td><td>1.MQ简介和应用场景<br>2.ActiveMQ安装<br>3.ActiveMQ模型分析<br>4.java操作ActiveMQ<br>5.Spring集成ActiveMQ<br>6.JMS操作ActiveMQ<br>7.ActiveMQ持久化设置<br>8.ActiveMQ群集的安装</td><td></td></tr><tr><td>Solr</td><td>1.Solr简介与安装（tomcat）<br>2.Solr和lucene对比<br>3.Solr库创建<br>4.Solr中文分词<br>5.SolrJ操作<br>6.Solr数据导入<br>7.SolrCloud方案和集群搭建<br>8.Solr增量导入</td><td></td></tr><tr><td>Redis</td><td>1.Redis简介与安装<br>2.Redis持久化介绍<br>3.Redis的作用以及数据结构<br>4.Redis穿透和雪崩及其解决方案<br>5.Redis哨兵模式</td><td></td></tr><tr><td>JVM</td><td>1.JVM简介<br>2.JVM组成结构<br>3.JVM堆、栈原理<br>4.JVM垃圾收集机制<br>5.JVM堆内存调优<br>6.垃圾回收策略</td><td></td></tr><tr><td>FastDFS</td><td>1.FastDFS简介与安装<br>2.FastDFS模型分析<br>3.java操作FastDFS<br>4.FastDFS实践</td><td></td></tr><tr><td>SpringBoot</td><td>1.Spring和SpringBoot的对比和介绍<br>2.包扫描实现<br>3.SpringBoot的配置类和配置文件<br>4.Restful设计开发<br>5.SpringBoot添加拦截器<br>6.SpringBoot跨域请求<br>7.SpringBoot Stater原理<br>8.SpringBoot核心开发</td><td></td></tr><tr><td>SpringCloud Bus</td><td>1.SpringCloud框架简介<br>2.SpringCloud 和Dubbo的区别<br>3.SpringCloud Netflix：核心组件<br>4.Rest连接</td><td></td></tr></tbody></table><h1 id="尚硅谷版java路线"><a href="#尚硅谷版java路线" class="headerlink" title="尚硅谷版java路线"></a>尚硅谷版java路线</h1><h2 id="快速学习路线"><a href="#快速学习路线" class="headerlink" title="快速学习路线"></a>快速学习路线</h2><ul><li>JavaSE:<a href="https://www.bilibili.com/video/BV1Kb411W75N">https://www.bilibili.com/video/BV1Kb411W75N</a></li><li>MySQL基础:<a href="https://www.bilibili.com/video/BV1xW411u7ax">https://www.bilibili.com/video/BV1xW411u7ax</a></li><li>JDBC:<a href="https://www.bilibili.com/video/BV1eJ411c7rf">https://www.bilibili.com/video/BV1eJ411c7rf</a></li><li>JavaWeb:<a href="https://www.bilibili.com/video/BV1Y7411K7zz">https://www.bilibili.com/video/BV1Y7411K7zz</a></li><li>Spring5:<a href="https://www.bilibili.com/video/BV1Vf4y127N5">https://www.bilibili.com/video/BV1Vf4y127N5</a></li><li>SpringMVC:<a href="https://www.bilibili.com/video/BV1mW411M7YA">https://www.bilibili.com/video/BV1mW411M7YA</a></li><li>MyBatis:<a href="https://www.bilibili.com/video/BV1mW411M737">https://www.bilibili.com/video/BV1mW411M737</a></li><li>Maven:<a href="https://www.bilibili.com/video/BV1TW411g7hP">https://www.bilibili.com/video/BV1TW411g7hP</a></li><li>SSM框架整合案例:<a href="https://www.bilibili.com/video/BV17W411g7zP">https://www.bilibili.com/video/BV17W411g7zP</a></li><li>Git/Github:<a href="https://www.bilibili.com/video/BV1vy4y1s7k6">https://www.bilibili.com/video/BV1vy4y1s7k6</a></li><li>Redis6:<a href="https://www.bilibili.com/video/BV1Rv41177Af">https://www.bilibili.com/video/BV1Rv41177Af</a></li><li>MySQL高级优化:<a href="https://www.bilibili.com/video/BV1KW411u7vy">https://www.bilibili.com/video/BV1KW411u7vy</a></li><li>MyBatisPlus:<a href="https://www.bilibili.com/video/BV1Ds411E76Y">https://www.bilibili.com/video/BV1Ds411E76Y</a></li><li>Spring注解驱动开发:<a href="https://www.bilibili.com/video/BV1gW411W7wy">https://www.bilibili.com/video/BV1gW411W7wy</a></li><li>Zookeeper:<a href="https://www.bilibili.com/video/BV1PW411r7iP">https://www.bilibili.com/video/BV1PW411r7iP</a></li><li>Dubbo:<a href="https://www.bilibili.com/video/BV1ns411c7jV">https://www.bilibili.com/video/BV1ns411c7jV</a></li><li>消息中间件ActiveMQ:<a href="https://www.bilibili.com/video/BV164411G7aB">https://www.bilibili.com/video/BV164411G7aB</a></li><li>RabbitMQ:<a href="https://www.bilibili.com/video/BV1cb4y1o7zz">https://www.bilibili.com/video/BV1cb4y1o7zz</a></li><li>SpringBoot2:<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></li><li>SpringCloud:<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li>尚筹网项目:<a href="https://www.bilibili.com/video/BV1bE411T7oZ">https://www.bilibili.com/video/BV1bE411T7oZ</a></li><li>在线教育项目:<a href="https://www.bilibili.com/video/BV1dQ4y1A75e">https://www.bilibili.com/video/BV1dQ4y1A75e</a></li><li>谷粒商城项目:<a href="https://www.bilibili.com/video/BV1np4y1C7Yf">https://www.bilibili.com/video/BV1np4y1C7Yf</a></li><li>尚医通项目:<a href="https://www.bilibili.com/video/BV1V5411K7rT">https://www.bilibili.com/video/BV1V5411K7rT</a></li><li>尚融宝项目:<a href="https://www.bilibili.com/video/BV1VV411n7nR">https://www.bilibili.com/video/BV1VV411n7nR</a></li><li>高频面试题第一季:<a href="https://www.bilibili.com/video/BV1Eb411P7bP">https://www.bilibili.com/video/BV1Eb411P7bP</a></li><li>大厂面试题第二季:<a href="https://www.bilibili.com/video/BV18b411M7xz">https://www.bilibili.com/video/BV18b411M7xz</a></li><li>大厂面试题第三季:<a href="https://www.bilibili.com/video/BV1Hy4y1B78T">https://www.bilibili.com/video/BV1Hy4y1B78T</a></li></ul><p><img src="/2021/07/06/java-2021-07-06-JavaRoute/image-20210729185124562.png" alt="image-20210729185124562"></p><p><a href="https://www.bilibili.com/read/cv5216534?spm_id_from=333.788.b_636f6d6d656e74.5">https://www.bilibili.com/read/cv5216534?spm_id_from=333.788.b_636f6d6d656e74.5</a></p><h1 id="不开心就喝开水-水哥出品"><a href="#不开心就喝开水-水哥出品" class="headerlink" title="不开心就喝开水(==水哥出品==)"></a>不开心就喝开水(==水哥出品==)</h1><p>==以下部分是科班生和培训生的分水岭，有些公司很喜欢考(尤其数据结构和算法)==</p><h2 id="1-计算机网络-速览速背"><a href="#1-计算机网络-速览速背" class="headerlink" title="1. 计算机网络(速览速背)"></a>1. 计算机网络(速览速背)</h2><ul><li>分层架构</li><li>TCP/UDP<ul><li>区别</li><li>TCP三次握手，四次挥手</li></ul></li><li>HTTP/HTTPS<ul><li>区别</li><li>无状态</li><li>长连接、短连接</li></ul></li><li>状态码</li><li>Cookie和session</li><li>URI和URL</li></ul><h2 id="2-操作系统-能理解最好，不理解先背，不要花太多时间"><a href="#2-操作系统-能理解最好，不理解先背，不要花太多时间" class="headerlink" title="2. 操作系统(能理解最好，不理解先背，不要花太多时间)"></a>2. 操作系统(能理解最好，不理解先背，不要花太多时间)</h2><ul><li>线程和进程<ul><li>区别</li><li>状态</li><li>同步</li><li>死锁</li></ul></li></ul><h2 id="3-数据结构和算法"><a href="#3-数据结构和算法" class="headerlink" title="3. 数据结构和算法"></a>3. 数据结构和算法</h2><ul><li>数据结构(找带图的学习资源，可以结合Java动手学习)<ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>树</li><li>堆</li></ul></li><li>算法(重点把最简单的几个排序查找看)<ul><li><a href="https://www.zhihu.com/question/24964987">https://www.zhihu.com/question/24964987</a></li></ul></li></ul><h2 id="4-设计模式-23种"><a href="#4-设计模式-23种" class="headerlink" title="4. 设计模式(23种)"></a>4. 设计模式(23种)</h2><p>==会实现==</p><ul><li>单例模式</li><li>工厂</li><li>代理</li></ul><p>==能看懂==</p><ul><li>适配器</li><li>观察者</li><li>模板</li></ul><h2 id="5-实操工具"><a href="#5-实操工具" class="headerlink" title="5. 实操工具"></a>5. 实操工具</h2><p>(==这块面试中问的不多，但是如果你虚构了工作经验，这块东西不熟练会露馅==)</p><ul><li><p>Git/SVN</p></li><li><p>Maven/Gradle</p></li><li><p>Linux基本操作</p></li><li><p>Nginx</p></li><li><p>ELK</p></li><li><p>postman</p></li></ul><h2 id="6-Java基础"><a href="#6-Java基础" class="headerlink" title="6. Java基础"></a>6. Java基础</h2><h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><h4 id="HELLOWORD"><a href="#HELLOWORD" class="headerlink" title="HELLOWORD"></a>HELLOWORD</h4><ul><li>Java特点、优点</li><li>环境<ul><li>JDK</li><li>JRE</li><li>开发环境配置</li></ul></li></ul><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><ul><li>语法</li><li>关键字</li><li>数据类型</li><li>逻辑控制语句</li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li>思想<ul><li>细细品</li><li>对象之间的关系<ul><li>依赖</li><li>关系</li><li>聚合</li><li>组合</li></ul></li></ul></li><li>原则<ul><li>继承</li><li>封装</li><li>多态</li></ul></li><li>四个常考关键字<ul><li>static</li><li>final</li><li>this</li><li>super</li></ul></li><li>初始化</li><li>属性和方法<ul><li>构造方法</li><li>重载和重写</li></ul></li><li>向上转型、向下转型</li><li>内部类</li></ul><h4 id="接口和抽象类-这是一道考烂了的题，背也要背会"><a href="#接口和抽象类-这是一道考烂了的题，背也要背会" class="headerlink" title="接口和抽象类(==这是一道考烂了的题，背也要背会==)"></a>接口和抽象类(==这是一道考烂了的题，背也要背会==)</h4><h4 id="集合-重要"><a href="#集合-重要" class="headerlink" title="集合(==重要==)"></a>集合(==重要==)</h4><ul><li>集合家谱:<a href="https://www.runoob.com/java/java-collections.html">https://www.runoob.com/java/java-collections.html</a></li></ul><p>==原理、特点、异同、线程安全、常用操作及其复杂度==</p><ul><li>各种List</li><li>各种Set</li><li>各种Map</li></ul><p>==后续学习和工作中非常有用的东西，建议玩明白==</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>==东西不多，实操踩一遍，考前刷刷题==</p><h4 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h4><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>==初学者反复学不明白挺正常，学两遍，在实战项目中找机会实践一下。可以选择把几个常见问题背下来，先上车后补票。==</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>线程池</li><li>并发容器</li><li>原子类</li><li>线程与进程</li><li>并发与并行</li><li>死锁</li><li>生命周期和状态</li><li>两个常问的关键字<ul><li>synchronize</li><li>volatile</li></ul></li></ul><p>初学者比较抽象，如果时间比较紧，可安排在面试前突击记忆，这些内容空缺并不影响后面的学习</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>内存模型</li><li>垃圾回收</li><li>类加载机制</li><li>调优</li></ul><h2 id="7-数据库-MySQL"><a href="#7-数据库-MySQL" class="headerlink" title="7. 数据库(MySQL)"></a>7. 数据库(MySQL)</h2><p>==CRUD(Create Retrieve Update，Delete)工程师的基本素养，至少把链接里的内容看完==</p><ul><li>SQL基本能力:<a href="https://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.html</a></li><li>事务</li><li>索引</li><li>锁</li><li>连接池</li><li>分库分表<ul><li>为什么分?</li><li>如何分?<ul><li>水平</li><li>垂直</li></ul></li><li>用什么?<ul><li>Mycat</li></ul></li></ul></li><li>主从</li><li>读写分离</li></ul><p>==很多教程学完这些后会开启一个小实战项目，个人认为学习时间紧可以跳过小项目，待后面学完框架后一并实战，还有就是，跳过JSP吧。==</p><h2 id="8-JavaWeb"><a href="#8-JavaWeb" class="headerlink" title="8. JavaWeb"></a>8. JavaWeb</h2><p>==走马观花，随用随抄即可，不要在这个上面浪费时间==</p><ul><li>html</li><li>css</li><li>js</li><li>ajax</li><li>vue</li></ul><p>==这个要学明白，为SpringMVC做基础==</p><ul><li>Servlet</li></ul><p>==在实战中边学边用，三周中间件至少学好一种，能聊几句原理那种==</p><h2 id="9-中间件"><a href="#9-中间件" class="headerlink" title="9. 中间件"></a>9. 中间件</h2><p>==面试最容易问的中间件==</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>Redis</p><ul><li><p>数据类型</p><ul><li>String</li><li>hash</li><li>list</li><li>set</li><li>zset</li></ul></li><li><p>基础学习:<a href="https://www.runoob.com/redis/redis-tutorial.html">https://www.runoob.com/redis/redis-tutorial.html</a></p></li><li><p>常见问题</p><ul><li><p>数据类型</p></li><li><p>持久化</p></li><li><p>集群</p></li><li><p>通道</p></li><li><p>事务</p></li><li><p>Redis分布式锁</p><p>==是什么?原因，如何避免==</p></li><li><p>缓存穿透</p></li><li><p>缓存雪崩</p></li><li><p>缓存击穿</p></li></ul></li></ul></li></ul><p>==消息队列一般的业务rabbitMQ已经足够使用了，学会一个，面试考到其他的，把话题往用过的上面引，了解几种MQ的异同和优缺点==</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li>rabbiMQ</li><li>rocketMQ</li><li>kafka</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li>elasticsearch(==主要==)</li><li>solar</li></ul><p>==熟练运用，结合实战项目学习==</p><h2 id="10-框架"><a href="#10-框架" class="headerlink" title="10. 框架"></a>10. 框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li>AOP</li><li>IOC</li><li>BeanFactory</li><li>bean的作用域、生命周期</li><li>事务隔离级别</li></ul><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><ul><li>工作流程图</li><li>DispatchServlet</li><li>WebApplicationContext</li></ul><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul><li>启动过程、自动装配原理?</li></ul><p>==直接找一个SpringCloud全家桶教程从头到尾，把每个组件是做什么的弄清楚，先会用。服务发现/注册可以认真学一下，这块容易问。==</p><h2 id="11-0-微服务-分布式"><a href="#11-0-微服务-分布式" class="headerlink" title="11.0 微服务/分布式"></a>11.0 微服务/分布式</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li>CAP</li><li>BASE</li></ul><p>==相同作用的，会一个就行，但是名字要记一下，最好能知道他们的区别和优缺点，面试官问到了至少知道是做什么用的，快速定位同类组件自己会的那一个，把问题接下来，聊自己会的，下同。==</p><h3 id="服务发现-注册"><a href="#服务发现-注册" class="headerlink" title="服务发现/注册"></a>服务发现/注册</h3><ul><li>Eureka(==学这个就行==)</li><li>zookeeper</li><li>etcd</li><li>Nacos</li><li>Consul</li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><ul><li>Zuul</li><li>Gateway</li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>Ribbon</li></ul><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><ul><li>Feign</li></ul><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><ul><li>Hystrix</li></ul><h3 id="统一配置"><a href="#统一配置" class="headerlink" title="统一配置"></a>统一配置</h3><ul><li>Config</li><li>Nacos</li></ul><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><ul><li>Sleuth</li><li>zipkin</li><li>skywalking</li></ul><h3 id="认证、鉴权、单点登录"><a href="#认证、鉴权、单点登录" class="headerlink" title="认证、鉴权、单点登录"></a>认证、鉴权、单点登录</h3><ul><li>Shiro</li><li>Spring Security</li><li>OAuth2</li><li>SSo</li></ul><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><p>Bus</p><h3 id="SpringCloud和dubbo的对比"><a href="#SpringCloud和dubbo的对比" class="headerlink" title="SpringCloud和dubbo的对比"></a>SpringCloud和dubbo的对比</h3><h2 id="12-简历优化"><a href="#12-简历优化" class="headerlink" title="12. 简历优化"></a>12. 简历优化</h2><ul><li><p>简历优化</p><ul><li>校招:</li><li>社招:</li></ul></li><li><p>面试准备与技巧:</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;英格版java全站培训&quot;&gt;&lt;a href=&quot;#英格版java全站培训&quot; class=&quot;headerlink&quot; title=&quot;英格版java全站培训&quot;&gt;&lt;/a&gt;英格版java全站培训&lt;/h1&gt;&lt;h2 id=&quot;javaSE&quot;&gt;&lt;a href=&quot;#javaSE&quot; cla</summary>
      
    
    
    
    <category term="default" scheme="https://stary1999.github.io/categories/default/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>springBoot2</title>
    <link href="https://stary1999.github.io/2021/07/04/java-2021-07-04-springBoot2/"/>
    <id>https://stary1999.github.io/2021/07/04/java-2021-07-04-springBoot2/</id>
    <published>2021-07-04T10:29:15.000Z</published>
    <updated>2021-07-10T12:27:11.622Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.yuque.com/atguigu/springboot">https://www.yuque.com/atguigu/springboot</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><p>掌握Spring，Maven</p><p>ps：需要对springMVC、redis有一定了解</p><p>环境要求：</p><p>java8或以上，</p><p>maven3.3+</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>spring能做什么：IOP，AOC，web</p><p>spring：微服务。将大型应用拆分为许多小模块。</p><p>SpringBoot是一个高层框架、一站式框架，Boot：开始。可以帮助整合整个Spring的生态框架。帮助我们快捷地创建出一个生产级别的应用，快速开发的脚手架。</p><p>Spring的生态，涵盖了：web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理……</p><p>jdk1.8更新接口适配器模式，Spring5更新响应式编程</p><p>SpringBoot优点：</p><ol><li>创建独立的Spring应用。之前使用Spring的应用能够快捷地移植到SpringBoot，且功能不会减少</li><li>内嵌服务器，不需要再额外部署到tomcat之类的服务器上</li><li>自动配置Spring以及第三方的功能</li><li>提供生产级别的监控，健康检查以及外部化配置</li><li>无代码生成，无需编写xml。</li></ol><p>基于自动装配</p><p>缺点：迭代快（人称版本帝）、封装深（不易精通）</p><h2 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h2><p>微服务构建导致分布式</p><p>ps：（php开发小型后台快）</p><p>分布式开发困难，需要统一调度</p><ul><li>远程调用</li><li>服务发现</li></ul><ul><li><p>负载均衡</p></li><li><p>服务容错</p></li><li><p>配置管理</p></li><li><p>服务监控</p></li><li><p>链路追踪</p></li><li><p>日志管理</p></li><li><p>任务调度</p></li><li><p>……</p></li></ul><p>云原生中要处理的问题</p><ul><li>服务自愈</li><li>弹性伸缩</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>……</li></ul><p>云原生技术路线（运维方向）：Docker，星际级容器编排Kubernetes，企业CI/CD、构建企业云平台，新一代架构Service Mesh 和serverless，</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>官网地址：</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started</a></p><h1 id="hello-SpringBoot2"><a href="#hello-SpringBoot2" class="headerlink" title="hello SpringBoot2"></a>hello SpringBoot2</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>SpringBoot2中整合了常用的框架，所以，只需要在maven中导入需要的相关依赖，新建运行的主类，然后就可以快速编写controller方法，实现业务。<br>如果需要数据库操作，导入数据库的场景依赖，然后设置数据库相关配置，便可以进行业务开发。</p><p>新建一个maven工程</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入web的场景依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注解告诉这是一个SpringBoot应用*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新建控制类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,springBoot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2021/07/04/java-2021-07-04-springBoot2/image-20210704203805336.png" alt="image-20210704203805336"></p><p>配置文件：</p><p>application.properties</p><p>一个配置文件配置所有。参考官网的配置文件说明，有默认值。</p><p>包含运行环境的jar包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以打一个可以直接运行的jar包，在命令行输入下列命令直接运行（jar包中包含了tomcat，所以移植性极佳）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar [name.jar]</span><br></pre></td></tr></table></figure><h2 id="正式开发"><a href="#正式开发" class="headerlink" title="正式开发"></a>正式开发</h2><p>在idea中新建一个SpringBoot项目：file-new- project，选择Spring Initializr，填写相关信息。</p><p><img src="/2021/07/04/java-2021-07-04-springBoot2/image-20210709153420089.png" alt="image-20210709153420089"></p><p>点击下一步，配置场景。点击finish，完成项目的创建</p><p><img src="/2021/07/04/java-2021-07-04-springBoot2/image-20210709153838551.png" alt="image-20210709153838551"></p><p>目录说明：</p><p><img src="/2021/07/04/java-2021-07-04-springBoot2/image-20210709154206449.png" alt="image-20210709154206449"></p><h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><ol><li>无法找到run方法</li></ol><p>SpringApplication错写成SpringBootApplication</p><ol start="2"><li>无法运行：</li></ol><p>注意8080端口是否被tomcat服务占用</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="版本仲裁"><a href="#版本仲裁" class="headerlink" title="版本仲裁"></a>版本仲裁</h3><p>父项目做依赖管理：父项目的父项目中定义了很多常用的版本依赖。</p><p>自动仲裁版本管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.13<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.82<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.16.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">awaitility.version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">awaitility.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitronix.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">bitronix.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build-helper-maven-plugin.version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">build-helper-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.10.14<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caffeine.version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">caffeine.version</span>&gt;</span>  </span><br><span class="line">    ……</span><br><span class="line">    ……</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>自定义修改版本号：查看spring-dependency中规定的当前依赖的版本用的key。然后重写依赖（maven中的就近原则）。</p><h3 id="start场景管理"><a href="#start场景管理" class="headerlink" title="start场景管理"></a>start场景管理</h3><p>开发导入start场景管理</p><p>当引入了某个场景后，会自动引入场景所需要的所有的依赖</p><p>官方start和第三方start。</p><p>所有场景的启动器是spring-boot-start，最基础的启动器。</p><p>ps：当引入不在版本仲裁的jar包时，需要额外写依赖。</p><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><ul><li>自动配好了tomcat<ul><li>引入tomcat依赖</li><li>配置tomcat</li></ul></li><li>自动配好了SpringMVC的常用场景（乱码，视图解析器，文件上传解析器）<ul><li>引入SpringMVC全套组件</li><li>自动配置好SpringMVC常用组件</li></ul></li><li>自动配置好web常见功能，如字符编码问题等（需要导入场景依赖）</li><li>自动配置了默认包结构，主程序及其所在的包结构下的所有包都能被扫描。<ul><li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li><li>无需配置以前的包扫描配置</li><li>想要改变扫描路径：修改主程序注解，放大扫描的包的层级<code>@SpringBootApplication(scanBasePackages = &quot;com.atguigu&quot;)</code> 或用<code>@ComponentScan</code>标识需要扫描的包，注意<code>@SpringBootApplication</code>是一个合成注解，使用时需要将<code>@SpringBootApplication</code>替换成三个字注解</li></ul></li><li>各种配置拥有默认值<ul><li>默认配置最终都是映射到某个类上，如：MultipartProperties</li><li>配置文件的值最终都会绑定到每个类上，这个类会在容器中创建对象</li></ul></li><li>按需加载所有的自动配置项<ul><li>根据Start加载，引入那些场景，这个场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在spring-boot-autoconfigure包中</li></ul></li></ul><h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><h3 id="组件添加："><a href="#组件添加：" class="headerlink" title="组件添加："></a>组件添加：</h3><ol><li><p>@Configuration</p><p>Full模式与Lite模式</p><ul><li>配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li><li>配置类组件之间有依赖关系，方法调用得到之前的单实例组件，使用Full。</li></ul></li><li><p>@Bean、@Component、@Controller、@Service、@Repository</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#############################Configuration使用示例######################################################</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)【每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span></span><br><span class="line"><span class="comment"> *      组件依赖必须使用Full模式默认。其他默认是否Lite模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################<span class="meta">@Configuration</span>测试代码如下########################################</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">        Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">        MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">        <span class="comment">//保持组件单实例</span></span><br><span class="line">        User user = bean.user01();</span><br><span class="line">        User user1 = bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@ComponentScan、@Import</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="number">4</span>、<span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"> *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>@Conditional</p><p>条件装配，满足Conditional指定的条件，则进行组件注入</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">=====================测试条件装配==========================</span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="comment">//@ConditionalOnBean(name = &quot;tom&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom22 = run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>原生配置文件引入</p><ol><li>@ImportResource</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">======================beans.xml=========================</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">======================测试=================</span><br><span class="line">        <span class="keyword">boolean</span> haha = run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> hehe = run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><p>使用java读取properties文件中的内容，并将之封装至JavaBean中以供随时使用：</p><p>传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getProperties</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNoFoundException,IOException</span>&#123;</span><br><span class="line">        Properties pps=<span class="keyword">new</span> properties();</span><br><span class="line">        pps.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.properties&quot;</span>));</span><br><span class="line">        Enumeration enum1=pps.propertyNames();</span><br><span class="line">        <span class="keyword">while</span>(enum1.hasMoreElements())&#123;</span><br><span class="line">            String strKey=(String)enum1.nextElement();</span><br><span class="line">            String strValue=pps.getProperty(strKey);</span><br><span class="line">            System.out.println(strKet+<span class="string">&quot;=&quot;</span>+strValue);</span><br><span class="line">            <span class="comment">//封装到javaBean类中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：SpringBoot中可以只有一个配置文件（properties或yaml），可以自动识别配置文件中需要配置的属性。</p><p>注解实现：</p><ol><li>@ConfigurationProperties</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Integer price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@EnableConfigurationProperties+@ConfigurationProperties</li><li>@Component+@ConfigurationProperties</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="comment">//1、开启Car配置绑定功能</span></span><br><span class="line"><span class="comment">//2、把这个Car这个组件自动注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>引导加载自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><p>@SpringBootConfiguration</p><p>@Configuration。代表当前是一个配置类</p></li><li><p>@ComponentScan。指定扫描那些Spring注解</p></li><li><p>@EnableAutoConfiguration</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>AutoConfigurationPackage。自动配置包，指定了默认的包规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span>  <span class="comment">//给容器中导入一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Registrar给容器中导入一系列组件</span></span><br><span class="line"><span class="comment">//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。</span></span><br></pre></td></tr></table></figure><ul><li>@Import（AutoConfigurationImportSelector.class）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</span><br><span class="line"><span class="number">2</span>、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</span><br><span class="line"><span class="number">3</span>、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader)；得到所有的组件</span><br><span class="line"><span class="number">4</span>、从META-INF/spring.factories位置来加载一个文件。</span><br><span class="line">默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件</span><br><span class="line">    spring-boot-autoconfigure-<span class="number">2.3</span><span class="number">.4</span>.RELEASE.jar包里面也有META-INF/spring.factories</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>文件中写死了Spring-boot一启动就要给容器中加载的所有配置类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">文件里面写死了spring-boot一启动就要给容器中加载的所有配置类</span><br><span class="line">spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories</span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span><br></pre></td></tr></table></figure><p><strong>按需开启自动配置项</strong></p><h3 id="修改默认配置项"><a href="#修改默认配置项" class="headerlink" title="修改默认配置项"></a>修改默认配置项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="comment">//容器中有这个类型组件</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="comment">//容器中没有这个名字 multipartResolver 的组件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span></span><br><span class="line">            <span class="comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span></span><br><span class="line"><span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line"><span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给容器中加入了文件上传解析器；</span></span><br></pre></td></tr></table></figure><p>SpringBoot默认会在底层配好所有的组件。以用户自己配置的优先。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>SpringBoot先加载所有的自动配置类。xxxx.AutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件默认的值。对应的值从xxx.Properties中获取，两者进行了绑定</li><li>生效的配置类会给容器中装配很多的组件</li><li>只要容器中有这些组件，就相当于拥有这些功能</li><li>定制化配置<ul><li>用户自己@Bean替换底层的组件</li><li>用户查找这个组件是获取配置文件的什么值就去修改。</li></ul></li></ul><h1 id="开发小技巧"><a href="#开发小技巧" class="headerlink" title="开发小技巧"></a>开发小技巧</h1><h2 id="1-Lombok"><a href="#1-Lombok" class="headerlink" title="1.Lombok"></a>1.Lombok</h2><p>作用：简化JavaBean开发：</p><p>maven中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>idea中搜索安装lombok插件，使用下列三个注解来替代get、set等方法</p><p>@Data<br>@ToString<br>@EqualsAndHashCode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">===============================简化JavaBean开发===================================</span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================================简化日志开发===================================</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;请求进来了....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>+<span class="string">&quot;你好：&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-dev-tools"><a href="#2-dev-tools" class="headerlink" title="2.dev-tools"></a>2.dev-tools</h2><p>maven中导入依赖。项目或者页面修改后，按住Ctrl+F9，快速编译</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-快速创建SpringBoot项目"><a href="#3-快速创建SpringBoot项目" class="headerlink" title="3.快速创建SpringBoot项目"></a>3.快速创建SpringBoot项目</h2><p>参考：正式开发</p><ul><li>引入场景依赖</li><li>查看自动配置的参数（是否需要修改）</li></ul><p>debug=true，查看自动配置报告</p><p>banner图修改</p><p>ctrl+f9 项目重新编译，配合热部署插件使用</p><p>ctrl+h，查看继承树</p><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><ul><li>配置文件</li><li>web开发</li><li>数据访问</li><li>单元测试</li><li>指标监控</li><li>原理解析</li></ul><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>文件类型：xxx.properties。xxx.yaml</p><h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><p>“YAML Ain’t Markup Language”(YAML不是一种标记语言)的递归缩写。在开发这种语言时，YAML的意识其实是：”Yet Another Markup Langeage”(仍是一种标记语言)。YAML非常适合用来作为<strong>以数据为中心</strong>的配置文件。</p><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><ul><li>key: value;key和value之间有空格</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许使用空格</li><li>缩进空格数不重要，只要相同层级的元素左对齐即可</li><li>#表示注释</li><li>字符串无需加引号，如果要加，单引号表示字符内容会被转义。例如/n就输出/n。双引号则表示字符内容不会被转义，例如，/n的输出效果是换行。</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><p>字面量：单个的、不可再分的值。例如：date、boolean、string、number、null</p></li><li><p>对象：键值对的集合。map、hash、set、object</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">行内写法：</span>  <span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure></li><li><p>数组：一组按次序排列的值。array、list、queue。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">行内写法：</span>  <span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml表示</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/12</span> <span class="number">20</span><span class="string">:12:33</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">pet:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">23.4</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">篮球</span>,<span class="string">游泳</span>]</span><br><span class="line">  <span class="attr">animal:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jerry</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mario</span></span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">english:</span> </span><br><span class="line">      <span class="attr">first:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">second:</span> <span class="number">40</span></span><br><span class="line">      <span class="attr">third:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">math:</span> [<span class="number">131</span>,<span class="number">140</span>,<span class="number">148</span>]</span><br><span class="line">    <span class="attr">chinese:</span> &#123;<span class="attr">first:</span> <span class="number">128</span>,<span class="attr">second:</span> <span class="number">136</span>&#125;</span><br><span class="line">  <span class="attr">salarys:</span> [<span class="number">3999</span>,<span class="number">4999.98</span>,<span class="number">5999.99</span>]</span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tom</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">jerry</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;</span><br><span class="line">    <span class="attr">health:</span> [&#123;<span class="attr">name:</span> <span class="string">mario</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h2><ul><li><p>SpringMVC自动配置概览</p></li><li><p>简单功能分析</p></li><li><p>请求参数处理</p></li><li><p>数据响应与内容协商</p></li><li><p>视图解析与模板引擎</p></li><li><p>拦截器</p></li><li><p>异常处理</p></li><li><p>原生Servlet组件</p></li><li><p>嵌入式Web开发</p></li><li><p>定制化原理</p></li></ul><h3 id="1-SpringMVC自动配置概览"><a href="#1-SpringMVC自动配置概览" class="headerlink" title="1.SpringMVC自动配置概览"></a>1.SpringMVC自动配置概览</h3><h3 id="2-简单功能分析"><a href="#2-简单功能分析" class="headerlink" title="2.简单功能分析"></a>2.简单功能分析</h3><h4 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h4><ol><li>静态资源目录</li></ol><p>只要静态资源放在类路径下：/static、/public、/resource、/META-INF/resource</p><p>访问：当前项目根路径/+静态资源名</p><p>原理：静态映射/**<br>请求进来，先去找Controller看能不能处理。不能处理的所有请求都交给静态资源处理器。静态资源也找不到则响应404页面。</p><p>改变默认的静态资源路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li><p>静态资源访问前缀：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure><p>当前项目+static-path-pattern+静态资源名</p></li><li><p>webjar<br>自动映射/webjars/**。<br>导入相关的web的jar包，网址：<a href="https://www.webjars.org./">https://www.webjars.org。</a><br>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入jQuery后，可以在：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js%E4%B8%AD%E8%AE%BF%E9%97%AEjQuery%E3%80%82">http://localhost:8080/webjars/jquery/3.5.1/jquery.js中访问jQuery。</a></p></li></ol><h4 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h4><ul><li>静态资源路径下，index.html页面会被自动识别为首页<ul><li>可以配置静态资源路径</li><li>但是不可用配置静态资源访问前缀。否则导致index.html不能被默认访问。</li></ul></li><li>或者用controller处理/index页面跳转。自定义/请求的跳转页面。</li></ul><h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><p>自定义网站的图标，favicon.ico文件放在静态资源目录下即可</p><h4 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h4><ul><li><p>SpringBoot启动默认加载xxx.AutoConfiguration类（自动配置类）</p></li><li><p>SpringMVC功能的自动配置类：WebMVCAutoConfiguration，生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>给容器中配置了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件的相关属性和xxx进行了绑定|<br>WebMVCProperties==spring.mvc、ResourceProperties==spring.resource</p></li></ul><p>源码解析</p><ol><li><p>配置类只有一个有参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造器所有参数的值都会从容器中确定</span></span><br><span class="line"><span class="comment">//ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象</span></span><br><span class="line"><span class="comment">//WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象</span></span><br><span class="line"><span class="comment">//ListableBeanFactory beanFactory Spring的beanFactory</span></span><br><span class="line"><span class="comment">//HttpMessageConverters 找到所有的HttpMessageConverters</span></span><br><span class="line"><span class="comment">//ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。=========</span></span><br><span class="line"><span class="comment">//DispatcherServletPath  </span></span><br><span class="line"><span class="comment">//ServletRegistrationBean   给应用注册Servlet、Filter....</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebMvcAutoConfigurationAdapter</span><span class="params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span></span></span><br><span class="line"><span class="params"><span class="function">ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span></span></span><br><span class="line"><span class="params"><span class="function">ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span></span></span><br><span class="line"><span class="params"><span class="function">ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line"><span class="keyword">this</span>.mvcProperties = mvcProperties;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line"><span class="keyword">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line"><span class="keyword">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line"><span class="keyword">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line"><span class="keyword">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>资源处理的默认规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line"><span class="comment">//webjars的规则</span></span><br><span class="line">            <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">.addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">.addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="string">禁用所有静态资源规则</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line"><span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span></span><br><span class="line"><span class="comment"> * /resources/, /static/, /public/].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br></pre></td></tr></table></figure></li><li><p>欢迎页的处理规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,</span></span></span><br><span class="line"><span class="params"><span class="function">FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(</span><br><span class="line"><span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line"><span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line"><span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;</span><br><span class="line"><span class="keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">           <span class="comment">//要用欢迎页功能，必须是/**</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());</span><br><span class="line">setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">           <span class="comment">// 调用Controller  /index</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>favicon</p></li></ol><h3 id="3-请求参数处理"><a href="#3-请求参数处理" class="headerlink" title="3.请求参数处理"></a>3.请求参数处理</h3><h4 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h4><ol><li><p>rest使用与原理。</p><ul><li><p>@xxxMapping</p></li><li><p>Rest风格支持（使用HTTP请求方式动词来表示对资源的操作）</p><ul><li><p>以前：/getUser 获取用户  、/deleteUser 删除用户、/editUser 修改用户、/saveUser 保存用户</p></li><li><p>现在：/user GET-获取用户，DELETE-删除用户、PUT-修改用户、POST-保存用户</p></li><li><p>核心Filter：HiddenHttpMethodFilter</p><ul><li>用法：表单method=post，隐藏域：_method=put</li><li>SpringBoot中手动开启</li></ul></li><li><p>拓展：自定义_method的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HiddenHttpMethodFilter methodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Rest原理（表单提交要使用REST的时候）</p><ul><li>表单提交会带上_method=PUT</li><li>请求过来会被HiddenHttpMethodFilter拦截<ul><li>请求正常，且是POST<ul><li>获取到_method的值</li><li>兼容以下请求：PUT、DELETE、PATCH</li><li>原生request（post），包装模式requestWrapper重写了getMethod方法，返回的是传入的值</li><li>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requestWrapper</li></ul></li></ul></li></ul></li><li><p>Rest如何使用客户端工具</p><ul><li><p>使用PostMan直接发送put、delete等方式请求，无需Filter</p></li><li><p>开启表单的Rest功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>请求映射原理</p><p><img src="/2021/07/04/java-2021-07-04-springBoot2/1603181171918-b8acfb93-4914-4208-9943-b37610e93864.png" alt="img"></p></li></ol><p>   SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch（）</p><ul><li><p>RequestMappingHandlerMapping：保存了所有@RequestMapping和handle的映射规则</p></li><li><p>所有的请求映射都在HandleMapping中</p><ul><li><p>SpringBoot自动配置欢迎页的WelcomePageHandleMapping。访问/  能访问到index.html</p></li><li><p>SpringBoot自动配置默认的RequestMappingHandleMapping</p></li><li><p>请求进来，挨个尝试所有的HandleMapping看是否有请求信息</p><ul><li>如果有就找到这个请求对应的handle</li><li>如果没有就是下一个HandleMapping</li></ul></li><li><p>我们需要一些自定义的映射处理，我们也可以自己给容器中放HandleMapping，自定义HandleMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="普通参数与基本注解"><a href="#普通参数与基本注解" class="headerlink" title="普通参数与基本注解"></a>普通参数与基本注解</h4><ol><li><p>注解：@PathVariable、@RequestHandle、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  car/2/owner/zhangsan</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@RequestParam(&quot;inters&quot;)</span> List&lt;String&gt; inters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@RequestParam</span> Map&lt;String,String&gt; params,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="meta">@CookieValue(&quot;_ga&quot;)</span> Cookie cookie)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        map.put(&quot;id&quot;,id);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;name&quot;,name);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;pv&quot;,pv);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;userAgent&quot;,userAgent);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;headers&quot;,header);</span></span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">        map.put(<span class="string">&quot;inters&quot;</span>,inters);</span><br><span class="line">        map.put(<span class="string">&quot;params&quot;</span>,params);</span><br><span class="line">        map.put(<span class="string">&quot;_ga&quot;</span>,_ga);</span><br><span class="line">        System.out.println(cookie.getName()+<span class="string">&quot;===&gt;&quot;</span>+cookie.getValue());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;content&quot;</span>,content);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd</span></span><br><span class="line">    <span class="comment">//2、SpringBoot默认是禁用了矩阵变量的功能</span></span><br><span class="line">    <span class="comment">//      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。</span></span><br><span class="line">    <span class="comment">//              removeSemicolonContent（移除分号内容）支持矩阵变量的</span></span><br><span class="line">    <span class="comment">//3、矩阵变量必须有url路径变量才能被解析</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">carsSell</span><span class="params">(<span class="meta">@MatrixVariable(&quot;low&quot;)</span> Integer low,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@PathVariable(&quot;path&quot;)</span> String path)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;low&quot;</span>,low);</span><br><span class="line">        map.put(<span class="string">&quot;brand&quot;</span>,brand);</span><br><span class="line">        map.put(<span class="string">&quot;path&quot;</span>,path);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// /boss/1;age=20/2;age=10</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">boss</span><span class="params">(<span class="meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;)</span> Integer bossAge,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;)</span> Integer empAge)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;bossAge&quot;</span>,bossAge);</span><br><span class="line">        map.put(<span class="string">&quot;empAge&quot;</span>,empAge);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Servlet API<br>WebRequest、ServletRequest、MultipartSession、HttpSession、javax.servlet.http.PushBuild、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、Zoneld</p></li><li><p>复杂参数<br>Map、Model（map、model里面的数据会被放在request的请求域request.setAttribute）、Error/BindingResult、RedirectAttribute（重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</p><p>Map、Model类型的参数，会返回mavContainer.getModel()；—&gt;BindingAwareModelMap是Model也是Map<br>mavContainer.getModel()；获取到值的</p></li><li><p>自定义对象：<br>可以自动类型转换与格式化，可以级联封装</p></li></ol><h4 id="POJO封装过程"><a href="#POJO封装过程" class="headerlink" title="POJO封装过程"></a>POJO封装过程</h4><ul><li>ServletModelAttributeMethodProcessor</li></ul><h4 id="参数处理原理"><a href="#参数处理原理" class="headerlink" title="参数处理原理"></a>参数处理原理</h4><ul><li>HandlerMapping中找到能处理请求的Handle（Controller.method())</li><li>为当前Handle找一个适配器HandleAdapter；RequestMappingHandlerAdapter</li><li>适配器执行目标方法并确定方法参数的每一个值</li></ul><ol><li><p>HandlerAdapter</p></li><li><p>执行目标方法</p></li><li><p>参数解析器-HandlerMethodArgumentResolver<br>确认将要执行的目标方法的每一个参数的值是什么。<br>SpringMVC目标方法能写多少种参数类型，取决于参数解析器</p><ul><li>当前解析器是否支持解析这种参数</li><li>支持就调用resolveArgument</li></ul></li><li><p>返回值处理器</p></li><li><p>如何确定目标方法每一个参数的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">============InvocableHandlerMethod==========================</span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line">parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">args[i] = <span class="keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">String exMsg = ex.getMessage();</span><br><span class="line"><span class="keyword">if</span> (exMsg != <span class="keyword">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>挨个判断所有参数解析器那个支持解析这个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">result = resolver;</span><br><span class="line"><span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析这个参数的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可</span><br></pre></td></tr></table></figure></li><li><p>自定义参数类型、封装POJO<br>ServletModelAttributeMethodProcessor，这个参数处理器支持是否为简单类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSimpleValueType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Void.class != type &amp;&amp; <span class="keyword">void</span>.class != type &amp;&amp;</span><br><span class="line">(ClassUtils.isPrimitiveOrWrapper(type) ||</span><br><span class="line">Enum.class.isAssignableFrom(type) ||</span><br><span class="line">CharSequence.class.isAssignableFrom(type) ||</span><br><span class="line">Number.class.isAssignableFrom(type) ||</span><br><span class="line">Date.class.isAssignableFrom(type) ||</span><br><span class="line">Temporal.class.isAssignableFrom(type) ||</span><br><span class="line">URI.class == type ||</span><br><span class="line">URL.class == type ||</span><br><span class="line">Locale.class == type ||</span><br><span class="line">Class.class == type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Assert.state(mavContainer != <span class="keyword">null</span>, <span class="string">&quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;</span>);</span><br><span class="line">Assert.state(binderFactory != <span class="keyword">null</span>, <span class="string">&quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">String name = ModelFactory.getNameForParameter(parameter);</span><br><span class="line">ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line"><span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">mavContainer.setBinding(name, ann.binding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object attribute = <span class="keyword">null</span>;</span><br><span class="line">BindingResult bindingResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">attribute = mavContainer.getModel().get(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Create attribute instance</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">attribute = createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BindException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (isBindExceptionRequired(parameter)) &#123;</span><br><span class="line"><span class="comment">// No BindingResult parameter -&gt; fail with BindException</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise, expose null/empty value and associated BindingResult</span></span><br><span class="line"><span class="keyword">if</span> (parameter.getParameterType() == Optional.class) &#123;</span><br><span class="line">attribute = Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line">bindingResult = ex.getBindingResult();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bindingResult == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Bean property binding and validation;</span></span><br><span class="line"><span class="comment">// skipped in case of binding failure on construction.</span></span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line"><span class="keyword">if</span> (binder.getTarget() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mavContainer.isBindingDisabled(name)) &#123;</span><br><span class="line">bindRequestParameters(binder, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BindException(binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Value type adaptation, also covering java.util.Optional</span></span><br><span class="line"><span class="keyword">if</span> (!parameter.getParameterType().isInstance(attribute)) &#123;</span><br><span class="line">attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br><span class="line">bindingResult = binder.getBindingResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add resolved attribute and BindingResult at the end of the model</span></span><br><span class="line">Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();</span><br><span class="line">mavContainer.removeAttributes(bindingResultModel);</span><br><span class="line">mavContainer.addAllAttributes(bindingResultModel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</span><br></pre></td></tr></table></figure><p>WebDataBinder：web数据绑定器，将请求参数的值绑定到指定的JavaBean里面<br>WebDataBinder：利用它里面的Converters将请求数据转成指定的数据类型。再次封装到JavaBean中<br>GenericConversionService：在设置每一个值的时候，找它里面的所有Converter那个可以将这个数据类型（request带来的参数的字符串）转到指定的类型<br>@FunctionalInterface public interface Converter&lt;S,T&gt;</p><p>给WebDataBinder里面放自己的Converter：<br>private static final class StringToNumber<T extends number>implements Converter&lt;String,T&gt;<br>自定义converter:</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、WebMvcConfigurer定制化SpringMVC的功能</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">            UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">            <span class="comment">// 不移除；后面的内容。矩阵变量功能就可以生效</span></span><br><span class="line">            urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">            configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addConverter(<span class="keyword">new</span> Converter&lt;String, Pet&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Pet <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 啊猫,3</span></span><br><span class="line">                    <span class="keyword">if</span>(!StringUtils.isEmpty(source))&#123;</span><br><span class="line">                        Pet pet = <span class="keyword">new</span> Pet();</span><br><span class="line">                        String[] split = source.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                        pet.setName(split[<span class="number">0</span>]);</span><br><span class="line">                        pet.setAge(Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">                        <span class="keyword">return</span> pet;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>目标方法执行完成<br>将所有数据都放在ModelAndViewContainer；包含要去的页面地址View，还包含Model数据。</p></li><li><p>处理派发结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">InternalResourceView：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose the model object as request attributes.</span></span><br><span class="line">exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose helpers as request attributes, if any.</span></span><br><span class="line">exposeHelpers(request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine the path for the request dispatcher.</span></span><br><span class="line">String dispatcherPath = prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span></span><br><span class="line">RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);</span><br><span class="line"><span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;Could not get RequestDispatcher for [&quot;</span> + getUrl() +</span><br><span class="line"><span class="string">&quot;]: Check that the corresponding file exists within your web application archive!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If already included or response already committed, perform include, else forward.</span></span><br><span class="line"><span class="keyword">if</span> (useInclude(request, response)) &#123;</span><br><span class="line">response.setContentType(getContentType());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Including [&quot;</span> + getUrl() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">rd.include(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Note: The forwarded resource is supposed to determine the content type itself.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Forwarding to [&quot;</span> + getUrl() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">rd.forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">暴露模型作为请求域属性</span><br><span class="line"><span class="comment">// Expose the model object as request attributes.</span></span><br><span class="line">exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exposeModelAsRequestAttributes</span><span class="params">(Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//model中的所有数据遍历挨个放在请求域中</span></span><br><span class="line">model.forEach((name, value) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(name, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">request.removeAttribute(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-数据响应与内容协商"><a href="#4-数据响应与内容协商" class="headerlink" title="4.数据响应与内容协商"></a>4.数据响应与内容协商</h3><p>数据响应：</p><ul><li>响应页面</li><li>响应数据<ul><li>json</li><li>xml</li><li>xls</li><li>图片、音视频</li><li>自定义协议数据</li></ul></li></ul><h4 id="响应json"><a href="#响应json" class="headerlink" title="响应json"></a>响应json</h4><p>jackson.jar+@ResponseBody</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">web场景自动引入了json场景</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/04/java-2021-07-04-springBoot2/1605151090728-f7c60e6f-d0c0-4541-bfa3-8cc805dfd5d6.png" alt="image.png"></p><p>给前端自动返回json数据</p><ol><li>返回值解析器</li><li>返回值解析器原理<ul><li>返回值处理器判断是否支持这种类型返回值：supportsReturnType</li><li>返回值处理器调用handleReturnValue进行处理</li><li>RequestResponseBodyMethodProcess可以处理返回值标了@ResponseBody注解的<ul><li>利用MessageConverters进行处理，将 数据写为json<ul><li>内容协商：浏览器默认会以请求头的方式告诉服务器他能接收什么样的内容类型</li><li>服务器最终根据自身的能力，决定服务器能生产出什么样内容类型的数据</li><li>SpringMVC会挨个遍历所有的底层的HttpMessageConverter，看谁能处理<ul><li>得到MappingJackson2HttpMessageConverter可以将对象写为json</li><li>利用MappingJackson2HttpMessageConverter将对象转为json再写出去</li></ul></li></ul></li></ul></li></ul></li></ol><p>SpringMVC支持的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ModelAndView</span><br><span class="line">Model</span><br><span class="line">View</span><br><span class="line">ResponseEntity </span><br><span class="line">ResponseBodyEmitter</span><br><span class="line">StreamingResponseBody</span><br><span class="line">HttpEntity</span><br><span class="line">HttpHeaders</span><br><span class="line">Callable</span><br><span class="line">DeferredResult</span><br><span class="line">ListenableFuture</span><br><span class="line">CompletionStage</span><br><span class="line">WebAsyncTask</span><br><span class="line">有 <span class="meta">@ModelAttribute</span> 且为对象类型的</span><br><span class="line"><span class="meta">@ResponseBody</span> 注解 ---&gt; RequestResponseBodyMethodProcessor；</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTPMessageConverter原理：</p><ol><li><p>MessageConverter规范：<br><img src="/2021/07/04/java-2021-07-04-springBoot2/1605163447900-e2748217-0f31-4abb-9cce-546b4d790d0b.png" alt="image.png"><br>HttpMessageConverter：看是否支持将此class类型的对象，转化为MediaType类型的数据</p></li><li><p>默认的MessageConverter</p><p><img src="/2021/07/04/java-2021-07-04-springBoot2/1605163584708-e19770d6-6b35-4caa-bf21-266b73cb1ef1.png" alt="image.png"></p><ul><li>0：只支持Byte类型的</li><li>1：String</li><li>2：String</li><li>3：Resource</li><li>4：ResourceRegion</li><li>5：DOMSource.class\SAXSource.class\StAXSource.class\StreamSource.class\Source.class</li><li>6：MutiValueMap</li><li>7：true</li><li>8：true</li><li>9：支持注解方式xml处理</li></ul><p>最终MappingJack2HttpMessageConverter把对象转化为JSON（利用底层的jackson的objectMapping转换的）</p><h4 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h4><p>根据客户的接收能力不同，返回不同媒体类型的数据。</p><ol><li><p>引入xml依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>postman分别测试返回json和xml<br>只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型</p></li><li><p>开启浏览器参数方式内容协商功能<br>开启基于请求参数的内容协商功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span>  <span class="comment">#开启请求参数内容协商模式</span></span><br></pre></td></tr></table></figure><p>测试：</p><p>发请求： <a href="http://localhost:8080/test/person?format=json">http://localhost:8080/test/person?format=json</a></p><p><a href="http://localhost:8080/test/person?format=json">http://localhost:8080/test/person?format=</a>xml<br>确定客户端接收什么样的内容类型</p><ol><li>Parameter策略优先确定是要返回json的数据（获取请求头中的format的值）</li><li>最终进行内容协商返回给客户端json即可</li></ol></li><li><p>内容协商原理</p><ul><li>判断当前响应头中是否已经有确定的媒体类型。MediaType</li><li>获取客户端（PostMan、浏览器等）支持接收的内容类型。（客户端Accept请求头字段）<ul><li>contentNegotiationManager内容协商管理器，默认使用基于请求头的策略</li><li>HeaderContentNegotiationStrategy确定客户端可以接收的内容类型</li></ul></li><li>遍历循环所有当前系统的MessageConverter，看谁支持操作这个对象</li><li>找到支持操作此对象的Converter，把converter支持的媒体类型统计出来</li><li>总结客户端需要的媒体类型，与服务端的能力（能提供的媒体类型）</li><li>进行内容协商的最佳匹配媒体类型</li><li>将对象转为最佳匹配媒体类型的converter，调用它进行转化</li></ul></li><li><p>自定义MessageConverter<br>实现多协议数据兼容</p><ul><li>@ResponseBody响应数据处理调用：RequestResponseBodyethodProcessor处理</li><li>Processor处理方法返回值，通过MessageConverter处理</li><li>所有MessageConverter合起来可以支持各种媒体类型数据的操作（读、写）</li><li>内容协商找到最终的MessageConverter</li></ul><p>SpringMVC的什么功能，衣蛾入口给容器中添加衣蛾WebMvcConfigurer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">      </span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>有可能我们添加的自定义功能会覆盖默认的很多功能，导致一些默认的功能失效。</strong></p></li></ol></li></ol><h3 id="5-视图解析与模板引擎"><a href="#5-视图解析与模板引擎" class="headerlink" title="5.视图解析与模板引擎"></a>5.视图解析与模板引擎</h3><p>视图解析：SpringBoot默认不支持jsp，需要引入第三方模板引擎技术实现页面渲染</p><h4 id="视图解析："><a href="#视图解析：" class="headerlink" title="视图解析："></a>视图解析：</h4><ul><li>视图处理方式：<ul><li>转发</li><li>重定向</li><li>自定义视图</li></ul></li></ul><ol><li><p>视图解析原理流程</p><ol><li><p>目标方法处理的过程中，所有数据都会被放在ModelAndViewContainer里面，包括数据和视图地址</p></li><li><p>方法的参数是一个自定义类型对象（从请求参数中确定的），把他重写放在ModelAndViewContainer</p></li><li><p>任何目标方法执行完成以后都会返回ModelAndView（数据和视图地址）</p></li><li><p>processDispatchResult处理派发结果</p><p>根据方法的String返回值得到view对象（定义了页面渲染逻辑）</p><ol><li>所有视图解析器尝试是否能根据当前返回值得到view对象</li><li>得到了redirect:/main.html，—-》Thymeleaf new RedirectView()</li><li>ContentNegotiationViewResolver里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象</li><li>view.render(mv.getModelInternal(),request,response)，视图对象调用自定义的render进行页面渲染工作<ul><li>RedirectView如何渲染：重定向到一个页面</li><li>获取目标url地址</li><li>response.sendRedirect(encodeURL)</li></ul></li></ol><p>视图解析：</p><ul><li>返回值以forward：开始：new InternalResourceView(forwardUrl);—-&gt;转发。<br>request.getRequestDispatcher(path).forward(request,response);</li><li>返回值以redirect：开始：new RedirectView()—-&gt;render就是重定向</li><li>返回值是普通字符串：new ThymeleafView()—–&gt;</li></ul><p>自定义视图+自定义视图解析器。。。。略</p></li></ol></li></ol><h4 id="模板引擎thymeleaf"><a href="#模板引擎thymeleaf" class="headerlink" title="模板引擎thymeleaf"></a>模板引擎thymeleaf</h4><p>thymeleaf：参考官网。<br>不推荐使用，建议使用vue</p><p>基本语法：<br>表达式：</p><table><thead><tr><th>表达式名字</th><th>语法</th></tr></thead><tbody><tr><td>变量取值</td><td>${…}</td></tr><tr><td>选择变量</td><td>*{…}</td></tr><tr><td>消息</td><td>#{…}</td></tr><tr><td>链接</td><td>@{…}</td></tr><tr><td>片段表达式</td><td>~{…}</td></tr></tbody></table><p><strong>使用：</strong></p><ol><li><p>引入start：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动配置<br>自动配置策略：</p><ul><li>所有的thymeleaf的配置值都在ThymeleafProperties</li><li>配置好了SpringTemplateEngine</li><li>配好了ThymeleafViewResolve</li><li>我们只需要开发页面</li></ul></li><li><p>页面开发：<br>注意，需要引入thymeleaf的命名空间：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.atguigu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;link&#125;&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.atguigu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;link&#125;&quot;</span>&gt;</span>去百度2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>构建后台管理系统：</p><ol><li>项目创建</li><li>静态资源处理</li><li>路径构建</li><li>模板抽取</li><li>页面跳转</li><li>数据渲染</li></ol><p>具体项目：略。参考完整的springBoot+vue项目</p><h3 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6.拦截器"></a>6.拦截器</h3><ol><li><p>HandlerInterceptor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录检查</span></span><br><span class="line"><span class="comment"> * 1、配置好拦截器要拦截哪些请求</span></span><br><span class="line"><span class="comment"> * 2、把这些配置放在容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;preHandle拦截的请求路径是&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录检查逻辑</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        Object loginUser = session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(loginUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截住。未登录。跳转到登录页</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line"><span class="comment">//        re.sendRedirect(&quot;/&quot;);</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行完成以后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;postHandle执行&#123;&#125;&quot;</span>,modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面渲染以后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterCompletion执行异常&#123;&#125;&quot;</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、编写一个拦截器实现HandlerInterceptor接口</span></span><br><span class="line"><span class="comment"> * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</span></span><br><span class="line"><span class="comment"> * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)  <span class="comment">//所有请求都被拦截包括静态资源</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>); <span class="comment">//放行的请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>拦截器原理：</p><ol><li>根据当前请求，找到HandlerExecutionChain（可以处理请求的handler以及handler的所有拦截器）</li><li>顺序执行所有拦截器的preHandle方法<ul><li>如果当前拦截器prehandler返回值为true，则执行下一个拦截器的preHandler</li><li>如果当前拦截器返回为false，直接倒序执行所有已经执行了的拦截器的afterCompletion</li></ul></li><li>如果任何一个拦截器返回false，直接跳出不执行目标方法</li><li>如果所有拦截器都返回True，执行目标方法</li><li>倒序执行所有拦截器的postHandle方法</li><li>前面的所有步骤有任何的异常都会直接触发afterCompletion</li><li>页面成功渲染完成以后，也会倒序触发afterCompletion：<br><img src="/2021/07/04/java-2021-07-04-springBoot2/1605765121071-64cfc649-4892-49a3-ac08-88b52fb4286f.png" alt="img"></li></ol></li></ol><h3 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7.文件上传"></a>7.文件上传</h3><ol><li><p>页面表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文件上传代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MultipartFile 自动封装上传过来的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headerImg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> photos</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@RequestPart(&quot;photos&quot;)</span> MultipartFile[] photos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    log.info(<span class="string">&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;</span>,</span><br><span class="line">            email,username,headerImg.getSize(),photos.length);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!headerImg.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//保存到文件服务器，OSS服务器</span></span><br><span class="line">        String originalFilename = headerImg.getOriginalFilename();</span><br><span class="line">        headerImg.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;H:\\cache\\&quot;</span>+originalFilename));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(photos.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile photo : photos) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!photo.isEmpty())&#123;</span><br><span class="line">                String originalFilename = photo.getOriginalFilename();</span><br><span class="line">                photo.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;H:\\cache\\&quot;</span>+originalFilename));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动配置原理<br>文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties</p><ul><li><p>自动配置好了StandardServletMultipartResolver（文件上传解析器）</p></li><li><p>原理步骤：</p><ul><li><p>请求进来使用文件上传解析器判断（isMultipart）并封装（resolverMultipart，返回MultipartHttpServletRequest）文件上传请求</p></li><li><p>参数解析器来解析请求中的文件内容封装成MultipartFile</p></li><li><p>将request中文件信息封装为一个Map；MultiValueMap&lt;String,MultipartFile&gt; FileCopyUtils。实现文件流的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@RequestPart(&quot;photos&quot;)</span> MultipartFile[] photos)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="8.异常处理"></a>8.异常处理</h3><ol><li>错误处理<ol><li>默认规则<ul><li>默认情况下，SpringBoot提供/error处理所有错误的映射</li><li>对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“whitelabel”错误视图，以HTML的格式呈现相同的数据</li><li>要对其进行自定义，添加View解析为error</li><li>要完全替换默认行为，可以实现ErrorController并注册该类的Bean定义，或添加ErrorAttributes类的组件以使用现有机制但替换其内容</li><li>error/下的4xx，5xx页面会被自动解析</li></ul></li><li>定制错误处理逻辑<ul><li>自定义错误页：<br>error/    下的页面，有精确的错误状态码页面就精确匹配，没有就找4xx.html，如果还没有就触发空白页</li><li>@ControllerAdvice+@ExceptionHandler处理全局异常，底层是ExceptionHandlerExceptionResolve，把responsestatus注解的信息底层调用response.sendError(ststusCode,resolvedReason)；tomcat发送的/error</li><li>Spring底层的异常，如参数类型转换异常；<br>DefaultHandlerExceptionResolver处理框架底层的异常<br>response.sendError(HttpServletResponse.SC_BAD_REQUEST,ex.getMessage());</li><li>自定义实现HandlerExceptionResolve处理异常，可以作为默认的全局异常处理规则</li><li>ErrorViewResolver实现自定义处理异常：<ul><li>response.sendError。error请求就会转给controller</li><li>你的异常没有任何人能够处理。tomcat底层response.sendError。error请求就会转给controller</li><li>basicErrorController要去的页面地址是：ErrorViewResolver</li></ul></li></ul></li><li>异常处理自动配置原理<ul><li>ErrorMvcAutoConfiguration自动配置异常处理规则：<ul><li>容器中的组件：类型：DefaultErrorAttributes—-》id：errorAttributes<ul><li>public class DefaultErrorAttributes implements ErrorAttributes，HandlerExceptionResolver</li><li>DefaultErrorAttributes：定义错误页面中可以包含哪些数据</li></ul></li><li>容器中的组件：类型：BasicErrorController—》id：basicErrorController（json+白页 适配响应）<ul><li>处理默认/error路径的请求：页面响应new ModelAndView(“error”,model);</li><li>容器中有组件View–》id是error；响应默认错误页</li><li>容器中放组件BeanNameViewResolver（视图解析器）；按照返回的视图名字作为组件的id去容器中找View对象</li></ul></li><li>容器中的组件：类型：DefaultErrorViewResolver—》id：conventionErrorViewResolver<ul><li>如果发生错误，会以HTTP的状态码作为视图页地址（viewName），找到真正的页面</li></ul></li></ul></li><li>如果想要返回页面，就会找error视图（StaticView）。默认是一个空白页</li></ul></li><li>异常处理步骤流程<ol><li>执行目标方法，目标方法运行期间有任何异常都会被catch、而且标志当前请求结束，并且用dispatchException</li><li>进入视图解析流程（页面渲染？）<br>processDispatchResolver（processedRequest，response，mappedHandler，mv，dispatchException）；</li><li>mv=processHandlerException，处理handler发生的异常，处理完返回ModelAndView<ul><li>遍历所有的handlerExceptionResolvers，看谁能处理当前异常（HandlerExceptionResolvers处理器异常解析器）</li><li>系统默认的 异常解析器：<ul><li>DefaultErrorAttributes先来处理异常，把异常信息保存到request域，并返回null</li><li>默认没有任何人能处理异常，所以异常会被抛出<ol><li>如果没有任何人能处理，最终底层就会发送/error请求，会被底层的BasicErrorController处理</li><li>解析错误视图，遍历所有的ErrorViewResolver，看谁能解析</li><li>默认的DefaultErrorViewResolver，作用是吧响应状态码作为错误页的地址。例如：/error/500.html</li><li>模板引擎最终响应这个页面：/error/500.html</li></ol></li></ul></li></ul></li></ol></li></ol></li></ol><h3 id="9-web原生组件注入"><a href="#9-web原生组件注入" class="headerlink" title="9.web原生组件注入"></a>9.web原生组件注入</h3><ol><li><p>使用Servlet API<br>@ServletComponentScan（basePackages=”com.example.servlet”）:指定原生servlet组件都放在那里<br>@WebServlet（urlPatterns=”/my”）:效果：直接响应，没有经过Spring的拦截器<br>@Webfilter（urlPatterns={“/css”,”/images/*”}）<br>@WebListener<br>拓展：DispatchServlet如何注册进来：</p><ul><li>容器中自动配置了DispatchServlet属性绑定到WebMvcProperties；对应的配置文件配置项是：Spring.mvc。</li><li>通过ServletRegistrationBean&lt;DispatcherServlet&gt;把DispatchServlet配置进来</li><li>默认映射的是/路径</li></ul><p>Tomcat-Servlet:多个Servlet都能处理到同一层路径，精确优先原则</p></li><li><p>使用RegistrationBean<br><code>ServletRegistrationBean</code>, <code>FilterRegistrationBean</code>, and <code>ServletListenerRegistrationBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRegistConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyServlet myServlet = <span class="keyword">new</span> MyServlet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(myServlet,<span class="string">&quot;/my&quot;</span>,<span class="string">&quot;/my02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        MyFilter myFilter = <span class="keyword">new</span> MyFilter();</span><br><span class="line"><span class="comment">//        return new FilterRegistrationBean(myFilter,myServlet());</span></span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean(myFilter);</span><br><span class="line">        filterRegistrationBean.setUrlPatterns(Arrays.asList(<span class="string">&quot;/my&quot;</span>,<span class="string">&quot;/css/*&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MySwervletContextListener mySwervletContextListener = <span class="keyword">new</span> MySwervletContextListener();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletListenerRegistrationBean(mySwervletContextListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="10-嵌入式Web开发"><a href="#10-嵌入式Web开发" class="headerlink" title="10.嵌入式Web开发"></a>10.嵌入式Web开发</h3><ol><li><p>切换嵌入式Servlet容器</p><ul><li><p>默认支持的webServlet</p><ul><li>Tomcat、Jetty、Undertow</li><li>ServletWebServerApplicationContext容器启动寻找ServletWebServerFactory并引导创建服务器</li></ul></li><li><p>切换服务器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>原理</p><ul><li>SpringBoot应用启动发现当前是web应用。Web场景包，导入tomcat</li><li>web应用会创建一个web版的ico容器ServletWebServerApplicationContext</li><li>ServletWebServerApplicationContext启动的时候寻找ServletWebServerFactory（Servlet的web服务器工厂——》Servlet的web服务器）</li><li>SpringBoot底层默认有很多的WebServer工厂：<br>TomcatServletWebServerFactory<br>JettyServletWebServerFactory<br>UndertowServletWebServerFactory</li><li>底层直接会有一个自动配置类：<br>ServletWebServerFactoryAutoConfiguration</li><li>ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration配置类</li><li>ServletWebServerFactoryConfiguration配置类根据动态判断系统中到底导入了那个web服务器的包。（默认是web-starter导入tomcat包，容器中就有TomcatServletWebServerFactory）</li><li>TomcatServletWebServerFactory创建出Tomcat服务器并启动；TomcatServletWebServer的构造器拥有初始化方法：initialize—-this.tomcat.start()；</li><li>内嵌服务器，就是手动吧启动服务器的代码调用（tomcat核心jar包存在）</li></ul></li></ul></li><li><p>定制Servlet容器</p><ul><li><p>实现：WenServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;<br>把配置文件的值和ServletWebServerFactory进行绑定</p></li><li><p>修改配置文件：server.xxx</p></li><li><p>直接自定义ConfigurableServletWebFactory<br>xxxCustomizer:定制化器，可以改变xxx的默认规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="11-定制化原理"><a href="#11-定制化原理" class="headerlink" title="11.定制化原理"></a>11.定制化原理</h3><ol><li><p>定制化的常见方式</p><ul><li><p>修改配置文件</p></li><li><p>xxxxCustomizer</p></li><li><p>编写自定义配置类xxxConfiguration；+@Bean替换、增加容器中默认组件；视图解析器</p></li><li><p>Web应用，编写一个配置类实现WebMvcConfigurer即可定制化web功能；+@Bean给容器中在拓展一些组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span></span><br></pre></td></tr></table></figure></li><li><p>@EnableWebMvc+WebMvcConfigurer+@Bean，可以全面接管SpringMVC，所有的规则全部自己重新配置，实现定制和拓展功能</p><ul><li>原理：<ol><li>WebMvcAutoConfiguration默认的SpringMVC的自动配置功能类，静态资源、欢迎页……</li><li>一旦使用@EnableWebMvc，会@Import(DelegationWebMvcConfiguration.class)</li><li>DelegationWebMvcConfiguration的作用，只保证SpringMVC最基本的使用<ul><li>把所有系统中的WebMvcConfigurer拿过来。所有功能的地址都是这些WebMvcConfigurer合起来一起生效</li><li>自动配置了一些非常底层的组件。RequestMappingHandlerMapping这些组件依赖的组件都是从容器中获取</li><li>public class DelegationWebMvcConfiguration extends WebMvcAutoConfigurationSupport</li></ul></li><li>WebMvcAutoConfiguration里面的配置要能生效，必须@ConditionalOnMissingBean（WebMvcAutoConfigurationSupport.class）</li><li>@EnableWebMvc导致了WebMvcAutoConfiguration没有生效</li></ol></li></ul></li></ul></li><li><p>原理分析套路：<br>场景starter—xxxAutoConfiguration—导入xxx组件—绑定xxxProperties—绑定配置文件项</p></li></ol><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1.SQL"></a>1.SQL</h3><p>1.数据源的自动配置-HikariDataSource</p><ol><li><p>导入JDBC场景</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库驱动：<br>为什么导入JDBC场景：官方不知道我们要操作什么数据库，所以官方没有导入</p><p><strong>数据库版本和驱动版本要对应</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">默认版本：<span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;5.1.49&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">想要修改版本</span><br><span class="line">1、直接依赖引入具体版本（maven的就近依赖原则）</span><br><span class="line">2、重新声明版本（maven的属性的就近优先原则）</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分析自动配置</p><ol><li>自动配置的类<ul><li>DataSourceAutoConfiguration：数据源的自动配置<ul><li>修改数据源的相关配置：spring.datasource</li><li>数据库连接池的配置，是自己容器中没有DataSource才自动配置</li><li>底层配置好的连接池是：HikariDataSource</li></ul></li><li>DataSourceTransactionManagerAutoConfiguration：事务管理器的自动配置</li><li>JdbcTemplateAutoConfiguration：JdbcTemplate的自动配置，可以来对数据库进行crud<ul><li>可以修改这个配置项@ConfigurationProperties(prefix=”spring.jdbc”)来修改JdbcTemplate</li><li>@Bean@Primary JdbcTemplate；容器中有这个组件</li></ul></li><li>JndiDataSourceAutoConfiguration：Jndi的自动配置</li><li>XAdataSourceAutoConfiguration：分布式事务相关的</li></ul></li></ol></li><li><p>修改配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boot05WebAdminApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)</span></span><br><span class="line"><span class="comment">//        jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,)</span></span><br><span class="line">        Long aLong = jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account_tbl&quot;</span>, Long.class);</span><br><span class="line">        log.info(<span class="string">&quot;记录总数：&#123;&#125;&quot;</span>,aLong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-使用Druid数据源"><a href="#2-使用Druid数据源" class="headerlink" title="2. 使用Druid数据源"></a>2. 使用Druid数据源</h3><ol><li><p>Druid官方地址：<a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a><br>整合第三方技术的两种方式：</p><ul><li>自定义</li><li>找starter</li></ul></li><li><p>自定义方式</p><ol><li><p>创建数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxOpenPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>StatViewServlet<br>用途：</p><ul><li>提供监控信息展示的html页面</li><li>提供监控信息的JSON API</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>StatFilter<br>用于统计监控信息，如SQL监控、URL监控</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要给数据源中配置如下属性；可以允许多个filter，多个用，分割；如：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat,slf4j&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>系统中所有的filter：</p><table><thead><tr><th>别名</th><th>Filter类名</th></tr></thead><tbody><tr><td>default</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>stat</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>mergeStat</td><td>com.alibaba.druid.filter.stat.MergeStatFilter</td></tr><tr><td>encoding</td><td>com.alibaba.druid.filter.encoding.EncodingConvertFilter</td></tr><tr><td>log4j</td><td>com.alibaba.druid.filter.logging.Log4jFilter</td></tr><tr><td>log4j2</td><td>com.alibaba.druid.filter.logging.Log4j2Filter</td></tr><tr><td>slf4j</td><td>com.alibaba.druid.filter.logging.Slf4jLogFilter</td></tr><tr><td>commonlogging</td><td>com.alibaba.druid.filter.logging.CommonsLogFilter</td></tr></tbody></table></li></ol></li></ol><p>​              慢SQL记录配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stat-filter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.filter.stat.StatFilter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;slowSqlMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logSlowSql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用 slowSqlMillis 定义慢SQL的时长</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用官方starter的方式：</p><ol><li><p>引入druid-starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分析自动配置</p><ul><li>扩展配置项：spring.datasource.druid</li><li>DruidSpringAopConfiguration.class，监控SpringBean的，配置项：spring.datasource.druid.aop-patterns</li><li>DruidStatViewServletConfiguration.class，监控页的配置：spring.datasource.druid.stat-view-servlet-filter；默认开启</li><li>DruidFilterConfiguration.class，所有Druid自己filter 的配置</li></ul></li><li><p>配置示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">aop-patterns:</span> <span class="string">com.atguigu.admin.*</span>  <span class="comment">#监控SpringBean</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span>     <span class="comment"># 底层开启功能，stat（sql监控），wall（防火墙）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">stat-view-servlet:</span>   <span class="comment"># 配置监控页功能</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">resetEnable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">web-stat-filter:</span>  <span class="comment"># 监控web</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">urlPattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">stat:</span>    <span class="comment"># 对上面filters里面的stat的详细配置</span></span><br><span class="line">          <span class="attr">slow-sql-millis:</span> <span class="number">1000</span></span><br><span class="line">          <span class="attr">logSlowSql:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">wall:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">drop-table-allow:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>SpringBoot配置示例<br><a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p><p>配置项列表<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p></li></ol></li></ol><h3 id="3-整合MyBatis"><a href="#3-整合MyBatis" class="headerlink" title="3. 整合MyBatis"></a>3. 整合MyBatis</h3><p><a href="https://github.com/mybatis">https://github.com/mybatis</a></p><ol start="0"><li>starter<br>SpringBoot官方的Starter：spring-boot-starter-*<br>第三方的： *-spring-boot-starter</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>配置模式：</p><ul><li><p>全局配置文件</p></li><li><p>SQLSessionFactory：自动配置好了</p></li><li><p>SqlSession：自动配置了SqlSessiontemplate组合了SqlSession</p></li><li><p>@Import（AutoConfiguredMapperScannerRegistrar.class）</p></li><li><p>Mapper：只要我们写的操作MyBatis的接口标准了 @Mapper就会被自动扫描进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span> ： MyBatis配置项绑定类。</span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisProperties</span></span></span><br></pre></td></tr></table></figure></li></ul><p>可以修改配置文件中MyBatis开始的所有：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis规则</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span>  <span class="comment">#全局配置文件位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span>  <span class="comment">#sql映射文件位置</span></span><br><span class="line">  </span><br><span class="line"><span class="string">Mapper接口---&gt;绑定Xml</span></span><br><span class="line"><span class="string">&lt;?xml</span> <span class="string">version=&quot;1.0&quot;</span> <span class="string">encoding=&quot;UTF-8&quot;</span> <span class="string">?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE</span> <span class="string">mapper</span></span><br><span class="line">        <span class="string">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span><span class="string">&gt;</span></span><br><span class="line"><span class="string">&lt;mapper</span> <span class="string">namespace=&quot;com.atguigu.admin.mapper.AccountMapper&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;!--</span>    <span class="string">public</span> <span class="string">Account</span> <span class="string">getAcct(Long</span> <span class="string">id);</span> <span class="string">--&gt;</span></span><br><span class="line">    <span class="string">&lt;select</span> <span class="string">id=&quot;getAcct&quot;</span> <span class="string">resultType=&quot;com.atguigu.admin.bean.Account&quot;&gt;</span></span><br><span class="line">        <span class="string">select</span> <span class="string">*</span> <span class="string">from</span>  <span class="string">account_tbl</span> <span class="string">where</span>  <span class="string">id=#&#123;id&#125;</span></span><br><span class="line">    <span class="string">&lt;/select&gt;</span></span><br><span class="line"><span class="string">&lt;/mapper&gt;</span></span><br></pre></td></tr></table></figure><p>配置private Configuration Configuration；mybatis.configuration下面的所有，就是相当于改MyBatis全局配置文件中的值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis规则</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="comment">#  config-location: classpath:mybatis/mybatis-config.xml</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"> <span class="string">可以不写全局；配置文件，所有全局配置文件的配置都放在configuration配置项中即可</span></span><br></pre></td></tr></table></figure><p>步骤：</p><ul><li><p>导入MyBatis官方的starter</p></li><li><p>编写mapper接口。标准@Mapper注解</p></li><li><p>编写Sql映射文件并绑定Mapper接口</p></li><li><p>在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息。建议<strong>配置在mybatis.configuration</strong></p></li></ul></li><li><p>注解模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from city where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(City city)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>混合模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from city where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(City city)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最佳实战：</strong></p><ul><li><p>引入mybatis-starter</p></li><li><p><strong>配置application.yaml中，指定mapper-location位置即可</strong></p></li><li><p>编写Mapper接口并标注@Mapper注解</p></li><li><p>简单方法直接注解方式</p></li><li><p>复杂方法编写mapper.xml进行绑定映射</p></li><li><p><em>@MapperScan(“com.atguigu.admin.mapper”) 简化，其他的接口就可以不用标注@Mapper注解</em></p></li></ul></li></ol><h3 id="4-整合MyBatis-Plus完成CRUD"><a href="#4-整合MyBatis-Plus完成CRUD" class="headerlink" title="4. 整合MyBatis-Plus完成CRUD"></a>4. 整合MyBatis-Plus完成CRUD</h3><ol><li><p>MyBatis-plus：<br>MyBatis-plus是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提升效率而生<br>详情参考官网<br>建议在IDEA中配合插件：MyBatisX使用</p></li><li><p>整合MyBatis-plus：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动配置：</p><ul><li>MyBatisPlusAutoConfiguration配置类，MyBatisPlusProperties配置项绑定。</li><li>SqlSessionFactory自动配置好，底层是容器中默认的数据源</li><li>mapperLocations自动配置好的，有默认值<br>classpath*:/mapper/**/*.xml；任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。<strong>建议</strong>：以后sql映射文件，放在mapper下</li><li>容器中也自动配置好了SQLSessiontemplate</li><li>@Mapper标注的接口也会被自动扫描；建议直接@MapperScan(“com.example.admin.mapper”)批量扫描</li></ul><p><strong>优点：只需要我们的Mapper继承BaseMapper就可以拥有crud能力</strong></p></li><li><p>CRUD功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="meta">@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)</span>Integer pn,</span></span></span><br><span class="line"><span class="params"><span class="function">                             RedirectAttributes ra)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        userService.removeById(id);</span><br><span class="line"></span><br><span class="line">        ra.addAttribute(<span class="string">&quot;pn&quot;</span>,pn);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/dynamic_table&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dynamic_table&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamic_table</span><span class="params">(<span class="meta">@RequestParam(value=&quot;pn&quot;,defaultValue = &quot;1&quot;)</span> Integer pn,Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格内容的遍历</span></span><br><span class="line"><span class="comment">//        response.sendError</span></span><br><span class="line"><span class="comment">//     List&lt;User&gt; users = Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),</span></span><br><span class="line"><span class="comment">//                new User(&quot;lisi&quot;, &quot;123444&quot;),</span></span><br><span class="line"><span class="comment">//                new User(&quot;haha&quot;, &quot;aaaaa&quot;),</span></span><br><span class="line"><span class="comment">//                new User(&quot;hehe &quot;, &quot;aaddd&quot;));</span></span><br><span class="line"><span class="comment">//        model.addAttribute(&quot;users&quot;,users);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(users.size()&gt;3)&#123;</span></span><br><span class="line"><span class="comment">//            throw new UserTooManyException();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//从数据库中查出user表中的用户进行展示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造分页参数</span></span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(pn, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用page进行分页</span></span><br><span class="line">        Page&lt;User&gt; userPage = userService.page(page, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        userPage.getRecords()</span></span><br><span class="line"><span class="comment">//        userPage.getCurrent()</span></span><br><span class="line"><span class="comment">//        userPage.getPages()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;users&quot;</span>,userPage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;table/dynamic_table&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>,<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-NoSQL"><a href="#5-NoSQL" class="headerlink" title="5.NoSQL"></a>5.NoSQL</h3><p>Redis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串（String）、散列（Hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）与范围查询、bitmaps、hyperloglogs和地理空间（geospatial）索引半径查询。<br>Redis内置了复制、LUA脚本、LRU驱动事件、事务和不同级别的磁盘持久化，并通过Redis哨兵和自动分区提高可用性。</p><ol><li><p>Redis自动配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动配置：</p><ul><li>RedisAutoConfiguration自动配置类。Redisproperties属性类—》spring.redis.xxx是对redis的配置</li><li>连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration</li><li>自动注入了Redistemplate&lt;Object,Object&gt;</li><li>自动注入了StringRedisTemplate：k: v都是String</li><li>key: value</li><li>底层只要我们使用StringRedisTemplate、RedisTemplate就可以操作redis</li></ul><p>Redis环境搭建（阿里）</p><ol><li>阿里云付费</li><li>申请redis的公网连接地址</li><li>修改白名单，允许0.0.0.0/0（任意网段）访问</li></ol></li><li><p>RedisTemplate与Lettuce</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">   </span><br><span class="line">    operations.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    String hello = operations.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切换至jedis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        导入jedis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">lfy:Lfy123456</span></span><br><span class="line">      <span class="attr">client-type:</span> <span class="string">jedis</span></span><br><span class="line">      <span class="attr">jedis:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="1-JUnit5的变化"><a href="#1-JUnit5的变化" class="headerlink" title="1. JUnit5的变化"></a>1. JUnit5的变化</h3><p>SpringBoot2.2.0版本开始引入JUnit5作为测试单元默认库</p><p>JUnit5=JUnit Platform+JUnit Jupiter+JUnit Vintage</p><p>JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。<br>JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。<br>JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。</p><p>注意：</p><p><strong>SpringBoot 2.4 以上版本移除了默认对</strong> <strong>Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test****）</strong></p><p><strong>JUnit 5’s Vintage Engine Removed from</strong> <code>spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boot05WebAdminApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前：</p><p>@SpringBootTest + @RunWith(SpringTest.class)</p><p>SpringBoot整合Junit以后。</p><ul><li>编写测试方法：@Test标注（注意需要使用junit5版本的注解）</li><li>Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</li></ul><h3 id="2-JUnit5常用注解"><a href="#2-JUnit5常用注解" class="headerlink" title="2. JUnit5常用注解"></a>2. JUnit5常用注解</h3><p>JUnit5的注解与JUnit4的注解有所变化</p><p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</a></p><ul><li><p>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</p></li><li><p>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</p></li><li><p>**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍</p></li><li><p>**@DisplayName :**为测试类或者测试方法设置展示名称</p></li><li><p>**@BeforeEach :**表示在每个单元测试之前执行</p></li><li><p>**@AfterEach :**表示在每个单元测试之后执行</p></li><li><p>**@BeforeAll :**表示在所有单元测试之前执行</p></li><li><p>**@AfterAll :**表示在所有单元测试之后执行</p></li><li><p>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</p></li><li><p>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</p></li><li><p>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</p></li><li><p>**@ExtendWith :**为测试类或测试方法提供扩展类引用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test; <span class="comment">//注意这里使用的是jupiter的Test注解！！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@DisplayName(&quot;第一次测试&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3、断言（assertions）"><a href="#3、断言（assertions）" class="headerlink" title="3、断言（assertions）"></a>3、断言（assertions）</h3><p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。<strong>这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法</strong>。JUnit 5 内置的断言可以分成如下几个类别：</p><p><strong>检查业务逻辑返回的数据是否合理。</strong></p><p><strong>所有的测试运行结束以后，会有一个详细的测试报告；</strong></p><ol><li>简单断言<br>用来对单个值进行简单的验证。如：</li></ol><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;simple assertion&quot;)</span><br><span class="line">public void simple() &#123;</span><br><span class="line">     assertEquals(3, 1 + 2, &quot;simple math&quot;);</span><br><span class="line">     assertNotEquals(3, 1 + 1);</span><br><span class="line"></span><br><span class="line">     assertNotSame(new Object(), new Object());</span><br><span class="line">     Object obj = new Object();</span><br><span class="line">     assertSame(obj, obj);</span><br><span class="line"></span><br><span class="line">     assertFalse(1 &gt; 2);</span><br><span class="line">     assertTrue(1 &lt; 2);</span><br><span class="line"></span><br><span class="line">     assertNull(null);</span><br><span class="line">     assertNotNull(new Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>数组断言<br>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;array assertion&quot;)</span><br><span class="line">public void array() &#123;</span><br><span class="line"> assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>组合断言<br>IassertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;assert all&quot;)</span><br><span class="line">public void all() &#123;</span><br><span class="line"> assertAll(&quot;Math&quot;,</span><br><span class="line">    () -&gt; assertEquals(2, 1 + 1),</span><br><span class="line">    () -&gt; assertTrue(1 &gt; 0)</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>异常断言<br>在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule<strong>注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式</strong>Assertions.assertThrows()** ,配合函数式编程就可以进行使用。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;异常测试&quot;)</span><br><span class="line">public void exceptionTest() &#123;</span><br><span class="line">    ArithmeticException exception = Assertions.assertThrows(</span><br><span class="line">           //扔出断言异常</span><br><span class="line">            ArithmeticException.class, () -&gt; System.out.println(1 % 0));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>超时断言<br>Junit5还提供了<strong>Assertions.assertTimeout()</strong> 为测试方法设置了超时时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;超时测试&quot;)</span><br><span class="line">public void timeoutTest() &#123;</span><br><span class="line">    //如果测试方法时间超过1s将会异常</span><br><span class="line">    Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>快速失败<br>通过 fail 方法直接使得测试失败</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">@DisplayName(&quot;fail&quot;)</span><br><span class="line">public void shouldFail() &#123;</span><br><span class="line"> fail(&quot;This should fail&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、前置条件"><a href="#4、前置条件" class="headerlink" title="4、前置条件"></a>4、前置条件</h3><p>JUnit 5 中的前置条件（<strong>assumptions【假设】</strong>）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@DisplayName(&quot;前置条件&quot;)</span><br><span class="line">public class AssumptionsTest &#123;</span><br><span class="line"> private final String environment = &quot;DEV&quot;;</span><br><span class="line"> </span><br><span class="line"> @Test</span><br><span class="line"> @DisplayName(&quot;simple&quot;)</span><br><span class="line"> public void simpleAssume() &#123;</span><br><span class="line">    assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;));</span><br><span class="line">    assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> @Test</span><br><span class="line"> @DisplayName(&quot;assume then do&quot;)</span><br><span class="line"> public void assumeThenDo() &#123;</span><br><span class="line">    assumingThat(</span><br><span class="line">       Objects.equals(this.environment, &quot;DEV&quot;),</span><br><span class="line">       () -&gt; System.out.println(&quot;In DEV&quot;)</span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p><h3 id="5、嵌套测试"><a href="#5、嵌套测试" class="headerlink" title="5、嵌套测试"></a>5、嵌套测试</h3><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@DisplayName(&quot;A stack&quot;)</span><br><span class="line">class TestingAStackDemo &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @DisplayName(&quot;is instantiated with new Stack()&quot;)</span><br><span class="line">    void isInstantiatedWithNew() &#123;</span><br><span class="line">        new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nested</span><br><span class="line">    @DisplayName(&quot;when new&quot;)</span><br><span class="line">    class WhenNew &#123;</span><br><span class="line"></span><br><span class="line">        @BeforeEach</span><br><span class="line">        void createNewStack() &#123;</span><br><span class="line">            stack = new Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;is empty&quot;)</span><br><span class="line">        void isEmpty() &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;throws EmptyStackException when popped&quot;)</span><br><span class="line">        void throwsExceptionWhenPopped() &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span><br><span class="line">        void throwsExceptionWhenPeeked() &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Nested</span><br><span class="line">        @DisplayName(&quot;after pushing an element&quot;)</span><br><span class="line">        class AfterPushing &#123;</span><br><span class="line"></span><br><span class="line">            String anElement = &quot;an element&quot;;</span><br><span class="line"></span><br><span class="line">            @BeforeEach</span><br><span class="line">            void pushAnElement() &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;it is no longer empty&quot;)</span><br><span class="line">            void isNotEmpty() &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;returns the element when popped and is empty&quot;)</span><br><span class="line">            void returnElementWhenPopped() &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span><br><span class="line">            void returnElementWhenPeeked() &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、参数化测试"><a href="#6、参数化测试" class="headerlink" title="6、参数化测试"></a>6、参数化测试</h3><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p><p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><ul><li>@ValueSource**: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型**</li><li>@NullSource**: 表示为参数化测试提供一个null的入参**</li><li>@EnumSource**: 表示为参数化测试提供一个枚举入参**</li><li>@CsvFileSource<strong>：表示读取指定CSV文件内容作为参数化测试入参</strong></li><li>@MethodSource<strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</strong></li></ul><p>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现<strong>ArgumentsProvider</strong>接口，任何外部文件都可以作为它的入参。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@ParameterizedTest</span><br><span class="line">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span><br><span class="line">@DisplayName(&quot;参数化测试1&quot;)</span><br><span class="line">public void parameterizedTest1(String string) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ParameterizedTest</span><br><span class="line">@MethodSource(&quot;method&quot;)    //指定方法名</span><br><span class="line">@DisplayName(&quot;方法来源参数&quot;)</span><br><span class="line">public void testWithExplicitLocalMethodSource(String name) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Stream&lt;String&gt; method() &#123;</span><br><span class="line">    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、迁移指南"><a href="#7、迁移指南" class="headerlink" title="7、迁移指南"></a>7、迁移指南</h3><p>在进行迁移的时候需要注意如下的变化：</p><ul><li><p>注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。</p></li><li><p>把@Before 和@After 替换成@BeforeEach 和@AfterEach。</p></li><li><p>把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。</p></li><li><p>把@Ignore 替换成@Disabled。</p></li><li><p>把@Category 替换成@Tag。</p></li><li><p>把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。</p></li></ul><h2 id="指标监控"><a href="#指标监控" class="headerlink" title="指标监控"></a>指标监控</h2><h3 id="1-SpringBootActuator"><a href="#1-SpringBootActuator" class="headerlink" title="1. SpringBootActuator"></a>1. SpringBootActuator</h3><ol><li><p>简介：未来微服务在云上部署以后，需要对其进行监控、追踪、审计、控制等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>1.x与2.x的区别：<br><img src="/2021/07/04/java-2021-07-04-springBoot2/1606884394162-ac7f2d8e-7abb-44df-9998-fb0f2705f238.png" alt="image.png"></p></li><li><p>如何使用：</p><ul><li><p>引入场景</p></li><li><p>访问：<a href="http://localhost:8080/actuator/">http://localhost:8080/actuator/</a>**</p></li><li><p>暴露所有监控信息为HTTP：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span> <span class="comment">#暴露所有端点信息</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span>  <span class="comment">#以web方式暴露</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>可视化：<br><a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p></li></ol><h3 id="2-Actuator-Endpoint"><a href="#2-Actuator-Endpoint" class="headerlink" title="2. Actuator Endpoint"></a>2. Actuator Endpoint</h3><ol><li>常用端点：</li></ol><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td><code>auditevents</code></td><td>暴露当前应用程序的审核事件信息。需要一个<code>AuditEventRepository组件</code>。</td></tr><tr><td><code>beans</code></td><td>显示应用程序中所有Spring Bean的完整列表。</td></tr><tr><td><code>caches</code></td><td>暴露可用的缓存。</td></tr><tr><td><code>conditions</code></td><td>显示自动配置的所有条件信息，包括匹配或不匹配的原因。</td></tr><tr><td><code>configprops</code></td><td>显示所有<code>@ConfigurationProperties</code>。</td></tr><tr><td><code>env</code></td><td>暴露Spring的属性<code>ConfigurableEnvironment</code></td></tr><tr><td><code>flyway</code></td><td>显示已应用的所有Flyway数据库迁移。 需要一个或多个<code>Flyway</code>组件。</td></tr><tr><td><code>health</code></td><td>显示应用程序运行状况信息。</td></tr><tr><td><code>httptrace</code></td><td>显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个<code>HttpTraceRepository</code>组件。</td></tr><tr><td><code>info</code></td><td>显示应用程序信息。</td></tr><tr><td><code>integrationgraph</code></td><td>显示Spring <code>integrationgraph</code> 。需要依赖<code>spring-integration-core</code>。</td></tr><tr><td><code>loggers</code></td><td>显示和修改应用程序中日志的配置。</td></tr><tr><td><code>liquibase</code></td><td>显示已应用的所有Liquibase数据库迁移。需要一个或多个<code>Liquibase</code>组件。</td></tr><tr><td><code>metrics</code></td><td>显示当前应用程序的“指标”信息。</td></tr><tr><td><code>mappings</code></td><td>显示所有<code>@RequestMapping</code>路径列表。</td></tr><tr><td><code>scheduledtasks</code></td><td>显示应用程序中的计划任务。</td></tr><tr><td><code>sessions</code></td><td>允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</td></tr><tr><td><code>shutdown</code></td><td>使应用程序正常关闭。默认禁用。</td></tr><tr><td><code>startup</code></td><td>显示由<code>ApplicationStartup</code>收集的启动步骤数据。需要使用<code>SpringApplication</code>进行配置<code>BufferingApplicationStartup</code>。</td></tr><tr><td><code>threaddump</code></td><td>执行线程转储。</td></tr></tbody></table><p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td><code>heapdump</code></td><td>返回<code>hprof</code>堆转储文件。</td></tr><tr><td><code>jolokia</code></td><td>通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖<code>jolokia-core</code>。</td></tr><tr><td><code>logfile</code></td><td>返回日志文件的内容（如果已设置<code>logging.file.name</code>或<code>logging.file.path</code>属性）。支持使用HTTP<code>Range</code>标头来检索部分日志文件的内容。</td></tr><tr><td><code>prometheus</code></td><td>以Prometheus服务器可以抓取的格式公开指标。需要依赖<code>micrometer-registry-prometheus</code>。</td></tr></tbody></table><p>最常用的Endpoint</p><ul><li><p><strong>Health：监控状况</strong></p></li><li><p><strong>Metrics：运行时指标</strong></p></li><li><p><strong>Loggers：日志记录</strong></p></li></ul><ol start="2"><li>Health Endpoint</li></ol><p>健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。</p><p>重要的几点：</p><ul><li><p>health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告</p></li><li><p>很多的健康检查默认已经自动配置好了，比如：数据库、redis等</p></li><li><p>可以很容易的添加自定义的健康检查机制</p></li></ul><ol start="3"><li>Metrics Endpoint</li></ol><p>提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；</p><ul><li><p>通过Metrics对接多种监控系统</p></li><li><p>简化核心Metrics开发</p></li><li><p>添加自定义Metrics或者扩展已有Metrics</p></li></ul><ol start="4"><li><p>管理Endpoints</p><ol><li><p>开启与禁用Endpoints</p><ul><li><p>默认所有的Endpoint除过shutdown都是开启的。</p></li><li><p>需要开启或者禁用某个Endpoint。配置模式为  **management.endpoint.**&lt;endpointName&gt;.enabled = true</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>或者禁用所有的Endpoint然后手动开启指定的Endpoint</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure><pre><code>   2.    暴露Endpoints         支持的暴露方式         * HTTP：默认只暴露**health**和**info** Endpoint         * **JMX**：默认暴露所有Endpoint         * 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则</code></pre></li></ul></li></ol></li></ol><table><thead><tr><th>ID</th><th>JMX</th><th>Web</th></tr></thead><tbody><tr><td><code>auditevents</code></td><td>Yes</td><td>No</td></tr><tr><td><code>beans</code></td><td>Yes</td><td>No</td></tr><tr><td><code>caches</code></td><td>Yes</td><td>No</td></tr><tr><td><code>conditions</code></td><td>Yes</td><td>No</td></tr><tr><td><code>configprops</code></td><td>Yes</td><td>No</td></tr><tr><td><code>env</code></td><td>Yes</td><td>No</td></tr><tr><td><code>flyway</code></td><td>Yes</td><td>No</td></tr><tr><td><code>health</code></td><td>Yes</td><td>Yes</td></tr><tr><td><code>heapdump</code></td><td>N/A</td><td>No</td></tr><tr><td><code>httptrace</code></td><td>Yes</td><td>No</td></tr><tr><td><code>info</code></td><td>Yes</td><td>Yes</td></tr><tr><td><code>integrationgraph</code></td><td>Yes</td><td>No</td></tr><tr><td><code>jolokia</code></td><td>N/A</td><td>No</td></tr><tr><td><code>logfile</code></td><td>N/A</td><td>No</td></tr><tr><td><code>loggers</code></td><td>Yes</td><td>No</td></tr><tr><td><code>liquibase</code></td><td>Yes</td><td>No</td></tr><tr><td><code>metrics</code></td><td>Yes</td><td>No</td></tr><tr><td><code>mappings</code></td><td>Yes</td><td>No</td></tr><tr><td><code>prometheus</code></td><td>N/A</td><td>No</td></tr><tr><td><code>scheduledtasks</code></td><td>Yes</td><td>No</td></tr><tr><td><code>sessions</code></td><td>Yes</td><td>No</td></tr><tr><td><code>shutdown</code></td><td>Yes</td><td>No</td></tr><tr><td><code>startup</code></td><td>Yes</td><td>No</td></tr><tr><td><code>threaddump</code></td><td>Yes</td><td>No</td></tr></tbody></table><h3 id="3、定制-Endpoint"><a href="#3、定制-Endpoint" class="headerlink" title="3、定制 Endpoint"></a>3、定制 Endpoint</h3><ol><li>定制 Health 信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.actuate.health.Health;</span><br><span class="line">import org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyHealthIndicator implements HealthIndicator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Health health() &#123;</span><br><span class="line">        int errorCode = check(); // perform some specific health check</span><br><span class="line">        if (errorCode != 0) &#123;</span><br><span class="line">            return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        return Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">构建Health</span><br><span class="line">Health build = Health.down()</span><br><span class="line">                .withDetail(&quot;msg&quot;, &quot;error service&quot;)</span><br><span class="line">                .withDetail(&quot;code&quot;, &quot;500&quot;)</span><br><span class="line">                .withException(new RuntimeException())</span><br><span class="line">                .build();</span><br><span class="line">management:</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">      show-details: always #总是显示详细信息。可显示每个模块的状态信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComHealthIndicator extends AbstractHealthIndicator &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 真实的检查方法</span><br><span class="line">     * @param builder</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;</span><br><span class="line">        //mongodb。  获取连接进行测试</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // 检查完成</span><br><span class="line">        if(1 == 2)&#123;</span><br><span class="line">//            builder.up(); //健康</span><br><span class="line">            builder.status(Status.UP);</span><br><span class="line">            map.put(&quot;count&quot;,1);</span><br><span class="line">            map.put(&quot;ms&quot;,100);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">//            builder.down();</span><br><span class="line">            builder.status(Status.OUT_OF_SERVICE);</span><br><span class="line">            map.put(&quot;err&quot;,&quot;连接超时&quot;);</span><br><span class="line">            map.put(&quot;ms&quot;,3000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        builder.withDetail(&quot;code&quot;,100)</span><br><span class="line">                .withDetails(map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>定制info信息<br>常用两种方式</p><ul><li><p>编写配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">appName:</span> <span class="string">boot-admin</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">mavenProjectName:</span> <span class="string">@project.artifactId@</span>  <span class="comment">#使用@@可以获取maven的pom文件值</span></span><br><span class="line">  <span class="attr">mavenProjectVersion:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure></li><li><p>编写InfoContributor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;example&quot;</span>,</span><br><span class="line">                Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://localhost:8080/actuator/info">http://localhost:8080/actuator/info</a> 会输出以上方式返回的所有info信息</p></li></ul></li><li><p>定制Metrics信息</p><ol><li><p>SpringBoot支持自动适配的Metrics</p><ul><li>JVM metrics, report utilization of:</li><li>Various memory and buffer pools</li><li>Statistics related to garbage collection</li><li>Threads utilization</li><li>Number of classes loaded/unloaded</li><li>CPU metrics</li><li>File descriptor metrics</li><li>Kafka consumer and producer metrics</li><li>Log4j2 metrics: record the number of events logged to Log4j2 at each level</li><li>Logback metrics: record the number of events logged to Logback at each level</li><li>Uptime metrics: report a gauge for uptime and a fixed gauge representing the application’s absolute start time</li><li>Tomcat metrics (<code>server.tomcat.mbeanregistry.enabled</code> must be set to <code>true</code> for all Tomcat metrics to be registered)</li><li><a href="https://docs.spring.io/spring-integration/docs/5.4.1/reference/html/system-management.html#micrometer-integration">Spring Integration</a> metrics</li></ul></li><li><p>增加定制Metrics</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span>&#123;</span><br><span class="line">    Counter counter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(MeterRegistry meterRegistry)</span></span>&#123;</span><br><span class="line">         counter = meterRegistry.counter(<span class="string">&quot;myservice.method.running.counter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用下面的方式</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">MeterBinder <span class="title">queueSize</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">&quot;queueSize&quot;</span>, queue::size).register(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>定制Endpoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint(id = &quot;container&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getDockerInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;docker started...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WriteOperation</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restartDocker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;docker restarted....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>场景：开发<strong>ReadinessEndpoint</strong>来管理程序是否就绪，或者<strong>Liveness****Endpoint</strong>来管理程序是否存活；</p><p>当然，这个也可以直接使用 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes</a></p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="1、Profile功能"><a href="#1、Profile功能" class="headerlink" title="1、Profile功能"></a>1、Profile功能</h3><p>为了方便多环境适配，springboot简化了profile功能。</p><ol><li><p>application-profile功能</p><ul><li>默认配置文件  application.yaml；任何时候都会加载</li><li>指定环境配置文件  application-{env}.yaml</li><li>激活指定环境</li><li>配置文件激活</li><li>命令行激活：java -jar xxx.jar –<strong>spring.profiles.active=prod  –person.name=haha</strong></li><li><strong>修改配置文件的任意值，命令行优先</strong></li><li>默认配置与环境配置同时生效</li><li>同名配置项，profile配置优先</li></ul></li><li><p>ofile条件装配功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>profile分组</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.profiles.group.production[0]=proddb</span></span><br><span class="line"><span class="string">spring.profiles.group.production[1]=prodmq</span></span><br><span class="line"></span><br><span class="line"><span class="string">使用：--spring.profiles.active=production</span>  <span class="string">激活</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2、外部化配置"><a href="#2、外部化配置" class="headerlink" title="2、外部化配置"></a>2、外部化配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><ol><li><p>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</p></li><li><p><code>@PropertySource</code> annotations on your <code>@Configuration</code> classes. Please note that such property sources are not added to the <code>Environment</code> until the application context is being refreshed. This is too late to configure certain properties such as <code>logging.*</code> and <code>spring.main.*</code> which are read before refresh begins.</p></li><li><p><strong>Config data (such as</strong> <code>**application.properties**</code> <strong>files)</strong></p></li><li><p>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</p></li><li><p>OS environment variables.</p></li><li><p>Java System properties (<code>System.getProperties()</code>).</p></li><li><p>JNDI attributes from <code>java:comp/env</code>.</p></li><li><p><code>ServletContext</code> init parameters.</p></li><li><p><code>ServletConfig</code> init parameters.</p></li><li><p>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</p></li><li><p>Command line arguments.</p></li><li><p><code>properties</code> attribute on your tests. Available on <code>@SpringBootTest</code> and the <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">test annotations for testing a particular slice of your application</a>.</p></li><li><p><code>@TestPropertySource</code> annotations on your tests.</p></li><li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools-globalsettings">Devtools global settings properties</a> in the <code>$HOME/.config/spring-boot</code> directory when devtools is active.</p></li></ol><ol><li><p>外部配置源<br>常用：<strong>Java属性文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>、<strong>命令行参数</strong>；</p></li><li><p>配置文件查找位置</p><ul><li>(1) classpath 根路径</li><li>(2) classpath 根路径下config目录</li><li>(3) jar包当前目录</li><li>(4) jar包当前目录的config目录</li><li>(5) /config子目录的直接子目录</li></ul></li><li><p>配置文件加载顺序：</p><ol><li>当前jar包内部的application.properties和application.yml</li><li>当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li><li>引用的外部jar包的application.properties和application.yml</li><li>引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li></ol></li><li><p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</p></li></ol><h3 id="3、自定义starter"><a href="#3、自定义starter" class="headerlink" title="3、自定义starter"></a>3、自定义starter</h3><ol><li><p>starter启动原理</p><ul><li>starter-pom引入 autoconfigurer 包<br><img src="/2021/07/04/java-2021-07-04-springBoot2/1606995919308-b2c7ccaa-e720-4cc5-9801-2e170b3102e1.png" alt="img"></li><li>autoconfigure包中配置使用 <strong>META-INF/spring.factories</strong> 中 <strong>EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类</strong></li><li><strong>编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</strong></li><li><strong>@Configuration</strong></li><li><strong>@Conditional</strong></li><li><strong>@EnableConfigurationProperties</strong></li><li><strong>@Bean</strong></li><li>……<br><strong>引入starter</strong> <strong>— xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —-</strong> <strong>配置项</strong></li></ul></li><li><p>自定义starter<br><strong>atguigu-hello-spring-boot-starter（启动器）</strong><br><strong>atguigu-hello-spring-boot-starter-autoconfigure（自动配置包）</strong></p></li></ol><h3 id="4、SpringBoot原理"><a href="#4、SpringBoot原理" class="headerlink" title="4、SpringBoot原理"></a>4、SpringBoot原理</h3><p>Spring原理【<a href="https://www.bilibili.com/video/BV1gW411W7wy?p=1">Spring注解</a>】、<strong>SpringMVC</strong>原理、<strong>自动配置原理</strong>、SpringBoot原理</p><ol><li><p>SpringBoot启动过程</p><ul><li>创建 <strong>SpringApplication</strong></li><li>保存一些信息。</li><li>判定当前应用的类型。ClassUtils。Servlet</li><li><strong>bootstrappers****：初始启动引导器（</strong>List<Bootstrapper><strong>）：去spring.factories文件中找</strong> org.springframework.boot.<strong>Bootstrapper</strong></Bootstrapper></li><li>找 <strong>ApplicationContextInitializer</strong>；去<strong>spring.factories找 ApplicationContextInitializer</strong></li><li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li><li><strong>找</strong> <strong>ApplicationListener  ；应用监听器。</strong>去<strong>spring.factories找ApplicationListener</strong></li><li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li><li>运行 <strong>SpringApplication</strong>、<strong>StopWatch</strong></li><li><strong>记录应用的启动时间</strong></li><li><strong>创建引导上下文（Context环境）createBootstrapContext()</strong></li><li>获取到所有之前的 <strong>bootstrappers 挨个执行</strong> intitialize() 来完成对引导启动器上下文环境设置</li><li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li><li><strong>获取所有</strong> *<em>RunListener</em>***（运行监听器）【为了方便所有Listener进行事件感知】</li><li><strong>getSpringFactoriesInstances 去</strong>spring.factories找** <strong>SpringApplicationRunListener</strong>. </li><li>遍历 <strong>SpringApplicationRunListener 调用 starting 方法；</strong></li><li><strong>相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</strong></li><li>保存命令行参数；ApplicationArguments</li><li>准备环境 prepareEnvironment（）;</li><li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li><li><strong>配置环境信息对象。</strong></li><li><strong>读取所有的配置源的配置属性值。</strong></li><li>绑定环境信息</li><li>监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</li><li>创建IOC容器（createApplicationContext（））</li><li>根据项目类型（Servlet）创建容器，</li><li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong></li><li><strong>准备ApplicationContext IOC容器的基本信息</strong>  <strong>prepareContext()</strong></li><li>保存环境信息</li><li>IOC容器的后置处理流程。</li><li>应用初始化器；applyInitializers；</li><li>遍历所有的 <strong>ApplicationContextInitializer 。调用</strong> <strong>initialize.。来对ioc容器进行初始化扩展功能</strong></li><li>遍历所有的 listener 调用 *<em>contextPrepared。EventPublishRunListenr；通知所有的监听器</em>***contextPrepared</li><li>所有的监听器 调用** <strong>contextLoaded。通知所有的监听器</strong> <strong>contextLoaded；</strong></li><li><strong>刷新IOC容器。</strong>refreshContext</li><li>创建容器中的所有组件（Spring注解）</li><li>容器刷新完成后工作？afterRefresh</li><li>所有监听 器 调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器</strong> <strong>started</strong></li><li><strong>调用所有runners；</strong>callRunners()</li><li><strong>获取容器中的</strong> <strong>ApplicationRunner</strong> </li><li><strong>获取容器中的</strong>  <strong>CommandLineRunner</strong></li><li>**合并所有runner并且按照@Order进行排序</li><li>遍历所有的runner。调用 run** <strong>方法</strong></li><li><strong>如果以上有异常，</strong></li><li><strong>调用Listener 的 failed</strong></li><li><strong>调用所有监听器的 running 方法</strong>  listeners.running(context); <strong>通知所有的监听器</strong> <strong>running</strong> </li><li><strong>running如果有问题。继续通知 failed 。调用所有 Listener 的</strong> <strong>failed；****通知所有的监听器</strong> <strong>failed</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bootstrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the given &#123;<span class="doctag">@link</span> BootstrapRegistry&#125; with any required registrations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the registry to initialize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intitialize</span><span class="params">(BootstrapRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback used to run the bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args incoming application arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback used to run the bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Application Events and Listeners</p></li></ol><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners</a></p><ul><li><strong>ApplicationContextInitializer</strong></li><li><strong>ApplicationListener</strong></li><li><strong>SpringApplicationRunListener</strong></li></ul><ol start="3"><li>ApplicationRunner 与 CommandLineRunner</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://www.yuque.com/atguigu/springboot&quot;&gt;https://www.yuque.com/atguigu/springboot&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;h</summary>
      
    
    
    
    <category term="java" scheme="https://stary1999.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://stary1999.github.io/tags/java/"/>
    
    <category term="框架" scheme="https://stary1999.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="SpringBoot2" scheme="https://stary1999.github.io/tags/SpringBoot2/"/>
    
  </entry>
  
  <entry>
    <title>git和GitHub的使用</title>
    <link href="https://stary1999.github.io/2021/07/04/tools-2021-07-04-gitAndGitHub/"/>
    <id>https://stary1999.github.io/2021/07/04/tools-2021-07-04-gitAndGitHub/</id>
    <published>2021-07-04T02:18:56.000Z</published>
    <updated>2021-07-04T09:12:30.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>git：分布式版本控制，区别于集中式版本控制。</p><p>版本控制在本地进行。需要远程库协同，进行代码的克隆与推送。不再需要担心单点服务器故障（集中式）。</p><p>常见代码仓库：github、gitee（码云）。。。</p><p>工作区（git add）-暂存区（git commit）-本地库（生成历史版本）（git push）-远程库</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>注意非中文无空格目录下。</p><p>windows和linux中换行符不一样。</p><p>无脑安装。</p><p>打开git bush ，ctrl+滚轮调整字体大小。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>设置用户签名</td><td></td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志消息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><p><strong>首次安装git必须设置用户签名</strong></p><p>用于区分不同的代码提交者（与远程仓库账号没有关系）</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>选择一个文件夹，运行<code>git init</code>，生成<code>.git</code>的隐藏文件，查看本地库状态<code>git status</code>,</p><p>vim中，<code>yy</code>复制，<code>p</code>粘贴</p><p><code>ll</code>查看文件。</p><p><code>git add [名字]</code> 添加到暂存区，追踪文件。此时可以删除文件。<code>git rm --cached [文件名]</code>删除暂存区文件，此时工作区不受影响。</p><p><code>git commit -m &quot;提交信息&quot; [文件名]</code> 提交到本地库</p><p><code>git log</code>查看详细日志消息</p><p>git中按行记录文件信息</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>命令：</p><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch [branch name]</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout [branch name]</td><td>切换分支</td></tr><tr><td>git merge [branch name]</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><p>**合并分支时注意代码冲突 **</p><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p><code>git push</code> 推送到远程库</p><p><code>git clone</code> 拉取远程库</p><p><code>git pull</code> 对本地库进行更新</p><p><code>fork</code>从别的远程库获取所有的历史和记录到自己的远程库。<code>pull request</code> 拉取请求</p><p><img src="/2021/07/04/tools-2021-07-04-gitAndGitHub/image-20210704144737803.png" alt="image-20210704144737803"></p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><h4 id="上传到远地库"><a href="#上传到远地库" class="headerlink" title="上传到远地库"></a>上传到远地库</h4><p><strong>远程库的名字最好和当前的本地库的名字相同</strong></p><p><code>git remote -v</code> 查看当前的别名</p><p><code>git remote add [name][链接]</code>创建别名，替换链接</p><p><code>git push [name]/[链接] [branch name]</code> 推送是以分支为单位的 推送整个分支到仓库</p><h4 id="拉取远程库到本地库"><a href="#拉取远程库到本地库" class="headerlink" title="拉取远程库到本地库"></a>拉取远程库到本地库</h4><p><code>git pull [name]/[链接] [branch name]</code></p><p><code>git clone [链接] [branch name]</code> 克隆代码不需要登录，且会自动创建别名</p><h4 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h4><p>fork 和pull request</p><h4 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h4><p>添加ssh</p><p>参见hexo篇</p><h1 id="idea集成git"><a href="#idea集成git" class="headerlink" title="idea集成git"></a>idea集成git</h1><h2 id="配置忽略文件"><a href="#配置忽略文件" class="headerlink" title="配置忽略文件"></a>配置忽略文件</h2><p><strong>why</strong>：与实际项目功能无关，不参与服务器上部署运行，例如idea的配置文件等。一般项目只需要源码（src+pom.xml）,屏蔽ide工具之间的差异</p><p><strong>注意项目的导入方式</strong>，例如maven的导入方式。</p><p><strong>how</strong>：创建忽略规则文件：XXX.ignore(建议：git.ignore)，建议放置在用户家目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ file</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java(J2EE)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># Virtual machine crash logs,see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>在.gitconfig文件中引用忽略配置文件。.gitconfig文件在用户根目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">[core]</span><br><span class="line">excludesfile=C:/Users/[name]/git.ignore</span><br></pre></td></tr></table></figure><p><em><strong>注意需要使用斜线，不能使用反斜线</strong></em></p><h2 id="idea中使用"><a href="#idea中使用" class="headerlink" title="idea中使用"></a>idea中使用</h2><h3 id="定位git"><a href="#定位git" class="headerlink" title="定位git"></a>定位git</h3><p>新建项目-&gt;settings-&gt;version control-&gt;git-&gt;path to git executable。设置git的安装目录，”Test”进行测试，直到idea识别到git。至此，准备环境完毕</p><h3 id="让Git管理程序"><a href="#让Git管理程序" class="headerlink" title="让Git管理程序"></a>让Git管理程序</h3><p>VCS（Version control settings）-&gt;Import into Version Control -&gt;Create git repository。创建git的本地库。</p><p>当idea中的文件变<strong>红</strong>时，代表git托管成功，此时表示此文件未添加到暂存区。<strong>绿色</strong>文件代表已添加到暂存区，但为提交到本地库。<strong>此时的状态不影响代码的执行</strong>。文件名变为<strong>黑色</strong>，表示此时不需要操作。<strong>蓝色</strong>的文件表示提交过，但发生了修改。</p><p>存到暂存区：</p><ol><li>右键文件，git，add</li></ol><p>提交到本地库：</p><ol><li>右键文件，git，commit directory，添加提交信息，commit。</li></ol><h3 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h3><p>查看版本：idea左下角，version control</p><p>切换版本：选择需要切换的版本，右键，checkout Reversion [版本号]</p><h3 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h3><p>创建分支：</p><ol><li> 右键项目名，git，Repository，branches 。new branch。</li><li>右下角，git [branch name]</li></ol><p>切换分支同理</p><p>分支合并：</p><ol><li>正常合并：Merge into Current，</li><li>代码冲突：两个都修改的分支进行合并。Merge手动合并。x表示不要这部分代码，箭头表示需要这部分代码。变黑表示合并成功并主动提交。</li></ol><h2 id="idea集成"><a href="#idea集成" class="headerlink" title="idea集成"></a>idea集成</h2><p>settings，Version control，github（若没有github，点击plugs，下载github插件），</p><p>在github中设置github账号，右侧加号，登录账号。建议使用口令的方式登录（use token）</p><h3 id="项目上传到github"><a href="#项目上传到github" class="headerlink" title="项目上传到github"></a>项目上传到github</h3><p>VCS，import into Version control,share project on github。将自己的工程分项到远程库。===自动创建远程库+上传</p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>pull、push、clone：</p><ol><li>右键，git，repository</li><li>VCS，git</li></ol><p>默认使用http协议，建议使用ssh协议（网络原因）</p><p>push，项目名，Define Remote，加入ssh连接为url。</p><p>push操作：本地库版本一定得比远程库版本高，否则会失败。若本地库代码已经落后，需要先pull拉取远程代码，将本地代码更新到最新之后，在修改，提交，推送。即：<strong>push之前，先pull</strong>。</p><p>拉取前需要注意本地代码是否修改，否则拉取过程中容易出现<strong>冲突</strong></p><p><strong>clone</strong>代码到本地库：</p><p>​    打开idea，首页：get from Version Control，填入连接</p><h2 id="git（码云）"><a href="#git（码云）" class="headerlink" title="git（码云）"></a>git（码云）</h2><p>开源中国推出的，基于git的代码托管项目。中文友好</p><p>和github类似。</p><p>码云国内http使用方便。</p><h3 id="github项目迁移到gitee"><a href="#github项目迁移到gitee" class="headerlink" title="github项目迁移到gitee"></a>github项目迁移到gitee</h3><p>gitee，新建仓库，导入已有仓库，放入github链接，注意选择https协议。</p><p>github中项目更新后，在gitee中选择强制更新（项目名称后面的更新按钮）。</p><h1 id="gitlab搭建"><a href="#gitlab搭建" class="headerlink" title="gitlab搭建"></a>gitlab搭建</h1><p>使用基于MIT许可证的基于网络的Git仓库管理工具。使用Git作为代码管理工具的web项目。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>官网，install Gitlab，</p><p>需要有服务器（高版本的服务器）</p><p>“ee”表示旗舰版，“ce”表示免费社区版。</p><p>修改linux ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifconfig-ens33</span><br></pre></td></tr></table></figure><p>修改主机名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/hostsname</span><br></pre></td></tr></table></figure><p>此外，还需要修改windows中的hosts，将linux的ip地址和主机名加入。</p><p>前期准备完成后，安装步骤参考官网</p><p>初始化gitlab服务，成功标志，gitlab reconfigure</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>启动gitlab服务，停止命令（<code>gitlab-ctl stop</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><p>启动成功后，浏览器访问</p><ol><li>ip访问，默认为80端口</li><li>主机名访问，需要配置windows的hosts</li></ol><p>登录成功后，首先需要修改root密码</p><p>使用root登录后，正常使用</p><h2 id="idea集成gitlab"><a href="#idea集成gitlab" class="headerlink" title="idea集成gitlab"></a>idea集成gitlab</h2><p>安装插件gitlab</p><p>version control，gitlab</p><p>使用详情参考github</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;git：分布式版本控制，区别于集中式版本控制。&lt;/p&gt;
&lt;p&gt;版本控制在本地进行。需要远程库协同，进行代码的克隆与推送。不再需要担心单点服务</summary>
      
    
    
    
    <category term="工具" scheme="https://stary1999.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://stary1999.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="git" scheme="https://stary1999.github.io/tags/git/"/>
    
    <category term="github" scheme="https://stary1999.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>未来网络技术课程设计小结</title>
    <link href="https://stary1999.github.io/2021/07/04/course-2021-07-04-SDNnetANDDDos/"/>
    <id>https://stary1999.github.io/2021/07/04/course-2021-07-04-SDNnetANDDDos/</id>
    <published>2021-07-04T02:18:24.000Z</published>
    <updated>2021-07-04T04:58:14.404Z</updated>
    
    <content type="html"><![CDATA[<p>博客内容为课设个人小结，具体课设参考课设报告</p><h1 id="资料查找"><a href="#资料查找" class="headerlink" title="资料查找"></a>资料查找</h1><p>这次课设的题目是在老师给的题目中四选一，在初步选定做DDos的检测与防御之后，就需要在网络上查询相关的资料、以及前人的设计方案，最初使用搜索引擎直接搜索关键字和题目，经过筛选后，有用的结果主要就一篇博文，其他的大多是类似的内容，博文写得比较详细，但是设计方案比较简略，无法有效地达到实现目的要求（自主检测与防御）。</p><p>从这，可以看出，从事相关方面的研究的人并不是太多，至少没有广泛的编写博客并被搜索引擎检测到。不过，值得注意的是，同等的筛选条件下，google比百度的结果要好很多，当然，不能否认百度的搜索结果更加贴近日常生活中，比较符合国人习惯，但是如果需要查询专业一些的资料、文献的话，还是优先考虑google、bing等搜索引擎。至于国内其他的搜索引擎，例如搜狗、360、神马等，在资料收集方面，甚至还不如百度。</p><p>其次是很多资料并不一定会被搜索引擎所检索到，需要到专门的论坛、网站去搜索，这方面也是google比百度强的一个因素。对于一个比较热门的技术或实现架构，可以尝试在B站或者知乎、CSDN上寻找相关的教学视频、博文。但如果这几个地方都找不到的话，就需要去相关工具的官网，或者github上寻找相关的项目，现在许多开源的项目都把代码托管到了github上，可以在上面查看使用说明、官方文档，遇到问题的时候，在github的issue上面找找，或许能够解决问题。</p><p>最重要也是难度比较高的资料收集方式，便是查找论文，不过论文主要对于不需要太大代码量的设计比较友好，对于需要大量编程来实现的项目，通过论文的方式只能获取实现的思路与基本算法，具体代码实现仍旧是一个十分困难的事儿，所以，对于项目而言，最佳的方式仍旧是官网和使用手册。其次是YouTube，YouTube类似B站，可以在上面找到许多相关的教学视频。</p><p>对于it行业来说，前言的技术、架构，多是国外开发的，代码也是英文编写的，所以英语在编程的学习过程中至关重要，因为使用手册大概率是英文的、官网也很有可能是英文的，代码肯定是英文的，而代码中的注释也大概率是英文的。所以，在遇到不懂的东西的时候，需要查找东西的时候，你所查询得到的结果，大概率也是英文。对于非英语母语的我而言，看下去，是最困难的一件事，但是却必须坚持看下去，值得一提的是，google翻译很好用，但是很多时候，自动翻译的情况下，它会将一些很重要的信息也给翻译成中文，所以，如果时间允许的情况下，最好还是直接看英文原文。</p><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><p>工具的使用一般网上都有教程，大多时候跟着教程一步一步走即可，但是这里面最容易出现却又最容易忽略的问题，便是版本问题。</p><p>在进行仿真实验等的过程中，往往需要同时使用多个工具进行协同，如果版本没有控制好，极大可能造成，每一步都是正确的，但是合起来就不正确了。</p><p>Example：本次实验需要用到的工具主要有，VMware、Ubuntu、mininet、floodligh、sFlow。大体流程是在VMware中创建Ubuntu虚拟机，在虚拟机中安装mininet用来搭建SDN仿真网络，使用floodlight下发流表控制，使用sFlow进行流量监控。但是需要注意的一点是，floodlight的使用需要预先安装jdk环境，在Ubuntu中使用命令安装时jdk时，14的Ubuntu默认安装的是1.7的jdk，16的Ubuntu默认安装的是1.8的jdk。但是对于floodlight而言，1.0以下的版本是基于jdk1.7的，而1.0以后的则是需要jdk1.8的环境才能运行，所以，如果在14版本的Ubuntu中安装了1.7的jdk，然后安装1.0以后版本的floodlight，那floodlight便无法顺利运行。</p><p>其次是编译，在本次实验中，floodlight的编译需要使用ant，或者maven。相较于传统的项目而言，maven确实要好用很多，很适合项目的移植，而且在IDE中导入maven项目也比较方便。不过在这次的floodlight工程中，每次打包都需要编译、测试等，每次都执行测试步骤，有些浪费时间。</p><p>最后是关于日志。一个工具的使用过程，必然伴随着日志的产生，通过分析日志，可以比较清晰明了地知道工具的状态。例如，在使用ant编译过程中报错，不能一看到“100个错”就被吓退，去仔细看日志文件，检查是什么地方出错，事实上，最后发现，所谓的100个错，是中文编码字符集不统一导致的，这也进一步说明了，在平时编码的过程中，字符集的统一的重要性，值得一提的一点是，编码不同往往会导致中文乱码，但是英文不会，所以，如果条件允许，注释什么的，也尽量使用英文编写。此外，在确实发生乱码的情况下，使用编码转换工具，最好不要生硬地改变编码，这样容易导致乱码（中文）。<br>除了工具本身提供的日志之外，我们在编写一个项目的过程中，也应该注意日志的使用，一个项目在运行过程中，其内部的运行过程与结果对我们而言是封闭的（debug）除外，我们不知道编写的代码是否出错，在那里错。所以日志输出就显得很重要，在合适的位置插入日志输入，可以便于我们在控制台上检测、判断我们的程序的问题是出在那里。输出某些关键的参数，一方面能够让我们直观地知道程序的运行状态，另一方面也能方面我们后面调试修改程序。</p><h1 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h1><p>在floodlight中添加模块：</p><p>编写类继承特定的接口并实现接口的抽象类，然后在两个配置文件中将模块注册，这样floodlight在启动的时候便可以开启相应的模块，然后再模块的startUp方法中定义自己需要添加的功能。可以通过调用接口的实现类来获取对象，（例如switch信息），根据获取的对象，便可以获取整个floodlight中的开放的参数。</p><p>获取参数后，将参数信息传到处理的函数中，从所有信息中解析出我们实验所需要的信息，然后对信息进行二次封装，方便其他类对信息进行使用。</p><p>自主检测与防御。将获取到的信息与阈值进行比较（这里提供一个想法，阈值可不可以通过某种自主学习的算法实现），根据判断结果来执行后续的操作。</p><p>下发流表进行控制。在命令行中下发流表可以通过直接敲命令的方式实现，但在编程中，下发流表需要经过开启连接-传递参数-关闭连接的过程，而且着重要注意对参数的封装。现在主流的参数传递方法为json，能够比较友好地在前端和后端进行数据传输。</p><h1 id="标准的格式"><a href="#标准的格式" class="headerlink" title="标准的格式"></a>标准的格式</h1><p>在制作PPT和Word报告是，平时做的比较随意，在一些格式、细节上不是太重视，这也进一步导致了文档本身的不够规范问题。</p><p>对于一份标准的word格式的论文。封面，样式，字体，是否有横线，页边距。目录的缩进、字体、行距。正文中的各级标题，行距，字体，西文字体，代码格式，页眉页脚，题注表注等内容，以及对参考文献的引用等。这些细节或许很小，可以忽略，但是对于一份正式的报告而言，这些细节却是必须的。</p><p>PPT。PPT主要是用来作演示的，所以PPT的排版需要着重考虑观者的感受，PPT中不一定非得有很多内容，但是一定得把自己要体现的核心东西表现出来。PPT不一定非得很多页，但是每页需要体现出每页的价值。对于一些比较正式的汇报，PPT中则不应该出现太多花里胡哨的东西，对于正式的汇报而言，需要着重突出“学术性”和“庄重性”，其他的元素过多容易喧宾夺主，也容易影响观众观感。奥卡姆剃刀原则：如无必要，勿增实体。此外，对于某个特定主题的PPT而言，尽量不要出现过多其他的元素，PPT中的任何一个图片，应该有它存在的价值，不能为了有图片而存在图片，每一个元素都应该对他的存在负责。</p><p>流程图。流程图是一个很有必要的东西，很多时候，我们可以把冗长的文字描述转换为流程图，或者其他的图标，这样做最大的好处便是直观，方便观众去理解我们所要表达的东西，其次是简化页面，报告中与其全是文字，何不如将部分文字转化为图表，这样的排版，更能让人有看下去的想法。类似的还有结构图，拓扑图等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客内容为课设个人小结，具体课设参考课设报告&lt;/p&gt;
&lt;h1 id=&quot;资料查找&quot;&gt;&lt;a href=&quot;#资料查找&quot; class=&quot;headerlink&quot; title=&quot;资料查找&quot;&gt;&lt;/a&gt;资料查找&lt;/h1&gt;&lt;p&gt;这次课设的题目是在老师给的题目中四选一，在初步选定做DDos的检</summary>
      
    
    
    
    <category term="2021课设" scheme="https://stary1999.github.io/categories/2021%E8%AF%BE%E8%AE%BE/"/>
    
    
    <category term="实验" scheme="https://stary1999.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="课程设计" scheme="https://stary1999.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="ubuntu" scheme="https://stary1999.github.io/tags/ubuntu/"/>
    
    <category term="SDN" scheme="https://stary1999.github.io/tags/SDN/"/>
    
    <category term="日志" scheme="https://stary1999.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="心得" scheme="https://stary1999.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>maven的使用</title>
    <link href="https://stary1999.github.io/2021/06/30/tools-2021-06-30-mavenUse/"/>
    <id>https://stary1999.github.io/2021/06/30/tools-2021-06-30-mavenUse/</id>
    <published>2021-06-30T01:41:37.000Z</published>
    <updated>2021-06-30T07:28:09.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装maven核心程序"><a href="#安装maven核心程序" class="headerlink" title="安装maven核心程序"></a>安装maven核心程序</h2><ol><li><strong>检查java的JAVA_HOME环境变量的配置</strong></li><li>解压maven的核心程序，放在非中文无空格的路径下</li><li>配置maven的环境变量<ol><li>MAVEN_HOME或M2_HOME</li><li>配置path变量</li></ol></li><li>验证：mvn -v</li><li>maven的核心概念<ol><li>约定的目录结构</li><li>POM</li><li>坐标</li><li><strong>依赖</strong></li><li>仓库</li><li>生命周期</li><li>继承</li><li>聚合</li></ol></li></ol><h2 id="maven工程的创建"><a href="#maven工程的创建" class="headerlink" title="maven工程的创建"></a>maven工程的创建</h2><ol><li>创建约定的目录结构</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">|---src</span><br><span class="line">|---|---main</span><br><span class="line">|---|---|---java</span><br><span class="line">|---|---|---resources</span><br><span class="line">|---|---test</span><br><span class="line">|---|---|---java</span><br><span class="line">|---|---|---resources</span><br><span class="line">|---pom.xml</span><br></pre></td></tr></table></figure><p><strong>约定&gt;配置&gt;编码</strong></p><ol start="2"><li>pom.xml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--工程名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--依赖的文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>手动运行maven</p><p>在main和test目录下创建对应的主程序和测试程序，利用dos命令运行maven。</p></li></ol><p>常用maven命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn clean清理</span><br><span class="line">mvn compile编译主程序</span><br><span class="line">mvn test-compile编译测试程序</span><br><span class="line">mvn test执行测试</span><br><span class="line">mvn package打包</span><br><span class="line">mvn install 安装</span><br><span class="line">mvn site 生成站点</span><br><span class="line">※注意：运行Maven命令时一定要进入pom.xml文件所在的目录！</span><br></pre></td></tr></table></figure><p> 修改默认本地仓库的位置：maven解压目录下的config/settings.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> localRepository</span></span><br><span class="line"><span class="comment">  | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">  | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment"> &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ul><li>pom:Project Object Model,核心配置文件，必须</li><li>坐标：groupId：公司或组织名。artificiatId:模块名。version：版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630105324108.png" alt="image-20210630105324108"></p></blockquote><ul><li><p>依赖：对于自己创建的工程，执行mvn install，将自己创建的工程添加到本地仓库中。</p><ul><li><p>依赖的范围：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">compile：主程序的可见，对测试程序也可见，参与打包</span><br><span class="line">test：主程序不可见，测试程序可见， 不参与打包</span><br><span class="line">provided：主程序可见， 测试程序可见，  不参与打包</span><br><span class="line"> 开发时用，部署时忽略，由服务器提供，例如：servlet接口，</span><br></pre></td></tr></table></figure></li></ul></li><li><p>生命周期</p><p>Clean</p><p>Site</p><p>Default</p><p>生命周期开始一样，从最初的位置开始执行，执行到指定的位置，<strong>自动化构建</strong></p><p>生命周期阶段，插件目标，插件。在生命周期阶段，插件调用指定目标生成对应程序。</p></li></ul><h2 id="eclipse中maven的使用"><a href="#eclipse中maven的使用" class="headerlink" title="eclipse中maven的使用"></a>eclipse中maven的使用</h2><p>不建议使用插件自带的（不稳定）</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630130743248.png" alt="image-20210630130743248"></p><p>指定仓库的位置</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630130906449.png" alt="image-20210630130906449"></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li>创建maven版的java工程</li><li>创建maven版的web工程</li><li>执行maven命令</li></ol><p>eclipse中，添加开始菜单项：windows-customize Respective-Menu Visibility-File-New。</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630131339995.png" alt="image-20210630131339995"></p><p>设置通过maven创建的工程的JDK版本。</p><ol><li><p>config/settings.xml文件</p></li><li><p>在profiles标签中加入如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;profile&gt;</span><br><span class="line">&lt;id&gt;jdk-1.7&lt;/id&gt;</span><br><span class="line">&lt;activation&gt;</span><br><span class="line">&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">&lt;jdk&gt;1.7&lt;/jdk&gt;</span><br><span class="line">&lt;/activation&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>新建一个maven工程，勾选simple，填写坐标信息</p><p>不必选择quarkstart，创建的目录不完全。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--坐标--&gt;</span><br><span class="line">&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;Hello&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>在对应位置填写相关代码</p><h4 id="执行maven命令"><a href="#执行maven命令" class="headerlink" title="执行maven命令"></a>执行maven命令</h4><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630133048581.png" alt="image-20210630133048581"></p><p>在Maven build 。。。中添加compile</p><h3 id="建立web工程"><a href="#建立web工程" class="headerlink" title="建立web工程"></a>建立web工程</h3><p>修改新建项目时的打包方式：默认为jar包，修改为war包</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630134011484.png" alt="image-20210630134011484"></p><p>修改工程设置</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630134234682.png" alt="image-20210630134234682"></p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630134352355.png" alt="image-20210630134352355"></p><h3 id="工程导入"><a href="#工程导入" class="headerlink" title="工程导入"></a>工程导入</h3><p>file-import-选择existing maven project</p><p><img src="/2021/06/30/tools-2021-06-30-mavenUse/image-20210630141126537.png" alt="image-20210630141126537"></p><p><strong>注意无法复制</strong></p><p>识别依据是pom.xml</p><p><strong>依赖具有传递性</strong></p><p>直接依赖与间接依赖<br>可以传递的依赖不必再每个工程模块中都重复声明。但是，注意非compile范围的依赖无法传递</p><p><strong>依赖的排除</strong></p><p>不稳定的jar包对项目造成影响  版本冲突<br>依赖排除的设置，从中间掐断的方式解除依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖的原则</strong></p><p>解决jar包的冲突问题</p><p>​    就近优先原则，路径最短<br>​    路径相同时，先声明者优先，根据dependency中的顺序</p><p><strong>统一版本管理</strong></p><p>建议配置：使用properties标签内使用自定义标签统一声明版本号<br>                    在需要统一的版本位置，使用${自定义标签名}引用声明的版本号<br>凡是需要统一引用的场合都可以采用properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>继承</p><p>例如：test范围内的Junit不能传递，必然分散在各个模块中，造成版本不一致。<br>解决思路，将Junit版本统一提取到父工程中，在子工程中不在设置，则以父工程为基准，便于修改。</p><p>操作：创建一个maven工程作为父工程，选择打包方式为pom。</p><p>在子工程中声明对父工程的引用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    父工程坐标</span><br><span class="line">    <span class="comment">&lt;!--以当前文件未基准的父工程pom.xml文件的相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relationPath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relationPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将子工程的坐标中与父工程冲突的部分删除。</p><p>在父工程中统一管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencymanagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        //配置依赖</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencymanagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>继承后，执行install安装时需要先安装父工程</strong></p></li><li><p>聚合<br>作用：一键安装各种需要使用的模块<br>配置聚合：指定各个子工程的相对路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../hellofriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../makefriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在聚合工程的pom.xml选择安装。（mvn insatll）</p></li></ul><h3 id="web工程"><a href="#web工程" class="headerlink" title="web工程"></a>web工程</h3><p>配置当前工程构建过程中的特殊配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---Web工程自动部署--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>AtguiguWeb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat6x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\DevInstall\apache-tomcat-6.0.39<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\DevInstall\apache-tomcat-6.0.39<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;properties&gt;</span></span><br><span class="line"><span class="comment">&lt;cargo.servlet.port&gt;8989&lt;/cargo.servlet.port&gt;</span></span><br><span class="line"><span class="comment">&lt;/properties&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>cargo-run<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动部署不适合在eclipse中使用</p><p>适合在命令行中用：cmd：mvn deploy</p><h2 id="maven依赖获取"><a href="#maven依赖获取" class="headerlink" title="maven依赖获取"></a>maven依赖获取</h2><p> 到<a href="http://mvnrepository.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84">http://mvnrepository.com/搜索需要的</a> jar 包的依赖信息。</p><p>常用依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装maven核心程序&quot;&gt;&lt;a href=&quot;#安装maven核心程序&quot; class=&quot;headerlink&quot; title=&quot;安装maven核心程序&quot;&gt;&lt;/a&gt;安装maven核心程序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;检查java的JAVA_HOME环境变量</summary>
      
    
    
    
    <category term="工具" scheme="https://stary1999.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="java" scheme="https://stary1999.github.io/tags/java/"/>
    
    <category term="工具" scheme="https://stary1999.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>hexo安装与使用</title>
    <link href="https://stary1999.github.io/2021/06/29/tools-2021-06-29-hexoInstallAndUse/"/>
    <id>https://stary1999.github.io/2021/06/29/tools-2021-06-29-hexoInstallAndUse/</id>
    <published>2021-06-29T02:00:32.000Z</published>
    <updated>2021-07-18T03:08:02.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h1><h2 id="hexo简介："><a href="#hexo简介：" class="headerlink" title="hexo简介："></a>hexo简介：</h2><p>hexo是一个静态博客框架，基于node.js，可以方便托管到github或者gitee。</p><p>hexo在本地编写、保存文件，通过Git发布到github的仓库中，github中有提供相关静态页面访问的服务，借此完成一个静态博客的搭建。相较于其他方式搭建博客，Hexo资源占用更小，结合github使用，不需要额外的域名，也不需要租用服务器（服务器到期是一个比较麻烦的问题）。且由于是静态网页，基本不用担心后台入侵的问题，整个过程中，数据从本地到github，不需要其他环节参与。</p><p>其次是Hexo的可定制化高，主题、插件丰富，可定制化程度也比较高，markdown （我主要使用）的写作方式也比较符合未来的发展与规划，对程序员比较友好，较大的缺点是md文档在使用图片时不是太理想，如果能够将图片文件直接保存在md文件中就好了，但估计实现（<del>不可能</del>）难度较大。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>Github创建个人仓库</li><li>生成ssh并添加到GitHub</li><li>将Hexo部署到Github</li><li>其他</li></ol><span id="more"></span><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。</p><p>windows：git官网上下载，<a href="https://gitforwindows.org/">Download git</a>：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a>。下载后打开Git Bash工具，用这个工具来使用git。</p><p>linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><p>由于Hexo是基于node.js编写的，使用需要安装node.js和npm工具</p><p>windows：官网下载：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h3><p>在Git Bash中，进入要建立博客的文件夹，或者在该文件夹下，右键使用Git Bash打开。此目录是博客目录的父目录。</p><p>Git Bash进入这个目录后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>使用<code>hexo -v</code>检查hexo版本，测试是否暗转成功。</p><p>初始化Hexo：其中blogName是博客的名字，可以随便取，这个文件夹，即是博客文件夹。<br>进入文件夹，并在这个文件夹中安装博客系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blogName</span><br><span class="line">cd blogName</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装完成后，指定文件夹目录下有：</p><ul><li>node_moduls： #依赖包</li><li>public：#存放生成的页面</li><li>scaffold：#生成文章的模板</li><li>source：#存放文章、页面的目录</li><li>themes：#主题</li><li>_config.yml：#配置文件</li></ul><p>在Git Bash中输入（博客文件夹下）下列命令，开启本地服务。正常情况下，在浏览器中输入localhost:4000便可以打开博客。使用ctrl+c停止服务运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><strong>常用的命令还有：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean简写：hexo cl清除旧的静态资源</span><br><span class="line">hexo gender简写：hexo g生成静态文件</span><br><span class="line">hexo deploy简写：hexo d部署文件到网站</span><br><span class="line">hexo server简写：hexo s启动服务</span><br></pre></td></tr></table></figure><p>生成文章：建议title为英文。可在配置文件中开启默认标题，加上创建时期，便于区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">或简写：hexo &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="4-Github创建个人仓库"><a href="#4-Github创建个人仓库" class="headerlink" title="4 Github创建个人仓库"></a>4 Github创建个人仓库</h3><ol><li><p>注册/登录github账号</p></li><li><p>创建一个新的仓库（new repository），仓库名称为自己的用户名，后面加上.github.io</p><p>完整名称应为：用户名/用户名.github.io</p></li></ol><h3 id="生成ssh并添加到Github中"><a href="#生成ssh并添加到Github中" class="headerlink" title="生成ssh并添加到Github中"></a>生成ssh并添加到Github中</h3><p>在git bash中输入，其中youname和youemail为github的用户名和邮箱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>输入下列命令检查，正确无误后，输入第三条创建ssh，将youemail替换为github邮箱，一路回车默认，正常情况下可以在C:\Users\用户名\.ssh文件夹中找到ssh的公私秘钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>选择id_rsa.pub，打开并复制里面的文本内容。</p><p>在github中，点击设置，找到ssh keys，选择new ssh key，将复制的公钥消息粘贴进去。</p><p>在git bash中验证是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi 用户名! You&#x27;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure><p>则表示ssh部署成功</p><h3 id="6将hexo部署到Github"><a href="#6将hexo部署到Github" class="headerlink" title="6将hexo部署到Github"></a>6将hexo部署到Github</h3><p>打开博客文件夹下的_config.yml配置文件，在最末尾，修改配置文件：其中repo也可以选择  <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:用户名/用户名.github.io.git的方式，之前做的时候，使用https的方式提交失败，后面采用git的方式提交。具体地址也可以在github仓库中复制。brash则是提交到github仓库的哪一个分支中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装插件并部署到github：插件必须安装，否则无法用命令将博客部署到Github。这个阶段如果报错，主要检查仓库名称是否正确，repo地址是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>部署成功后，可以在<a href="https://yourname.github.io/">https://yourname.github.io</a>查看博客</p><h3 id="7其他设置"><a href="#7其他设置" class="headerlink" title="7其他设置"></a>7其他设置</h3><ol><li><p>设置个性域名</p><p>购买域名后，在域名服务商将购买的域名解析至Github的即可，Github地址可以在域名查询网站查询。</p><p>登录Github，进入博客的仓库，点击仓库的setting，设置Custom domain，输入购买的域名。</p><p>最后在博客的source中创建一个名为CNAME的文件，无后缀，在文件中写入域名。</p><p>最后在git bash中重新部署一遍博客（clean，g，d），便可以通过个性域名访问博客。</p></li></ol><h1 id="2-Hexo配置（简单版）"><a href="#2-Hexo配置（简单版）" class="headerlink" title="2.Hexo配置（简单版）"></a>2.Hexo配置（简单版）</h1><h2 id="1-config-yml配置文件修改"><a href="#1-config-yml配置文件修改" class="headerlink" title="1._config.yml配置文件修改"></a>1._config.yml配置文件修改</h2><p>这里主要修改几项常用的，其他可以根据需求查看官方文档进行修改</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>url</code></td><td align="left">网址, 即为本博客的网址</td></tr><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称，建议修改为:year-:month-:day-:title.md</td></tr><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr></tbody></table><p>详细配置参数可以参考官网：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p><h2 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h2><p>主题商店链接：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>可以在主题商店选择喜欢的主题，可以预览样式，点击主题名称，可以查看主题github项目地址。一般主题中都有README.md文档，里面有相对详细的功能说明。</p><p><strong>注意</strong></p><ul><li>主题的安装过程中，主题必须放在themes文件夹下，更换主题只需要更换博客根目录中的主题名称即可。注意通过clone下载的主题中可能会有一个”.git”的隐藏文件夹，需要手动删除，不然会影响项目的上传（不能嵌套.git）。</li><li>各种主题中有各种功能，很多都需要安装插件，所以，在clone主题，修改配置文件中的主题后，还需要安装相应的插件。还有就是，很多功能时依赖于配置文件来设置的，当运行报错的时候，仔细检查配置文件中是否有某样功能处于开启状态，但是却没有配置相关参数。</li><li>更换主题后报错，首先检查插件是否装对，其次检查各种操作是否符合README.md文档的说明，检查相关参数是否设置完毕。可以根据报错的信息，大概判断错误是在哪个部位。最后，可以去主题的仓库，里面有个issue的部分，说不定别人也遇到了相同的问题，最后，也可以虚心向作者请教。</li></ul><h1 id="3-使用hexo"><a href="#3-使用hexo" class="headerlink" title="3.使用hexo"></a>3.使用hexo</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>在git bash中，进入博客的目录。输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new postname</span><br></pre></td></tr></table></figure><p>在source/_post/文件夹中创建一个名字为postname的markdown文件。<br>（如果修改默认标题的话，以修改的为准），使用markdown编辑器，对md文件进行编辑，编写自己的文章，文章编写完成后，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>便可以将文章推送到github。</p><p>在scaffolds文件下，有个post.md文件，里面是创建一个新的post时默认使用的模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">author: &#123;&#123; author &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">- default</span><br><span class="line">categories: </span><br><span class="line">- default</span><br></pre></td></tr></table></figure><p>这一段消息会被默认添加到每一篇文章中，包括了文章标题、创建的日期、作者、标签、分类。其中标签可以由多个，分类只能有一个。</p><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>略</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>略</p><h3 id="文章统计"><a href="#文章统计" class="headerlink" title="文章统计"></a>文章统计</h3><p>略</p><h3 id="更换主页"><a href="#更换主页" class="headerlink" title="更换主页"></a>更换主页</h3><p>hexo默认的主页是显示文章列表，当我们不想首页显示文章列表时，可以自定义主页。</p><p>在source目录下，新建一个index文件夹，index文件夹中，新建一个index.md文件，填入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: index</span><br><span class="line">type: &quot;index&quot;</span><br><span class="line">permalink: index.html</span><br></pre></td></tr></table></figure><p>接下来填入需要在主页显示的内容，例如我的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* [主页](../home/)</span><br><span class="line">* [标签](../tages/)</span><br><span class="line">* [分类](../categories/)</span><br><span class="line">* [归档](../assort/)</span><br><span class="line">* [关于](../about/)</span><br></pre></td></tr></table></figure><p>打开根目录配置文件：_config.yml，修改path为’/index/‘，保存文件，重启服务器即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)  &#x27;/intro/&#x27;</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;/index/&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure><h1 id="final-踩坑"><a href="#final-踩坑" class="headerlink" title="final 踩坑"></a>final 踩坑</h1><h2 id="主题异常"><a href="#主题异常" class="headerlink" title="主题异常"></a>主题异常</h2><p>在使用主题时，开启服务后不断报错，<br>报错显示，有未定义的变量</p><p>无法运行，最后发现，是因为博客默认开启了评论功能，但是我没有再配置文件中添加相关的配置，于是就出现了”未定义的变量”的错误。</p><h2 id="hexo图片显示异常"><a href="#hexo图片显示异常" class="headerlink" title="hexo图片显示异常"></a>hexo图片显示异常</h2><ul><li><strong>设置路径</strong></li></ul><p>使用typora编辑md文件后，插入的图片如果是采用截图的方式，图片资源将会保存在临时文件中，图片的引用路径也是临时文件的路径。</p><p>首先，需要修改typora的图片设置：文件-偏好设置-图像，设置插入图片时的相关参数，选择复制图片到指定路径，指定路径为md文件的同名文件夹，并设置本地应用规则，如果对应服务器有账号，也可以选择上传到对应的服务器中（未尝试）。</p><p><img src="/2021/06/29/tools-2021-06-29-hexoInstallAndUse/image-20210629132211843.png"></p><ul><li><strong>hexo安装插件</strong></li></ul><p>修改配置文件_config.yml：设置post_asset_folder  为 true</p><p>安装插件 asset-image:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:<span class="comment">//github.com/CodeFalling/hexo-asset-image</span></span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s </span><br></pre></td></tr></table></figure><p><strong>注意修改图片路径</strong></p><p>注意修改图片路径中的\为/。</p><p>且文件名尽量不要为中文。</p><ul><li>其他方案</li></ul><ol><li>将图片放入<code>source/images</code>目录下,每次<code>generate</code>都会生成图片,在使用相对或绝对路径进行引用</li><li> 配置<code>hexo</code>的<code>_config.yml</code>文件, 将 <code>post_asset_folder</code> 设置为<code>true</code>, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. </li><li> 使用<code>hexo</code>官方的解决方案,使用模版变量, <code>&#123;% asset_img slug [title] %&#125; </code></li></ol><p>前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了<code>markdown</code>的意义。顾采用上述方案，保证本地文件显示正常，且网页正常显示。</p><p>参考：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1702112">https://cloud.tencent.com/developer/article/1702112</a></li><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-安装hexo&quot;&gt;&lt;a href=&quot;#1-安装hexo&quot; class=&quot;headerlink&quot; title=&quot;1.安装hexo&quot;&gt;&lt;/a&gt;1.安装hexo&lt;/h1&gt;&lt;h2 id=&quot;hexo简介：&quot;&gt;&lt;a href=&quot;#hexo简介：&quot; class=&quot;headerlink&quot; title=&quot;hexo简介：&quot;&gt;&lt;/a&gt;hexo简介：&lt;/h2&gt;&lt;p&gt;hexo是一个静态博客框架，基于node.js，可以方便托管到github或者gitee。&lt;/p&gt;
&lt;p&gt;hexo在本地编写、保存文件，通过Git发布到github的仓库中，github中有提供相关静态页面访问的服务，借此完成一个静态博客的搭建。相较于其他方式搭建博客，Hexo资源占用更小，结合github使用，不需要额外的域名，也不需要租用服务器（服务器到期是一个比较麻烦的问题）。且由于是静态网页，基本不用担心后台入侵的问题，整个过程中，数据从本地到github，不需要其他环节参与。&lt;/p&gt;
&lt;p&gt;其次是Hexo的可定制化高，主题、插件丰富，可定制化程度也比较高，markdown （我主要使用）的写作方式也比较符合未来的发展与规划，对程序员比较友好，较大的缺点是md文档在使用图片时不是太理想，如果能够将图片文件直接保存在md文件中就好了，但估计实现（&lt;del&gt;不可能&lt;/del&gt;）难度较大。&lt;/p&gt;
&lt;h2 id=&quot;安装步骤&quot;&gt;&lt;a href=&quot;#安装步骤&quot; class=&quot;headerlink&quot; title=&quot;安装步骤&quot;&gt;&lt;/a&gt;安装步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装Git&lt;/li&gt;
&lt;li&gt;安装Node.js&lt;/li&gt;
&lt;li&gt;安装Hexo&lt;/li&gt;
&lt;li&gt;Github创建个人仓库&lt;/li&gt;
&lt;li&gt;生成ssh并添加到GitHub&lt;/li&gt;
&lt;li&gt;将Hexo部署到Github&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="工具" scheme="https://stary1999.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="default" scheme="https://stary1999.github.io/tags/default/"/>
    
    <category term="hexo" scheme="https://stary1999.github.io/tags/hexo/"/>
    
    <category term="踩坑" scheme="https://stary1999.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://stary1999.github.io/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://stary1999.github.io/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2021-06-29T02:00:08.000Z</published>
    <updated>2021-07-01T10:06:57.613Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h1><h2 id="1-1-字体设置（斜体、粗体、删除线）"><a href="#1-1-字体设置（斜体、粗体、删除线）" class="headerlink" title="1.1 字体设置（斜体、粗体、删除线）"></a>1.1 字体设置（斜体、粗体、删除线）</h2><p>正常文字<br><em>斜体文字</em><br><em>斜体文字</em><br><strong>加粗文字</strong><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629101027698.png" alt="image-20210629101027698"></p><h2 id="1-2分级标题"><a href="#1-2分级标题" class="headerlink" title="1.2分级标题"></a>1.2分级标题</h2><p>标题用#+空格+标题内容表示，一个#号表示一级标题，最多为六级标题。</p><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629101313316.png" alt="image-20210629101313316"></p><p>写法二：</p><p>略，待更新</p><span id="more"></span><h2 id="1-3-链接"><a href="#1-3-链接" class="headerlink" title="1.3 链接"></a>1.3 链接</h2><p>插入图片为了便于迁移文档，建议在文档同名目录下，新建一个文件夹用作保存图片资源。</p><p>在typora中，可以开启自动保存图片的设置，方便编写文档，否则，截屏的图片资源默认是存在临时文件夹中的，当清理系统时，临时文件会被删除，文档中的图片资源链接也会随之失效。</p><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629102030713.png" alt="image-20210629102030713"></p><p>插入网页链接，可以用&lt;链接&gt;引起来，也可以直接输入链接地址，会自动转换。</p><p><strong>超链接</strong></p><p>格式为[内容]+(链接)</p><p>例如：<a href="baidu.com">百度</a></p><h2 id="1-4分割线"><a href="#1-4分割线" class="headerlink" title="1.4分割线"></a>1.4分割线</h2><p>在一行中用三个以上的星号（*），减号（-），底线（_)来建立分割线。注意行内不能有其他东西（可以插入空格）</p><hr><hr><hr><h2 id="1-5代码块"><a href="#1-5代码块" class="headerlink" title="1.5代码块"></a>1.5代码块</h2><h3 id="1批量代码"><a href="#1批量代码" class="headerlink" title="1批量代码"></a>1批量代码</h3><p>a:两种方式创建代码块，a：利用缩进tab（或四个空格）</p><p>未成功？？待更新</p><p>b:利用英文反引号，”`”,一般在键盘左上角。在代码的始末位置连续使用三个反引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class hello&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Syetem.out.println(&quot;hello markdown!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2行内式代码"><a href="#2行内式代码" class="headerlink" title="2行内式代码"></a>2行内式代码</h3><p>在行内引用代码，使用一对反引号包裹代码内容，例如：这是一个<code>code</code>。</p><h3 id="3代码高亮"><a href="#3代码高亮" class="headerlink" title="3代码高亮"></a>3代码高亮</h3><p>在反引号后面加上对应的代码语言</p><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629111930189.png" alt="image-20210629111930189"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Syetem.out.println(<span class="string">&quot;hello markdown!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="4代码块中包含html"><a href="#4代码块中包含html" class="headerlink" title="4代码块中包含html"></a>4代码块中包含html</h3><p><del>在代码块区域，&amp;、&lt;、&gt;会自动转换为html实体，顾代码块中的html会显示为html样式。</del></p><p>例如：</p><p>???</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>course<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>day 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>day 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>day 3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Kangkang<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Mary<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Jan<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-6引用"><a href="#1-6引用" class="headerlink" title="1.6引用"></a>1.6引用</h2><p>在被引用的文本前添加&gt;符号和一个空格。</p><blockquote><p>引用</p></blockquote><p>引用嵌套：</p><p>?</p><p>引用其他要素</p><p>？</p><h2 id="1-7列表"><a href="#1-7列表" class="headerlink" title="1.7列表"></a>1.7列表</h2><ol><li>无序列表<br>使用*，+，-跟随空格表示无序列表</li></ol><ul><li>列表一</li><li>列表二</li></ul><ol start="2"><li>有序列表</li></ol><p>使用数字和英文句点表示有序列表，后跟空格。</p><ol start="3"><li><p>无序和有序可嵌套使用</p><ol><li>上一级和下一级之间敲三个空格（或者在缩进后直接敲）</li></ol></li><li><p>列表与其他混用</p><ul><li><ol><li><del>文字</del></li></ol></li></ul></li><li><p>注意事项</p><ul><li><p>加粗效果不能直接用于列表标题，但可以嵌套在列表中使用</p></li><li><p>列表中包含代码块，前面需要两个tab且空一行</p></li><li><p>使用列表时，数字后面+英文点号+空格，可能会被误判为列表，需使用转义字符\。</p></li></ul></li></ol><h2 id="1-8表格"><a href="#1-8表格" class="headerlink" title="1.8表格"></a>1.8表格</h2><p>表格的使用:</p><p><strong>注意行与行之间不能有空格，按回车时建议使用shift</strong></p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名<span class="params">|技能|</span>排行</span><br><span class="line">--<span class="params">|:--:|</span>--:</span><br><span class="line">刘备<span class="params">|哭|</span>大哥</span><br><span class="line">关羽<span class="params">|打|</span>二哥</span><br><span class="line">张飞<span class="params">|骂|</span>三弟</span><br></pre></td></tr></table></figure><h1 id="2快捷键"><a href="#2快捷键" class="headerlink" title="2快捷键"></a>2快捷键</h1><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td><strong>加粗</strong></td><td>ctrl+b</td></tr><tr><td><em>斜体</em></td><td>ctrl+i</td></tr><tr><td>引用</td><td>ctrl+q</td></tr><tr><td>插入链接</td><td>ctrl+l</td></tr><tr><td>插入代码</td><td>ctrl+k</td></tr><tr><td>插入图片</td><td>ctrl+g</td></tr><tr><td>提升标题</td><td>ctrl+h</td></tr><tr><td>有序列表</td><td>ctrl+o</td></tr><tr><td><u>无序列表</u></td><td>ctrl+u</td></tr><tr><td>横线</td><td>ctrl+r</td></tr><tr><td>撤销</td><td>ctrl+z</td></tr><tr><td>重做</td><td>ctrl+y</td></tr></tbody></table><h1 id="3-常用技巧"><a href="#3-常用技巧" class="headerlink" title="3.常用技巧"></a>3.常用技巧</h1><h2 id="3-1换行"><a href="#3-1换行" class="headerlink" title="3.1换行"></a>3.1换行</h2><ul><li><p>方法1：连续两个以上空格+回车</p></li><li><p>方法2：使用html中的<br></p></li></ul><h2 id="3-2缩进字符"><a href="#3-2缩进字符" class="headerlink" title="3.2缩进字符"></a>3.2缩进字符</h2><h2 id="3-3-特殊字符"><a href="#3-3-特殊字符" class="headerlink" title="3.3 特殊字符"></a>3.3 特殊字符</h2><ol><li><p>对于markdown中的语法符号，前方添加反斜线\即可显示符号本身</p></li><li><p>其他字符查看对于的Unicode码，参考网站：<a href="https://unicode-table.com/cn/">https://unicode-table.com/cn/</a></p></li></ol><h2 id="3-4-字体，字号，颜色"><a href="#3-4-字体，字号，颜色" class="headerlink" title="3.4 字体，字号，颜色"></a>3.4 字体，字号，颜色</h2><p>利用html内嵌代码实现</p><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629115237467.png"></p><h2 id="3-5-高级链接"><a href="#3-5-高级链接" class="headerlink" title="3.5 高级链接"></a>3.5 高级链接</h2><ul><li><p>行内式</p></li><li><p>参考式连接</p></li><li><p>内容目录<br>在段落中填写[TOC]以显示全文内容的目录</p></li></ul><p>[TOC]</p><ul><li><p>锚点：</p><p>即页内超链接</p><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629115733687.png" alt="image-20210629115733687"></p></li><li><p>注脚[^注脚名字]，实现，例如[^1]</p></li><li><p>背景色<br>采用内置html实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure><table><tr><td bgcolor="orange">背景色是：orange</td></tr></table></li><li><p>emoji表情符号</p><p>emoji表情使用:EMOJICODE:的格式，详细列表可见<br><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">https://www.webpagefx.com/tools/emoji-cheat-sheet/</a></p></li></ul><h1 id="4高级用法"><a href="#4高级用法" class="headerlink" title="4高级用法"></a>4高级用法</h1><h2 id="4-1latex数学公式"><a href="#4-1latex数学公式" class="headerlink" title="4.1latex数学公式"></a>4.1latex数学公式</h2><p>1.行内公式：使用两个”$”符号引用公式:</p><p>$公式$</p><p>2.行间公式：使用两对”$$”符号引用公式：</p><p>$$公式$$</p><p>输入$\sqrt{x^{2}}$<br>$<br>\sqrt{x^{2}}<br>$<br>具体可以参考 markdown编辑器使用LaTex数学公式（<a href="https://link.jianshu.com/?t=http://blog.csdn.net/testcs_dn/article/details/44229085%EF%BC%89">https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Ftestcs_dn%2Farticle%2Fdetails%2F44229085）</a></p><p>latex数学符号详见：<a href="https://www.mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a></p><h2 id="4-2流程图"><a href="#4-2流程图" class="headerlink" title="4.2流程图"></a>4.2流程图</h2><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/20180802165820199" alt="img"></p><h2 id="4-3-待办事项：Todo列表："><a href="#4-3-待办事项：Todo列表：" class="headerlink" title="4.3 待办事项：Todo列表："></a>4.3 待办事项：Todo列表：</h2><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/20180802165859799" alt="img"></p><h2 id="4-4-绘制序列图"><a href="#4-4-绘制序列图" class="headerlink" title="4.4 绘制序列图"></a>4.4 绘制序列图</h2><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/2018080216592352" alt="img"></p><h2 id="4-5绘制甘特图"><a href="#4-5绘制甘特图" class="headerlink" title="4.5绘制甘特图"></a>4.5绘制甘特图</h2><p><img src="/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/20180802165941601" alt="img"></p><p>参考文章：</p><p><a href="https://blog.csdn.net/u014061630/article/details/81359144">https://blog.csdn.net/u014061630/article/details/81359144</a></p><p><a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></p><p><a href="http://markdown.p2hp.com/basic-syntax/">http://markdown.p2hp.com/basic-syntax/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h1&gt;&lt;h2 id=&quot;1-1-字体设置（斜体、粗体、删除线）&quot;&gt;&lt;a href=&quot;#1-1-字体设置（斜体、粗体、删除线）&quot; class=&quot;headerlink&quot; title=&quot;1.1 字体设置（斜体、粗体、删除线）&quot;&gt;&lt;/a&gt;1.1 字体设置（斜体、粗体、删除线）&lt;/h2&gt;&lt;p&gt;正常文字&lt;br&gt;&lt;em&gt;斜体文字&lt;/em&gt;&lt;br&gt;&lt;em&gt;斜体文字&lt;/em&gt;&lt;br&gt;&lt;strong&gt;加粗文字&lt;/strong&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;斜体加粗&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629101027698.png&quot; alt=&quot;image-20210629101027698&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-2分级标题&quot;&gt;&lt;a href=&quot;#1-2分级标题&quot; class=&quot;headerlink&quot; title=&quot;1.2分级标题&quot;&gt;&lt;/a&gt;1.2分级标题&lt;/h2&gt;&lt;p&gt;标题用#+空格+标题内容表示，一个#号表示一级标题，最多为六级标题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/image-20210629101313316.png&quot; alt=&quot;image-20210629101313316&quot;&gt;&lt;/p&gt;
&lt;p&gt;写法二：&lt;/p&gt;
&lt;p&gt;略，待更新&lt;/p&gt;</summary>
    
    
    
    <category term="语言" scheme="https://stary1999.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="语法" scheme="https://stary1999.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
    <category term="入门" scheme="https://stary1999.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
    <category term="markdown" scheme="https://stary1999.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
