{"meta":{"title":"Hexo","subtitle":"","description":"this is a blog","author":"stary","url":"http://stary2020.gitee.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-27T10:24:42.500Z","updated":"2021-08-27T10:24:42.500Z","comments":false,"path":"/404.html","permalink":"http://stary2020.gitee.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-26T07:46:00.075Z","updated":"2021-08-26T07:46:00.075Z","comments":false,"path":"about/index.html","permalink":"http://stary2020.gitee.io/about/index.html","excerpt":"","text":"成长中的程序员，半个极客，伪文艺青年…… 未完待续……"},{"title":"分类","date":"2021-08-18T08:57:01.186Z","updated":"2021-05-30T11:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://stary2020.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-18T08:35:20.825Z","updated":"2021-05-30T11:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"http://stary2020.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-18T07:54:57.673Z","updated":"2021-08-18T07:54:57.673Z","comments":true,"path":"index/index.html","permalink":"http://stary2020.gitee.io/index/index.html","excerpt":"","text":"123title: indextype: &quot;index&quot;permalink: index.html 主页 标签 分类 归档 关于"}],"posts":[{"title":"EVE-NG仿真路由组网与交换机配置","slug":"project-2021-08-26-EVENGOfNetwork","date":"2021-08-26T05:40:34.000Z","updated":"2021-08-26T14:04:48.977Z","comments":true,"path":"2021/08/26/project-2021-08-26-EVENGOfNetwork/","link":"","permalink":"http://stary2020.gitee.io/2021/08/26/project-2021-08-26-EVENGOfNetwork/","excerpt":"","text":"说明：本项目截止日期：2021年1月11日 本项目为之前的学习实践内容整理，记录学习过程，仅供参考、学习。 概述环境windows 10 VMware 15.5 EVE-NG VNC Xshell …… 设计本次实验拓扑图由12台路由器和一台电脑、一个云网络接口构成。 主体分为四个部分：由两台路由器组成的公司网络，由两台路由器组成的子公司网络，由7台路由器和云组成的运营商网络，和由一台路由器和一台电脑组成的用户网络。公司和子公司之家通过运营商网络连接，用户通过运营商网络保证可以正常上网。 需求1.用户网络可以上网 2.运营商网络，运营商设备运行OSPF，重要节点运行BGP 3.企业与子公司之间使用MPLS VPN连接内网 拓扑 实现基础拓扑搭建略 功能实现1家庭网络上网基本ip配置与ospf R5 ​ 配置nat及下发默认路由 R6 R11 用户网络配置 R12： 2运营商网络基本IP与ospf配置 R3： R4 R6 R7 R8 MPLS 建立bgp 虚拟路由： 3企业网络公司ip配置与ospf 子公司IP配置与ospf bgp抓取、转发数据 验证1家庭网络上网用户网络可以正常上网： 2运营商网络验证mpls检查： 验证bgp 验证bgp邻居关系： 3企业网络连通性验证公司与运营商联通测试： 公司和子公司网络连通性验证： 4总结经过好几天的不断学习与尝试后，最终基本完成了本次实验，实验的过程并非一帆风顺，经常会遇到许多问题，许多东西，虽然老师上课讲过，但是自己实际操作时，仍会有许多疏漏与错误，一步一步做实验的过程，也是一个学习与思考的过程，付出与收获是一个正比例的关系，本次实验花了很多时间，同时也收获了许多东西。 不同与之前的几次作业，本次实验需要我们自己独立思考，独立构思网络结构，并实现该网络的各种配置，这对于习惯了跟着老师走的我们来说，无疑是一个不大不小的挑战，一方面，我们缺少这种独立搭建一个项目的经验，另一方面，我们未来工作需要的也正是这种经验，而这次实验则很好地填补了我们实验方面的短板。 在这次实验中，极大地加强了我的网络相关知识，但给我印象最深的还是关于组网、网络搭建这件事本身，互联网时代，人人都挂在网络上，但我们对网络的认知却依旧停留在一个十分浅显的表面。通过这次实验，我对网络有了一个十分深刻的认识与了解，在 进一步了解网络的组网与配置后，才能更进一步体会到互联网先辈的智慧与伟大，学习的道路仍旧漫长。","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"实践","slug":"实践","permalink":"http://stary2020.gitee.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"网络","slug":"网络","permalink":"http://stary2020.gitee.io/tags/%E7%BD%91%E7%BB%9C/"}],"author":null},{"title":"基于windows server搭建的故障群集转移","slug":"project-2021-08-26-windowsServerHyperV","date":"2021-08-26T05:31:28.000Z","updated":"2021-08-26T14:20:36.106Z","comments":true,"path":"2021/08/26/project-2021-08-26-windowsServerHyperV/","link":"","permalink":"http://stary2020.gitee.io/2021/08/26/project-2021-08-26-windowsServerHyperV/","excerpt":"","text":"说明：本项目截止日期：2021年6月24日 本项目为之前的学习实践内容整理，记录学习过程，仅供参考、学习。 概述环境windows 10 VMware 15.5 windows server 2012 centos 7 MobaXterm 设计说明Hyper-V 2012 R2 故障转移群集。故障转移群集是一组独立的计算机，这些计算机相互协作以提高群集角色（之前称为应用程序和服务）的可用性和可伸缩性。 多台群集服务器（称为节点）通过物理电缆和软件连接。 如果一个或多个群集节点出现故障，其他节点就会开始提供服务（该过程称为故障转移）。 此外，群集角色会得到主动监视以验证它们是否正常工作。 如果不工作，则会重新启动这些角色或将其移动到其他节点。 故障转移群集可以实现以下⼏个⽬标： 适应计划内的停机维护，通过故障转移群集，可以在设定的时间范围内对群集内的⼀部分服务器进⾏停机维护，同时可以保障业务的连贯性。使⽤故障转移群集，可以在⽩天进⾏⼀些维护⼯作，⽽⽆需等到夜深⼈静时加班去做这些操作。 减少计划外的停机时间，故障转移群集通过⾃有的算法机制，⾃动接管意外停机服务器上的服务，减少由于硬件或软件的故障造成的停机，对业务连贯性的影响，维护整套系统的⾼可⽤性。 在 Windows Server 2012 R2 中，故障转移群集⽀持最多 64 个节点，⽽在 Windows Server 2008 R2中，仅仅⽀持 16 个节点。在数据中⼼越来越庞⼤的今天，16 个节点的限制显然是捉襟⻅肘的，要满⾜⽤户的需求，升级系统势在必⾏。同时，在 Windows Server 2012 R2 中，每个群集中的最⼤虚拟机数量也从 Windows Server 2008 R2 中的 1000 个提升到了 8000 个。 故障转移群集可以为企业带来更⾼的可⽤性，相应的，为了搭建故障转移群集需要付出⼀部分代价⽅可实现。 相对较低的资源利⽤率，由于希望当故障发⽣时，可以有备⽤的服务器随时转移故障，接管服务，因此群集内的所有服务器不可能会满负荷运⾏，⾄少要预留⼀部分资源，以完成可能会发⽣的故障转移的操作。 增加响应时间，由于最终⽤户不是直接和⽬标服务器通信，⽽是由⼀套群集机制来负载和分流，因此对于维护故障转移群集本身，这需要消耗⼀部分系统资源去实现，相应的，会增加⼀些系统响应时间。 额外的成本，由于使⽤故障转移群集需要投⼊冗余的硬件成本和共享存储，因此在设备投资上会超越⾮⾼可⽤架构的设计规划。 相对较⾼的技术要求，由于使⽤了冗余的架构设计，因此需要 IT 管理⼈员的知识⾯要更加⼴泛。 故障转移群集要求⽹络存在冗余，⼀般实际部署中，单台物理服务器会使⽤两条⽹线，其中⼀条接⼊⽣产⽹络，另外⼀条作为⼼跳线（heart line），为群集之间互相验证存活的⼿段。需要注意的是，⼼跳线在Windows Server 2012/2012 R2 中并不是必要条件。故障转移群集建议的是⽹络链路的”最好”存在冗余，⾄于冗余的线路是承载⽣产⽹络还是单纯作为⼼跳使⽤，并没有严格要求。 如果希望业务能够很好的分层处理，在规划服务器虚拟化或微软私有云之初，就需要对故障转移群集的⽹络部分进⾏统筹设计。任何⽅案都类似，当架构成型后，再做架构⽅⾯的变动，就会牵扯到很多环节，继⽽有可能影响业务的持续可⽤。 原理及技术在本次实验中，主要通过在多台windows server 2012中构建一个故障转移群集，实现业务的连续不中断服务。 实验原理如下：选择多台windows server作为服务器，其中一台（storage）负责提供域名解析服务和ad域控制，并提供iSCI目标存储，即提供用作存储的虚拟磁盘。在另外两个服务器中开启故障转移群集并建立群集、搭建服务，实现服务的高可用。搭建过程中，节点服务器需要开启hyper-V虚拟功能用以安装centos系统提供服务。同时，群集的建立是在storage提供的虚拟磁盘的基础上的，这样可以保证某个节点掉线时，服务可以快速迁移。可以说，是利用storage作为存储和中介（判断服务在哪运行与提供AD服务），利用node1和node2的性能来实现服务的运行。 当节点发生故障时，由仲裁盘进行判定，决定服务在哪个节点上运行。 实现1初始化环境在VMware中安装windows server 2012 R2。打开VMware，新建一个windows server2012的虚拟机，设置相关硬件属性，导入ISO镜像并初始化安装。 在windows server中安装VMware tools工具，方便后续操作。 安装VMware tool时需下载相关补丁，并更新 使用VMware的克隆功能，获得多个windows server镜像，包括两个节点node1、node2和一个包含ad功能的存储服务器即storage。克隆时选择从链接获得克隆，节约存储空间，如果选择单独新建windows server 服务器的话，会极大地占用磁盘资源。 重置三个镜像的sID并设置ip地址和主机名。开启虚拟机后，按下win+R键，输入sysprep，勾选通用，重置系统的sID，重置SID后，设置相关ip地址和主机名，方便组网时区分，否则，由于windows server 服务器是克隆得来的，在组网时无法区分。 分别设置三个windows server的主机名和ip地址。其中node1节点ip为192.168.68.10，node2节点ip为192.168.68.20，storage节点ip为192.168.68.30，三者的dns解析服务器都是192.168.68.30（storage提供解析服务） 开启hyper-V虚拟化。为了实现在VMware中安装windows并使用windows的虚拟化技术hyper-V，需要开启处理器的虚拟化Intel VT-x/EPT，并修改vmx的配置文件（欺骗VMware）。 修改配置文件： 2创建域控制器，并加入域storage安装ad服务器和dns服务器。在storage服务器中，新建角色，在服务器角色勾选Active Directory 域服务，在功能处勾选DNS服务，确认后，安装。 安装后，需要重启，重启storage后，点击“将此服务器提升为域控制器”。 创建新的域林。在Active Directory域服务配置向导中，添加一个新的域林，输入域名“test.com”，一路点击下一步，安装，完成域林的配置。 关闭防火墙、配置节点加入、登录用户并测试各节点域名连通性。为了实现多个节点之间的网络连通，需要关闭防火墙。并在node1和node2上，更改计算机设置，选择加入域test.com，输入域账号密码，加入test.com域。 加入域后，需要重启服务器，重启后，注意登录时不能直接登录原有的本地账户，需要登录域账户。 测试各个节点之间的连通性，由于已经加入了域，可以直接使用域名测试。 3搭建iSCI存储节点新建iSCI服务。在storage节点，新建服务器角色，勾选文件存储服务中的iSCI功能，并勾选故障转移群集。在storage上搭建iSCI服务，并提前准备故障转移群集。 新建storage盘和仲裁盘。在iSCI中，新建一个虚拟磁盘，作为群集的主要工作盘，磁盘大小选择动态拓展。新建iSCI目标，在“添加发起程序 ID”中，选择查询程序计算机ID，将node1和node2都添加进来，创建虚拟磁盘。创建之后，同样的步骤，再创建一个容量较小的磁盘，用作仲裁盘。 连接iSCI初始化磁盘并修改逻辑单元号。选择任意一个节点，打开iSCI发起程序，开启服务后，输入storage.test.com进行查找，连接到iSCI目标后，打开磁盘管理，将新增的磁盘联机后，初始化磁盘，初始化时，磁盘大小小于2T选择MBR，大于2T选择GPT的方式，初始化磁盘后，将两个磁盘新建为简单卷，然后断开连接。去往另一个节点，开启iSCI服务。由于存储盘先于仲裁盘创建，顾存储盘的单元号要小，因为云计算中，默认使用单元号较小的盘作为仲裁盘，所以需要将存储盘和仲裁盘的单元号换过来。 打开iSCI目标，点击属性，查看连接的会话，node1和node2都连接正常。 4搭建群集开启群集功能。在node1和node2中，新建服务器角色，开启hyper-V虚拟化和故障转移群集，注意开启网卡和勾选“允许此服务器发送和接收虚拟机的实时迁移”，将两个服务器设置为群集服务器。 安装好后重启，验证配置，注意验证配置前需要登录test\\administrator账户，并开启iSCI程序。 搭建群集。两个节点都验证成功后，新建群集，注意配置群集地址为192.168.68.40。创建群集后，将另一个节点也加入群集。 另一个节点加入群集： 添加群集共享卷。正常情况下，群集的磁盘中应该会有之前设置的两个虚拟磁盘，并且已经自动分配好了仲裁盘。如果未自动分配，可以右键群集，新建仲裁盘。如果没有磁盘，可以在磁盘中添加新的磁盘。 新建centos7虚拟机。部署好磁盘后，此时此刻，node1和node2两个节点中的群集的文件夹会自动同步，将centos7安装在这个文件夹中，便可以实现故障迁移，点击新建虚拟机，任选一个节点（需要事先准备好centos7的安装镜像），新建一个虚拟机，虚拟机位置一定要选择群集的文件夹（创建的存储盘）。给虚拟机分配内存、磁盘，勾选网卡，选择操作系统镜像，安装。 5在centos7系统中部署web服务查询ip地址。正确安装centos系统后，启动并正确连接，登录后，输入ip addr查询当前VMware分配的ip地址（192.168.68.136）。 使用docker部署web服务。在主机中打开MobaXterm，连接centos7系统。安装docker引擎。并配置相关的docker服务。 1[root@localhost ~]# docker images 搭建games：上传并解压games文件夹 端口映射： 1[root@promote web]# docker run -d -p 8080:80 -v /root/web/:/usr/share/nginx/html/ nginx 浏览器输入地址：192.168.68.136:8080/games，即可访问web服务。 6验证群集故障迁移由于web页面服务体现不出群集性能，下面采用ping的方式测试集群迁移时的网络情况，服务从node1实时迁移至node2： 快速迁移时的网络状态： 快速迁移时，centos角色先在原本的节点上保存，然后再在迁移节点中启动。而实时迁移则是直接迁移服务，实时迁移服务，两者对业务的影响都差不多。 node2节点关机：测试node2节点关机时，服务中断情况，从ip请求可以看出，node2节点主动重启时，对服务影响不大，重启成功后，node2节点自动加入群集，并且网页也能正常访问。 当强行关掉node1。强行关掉node1后，发现服务中断，并且中断了很长的一段时间，且未恢复。 经过测试，发现是由于centos7系统ip地址变化，由于ip地址使用的是dhcp，导致centos在node1被关掉后重启的途中，ip发生了变化，原本的服务受到了影响，无法ping通。 解决：可以通过修改centos的配置文件，将ip地址设置为静态的、固定的，避免ip变动。也可以通过设置域名来避免ip变动。 继续测试。开启节点1后，再次测试强制关闭节点2 此时：centos在node2上正常运行。 强行关掉node2后，centos服务自动转移到了node1，此时centos系统由于node2是被动关闭的，需要重启，重启过程中，centos服务受到了一定影响，但是影响不大，这段时间的丢包，主要是重启系统造成的。系统重启后，服务继续运行。 7问题及总结问题1.创建iSCI虚拟磁盘时，找不到计算机节点。原因：未开启域网络，几个节点之间未形成一个域，所以无法发现。 2.在开启hyper V功能时，无法进行下一步，提示错误。解决：原语是因为windows系统虚拟化技术与VMware之间的冲突，需要修改配置文件，才能实现强制开启。 3.强制关闭节点，导致群集磁盘错误。解决：主要原因是节点连接iSCI虚拟磁盘初始化之后，并未断开连接，以至于建立群集时，磁盘来源是通过单一节点获得的，当该节点关闭时，群集的磁盘就坏了（或另一个节点的iSCI服务未开启）。 4.群集创建错误，新建第二个群集错误。解决：由于之前的一些失误，导致群集未正常工作，当在storage的AD管理中删除群集后，仍旧不能新建群集，查阅得知，还需要清理旧的群集数据，在node上运行命令：Clear-ClusterNode。 5.iSCI连接不正常。实验发现，storage中的iSCI属性中的连接显示异常，未能及时更新节点状态，需要手动关闭再打开，才能看到最新的状态。因为这个更新不及时，导致连接磁盘反复做了好多次。 6.centos的ip地址变化，导致服务“不能用”，在实验过程中，centos的ip地址曾经由于dhcp而发生变化，导致服务一直中断连接不上，经过排查后，才发现是ip的问题，修改ip设置解决。 2总结在这次课程设计中，学到了很多东西，也发现了自己的很多不足，学习知识的过程必然伴随着痛苦，但是也伴随着掌握知识的喜悦。 首先是过于依赖教程。平时的各种实验，都过于依赖于老师给予的教程文档，而忽视了最本质的东西。像这次实验为例，一上手就按着教程做，做到一半，却发现怎么做也做不下去了，然后各种查资料，却无法解决，在老师讲解后，才恍然大悟，一开始的方向就是错误的，后面又怎么可能对，同时，这件事也告诉了我们，凡事得从大处着眼，在没理清楚整体结构的情况下就开工，必然事倍功半，没有目的的前行，不如停下来想一想该怎么走。 其次是对一些基础的把握不牢，实验中有一个事我印象挺深，在搭建centos的web服务的过程中，我采用的是docker，在配置docker的daemon.json文件时，将一个单词给敲错了，导致docker运行失败，反复卸载安装了好几次，都没解决，最后检查的时候，才发现是单词写错了。还有就是文档阅读能力，其实许多问题在开发手册或者相应论坛中都有介绍，只是没找到罢了。 最后就是要善于请教。事实上，我们现阶段学习过程中所遇到的问题，大部分情况下别人都遇到过，伙伴之间应该多交流沟通合作，这能很大程度上提高工作效率。","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"群集","slug":"群集","permalink":"http://stary2020.gitee.io/tags/%E7%BE%A4%E9%9B%86/"}],"author":null},{"title":"docker实现企业服务负载均衡架构","slug":"project-2021-08-26-dockerOfDeploy","date":"2021-08-26T05:31:04.000Z","updated":"2021-08-26T10:42:28.249Z","comments":true,"path":"2021/08/26/project-2021-08-26-dockerOfDeploy/","link":"","permalink":"http://stary2020.gitee.io/2021/08/26/project-2021-08-26-dockerOfDeploy/","excerpt":"","text":"说明：本项目截止日期：2021年5月31日 本项目为之前的学习实践内容整理，记录学习过程以及企业级生产环境的搭建，仅供参考、学习。 概述现在企业服务的架构都会进⾏解耦设计，也就是会将各种能分离的服务，全部进⾏分离，⽽容器⼜是推崇⽆状态化的服务，也就是容器中不保存任何会变化的数据，凡是需要变化的，都会保存到数据卷中。 本次实验所有的业务都是运⾏在容器环境中。 环境windows 10 VMware15.5 centos 7 结构 实现步骤1docker-ce安装删除旧的docker组件： 1sudo yum remove docker docker-common docker-selinux docker-engine 安装相关工具: 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 下载华为云docker-ce: 1curl -o /etc/yum.repos.d/docker-ce.repo https://repo.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo 修改文件配置： 1sudo sed -i &#x27;s+download.docker.com+repo.huaweicloud.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo 生成缓存： 1sudo yum makecache fast 安装docker-ce： 1sudo yum install -y docker-ce 启动docker： 123sudo systemctl start dockersudo systemctl enable dockersudo docker version 2 nginx实现负载均衡：复制nginx容器的配置文件并检查： 12docker run -it -v /root/data/nginx:/data --rm nginx \\ cp /etc/nginx/conf.d/default.conf /data 检查： 1ls -lh /root/data/nginx/ 安装vim并修改配置文件： 1yum -y install vim &amp;&amp; vim /root/data/nginx/default.conf 创建web1容器： 123docker run -d \\ -v /root/data/html:/var/www/html \\ --rm --name web1 php:5.6-apache 创建web2容器： 123docker run -d \\ -v /root/data/html:/var/www/html \\ --rm --name web2 php:5.6-apache 在、root/data/html中创建php探针文件 12cd /root/data/htmlvim info.php 创建nginx容器，并读取配置文件在/root/data/nginx中，连接两个web容器 1docker run -d --rm --name lb -p 80:80 -v /root/data/nginx:/etc/nginx/conf.d --link web1:web1 --link web2:web2 nginx 打开浏览器，多次访问探针页面，观察主机名，测试是不同的web容器在提供服务。 证实nginx实现了负载均衡 3 web服务容器：删除所有容器： 12docker rm -f &#x27;docker ps -qa&#x27;docker ps -a 编写Dockerfile: 1vim Dockerfile 构建新php镜像myphp 1docker build -t myphp . docker images 在web服务器中添加memcache 12docker run --rm -v /root/data/phpini:/data myphp cp -r /usr/local/etc/php/. /datals -lh /root/data/phpini 修改php.ini 文件： 1session.save_handler=Memcached 1session.save_path=&quot;tcp://session:11211&quot; 修改完毕，启动web容器，查看组件是否安装齐全 12345docker run -d -p 81:80 \\ -v /root/data/html:/var/www/html \\-v /root/data/phpini:/usr/local/etc/php --rm --name web1 myphp 网页登录检查： 4 数据库容器：删除所有容器： 12345docker rm -f `docker ps -qa`docker run --name db --rm \\ -v /root/data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mariadb:5.5.64 加入探针测试： 1curl -o /root/data/html/tz.php http://mirrors.eagleslab.com:8889/tz.php 开启容器，访问探针，测试数据库连接 12345docker run -d --link db:db -p 81:80 \\ -v /root/data/html:/var/www/html \\ -v /root/data/phpini:/usr/local/etc/php --restart=always --name web1 myphp 5 搭建网站：删除所有容器： 12345docker rm -f `docker ps -qa`session缓存容器docker run -d --restart=always --name session memcached 启动mariadb数据库容器 123docker run --name db --restart=always \\ -v /root/data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mariadb:5.5.64 启动web1服务容器 12345docker run -d --link db:db --link session:session \\ -v /root/data/html:/var/www/html \\ -v /root/data/phpini:/usr/local/etc/php --restart=always --name web1 myphp 启动web2服务容器 12345docker run -d --link db:db --link session:session \\ -v /root/data/html:/var/www/html \\ -v /root/data/phpini:/usr/local/etc/php --restart=always --name web2 myphp 启动nginx容器 1docker run -d --restart=always --name lb -p 80:80 -v /root/data/nginx:/etc/nginx/conf.d --link web1:web1 --link web2:web2 nginx 6 部署网站：创建数据库 1docker exec -it db mysql -uroot -p123456 -e &quot;create database typecho;show databases;&quot; 下载原码： 12345cd data/html/curl -O http://mirrors.eagleslab.com:8889/typecho.zipyum -y install unzip &amp;&amp; unzip typecho.zip 访问网站： 手动创建config.inc.php文件 1vim /root/data/html/config.inc.php 粘贴代码 刷新 安装成功 查看1的日志 1docker logs -f web1 总结1.通过Dockerfile创建myphp镜像失败，原因：把zlib1g-dev中的1给输入成了l。 其次是报错：无法创建文件，文件已存在，解决：删除创建文件这条命令。 2.数据库连接异常，解决：将数据库地址由localhost修改为db。","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"实践","slug":"实践","permalink":"http://stary2020.gitee.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"docker","slug":"docker","permalink":"http://stary2020.gitee.io/tags/docker/"}],"author":null},{"title":"感知与控制（快递柜）","slug":"project-2021-08-26-PerceptionAndControl","date":"2021-08-26T05:29:47.000Z","updated":"2021-08-26T15:13:47.830Z","comments":true,"path":"2021/08/26/project-2021-08-26-PerceptionAndControl/","link":"","permalink":"http://stary2020.gitee.io/2021/08/26/project-2021-08-26-PerceptionAndControl/","excerpt":"","text":"说明：本项目截止日期：2020年7月12日 本项目为之前的学习实践内容整理，记录学习过程，仅供参考、学习。 备注：本项目由三人小组共同完成。 项目仓库： 概述环境windows 10 eclipse 串口通信助手 快递柜仿真软件 虚拟串口助手 jdk1.8 设计目标(1)理解快递柜控制板仿真软件的通信协议，并设计实现，进而实现与快递柜控制板仿真软件的通信(对于控制命令要考虑可靠传输)。 (2)实现对快递柜控制板状态数据的采集与显示，包括当前温度、控制温度、控制状态、10个抽屉的开关状态。 (3)实现对开关指定抽屉、启停温度控制(压缩机制冷控制)、设置控制温度、以及设置系统参数等设置操作。 (4)依据控制温度和压缩机的启停控制，实现对快递柜控制板温度的控制，控制精度为1度。 (5)以曲线方式显示1小时内的当前温度和设定温度的变化趋势。 设计方案编程语言与平台语言: Java语言，java是一 种面向对象的高级语言，自问世以来，因其简单性、 面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性 等特点广受编程人员喜爱，eclipse则是一款官方推出的IDE。因为java的简单性和丰富的类库，所以选择java作为编程语言。通过导入RXTEcomm.jar类库来重写串口，设置相关功能函数。使用Bottom、JTextField 、Jlabel等组件来构建界面。 设计原理（1）技术: RS232通信协议。RS-232是串行数据接口标准之一, 数据帧结构包括:信息头、帧长、帧号、设备地址、功能号、数据、校验、结束标志。具备传输距离短、速度较慢的特点，适合小型单片机开发，适合本项目使用。 波特率:这是一个衡量通信速度的参数，它表示每秒钟传送的bit的个数。本项目采用的波特率为38400。数据位:这是衡量通信中实际数据位的参数。本项目的数据位为8位。停止位:用于表示单个包的最后一位。本项目的停止位为1。奇偶校验位:在串口通信中一种简单的检错方式。有四种检错方式:偶、奇、高和低。本项目采用无校验。 （2）实现原理 采用RS232协议来进行串口通信，将快递柜和控制板的相关参数设置(串口号、波特率、数据位、校验位)好，建立快递柜和控制板的通信连接。将相关指令封装，把16进制的指令进行封装，避免输入过长的16进制指令，精简使用流程。采用图形界面进行操作，构建便捷的界面，将封装好的指令与按钮相关联，通过按钮发送相关指令。实现对快递柜的控制。 将整个项目划分为3个部分:由图像界面组成的操作界面，通信部分来实现具体通信功能。通信部分又分为数据接受和数据发送，串口之间进行通信时，将数据存储在一一个缓存区域内，若是发送指令，则将指令编码写入缓存区域，将缓存区域的数据通过串口发送给快递柜。从快递柜收到的消息也存储在缓存区域，然后将数据解析，从中找到需要的字段，再进行转换，输出到界面，实现实时显示快递柜信息的功能。 可靠传输如果接收端，收到一帧数据，经过CRC校验，数据正确，这时得传一帧简易的应答帧，以告诉主机，这个帧接收成功。如果接收端，收到一帧数据，经过CRC校验，发现数据有错，这时得传一帧简易的重传帧，以请求重传。 数据帧分析数据帧格式 帧号：取值范围1-255。 帧长：为每个物理帧的实际长度，取值为10-256。 设备地址：1字节，控制板地址为1-120。 数据帧定义（1）查询帧 查询帧帧长10字节，帧号n，设备地址是控制板的地址1-120，功能号01，数据0B为NULL，每间隔5秒定期对每块控制板发送一次查询帧。 （2）启停压缩机控制帧 启停压缩机控制帧对压缩机进行启停控制，帧长11字节，帧号为n，功能号02，设备地址1-120，数据部分01代表压缩机启动，00代表压缩机停止。 （3）开锁帧 开锁帧负责对快递柜指定抽屉的开关控制，帧长12字节，帧号n，设备地址是1-120，功能号为03，数据部分为2字节，其中0th-11th,表示对应的锁的状态，1代表开，0代表关。首先，我们将某- -所需数据转换成2进制， 利用字符串的加操作完成对每一位的判断，之后会获得两个字符串， 对它们进行进制转换，将其转换成两位16进制数，我们就可以通过指定格式完成帧的组成。 （4）设置温度帧 设置温度帧对温度进行设置，帧长11字节，帧号n，设备地址是1-120，功能号为04，数据部分为设定的温度值，7th:0代表非负数，1代表负数，1th-6th表示温度整数部分0-63，0th表示温度小数部分，存在0.5，0，1代表0.5，0代表0。在文本框中输入设定温度后，获得一字符串，依次检测其符号和字符串长度，注意最后剩余整数部分要通过十进制转2进制完成并在前位补0凑齐六位，加之首尾各-位完成8位2进制， 通过进制转换得到16进制数。 （5）设置参数帧 参数帧负责控制板参数，帧长28字节，帧号n，设备地址是OX75，功能号为05，参数部分18字节，参数具体见下图。 （1）设置温度控制偏差帧 设置温度温度偏差帧帧长11字节，帧号n，设备地址是1-120，功能号为06，数据部分1字节，设定温度控制偏差，数据按终端控制板参数表中的格式定义参数。 （2）设置设备地址帧 设置设备地址帧帧长16字节，帧号n，设备地址是OX7F，功能号为09，数据部分6字节，5字节设备编码和1字节新地址。 （3）上传状态帧 上传状态帧帧长16字节，帧号n，设备地址是OX7F，功能号为10，数据部分6字节，数据部分34字节，参数是终端控制板的当前参数，18字节参数和16字节状态，控制板参数见图，控制板状态参数具体见下图。 （9）ACK帧 ACK帧帧长14字节，帧号n，设备地址是0，功能号应答的功能号，数据部分6字节，数据部分4字节，1字节设备地址，1字节命令帧号，2字节数据，数据用于执行开锁命令后表示相应锁是否打开，对应位1表示打开，否则打开失败。可靠传输采用重传机制，若在一定时间段内收不到相应功能号的ACK，则重新传送。 实现功能设计信息采集123456789101112131415161718192021222324252627282930313233public double getTemperature_gather() &#123;/*采集温度*/ String str=FormatConverter.byteToHexStr(temperature_gather); int i1= Integer.parseInt(String.valueOf(str.charAt(0)),16); int i2=Integer.parseInt(String.valueOf(str.charAt(1)),16); int ii1[]; ii1=new int [8]; for(int n=0;n&lt;4;n++) &#123; ii1[n]=i1%2; i1=i1/2; &#125; for(int n=4;n&lt;8;n++) &#123; ii1[n]=i2%2; i2=i2/2; &#125; double x=ii1[5]*1+ii1[6]*2+ii1[7]*4+ii1[0]*8+ii1[1]*16+ii1[2]*32; if(ii1[4]==1) x=x+0.5; if(ii1[3]==1) x=x*(-1); return x; &#125; public int getMachine_state() &#123;/*机器状态*/ String str=FormatConverter.byteToHexStr(machine_state); int i=Integer.parseInt(str,16); return i; &#125; 抽屉的控制设置10个按钮分别控制10个抽屉，点击按钮改变对应的开关位，抽屉控制将需要控制的抽屉编号加入列表，传参到对应函数。函数经过提取，将列表中出现的抽屉对应位置1.以此类推转化为对应的二进制数字，再转化为十六进制，加入到对应命令帧的数据位，CRC填充完发送。 123456789101112131415161718192021222324252627282930313233343536373839button.setPreferredSize(new Dimension(150, 40)); add(button); setVisible(true); button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; command=&quot;&quot;; for(int i=0;i&lt;10;i++) &#123; if(checkBox[i].isSelected()) &#123; checkBox1[i].setSelected(true); command+=checkBox[i].getText(); &#125; &#125; String regEx=&quot;[^0-9]&quot;; Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(command); command=m.replaceAll(&quot;&quot;).trim(); System.out.println(command); long sum=0; for(int i=0;i&lt;command.length();i++) &#123; char s=command.charAt(i); System.out.println(s); switch(s) &#123; case &#x27;1&#x27;: if((command.length()==1)||command.charAt(i+1)!=&#x27;0&#x27;)sum+=256;else sum+=2;break; case &#x27;2&#x27;:sum+=512;break; case &#x27;3&#x27;:sum+=1024;break; case &#x27;4&#x27;:sum+=2048;break; case &#x27;5&#x27;:sum+=4096;break; case &#x27;6&#x27;:sum+=8192;break; case &#x27;7&#x27;:sum+=16384;break; case &#x27;8&#x27;:sum+=32768;break; case &#x27;9&#x27;:sum+=1;break; default:break; &#125; &#125; 启停温度控制启停压缩机根据之前的数据分析结果，利用数据位的00和01进行压缩机的控制。启动压缩机需要考虑和温度偏差范围的配合。高于则停止，低于则运行。只有启动了温度控制，才会对接收到的实时温度进行判断是否达标(设置温度+-偏差值)，进而发送控制帧控制压缩机的停止启动。 123456789101112if(button2.getText().equals(&quot;启动温度控制&quot;)) &#123; button2.setBackground(Color.CYAN); button2.setText(&quot;停止温度控制&quot;); command=&quot;01&quot;; createFrame(2); &#125; else &#123; button2.setBackground(Color.RED); button2.setText(&quot;启动温度控制&quot;); command=&quot;00&quot;; createFrame(2);/*启停压缩机指令*/&#125;&#125; 设置控制温度在Textbox组件输入温度，点击按钮，设定中当温度控制系统处于开启状态，若检测到温度低于设定，则停止压缩机，若检测到温度高于设定，则打开压缩机，但此时压缩机会有预启动状态，所以在其预启动与启动状态不发送打开压缩机命令。 123456789101112131415161718192021222324252627282930313233public void actionPerformed(ActionEvent e) &#123; String Tem=textField.getText(); dispose(); float tem=Float.parseFloat(Tem); int t=(int)tem; String s = Integer.toString(t); textField2.setText(s); boolean flag=false; t=t*2; if(tem&lt;0) &#123; t=t*(-1); t=t+128; // t=t+1; &#125; if((tem%1)==0.5) &#123; t=t+1; flag=true; &#125; if(t&lt;15) &#123; command=&quot;0&quot;+Integer.toHexString((int)t); &#125; else &#123; command=Integer.toHexString((int)t); &#125; command=command.toUpperCase(); System.out.println(tem); System.out.println(&quot;设置温度command= &quot;+command); downQueue.add(new SetTemperatureFrame(sequence++,deviceAddress,FormatConverter.hexStringToBytes(command)[0]));/*设置温度*/ 设置系统参数参数控制包括温度，温度偏差，设备地址，压缩机预启动时间等处理方法类似。将输入的十进制数字转化为十六进制，加入到对应命令帧的数据位，CRC填充完发送。点击按钮弹出参数设置窗口， 允许不做任何输入或只设置部分参数， 不输入会默认发送上次设置的参数，如果是第一次则发送缺省值。对于组帧，要先得到文本框内字符串、先转2进制，再转16进制，组成相应帧即可。系统参数帧会有缺省情况，因此在文本框输入字符串中若为空，则使用相应缺省数据填充该位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485enter.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; String[] str=new String[6]; command=&quot;&quot;; for(int i=0;i&lt;6;i++) &#123; if(i==0)//设备编码 &#123; for(int j=textField[i].getText().length();j&lt;10;j++) command+=&quot;F&quot;; command+=textField[i].getText(); &#125; if(i==1)//设备地址 command+=textField[i].getText(); if(i==2)//上传间隔 &#123; command+=&quot;00&quot;;//备用空白帧 command+=textField[i].getText(); &#125; if(i==3)//启动时延 &#123; String tem=textField[i].getText(); int mn=Integer.parseInt(tem); String hexs=new String(); if(mn&gt;15) hexs =FormatConverter.intToHex(mn); else hexs=&quot;0&quot;+FormatConverter.intToHex(mn); command+=hexs; command+=&quot;0000&quot;;//备用 &#125; if(i==4)//设定温度 &#123; String Tem=textField[i].getText(); dispose(); String s=new String(); float tem=Float.parseFloat(Tem); int t=(int)tem; boolean flag=false; t=t*2; if(tem&lt;0) &#123; t=t*(-1); t=t+128; // t=t+1; &#125; if((tem%1)==0.5) &#123; t=t+1; flag=true; &#125; if(t&lt;15) &#123; s=&quot;0&quot;+Integer.toHexString((int)t); &#125; else &#123; s=Integer.toHexString((int)t); &#125; s=s.toUpperCase(); command+=s; &#125; if(i==5)//温度控制偏差 &#123; command+=textField[i].getText(); command+=&quot;FFFFFFFF00&quot;; &#125; //command+=textField[i].getText(); &#125; System.out.println(&quot;设置参数command= &quot;+command); dispose(); downQueue.add(new SetParameterFrame(sequence++,deviceAddress,FormatConverter.hexStringToBytes(command)));/*设置参数*/ // createFrame(5); 折线图的绘制创建CategoryDataset对象（准备数据）。 根据Dataset 生成JFreeChart对象，以及做相应的设置。 根据CategoryDataset创建JFreeChart对象。 将仿真软件发送的数据放入内存，实现一个循环数组接受数据， 12345678if (values.size() &gt; MAX_COUNT_OF_VALUES) &#123; values.remove(0); &#125;for (int i = 0; i &lt; length - 1; ++i) &#123; g2d.drawLine(xDelta * (MAX_COUNT_OF_VALUES - length + i), normalizeValueForYAxis(values.get(i), h), xDelta * (MAX_COUNT_OF_VALUES - length + i + 1), normalizeValueForYAxis(values.get(i + 1), h)); &#125; 界面设计界面布局1)、流布局： FlowLayout 从左到右，自上而下方式在容器中排列，控件的大小不会随容器大小变化. 容器.setLayout(new FlowLayout(FlowLayout.LEFT)); 2)、网格布局： GridLayout 按照指定行数与列数，将容器分成大小相等的单元格每个单元格放置一个控件. 不能将控件放在指定单元格 容器.setLayout(new GridLayout(3,4,10,15)); 3)、边界布局: BorderLayout 将容器分成东、西、南、北、中五个部分 容器.setLayout(new BorderLayout()); 窗口的内容面板默认布局就是边界布局。 容器.add(控件,BorderLayout.NORTH); 界面组件文本框：使用JComponent的子类JTextField创建文本框。文本框的允许用户输入单行文本。 文本区：使用JComponent的子类JButton类创建按钮，允许用户单击按钮。 标签：使用JComponent的子类JLabel类创建标签，标签为用户提供信息提示。 选择框：使用JComponent的子类JCheckBox类来创建选择框，为用户提供多项悬着。选择框提供两种状态，选中和未选中，用户通过单击该组件切换状态。 单选按钮:使用JComponent的子类的JRadioButton类创建单项选择框，为用户提供单项选择。 下拉列表:使用JComponent的子类的JComboBox类来创建下拉列表，为用户提供下拉列表。 部分代码public class Win extends JFrame {}建立窗体类。 private JLabel[] label;声明标签组 public JCheckBox[] checkBox1; 建立三个 JTextField类型变量，textField1文本框显示当前温度，textField2文本框显示设置温度，textField3文本框显示压缩机状态。 Piblic Win{}来设置布局和边界布局new BorderLayout()，设置窗口的长宽高setBounds(100,50,800, 650)， 设置标题setTitle(“现场快递柜状态采集与控制系统”); private class Top extends JPanel{}来设置顶部布局，建立三个标签，分别表示当前温度，设定温度，工作状态，再进行设置边界。 public class center extends JPanel {}来设置界面中的抽屉组，建立十个抽屉。规定他们的位置。 private class Bottom extends JPanel{}来设置界面底部的四个按钮以及功能的实现，就是课设要实现的四个功能，开关指定抽屉，启动温度控制，设置控制温度，设置系统参数。 button.addActionListener（new ActionListener()）来进行事件的监听，实现根据用户的操作来执行相应功能。 JFreeChart jfreechart = ChartFactory.createLineChart()来进行折线图标题，x轴，Y轴标签的显示。 使用CategoryPlot设置各种参数。 1234567CategoryPlot plot = (CategoryPlot)jfreechart.getPlot();renderer.setBaseShapesVisible(true); // series 点（即数据点）可见 renderer.setBaseLinesVisible(true); // series 点（即数据点）间有连线可见 renderer.setUseSeriesOffset(true); // 设置偏移量 public void paintComponent(Graphics g) &#123;&#125;折线图的绘制。 验证首先启动程序，可以看到虚拟串口软件中的com2已连接上，然后开启快递柜仿真程序，可以在虚拟串口软件中看到com1和com2都已连接，在eclipse控制台中也可以看到串口启动成功，接着在快递柜仿真软件数据包显示区和eclipse控制台也可以看到不断接受和发送数据帧，说明两者成功连接，可以通信，接着检验是否能正确通信和功能是否完全实现。 首先测试打开关闭抽屉功能，在采集与控制程序中打开7号和8号抽屉，可以在快递柜程序中看见两个抽屉正确打开，再实验其他抽屉，所有抽屉都能准确打开和关闭，快递柜抽屉开关功能完全实现。 信息采集与显示功能也正确实现，可以看到快递柜的当前温度和压缩机状态抽屉开关状态在采集与控制系统中都进行了正确显示，两者同步。 接着来测试参数控制功能，我们可以观察到，启动程序后快递柜仿真程序系统参数部分已经显示了数据，这是在采集与控制系统中默认的数据，接下来我们进行修改，观察能否正确传给快递柜仿真程序，先在采集与控制系统中点击系统参数设置按钮，在弹出来的框中输入参数数据，包括设备ID，设备地址，采集时间间隔，压缩机启动延时，控制温度等，上传参数后可以观察到快递柜仿真软件参数部分发生了改变，与我们上传的参数相同，所以参数控制功能也正确实现。 然后进行温度控制功能测试，首先我们在采集与控制系统中设置控制温度为15度，然后上传，可以看到信息进行更新，控制温度由原先默认的20度变为了15度，然后可以观察到快递柜仿真软件当前温度为20.5度，压缩机进行启动，温度在下降，因为参数中温度偏差设置为3度，所以在温度下降到12度时，压缩机停止工作，温度上升，上升到18度时，压缩机开始工作，可以看到温度在控制温度周围上下拨动，温度控制功能实现。 总结本次课程设计主题是感知与控制，要求掌握基于RS232的协议设计与通信方法，在此基础上实现对现场设备状态数据的采集、对设备的控制。老师给出的题目是针对快递柜系统设计实现一个对现场快递柜状态数据采集、显示、参数设置、抽屉打开、保鲜控制等功能软件系统。 我们小组有三位成员，首先对题目进行了讨论，制定了初步课设计划，对每个人的任务进行大致分工，主要是通信实现，界面设计，数据帧分析，可靠传输的保证，ppt答辩等方面。我们共同完成了数据帧分析，然后各自负责实现某些功能，例如抽屉开关、温度控制、参数控制等，最后由组长进行整合，完成整个代码的实现。我们小组使用的语言是Java语言，可以调用类库来进行编程，减少了我们的工作量，利用的平台是eclipse，我们基本实现了通过控制面板对快递柜操作的控制，将指令封装后，通过点击按钮实现指令的发送，包括了相应的抽屉的开关、温度控制、温度设置等功能。但是还有许多不足之处，由于时间紧任务重，我们小组成员的编程能力和学习能力有限，界面有待优化，在温度曲线的输出功能方面没有完全实现，在实时上传数据并绘制成图没有成功，只做出了一个模拟图来进行输出，程序还有待完善，在课设结束后，我们还会继续讨论学习，争取实现其功能，还存在一些小细节问题有待处理，存在一些bug，例如有时候数据帧丢失，无法发送成功，还需要进一步去改进程序。 从本次课程设计中，我们小组学习了基于RS232的协议设计与通信方法，了解了现场网感知与控制的基本方法，锻炼了自己的思考能力和编程能力，之前也没接触过这些知识，我们都很陌生，在十天的学习里，我们一边百度自学以及向老师同学请教，一边积极讨论，各抒己见，很大方面提高了自己的学习能力和团队协助能力，为日后学习和工作积累了项目经验。从本次课设中，我们也深刻体会到了自己编程能力还是很弱，刚开始一头雾水，先采用c++来写程序，但是遇到了很多问题，首先就是我们没用过MFC，在学习过程中也感觉很难，甚至通信有的时候都不能成功，压力很大。经过我们后来的讨论研究后组长决定使用Java语言，因为他比较擅长Java，而且在大二学年我们刚学Java，并且使用Java语言做过项目，对Java界面设计，类库调用还是比较熟悉，确定方向后我们开始奋力苦干，小组成员每天汇报进程，以及讨论所遇到的问题，积极想办法去解决，功夫不负有心人，我们最后程序大致完成了，虽然还有很多改善的地方，但是还是做出了一个成果。经过这次课设，我们感受到了编程的有趣，利用所学的知识进行编程去实际解决问题，感觉很美妙，很快乐。 虽然课程设计结束了，但是学习不能结束，我们从本次课设中学习到了很多，这次课设也给了我们三个人一个警醒，让我们清醒了一下，明白了自己的水平在哪里，知道了自己和专业佼佼者的差距，在观看答辩过程中也见到了很多大佬的程序，五花八门，大开眼界，别人不仅完成课设还进行创新实践，成果非常棒，对比之下，我们感到很大压力，毕竟我们已经大二结束了，不考研的话，马上要找工作实习了，编程能力还急需提高，课设结束后就是暑假，经过这次对我们来说磕磕绊绊困难重重的课设，相信我们在暑假里也不敢放纵自我，每天沉浸于王者峡谷，在之后的日子里我们定当沉下心来，踏踏实实学习，多思考，多研究，提升自己的水平，不浪费自己的宝贵时间，成为一个优秀的大学生。","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"}],"author":null},{"title":"远程数据采集控制（android）","slug":"project-2021-08-26-androidAndIoT","date":"2021-08-26T05:28:03.000Z","updated":"2021-08-26T09:57:33.476Z","comments":true,"path":"2021/08/26/project-2021-08-26-androidAndIoT/","link":"","permalink":"http://stary2020.gitee.io/2021/08/26/project-2021-08-26-androidAndIoT/","excerpt":"","text":"说明：本项目截止日期：2020年11月14日 项目仓库：https://github.com/stary1999/schoolStudy/tree/main/android 本项目为之前的项目整理，技术实现比较老旧，仅供参考、学习。 概述本次案例实践的主题是进行移动物联网的应用开发，通过编写一个Android手机移动端app和微信小程序，实现对物联网设备的远程控制与感知。具体实现过程为开发移动端app，连接到阿里云的物联网平台，将这个平台作为一个中转的服务器，设备接入这个服务器，移动端应用和物联网设备通过这个平台进行连接，实现数据的远程收发，达到控制的效果。考虑到物联网设备的缺乏，本次实践主要采用虚拟平台进行设备模拟，达到实验效果。 意义本此移动开发，其目的是实现一个远程控制物联网设备的“系统”，通常，这个“系统”也被称为智能家居，正如实践里做的那样，我们可以通过移动应用远程了解卧室的温湿度情况，也可以远程控制卧室台灯的开关，而这一切并不需要我们“在卧室”这一前提，突破了传统意义上的距离限制，或者说，网络就是他的距离限制。 在这个体系架构里，开发是围绕以住宅为平台，以远程控制为核心思想，在保持传统的居住功能的基础上，摆脱了被动模式。通过网络实现人与设备的远程互联与控制，智能家居不仅提供了全方位的信息交换功能，还优化了人们的生活方式和居住环境，帮助人们有效地安排时间、节约各种能源，实现了家电控制、照明控制、室内外遥控、窗帘智控、防盗报警、定时控制以及手机APP远程控制等功能。 需求分析业务需求随着科学水平的不断发展与社会的进步，人们对未来的美好的生活已经不仅仅只满足于传统意义上的遮风避雨了，生活在信息如此发达的年代的人们，对此有着更高一层的诉求。随着互联网和手机的不断普及，极大地加快了人们对于这个世界的认知方式，而绵延了数千年的传统居家模式，却在时代的浪潮里显得是如此的无人问津，但在今天，我们却又不仅仅满足于此，随着知识的积累与科技的进步，我们渐渐希望“家”可以实现更多的功能，给我们带来更好的生活体验。如今，这份希望被变现，我们的家在逐步向着一个更加美好、更加符合我们习惯、诉求的方向发展，这便是智能家居，通过传感器等硬件设备，我们让“家”具备了“说话”的能力，家里的东西，可以通过传感器等设备表达出自身的状态，让我们更加地了解我们的家，同时，无处不在的互联网让我们即使远在他处，也能“倾听”家里的声音。 用户需求现代的智能家居，一方面，这是我们对于“家”这一特殊事物的特殊感情，但另一方面，家居的智能化，也在方方面面影响着我们的生活，最显著的例子，就是他能让我们的生活更有效率，如果有什么东西是比一天劳累后的一个热水澡更加让人舒心的话，相比便是这热水澡不用花额外的电费——他会在你需要的时候启动热水器。智能家居能帮助我们有效地安排时间、节约各种能源，最为典型的例子，便是让一些电器在不该开的时候关掉，在需要开的时候即使人不在家也能打开。我们到家后，无需多余的等待时间，便可直接开始做我们需要做的事，这无疑是十分舒心的。同时，远程控制的一大意义还体现在监查家里的情况上面，相较于传统的室内监控，智能家居能让我们更方便快捷地实时掌握家里的情况，这对于防盗以及防止熊孩子方面有着巨大的作用。 功能需求用户注册功能：和传统app一样，为了确保信息的安全，必须对用户的身份进行确认，识别非法用户，并禁止非法用户进入控制界面，避免造成损失。 开关灯功能：基础功能，实现远程控制台灯的亮灭，属于感知与控制的控制一环。 温湿度读取功能：基础功能，实现将传感器采集到的温度显示给用户，作为感知与控制里的感知，这使得用户对家里的状态有一个实时的了解与认识，方面用户制定下一步计划和方案。 历史数据展示功能：通过对历史数据的展示，能让用户对于所采集的温湿度有有一个具体的认识，方面分析趋势与采取后续行为。 原理物联网云平台是为物联网定制的云平台，在物联网解决方案中，物联网云平台有着举足轻重的作用。作为现代物联网系统的核心，物联网云平台向下连接海量设备，为设备提供安全可靠的连接通信能力，支撑设备数据采集上云；向上提供云端API，通过调用云端API将与应用端进行交互，实现远程控制。 接入前准备：1、产品与设备：云上定义的产品相当于一类设备的集合，同一产品下的设备具有相同的功能，比如可以根据产品批量管理设备。云上定义的设备对应于一个个实际的物联网设备，只要将物联网云颁发的设备证书(Productkey、DeviceName和DeviceSecret)关联到实际设备上，可实现实际设备接入物联网云平台。 2、设备功能：包括设备的属性，服务和事件。物联网平台通过定义TSL(Thing Specification Language)来描述物模型，这里TSL采用JSON格式。 （1）属性：设备的功能模型之一，一般用于描述设备运行时的状态，如环境监测设备所读取的当前环境温度等。属性支持GET和SET的请求方式，应用系统可发起对属性的读取和设置请求。 ​ （2）产品标识符：阿里云采用产品标识符来指向具体功能(属性)，这里产品标识符其实就是云上的变量声明。 （3）Topic 物联网云采用发布订阅的方式，与实际设备之间进行数据交互； Topic是UTF-8字符串，是发布(Pub)或订阅(Sub)消息的传输中介，设备可以向指定Topic发布或者订阅消息。 （4）设备证书（三元组）：设备证书指ProductKey、DeviceName、DeviceSecret。 ProductKey：是物联网平台为产品颁发的全局唯一标识。该参数很重要，在设备认证以及通信中都会用到； DeviceName：在注册设备时，自定义的或自动生成的设备名称，具备产品维度内的唯一性； DeviceSecret：物联网平台为设备颁发的设备密钥，和DeviceName成对出现。 接入阿里云IoT物联网平台： 基于MQTT自主接入IoT。阿里云IoT物联网平台支持MQTT协议自主接入。 MQTT(消息队列遥测传输)是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议。它工作在 TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，为此，它需要一个消息中间件。MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用 在接入阿里云的过程中，首先需要根据自身的地理位置，设置合适的连接域名，域名根据产品是在区域regionId不同而不同。具体规则为：${productKey}.iot-as-mqtt.${regionId}.aliyuncs.com:1883。 其次是MQTT的Connect报文。设备端与阿里云IoT平台建立MQTT通道的CONNECT报文有三个关键参数：客户端标识符 (ClientId) ，用户名（User Name），密码（Password）。这三个参数由设备三元组(productKey,deviceName,deviceSecret)按照阿里云IoT签名规则生成。 部分核心代码如图： 计算MQTT连接参数clientId、username和password，并将username和password设置到MqttConnectOptions对象中。 接入物联网平台 发布消息： 订阅指定Topic 虚拟平台相关操作1、虚拟环境：创建虚拟房间的场景，创建Arduino节点，将传感器元件连接到Arduino板上，再将传感器元件与智能场景中的设备相互关联，(即数字继电器模块控制台灯，温湿度传感器读取场景温度)。设置环境： 添加传感器 绑定设备：将传感器拖动到场景 2、虚拟环境：为虚拟房间的WiFi设备配置相关联网参数。 3、实际环境：创建阿里云上产品与设备，获得设备的三元组信息。 三元组查看： 4、虚拟环境：在线填空式编程并允许，将虚拟环境中温湿度感知数据传到阿里云上；接收阿里云下发指令，对虚拟场景中的台灯进行开关控制。 在线编程： 选择开发板，编译上传： 绑定设备，运行仿真环境： 阿里云平台调试相关操作操作：查看设备状态： 创建规则引擎： 查看日志，分析运行情况 项目设计界面设计界面设计主体采用3个xml文件，即三个布局。分别作为登录界面，控制界面，数据展示界面。 登录界面、控制界面和历史数据展示界面。 登录界面：登录界面主要包含两个可编辑文本框和两个按钮，外加一个文本框和图片作为提示和装饰作用。用户在此界面进行操作时，输入账号密码后，点击登录，然后再user.db这个字段里查找相应的数据，若为未注册用户或者账号密码错误，则提示异常，并提示不能登录，若用户存在且账号密码正确，则正常登录。若用户点击注册按钮，则将文本编辑框里的账号密码读取写入数据库，完成并提示注册功能。 控制界面：控制界面主要提供了一系列按钮和用以提示的文本框，通过按钮点击，实现相关功能，通过文本框，输出相关提示信息。按钮开灯和关灯分别实现远程控制台灯的功能，数据查询按钮则展示最近一段时间从云端收到的温度和湿度信息，设备上线、设备下线按钮分别实现设备的上下线（连接、断开mqtt）。退出按钮则返回登录界面。 数据展示界面：数据展示界面主要包含一个listview组件和一个返回按钮，listview组件显示历史数据信息，返回按钮回到控制界面。 数据库设计数据库设计主要有三个类实现，第一个类是封装用户信息User类，里面封装了用户id，number，password三个属性以及设置、获取相关属性的函数。DatabaseHelper类则是数据库的定义类，继承自SQlite，生成一个名为user，包含两个属性列：number和password的数据表，用来存储用户账号密码信息，第三部分UService则是用来调用的类，里面封装了两个方法：登录和注册，调用相关方法，能够实现对相应数据的查询以及插入，完成登录、注册功能。 功能设计注册登录：注册和登录通过两个按钮实现，当点击相应按钮时，触发相应事件。当点击注册时，从界面的文本框里面获取账号密码字段，将字段设置为一个新的user数据后，插入数据库表，完成注册。当点击登录时，从文本框获取账号密码字段，将字段与数据库里的表进行对比，判断是否为合法用户，合法用户跳转至控制界面，非法用户输出提示信息，不跳转。 设备上线：设备上线功能主要是建立mqtt连接，通过预设定的三元组信息，通过算法计算出连接所需要的账号密码以及id等等，然后生成mqttClient对象，与阿里物联网云平台建立连接后，即实现了设备上线功能。同时重写一部分回调函数与设置函数，将整个连接进行封装处理。 读取数据：读取数据功能实现在mqtt连接之后，当连接成功后，调用相关函数，订阅对应的Topic主题，当订阅成功时，会从云端返回一个数据包，这个数据包里面包含有我们需要的数据，通过解析这个包，即可获得我们需要的数据，将这些数据输出到文本框后，便可以直观地向用户展示。 开关灯：开关灯是通过发送相应指令来实现的，对属性lightswitch而言，0对于关灯，1对应开灯。在判断mqtt处于连接状态后，即可通过此函数，实现数据发送功能：即将选择的指令与一些基本的信息封装成数据包，然后通过mqttClient.pulish发送出去。 数据查询与xml文件生成解析： 为了实现历史数据保存，在本案例里面采用了xml实现。通过将每一次收到的数据保存入xml文件，在需要查询时从xml文件读取数据，较好地实现了本功能。 实现与测试Android测试用户信息数据库管理实现定义一个数据库表user.db，用来存储用户账号密码等信息，在用户注册时，将注册信息插入数据库，在用户登录时，将用户的登录信息与数据库信息进行对比，完成合法用户的确认工作，实现用户信息管理。下为核心代码： 温度湿度显示在设备通过mqtt与阿里云平台连接后，通过调用订阅函数，订阅相关的Topic，订阅成功后，会从云端返回一个数据包，数据包里即包含了订阅的消息，将数据包解析后，即可得到温度湿度的数据。 部分核心代码如下： 测试结果： 远程控制开关灯通过按钮选择相应的开灯、关灯事件，通过按钮来进一步调用数据发送函数，上传Topic到云端，完成指令发送。上传Topic时，需要将指令打包为对应格式，核心代码如下： 测试结果 历史数据xml存储及展示xml文件的使用主要有生成和解析两部分，生成部分主要内容主要内容用于将要存入xml文件的数据进行序列化，然后存入文件，解析部分则是根据标签的提示，读出数据。 序列化数据： 解析数据： 测试结果： 微信小程序测试开关灯实现开关灯是通过将指令封装进json里面，然后通过数据上报的方式，将指令发送至云平台，经规则引擎流转后，下发至设备，实现远程控制功能，主要代码如下 温湿度数据显示温湿度的获取，通过将订阅主题获得的数据进行解析，通过标识符获取相关value，然后保存到本地，最后输出到界面， 测试结果： 总结实践中遇到的问题1.在微信小程序开发过程中，使用的是mqtt与阿里物联网云平台进行连接，但是在相关网站上面下载的mqtt的计算函数有误，前期一直无法连接到平台，但是找不到错误在哪里，后来经同学指点后，得到了新的mqtt依赖文件，成功连接阿里平台。 2.在android移动应用开发的过程中，应用权限的问题。在开发过程中，使用了xml文件技术来进行数据的保存，其需要对sd卡的读取和写入权限，之前使用android10的模拟器进行测试，当进行文件读写时程序闪退，查看日志显示权限没有获得，在网上查找资料后，发现android6以后需要动态申请权限，加上相关代码后，仍旧无法创建文件，反复尝试多次未果，修改模拟器为android5的版本。 \\3. android移动应用开发的过程中，textView显示异常。在开发过程中，在android5的模拟器上，出现了组件textView调用setText（）函数异常，无法有效显示文本到主界面处，将模拟器修改至高版本android，显示正常，异常原理未知，后来通过一个刷新函数再次设置文本。 \\4. android移动应用开发的过程中，图片显示异常问题。在界面设计里，出于美观需求，加了一张图片，在高版本android上运行正常，换低版本android后，程序无法运行，查找资料后，发现低版本的android查找资源文件是在drawable里面，但是在添加资源文件时，是加在了drawable-24文件夹里，高版本可以读取这个文件夹，但是低版本不可以。 4.解析mqtt数据包。为了实现对温度湿度数据的读取，我们需要订阅从云端发来的数据，这个数据是json格式的，但是平台对他进行了一定封装，由于对json的解析不是太清楚，所以这部分花了较多时间，数据转化时异常较多，最后通过提取字符串的方式，获得相应的温度湿度数据，通过这种方式，对特定结构的字段有效，例如从规则引擎处转发的数据，他们结构一致，方便解析，但是如果使用阿里平台的在线调试功能的话，所接受到的数据包的结构与规则平台的有异，需要修改相关设置。通过比对两种方式收到的数据包内容，发现两者虽然都传送了温度湿度信息，但是采用的结构不通，所以不管是截取字符串还是采用json或者别的，都无法兼容两种。 5.控制开关。控制台灯的开关是通过上报数据来实现的，在移动端通过发送一个包含指令的数据包给平台，经过规则引擎后，转发给虚拟设备。在封装数据时，开关灯是用1和0来表示的，开发时大意，将0和1的变量定义成了整型的，导致装入数据后异常，数据经过上报到平台后，显示的Lightswitch的值为相应的0或者1，但是转发至light设备时，通过sql筛选出来的指令却是空的，经过对比字段后，发现，如果将数据定义成整型后，数据包结构发生了变化，字段的顺序也变了，导致items里面没有数据，顾发生错误，将变量修改为String类型的便可以正常开关灯了，基于最简功能需求的原理，在封装发送数据时只封装了lightswitch，但是据此猜想，可以用同样的原理，远程设置温度湿度的值，只需要在封装时将对应的temp和hum加入就行，同时需要修改规则引擎和audino编程。 实践收获、想法本此移动开发，其目的是实现一个远程控制物联网设备的“系统”，开发本身在科研、商业上虽然不值一提，但这个过程本身就是一种尝试，一种我们将在课堂上所学的知识实际运用到现实生活中的尝试，基于此，我们或许可以思考更多。 区别于传统的作业，本次实践给我最大的体会，便是向我们展示了一个完整的物联网系统的整体结构，以及如何实现它，切实的，在现实生活中去实现它，我们只需要一些并不昂贵的硬件设备，就可以实现传说中的“智能家居”，“物联网”这一概念在此刻无比清晰，甚至会让人产生一种现在就动手做的地步，虽然简单，但，这却打开了一扇通往新世界的大门，与传统编程设计的教务系统、图书管理系统相比，它是可以直接用的，并且有切实的作用的。 本次实践，前前后后花了好几个周的时间，不得不说，实践的难度极大，虽然有之前课堂上学习android开发的基础，但这次面对的却比以往任何一次开发都要困难，它包含了一个相对完整的物联网系统涉及，从设备数据采集，硬件编程，到云平台设置、移动应用开发，虽然有老师和同学指导，但是面对各个阶段的层出不穷的bug，仍旧让人感到无力。 硬件编程是开发的第一步，但是在这一步上，我们就耽搁了太多的时间，初次接触这些东西，导致编程各种报错，现在回过头去看，发现当时的错误根本不值一提，但是在当时的环境下，那些错误却是一个又一个实实在在的拦路虎，拦住了继续前进的脚步。也许是开发版选错了（界面挡住了）、引脚设置错了、少了个分号、多了个空格······可笑，但真实，且存在。除此之外，由于是采用虚拟平台进行试验，加上试验人数有点多，所以平台几度崩溃，加上平台的维护等等，也给开发调试带来了一定的障碍，所幸，最后还是好了。 实践中的第二个难点，也是最重要的部分，应该就要算阿里云平台了吧，整个开发过程，都是围绕阿里平台来进行的，创建产品、设备并非难事，却难在使用mqtt接入阿里云，区别于传统开发，本次实践采用的是此前从未接触过的mqtt协议，所以，参考着网上的资料，几乎自学了一遍mqtt协议，在开发的初期，问题的重点就集中在“设备未激活”、“设备离线”等问题上，这很可笑，毕竟连设备都不能上线，还拿什么做开发，但却是那时的现状。 成功接入阿里云物联网云平台后，时间也所剩不多了，由于有平时上课、上机的基础，android开发终于不用再从头开始了，但开发也并非一番风顺。接入阿里平台的一大障碍就是android studio的同步，网上的例程无法运行，各种版本问题，设置问题，很多时候，一个很简单的问题，往往能耽搁好几天。 android开发是一个简单的过程，同时也是一个十分难的过程，在一切前置准备工作就绪后，添加组件、设计界面、编写逻辑函数，这一切看起来顺理成章，我也这么做了，但是做出来却发现效果大失所望，作为一个移动app，而且还是面向用户的app，它不仅仅需要实现基础功能，还需要一些拓展功能，以及一些优秀的界面设计，然而，浅薄的知识并不允许我考虑太多这些。一个程序的好坏，是由其功能决定的，最开始的我们，只想着实现它的功能，但事实上，界面同样重要，一位老师也说过 类似的话“可用、好用、放心用”，一个程序，当可用实现后，或许该进一步实现“好用”，至少让开发者之外的其他人也能够正常使用程序。同时，这也提醒了我，或许该学一些关于界面设计的知识，IT行业有前端和后端之分，界面设计也和逻辑代码一样重要。 最终，整个实践磕磕碰碰地完成了，虽然不甚满意，但也足以聊表这花掉的几个周，或许我没有达到整个实践的最终教学目的，但对我自己而言，在这个过程中，我也学到了许许多多此前从未掌握的知识。整个实践从大局上，让我认识到了我所学的专业的特性，在此以前，我一直想不清楚物联网和计算机的区别，他们学的，我们要学，他们不学的，我们也要学，书本上说的“万物互联”，但这对于我们而言，却是遥不可及的，都是写代码，有什么区别？可是这次实践却从另一个角度向我们展示了什么叫做“万物互联”，也为日后的工作指明了方向。其次，便是关于技术方面的积累了，无疑，在经历了数个周的高强度改bug后，对android开发显得更加得心应手了，一些编程的小技巧，一些函数的用法，一些设计思想，都在积累，他们显得那么微不足道，却足以堆积出一个高效、实用的开发习惯。 学习一个从不会到会的过程，没有什么东西是天生会的，我们磕磕碰碰的前进，每一次挫折都让我们更加强大，每一个bug都让我们更加地强大，成长并非坦途，你我皆有bug。","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"android","slug":"android","permalink":"http://stary2020.gitee.io/tags/android/"}],"author":null},{"title":"web商城（javaWeb重构版）","slug":"javaWeb2","date":"2021-08-26T04:47:12.000Z","updated":"2021-08-27T10:31:19.442Z","comments":true,"path":"2021/08/26/javaWeb2/","link":"","permalink":"http://stary2020.gitee.io/2021/08/26/javaWeb2/","excerpt":"","text":"概述本项目是在上一版书城项目的基础上，进一步重构，上一个项目地址：https://github.com/stary1999/JavaWebBookCity 本项目基于SpringBoot2和thymeleaf的Web开发，对旧的Web商城项目的重构和完善，独立开发和设计了基础页面。项目分为前台用户模块和后台管理模块，前台包括了商品展示，商品购买，用户注册、登录，等功能。后台管理模块包括商品管理、用户管理、订单管理、管理员管理四个模块，实现包括增删改查、以及权限管理等功能。 项目仓库：https://github.com/stary1999/MyMall 文档：https://stary1999.github.io/2021/08/26/javaWeb2/ 重构： 重构后台管理系统 重新设计界面 重新设计数据表 更新技术框架 由于此次独立程度较高，目前功能缺失较大，等待进一步实现。 截止：2020年8月26日 环境 idea2021 MySQL8.0 Maven3.8.1 技术栈 SpringBoot作为后端开发，负责处理业务逻辑和视图分发。 MyBatis Plus作为数据库框架，处理数据库相关操作，MySQL存储数据表信息。 thymeleaf作为前端模板引擎，使用Bootstrap进行页面开发。 …… 总体设计实现UI设计后台管理部分 前台基础页面 登录 设计中出现的问题1.静态资源导入html文件存储在resources/templates文件夹下，js、css等文件存在resource/static文件夹下，使用相对路径无法直接跳转到对应资源位置，所以当时认为相对路径无效，于是反复修改静态文件位置，后面出现了在idea中能够链接到资源文件，但是同时会首先被一个BasicErrorController管到错误的页面（应该是资源路径错误导致触发了error页面），最后开启测试后，使用相对路径，发现虽然不能够在idea中跳转链接，但是仍旧可以获取到静态资源。 绝对路径使用时报错。配置文件改了，但是没有效果（或许是没改对??） ps：静态资源有两种方式（使用bootstrap），一种是引用本地资源，另一种是引用网络资源。后面使用到了官方提供的模板，且考虑到不同层级的文件夹，采用直接从bootstrap提供的链接获取静态资源。 2.公共页面抽取公共页面抽取，需要注意thymeleaf中，三种抽取方式的区别，其次就是： 抽取的页面必须经过MVC控制器才能被渲染，所以直接使用浏览器打开页面的话，被抽取的页面会丢失。 所以，并不是所有的公共页面都建议抽取，具体建议视情况而定。 功能实现登录管理员登录测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@PostMapping(value = &quot;/admin/login&quot;) public ModelAndView login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, @RequestParam(defaultValue = &quot;no&quot;) String remember, HttpServletResponse httpResponse, HttpServletRequest httpRequest, ModelAndView modelAndView) throws IOException &#123; //判断是否登录 //TODO System.out.println(&quot;userName=&quot;+username); System.out.println(&quot;password=&quot;+password); System.out.println(&quot;remember=&quot;+remember); //验证cookie Cookie[] cookies = httpRequest.getCookies(); Map map=new HashMap(); for (Cookie cookie : cookies) &#123; String name = cookie.getName(); String value = URLDecoder.decode(cookie.getValue(), &quot;UTF-8&quot;); map.put(name, value); &#125; //todo 验证账号密码 if(username.equals(&quot;aa@aa.aa&quot;)&amp;&amp;password.equals(&quot;aa&quot;) || map.get(&quot;username&quot;).equals(&quot;aa@aa.aa&quot;)&amp;&amp;map.get(&quot;password&quot;).equals(&quot;aa&quot;))&#123; modelAndView.addObject(&quot;adminId&quot;,&quot;001&quot;); modelAndView.addObject(&quot;adminName&quot;,username); if(remember.equals(&quot;remember-me&quot;))&#123; //todo 生成cookie //创建登录用户名Cookie Cookie cook_name=new Cookie(&quot;username&quot;,username); //创建登录用户密码Cookie Cookie cook_pwd=new Cookie(&quot;password&quot;,password); //设置过期时间为10秒 cook_name.setMaxAge(60*60*24); cook_pwd.setMaxAge(60*60*24); //将Cookie写入客户端 httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); httpResponse.addCookie(cook_name); httpResponse.addCookie(cook_pwd); &#125; modelAndView.setViewName(&quot;admin/admin_Index&quot;); return modelAndView; &#125; else &#123; modelAndView.addObject(&quot;msg&quot;,&quot;账号或密码错误，请重试&quot;); modelAndView.setViewName(&quot;forward:/admin&quot;); return modelAndView; &#125; &#125; 存在的问题 1.@RequestParam注解的使用 2.Restful的使用 3.返回json（前后端分离做法） 4.ajax异步刷新（待完成） 5.cookie，前端cookie的使用还存在一些问题没解决。 6.数据库，总体数据库设计尚未完成，尚未加入数据库进行测试。 数据表设计用户表商品表 数据访问12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 配置jdbc 123456#数据库spring.datasource.url=jdbc:mysql://localhost:3306/mymallspring.datasource.username=rootspring.datasource.password=1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 测试 123456789101112131415161718192021222324252627282930313233343536373839404142package com.stary.mymall.dao;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.junit.platform.commons.logging.Logger;import org.junit.platform.commons.logging.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;/** * @author stary * @version 1.0 * @classname jdbc * @description * @create 2021/8/27-12:16 *///日志开发@Slf4j@SpringBootTestpublic class jdbcTest &#123; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() &#123; log.info(&quot;log 开始&quot;); System.out.println(&quot;sout开始&quot;); Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from product&quot;, Long.class); log.info(&quot;记录总数：&#123;&#125;&quot;,aLong); System.out.println(&quot;sout记录数&quot;+aLong); log.info(&quot;info massage&quot;); log.debug(&quot;debug massage&quot;); log.warn(&quot;warn massage&quot;); log.error(&quot;error massage&quot;); log.trace(&quot;trace massage&quot;); System.out.println(&quot;=====分割线&quot;); &#125;&#125; 注意，lombok的使用，@Slf4j，记录日志 还有在进行单元测试时，需要加入@SpringBootTest，（用到了自动注入） druid连接池12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; github地址：https://github.com/alibaba/druid/blob/master/druid-spring-boot-starter/README.md 配置 12345678910#数据库spring.datasource.url=jdbc:mysql://localhost:3306/mymallspring.datasource.username=rootspring.datasource.password=1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#druid#spring.datasource.druid.url=jdbc:mysql://localhost:3306/mymall # 或spring.datasource.url=#spring.datasource.druid.username=root # 或spring.datasource.username=#spring.datasource.druid.password=1234 # 或spring.datasource.password=#spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver #或 spring.datasource.driver-class-name= 总结","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://stary2020.gitee.io/tags/SpringBoot/"}],"author":null},{"title":"力扣题目","slug":"default-2021-08-20-leetcode","date":"2021-08-20T06:25:35.000Z","updated":"2021-08-26T05:32:14.966Z","comments":true,"path":"2021/08/20/default-2021-08-20-leetcode/","link":"","permalink":"http://stary2020.gitee.io/2021/08/20/default-2021-08-20-leetcode/","excerpt":"","text":"剑指offerday0101123456用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class CQueue &#123; int[] queue; int head; int tail; int length; public CQueue() &#123; this.queue=new int[20]; this.head=0; this.tail=0; this.length=20; &#125; public void appendTail(int value) &#123; if(this.tail&gt;=this.length-1)&#123; int[] newQueue=new int[this.length+20]; for(int i=0;i&lt;this.length-1;i++)&#123; newQueue[i]=this.queue[i]; &#125; this.queue=newQueue; &#125; this.tail++; this.queue[this.tail-1]=value; &#125; public int deleteHead() &#123; if(this.tail&lt;=this.head)&#123; return -1; &#125; else&#123; this.tail--; int returnNumber=this.queue[this.head]; int[] newQueue=this.queue; for(int i=0;i&lt;this.length-1;i++)&#123; newQueue[i]=this.queue[i+1]; &#125; this.queue=newQueue; return returnNumber; &#125; &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 官方; 123456789101112131415161718192021222324252627282930313233class CQueue &#123; Deque&lt;Integer&gt; stack1; Deque&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new LinkedList&lt;Integer&gt;(); stack2 = new LinkedList&lt;Integer&gt;(); &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; // 如果第二个栈为空 if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; if (stack2.isEmpty()) &#123; return -1; &#125; else &#123; int deleteItem = stack2.pop(); return deleteItem; &#125; &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 021定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2 12345678910111213141516171819202122232425Stack&lt;Integer&gt; A, B; public MinStack() &#123; A = new Stack&lt;&gt;(); B = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; A.add(x); if(B.empty() || B.peek() &gt;= x) B.add(x); &#125; public void pop() &#123; if(A.pop().equals(B.peek())) B.pop(); &#125; public int top() &#123; return A.peek(); &#125; public int min() &#123; return B.peek(); &#125;作者：jyd链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 day02011234输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。输入：head = [1,3,2]输出：[2,3,1] 自己的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.stary.top100;import org.junit.Test;import java.util.ArrayList;import java.util.LinkedList;/** * @author stary * @version 1.0 * @classname test01 * @description * @create 2021/8/20-16:53 */public class test01 &#123; // Definition for singly-linked list. public class ListNode &#123; public int val; public ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public int[] reversePrint(ListNode head) &#123; ListNode he=head; int count = 0; while (he!=null) &#123; System.out.println(he.val+&quot; &quot;); he=he.next; count++; &#125; he=head; int[] a=new int[count]; for (int i = count-1; i &gt;=0; i--) &#123; a[i]=he.val; he=he.next; &#125; return a; &#125; @Test public void test01() &#123; ListNode head = new ListNode(1); ListNode h1 = new ListNode(3); ListNode h2 = new ListNode(2); head.next = h1; h1.next = h2; int[] ints = reversePrint(head); System.out.println(ints); &#125;&#125; 官方 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode temp = head; while (temp != null) &#123; stack.push(temp); temp = temp.next; &#125; int size = stack.size(); int[] print = new int[size]; for (int i = 0; i &lt; size; i++) &#123; print[i] = stack.pop().val; &#125; return print; &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-b/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 评论区(思路一样) 021234定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 评论区 123456789101112class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null, cur = head, next = null; while(cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 03123456789101112131415161718请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 day0301空格替换123请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 评论区 123456789public String replaceSpace(String s) &#123; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; s.length(); i++)&#123; char c = s.charAt(i); if(c == &#x27; &#x27;) sb.append(&quot;%20&quot;); else sb.append(c); &#125; return sb.toString(); &#125; my 1234public String replaceSpace(String s) &#123; return s.replace(&quot; &quot;, &quot;%20&quot;);&#125; 021234567891011字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot;输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot; my 123456789101112131415161718192021222324252627282930313233343536package com.stary.leetcode.offer.day03;import org.junit.Test;/** * @author stary * @version 1.0 * @classname question02 * @description * @create 2021/8/22-16:35 */public class question02 &#123;// 输入: s = &quot;abcdefg&quot;, k = 2// 输出: &quot;cdefgab&quot;//// 输入: s = &quot;lrloseumgh&quot;, k = 6// 输出: &quot;umghlrlose&quot; public String reverseLeftWords(String s, int n) &#123; /* String s1=s.substring(n,s.length()); s1=s1+s.substring(0,n); return s1;*/ return s.substring(n,s.length())+s.substring(0,n); &#125; @Test public void test()&#123; String s=&quot;ahzhaisbiai&quot;; String s1 = reverseLeftWords(s, 5); System.out.println(&quot;s=&quot;+s); System.out.println(&quot;s1=&quot;+s1); &#125;&#125; top1001123456789给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910示例:输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。输入：nums = [3,2,4], target = 6输出：[1,2]输入：nums = [3,3], target = 6输出：[0,1] 官方 1 剑指第二版03数组中的重复数字123456789在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 my 123456789101112131415161718192021222324252627282930313233343536373839404142package com.stary.leetcode.offer2;import org.junit.Test;/** * @author stary * @version 1.0 * @classname question03 * @description * @create 2021/8/22-16:45 */public class question03 &#123;// 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。// 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。// 请找出数组中任意一个重复的数字。//// 输入：// [2, 3, 1, 0, 2, 5, 3]// 输出：2 或 3 public int findRepeatNumber(int[] nums) &#123; int[] num=nums; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(num[j]==nums[i])&#123; return num[j]; &#125; &#125; &#125; return 0; &#125; @Test public void test()&#123; int[] ints=&#123;0,2,3,4,5,3,8,7,3&#125;; int repeatNumber = findRepeatNumber(ints); System.out.println(repeatNumber); &#125;&#125; 评论区 12345678910class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int[] arr = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123; arr[nums[i]]++; if(arr[nums[i]] &gt; 1) return nums[i]; &#125; return -1; &#125;&#125; 04 二维数组中的查找1234567891011121314在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] my 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0) return false; else &#123; int n = matrix.length; int m = matrix[0].length; for (int i = 0; i &lt; n; i++) &#123; if(m-1&lt;0)&#123; return false; &#125; if (matrix[i][m - 1] &lt; target) &#123; i++; &#125; else &#123; for (int j = 0; j &lt; m; j++) &#123; if (matrix[i][j] == target) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125; &#125;&#125; 评论区 12345678910111213141516171819class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix == null || matrix.length == 0) &#123; return false; &#125; int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while(row &lt; m &amp;&amp; col &gt;= 0) &#123; if(matrix[row][col] &gt; target) &#123; col--; &#125;else if(matrix[row][col] &lt; target) &#123; row++; &#125;else &#123; return true; &#125; &#125; return false; &#125;&#125; 05替换空格123请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 评论区 123456789public String replaceSpace(String s) &#123; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; s.length(); i++)&#123; char c = s.charAt(i); if(c == &#x27; &#x27;) sb.append(&quot;%20&quot;); else sb.append(c); &#125; return sb.toString(); &#125; my 1234public String replaceSpace(String s) &#123; return s.replace(&quot; &quot;, &quot;%20&quot;);&#125; 06从头到尾打印链表1234输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。输入：head = [1,3,2]输出：[2,3,1] 自己的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class test01 &#123; // Definition for singly-linked list. public class ListNode &#123; public int val; public ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public int[] reversePrint(ListNode head) &#123; ListNode he=head; int count = 0; while (he!=null) &#123; System.out.println(he.val+&quot; &quot;); he=he.next; count++; &#125; he=head; int[] a=new int[count]; for (int i = count-1; i &gt;=0; i--) &#123; a[i]=he.val; he=he.next; &#125; return a; &#125; @Test public void test01() &#123; ListNode head = new ListNode(1); ListNode h1 = new ListNode(3); ListNode h2 = new ListNode(2); head.next = h1; h1.next = h2; int[] ints = reversePrint(head); System.out.println(ints); &#125;&#125; 官方 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode temp = head; while (temp != null) &#123; stack.push(temp); temp = temp.next; &#125; int size = stack.size(); int[] print = new int[size]; for (int i = 0; i &lt; size; i++) &#123; print[i] = stack.pop().val; &#125; return print; &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-b/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 评论区(思路一样) 07重建二叉树(中等)12345678输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]Input: preorder = [-1], inorder = [-1]Output: [-1] 评论区 123456789知识点：前序遍历列表：第一个元素永远是 【根节点 (root)】中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】算法思路：通过【前序遍历列表】确定【根节点 (root)】将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】 09用两个栈实现队列123456用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class CQueue &#123; int[] queue; int head; int tail; int length; public CQueue() &#123; this.queue=new int[20]; this.head=0; this.tail=0; this.length=20; &#125; public void appendTail(int value) &#123; if(this.tail&gt;=this.length-1)&#123; int[] newQueue=new int[this.length+20]; for(int i=0;i&lt;this.length-1;i++)&#123; newQueue[i]=this.queue[i]; &#125; this.queue=newQueue; &#125; this.tail++; this.queue[this.tail-1]=value; &#125; public int deleteHead() &#123; if(this.tail&lt;=this.head)&#123; return -1; &#125; else&#123; this.tail--; int returnNumber=this.queue[this.head]; int[] newQueue=this.queue; for(int i=0;i&lt;this.length-1;i++)&#123; newQueue[i]=this.queue[i+1]; &#125; this.queue=newQueue; return returnNumber; &#125; &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 官方; 123456789101112131415161718192021222324252627282930313233class CQueue &#123; Deque&lt;Integer&gt; stack1; Deque&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new LinkedList&lt;Integer&gt;(); stack2 = new LinkedList&lt;Integer&gt;(); &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; // 如果第二个栈为空 if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; if (stack2.isEmpty()) &#123; return -1; &#125; else &#123; int deleteItem = stack2.pop(); return deleteItem; &#125; &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 10 I，斐波那契数列123456789101112131415写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。输入：n = 2输出：1输入：n = 5输出：5 my 123456789101112131415161718class Solution &#123; long l=1000000007; public int fib(int n) &#123; if(n==0)&#123; return 0; &#125; else if (n==1)&#123; return 1; &#125; else &#123; int re= Math.toIntExact( fib(n - 1) + fib(n - 2) % l); return re; &#125; &#125;&#125; 官方 12345678910public int fib(int n) &#123; int a = 0, b = 1, sum; for (int i = 0; i &lt; n; i++) &#123; sum = (a + b) % 1000000007; a = b; b = sum; &#125; return a; &#125; 10 II青蛙跳台阶问题","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"故事/事故合集","slug":"something","date":"2021-08-13T06:42:39.000Z","updated":"2021-08-26T05:32:52.988Z","comments":true,"path":"2021/08/13/something/","link":"","permalink":"http://stary2020.gitee.io/2021/08/13/something/","excerpt":"","text":"post和put请求转:https://www.cnblogs.com/wuqilang/p/14173220.html 在http中，put被定义为幂等的方法，post不是幂等的方法。 幂等：数学中的一个术语，对于单个输入或者无输入的运算方法，如果每次都是同样的结果，则是幂等的。也就是说，如果一个网络重复执行多次，产生的效果是一样的，那就是幂等。 post 用于提交请求，可以更新或者创建资源，是非幂等的 在用户注册时，每次提交都是创建一个用户账号，此时用post put 用于向指定的url传送更新资源，是幂等的 还是用户模块，比如修改密码，虽然提交的还是账户名和密码，但是每次提交都只是更新该用户密码，每次请求都只是覆盖原型的值，此时用put 用post还是put 如果该更新对应的url多次调用的结果一致，用put 如果每次提交相同的内容，最终结果不一致，用post springBoot","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"faceToFace","slug":"default-2021-08-03-faceToFace","date":"2021-08-03T09:22:11.000Z","updated":"2021-08-19T02:33:57.332Z","comments":true,"path":"2021/08/03/default-2021-08-03-faceToFace/","link":"","permalink":"http://stary2020.gitee.io/2021/08/03/default-2021-08-03-faceToFace/","excerpt":"","text":"优势、亮点、基本情况言简意赅、语言精炼，控制时间和应聘岗位相关的经历为什么能够胜任为什么要应聘该岗位~求职动机 注意：重点介绍满足岗位要求的三个优势和亮点表现出对岗位的理解和自己清晰的职业规划表示愿意长期从事这个岗位","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"springcloud 狂神","slug":"java-2021-08-03-springcloudKuang","date":"2021-08-03T09:21:30.000Z","updated":"2021-08-27T10:28:01.252Z","comments":true,"path":"2021/08/03/java-2021-08-03-springcloudKuang/","link":"","permalink":"http://stary2020.gitee.io/2021/08/03/java-2021-08-03-springcloudKuang/","excerpt":"","text":"概述SpringCloud五大组件: 服务注册与发现:Netflix Eureka 负载均衡: 客户端:Netflix Ribbon 服务端:Feign(依赖与ribbon，只是将调用方式RestTemplete更改成Service接口) 断路器:Netflix Hystrix 服务网关:Netflix Zuul 分布式配置:Spring Cloud Config 常见面试题: 什么是微服务 微服务之间是如何独立通讯的 SpringCloud和Dubbo有哪些区别 SpringBoot和SpringCloud，请谈谈你对他们的理解 什么是服务熔断?什么是服务降级? 微服务的优缺点分别是什么?说下你在项目开发中遇到的坑 你所知道的微服务技术栈有哪些?列举一二 Eureka和Zookeeper都可以提供服务注册与发现的功能，请说说两者的区别 …… 微服务概述什么是微服务?微服务(Microservice Architecture)是近几年流行的一种架构思想。 ThoughtWorks公司的首席科学家Martin Fowler对此的解释: 原文:https://martinfowler.com/articles/microservices.html 汉化:https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它提倡将单一的应用程序划分为一组小的服务，但每个服务运行在其独立的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言、工具，对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 从技术角度来看: 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己的独立数据库。 微服务与服务架构微服务: 微服务强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构: 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。 优缺点优点: 单一职责原则 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求 开发简单，开发效率高，一个服务可能就是专一的只干一件事 微服务能够被小团队开发，这个团队只需2-5个开发人员组成 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的 微服务能使用不同的语言开发 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkis，hudson，bamboo 微服务易于被一个开发人员理解、修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值 微服务允许利用和融合最新技术 微服务只是业务逻辑的代码，不会和HTML、CSS，或其他的界面混合 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库 缺点: 开发人员要处理分布式系统的复杂性 多服务运维难度，随着服务的增加，运维的压力也在增大 系统部署依赖问题 服务间通信成本问题 数据一致性问题 系统集成测试问题 性能和监控问题 微服务技术栈 微服务技术条目 落地技术 服务开发 SpringBoot、Spring、SpringMVC等 服务配置与管理 Netfix公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、PRC、gRPC 服务熔断器 Hystrix、Envoy等 负载均衡 Ribbon、Nginx等 服务接口调用 Fegin等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由(API网关) Zuul等 服务监控 Zabbix、Nagios、Metrics、Specatator等 全链路追踪 Zipkin、Brave、Dapper等 数据流操作开发包 SpringCloud Stream(封装与Redis，Rabbit 时间消息总线 SpringCloud Bus 服务部署 Docker、OpenStack、Kubernetes等 为什么选择SpringCloud作为微服务架构选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务架构有那些？ 阿里：dubbo+HFS 京东：JFS 新浪：Motan 当当网：DubboX 各微服务框架对比 功能点/服务框架 Netflix/SpringCloud Motan gRPC Thri t Dubbo/DubboX 功能定位 完整的微服务框架 RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现 RPC框架 RPC框架 服务框架 支持Rest 是，Ribbon支持多种可拔插的序列号选择 否 否 否 否 支持RPC 否 是(Hession2) 是 是 是 支持多语言 是(Rest形式) 否 是 是 否 负载均衡 是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器） 是(客户端) 否 否 是(客户端) 配置服务 Netfix Archaius，Spring Cloud Config Server 集中配置 是(Zookeeper提供) 否 否 否 服务调用链监控 是(zuul)，zuul提供边缘服务，API网关 否 否 否 否 高可用/容错 是(服务端Hystrix+客户端Ribbon) 是(客户端) 否 否 是(客户端) 典型应用案例 Netflix Sina Google Facebook 社区活跃程度 高 一般 高 一般 2017年后重新开始维护，之前中断了5年 学习难度 中等 低 高 高 低 文档丰富程度 高 一般 一般 一般 高 其他 Spring Cloud Bus为我们的应用程序带来了更多管理端点 支持降级 Netflix内部在开发集成gRPC IDL定义 实践的公司比较多 SpringCloud入门概述SpringCloud是什么？Spring官网：https://spring.io/ SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； Dubbo 和 SpringCloud技术选型1. 分布式+服务治理Dubbo目前成熟的互联网架构，应用服务化拆分 + 消息中间件 2. Dubbo 和 SpringCloud对比可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： Dubbo SpringCloud 服务注册中心 Zookeeper Spring Cloud Netfilx Eureka 服务调用方式 RPC REST API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netfilx Hystrix 服务网关 无 Spring Cloud Netfilx Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总栈 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task 最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。 品牌机和组装机的区别 社区支持与更新力度的区别 总结：二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 SpringCloud能干嘛？ Distributed/versioned configuration 分布式/版本控制配置 Service registration and discovery 服务注册与发现 Routing 路由 Service-to-service calls 服务到服务的调用 Load balancing 负载均衡配置 Circuit Breakers 断路器 Distributed messaging 分布式消息管理 … SpringCloud下载官网：http://projects.spring.io/spring-cloud/ SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。 自学参考书： SpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区：http://springcloud.cn/ SpringCloud中文网：https://springcloud.cc SpringCloud Rest学习环境搭建：服务提供者介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 12345678910一个简单的Maven模块结构是这样的：-- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ...... 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 SpringCloud版本选择大版本说明 SpringBoot SpringCloud 关系 1.2.x Angel版本(天使) 兼容SpringBoot1.2x 1.3.x Brixton版本(布里克斯顿) 兼容SpringBoot1.3x，也兼容SpringBoot1.4x 1.4.x Camden版本(卡姆登) 兼容SpringBoot1.4x，也兼容SpringBoot1.5x 1.5.x Dalston版本(多尔斯顿) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 1.5.x Edgware版本(埃奇韦尔) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 2.0.x Finchley版本(芬奇利) 兼容SpringBoot2.0x，不兼容SpringBoot1.5x 2.1.x Greenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parent spring-cloud-dependencles 版本号 发布日期 版本号 发布日期 1.5.2.RELEASE 2017-03 Dalston.RC1 2017-x 1.5.9.RELEASE 2017-11 Edgware.RELEASE 2017-11 1.5.16.RELEASE 2018-04 Edgware.SR5 2018-10 1.5.20.RELEASE 2018-09 Edgware.SR5 2018-10 2.0.2.RELEASE 2018-05 Fomchiey.BULD-SNAPSHOT 2018-x 2.0.6.RELEASE 2018-10 Fomchiey-SR2 2018-10 2.1.4.RELEASE 2019-04 Greenwich.SR1 2019-03 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;springcloud-api&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;springcloud-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-eureka-7002&lt;/module&gt; &lt;module&gt;springcloud-eureka-7003&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;springcloud-zuul-9527&lt;/module&gt; &lt;module&gt;springcloud-config-server-3344&lt;/module&gt; &lt;module&gt;springcloud-config-client-3355&lt;/module&gt; &lt;module&gt;springcloud-config-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-config-dept-8001&lt;/module&gt; &lt;/modules&gt; &lt;!--打包方式 pom--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springCloud的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringBoot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot 启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志测试~--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 父工程为springcloud，其下有多个子mudule springcloud-consumer-dept-80访问springcloud-provider-dept-8001下的controller使用REST方式 如DeptConsumerController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */@RestControllerpublic class DeptConsumerController &#123; /** * 理解：消费者，不应该有service层~ * RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 * (地址：url, 实体：Map ,Class&lt;T&gt; responseType) * &lt;p&gt; * 提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ */ @Autowired private RestTemplate restTemplate; /** * 服务提供方地址前缀 * &lt;p&gt; * Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 */ private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;; //private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;; /** * 消费方添加部门信息 * @param dept * @return */ @RequestMapping(&quot;/consumer/dept/add&quot;) public boolean add(Dept dept) &#123; // postForObject(服务提供方地址(接口),参数实体,返回类型.class) return restTemplate.postForObject(REST_URL_PREFIX + &quot;/dept/add&quot;, dept, Boolean.class); &#125; /** * 消费方根据id查询部门信息 * @param id * @return */ @RequestMapping(&quot;/consumer/dept/get/&#123;id&#125;&quot;) public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123; // getForObject(服务提供方地址(接口),返回类型.class) return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/get/&quot; + id, Dept.class); &#125; /** * 消费方查询部门信息列表 * @return */ @RequestMapping(&quot;/consumer/dept/list&quot;) public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/list&quot;, List.class); &#125;&#125; 使用RestTemplete先需要放入Spring容器中 ConfigBean.java 1234567891011121314@Configurationpublic class ConfigBean &#123; //@Configuration -- spring applicationContext.xml //配置负载均衡实现RestTemplate // IRule // RoundRobinRule 轮询 // RandomRule 随机 // AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ // RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; springcloud-provider-dept-8001的dao接口调用springcloud-api模块下的pojo，可使用在springcloud-provider-dept-8001的pom文件导入springcloud-api模块依赖的方式： 123456&lt;!--我们需要拿到实体类，所以要配置api module--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; springcloud-consumer-dept-80和springcloud-provider-dept-8001的pom.xml和父工程下的依赖基本一样， Eureka服务注册中心什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 构建步骤1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 123456789101112131415&lt;!--导包~--&gt;&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.yml 1234567891011121314151617server: port: 7001# Eureka配置eureka: instance: # Eureka服务端的实例名字 hostname: 127.0.0.1 client: # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) register-with-eureka: false # fetch-registry如果为false,则表示自己为注册中心,客户端的化为 ture fetch-registry: false # Eureka监控页面~ service-url: defaultZone: http://$&#123; eureka.instance.hostname&#125;:$&#123; server.port&#125;/eureka/ 源码中Eureka的默认端口以及访问路径: 主启动类 12345678910111213/** * @Auther: csp1999 * @Date: 2020/05/18/10:26 * @Description: 启动之后，访问 http://127.0.0.1:7001/ */@SpringBootApplication// @EnableEurekaServer 服务端的启动类，可以接受别人注册进来~@EnableEurekaServerpublic class EurekaServer_7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer_7001.class,args); &#125;&#125; 启动成功后访问 http://localhost:7001/ eureka-client调整之前创建的springlouc-provider-dept-8001 导入Eureca依赖 1234567&lt;!--Eureka依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; application中新增Eureca配置 12345# Eureka配置：配置服务注册中心地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ 为主启动类添加@EnableEurekaClient注解 12345678910111213/** * @Auther: csp1999 * @Date: 2020/05/17/22:09 * @Description: 启动类 */@SpringBootApplication// @EnableEurekaClient 开启Eureka客户端注解，在服务启动后自动向注册中心注册服务@EnableEurekaClientpublic class DeptProvider_8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider_8001.class,args); &#125;&#125; 先启动7001服务端后启动8001客户端进行测试，然后访问监控页http://localhost:7001 修改Eureka上的默认描述信息 1234567# Eureka配置：配置服务注册中心地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制： 配置关于服务加载的监控信息 pom.xml中添加依赖 12345&lt;!--actuator完善监控信息--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; application.yml中添加配置 123456# info配置info:# 项目的名称app.name: haust-springcloud# 公司的名称company.name: 河南科技大学西苑校区软件学院 此时刷新监控页，点击进入 跳转新页面显示如下内容： EureKa自我保护机制：好死不如赖活着一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！ 默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。 该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。 但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：eureka.server.enable-self-preservation=false【不推荐关闭自我保护机制】 详细内容可以参考下这篇博客内容：https://blog.csdn.net/wudiyong22/article/details/80827594 4. 注册进来的微服务，获取一些消息（团队开发会用到）DeptController.java新增方法 123456789101112131415161718192021222324252627/** * DiscoveryClient 可以用来获取一些配置的信息，得到具体的微服务！ */@Autowiredprivate DiscoveryClient client;/** * 获取一些注册进来的微服务的信息~， * * @return */@GetMapping(&quot;/dept/discovery&quot;)public Object discovery() &#123; // 获取微服务列表的清单 List&lt;String&gt; services = client.getServices(); System.out.println(&quot;discovery=&gt;services:&quot; + services); // 得到一个具体的微服务信息,通过具体的微服务id，applicaioinName； List&lt;ServiceInstance&gt; instances = client.getInstances(&quot;SPRINGCLOUD-PROVIDER-DEPT&quot;); for (ServiceInstance instance : instances) &#123; System.out.println( instance.getHost() + &quot;\\t&quot; + // 主机名称 instance.getPort() + &quot;\\t&quot; + // 端口号 instance.getUri() + &quot;\\t&quot; + // uri instance.getServiceId() // 服务id ); &#125; return this.client;&#125; 主启动类中加入@EnableDiscoveryClient注解 12345678@SpringBootApplication// @EnableEurekaClient 开启Eureka客户端注解，在服务启动后自动向注册中心注册服务@EnableEurekaClient// @EnableEurekaClient 开启服务发现客户端的注解，可以用来获取一些配置的信息，得到具体的微服务@EnableDiscoveryClientpublic class DeptProvider_8001 &#123; ...&#125; 结果如图： Eureka：集群环境配置 初始化新建springcloud-eureka-7002、springcloud-eureka-7003 模块 1.为pom.xml添加依赖 (与springcloud-eureka-7001相同) 123456789101112131415&lt;!--导包~--&gt;&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.application.yml配置(与springcloud-eureka-7001相同) 1234567891011121314server: port: 7003# Eureka配置eureka: instance: hostname: localhost # Eureka服务端的实例名字 client: register-with-eureka: false # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false # fetch-registry如果为false,则表示自己为注册中心 service-url: # 监控页面~ # 重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ defaultZone: http://$&#123; eureka.instance.hostname&#125;:$&#123; server.port&#125;/eureka/ 3.主启动类(与springcloud-eureka-7001相同) 123456789101112/** * @Auther: csp1999 * @Date: 2020/05/18/10:26 * @Description: 启动之后，访问 http://127.0.0.1:7003/ */@SpringBootApplication// @EnableEurekaServer 服务端的启动类，可以接受别人注册进来~public class EurekaServer_7003 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer_7003.class,args); &#125;&#125; 2.集群成员相互关联模拟情况下，需要修改主机ip的对应地址为eureka700x.com 修改application.yml的配置，如图为springcloud-eureka-7001配置，springcloud-eureka-7002/springcloud-eureka-7003同样分别修改为其对应的名称即可 在集群中使springcloud-eureka-7001关联springcloud-eureka-7002、springcloud-eureka-7003 完整的springcloud-eureka-7001下的application.yml如下 1234567891011121314server: port: 7001#Eureka配置eureka: instance: hostname: eureka7001.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # 集群（关联）：7001关联7002、7003 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 同时在集群中使springcloud-eureka-7002关联springcloud-eureka-7001、springcloud-eureka-7003 完整的springcloud-eureka-7002下的application.yml如下 1234567891011121314server: port: 7002#Eureka配置eureka: instance: hostname: eureka7002.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # 集群（关联）：7002关联7001、7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/ springcloud-eureka-7003配置方式同理可得. 通过springcloud-provider-dept-8001下的yml配置文件，修改Eureka配置：配置服务注册中心地址 12345678# Eureka配置：配置服务注册中心地址eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 这样模拟集群就搭建好了，就可以把一个项目挂载到三个服务器上了 对比和Zookeeper区别1. 回顾CAP原则RDBMS (MySQL\\Oracle\\sqlServer) ===&gt; ACID NoSQL (Redis\\MongoDB) ===&gt; CAP 2. ACID是什么？ A (Atomicity) 原子性 C (Consistency) 一致性 I (Isolation) 隔离性 D (Durability) 持久性 3. CAP是什么? C (Consistency) 强一致性 A (Availability) 可用性 P (Partition tolerance) 分区容错性 CAP的三进二：CA、AP、CP 4. CAP理论的核心 一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求 根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类 CA：单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP：满足一致性，分区容错的系统，通常性能不是特别高 AP：满足可用性，分区容错的系统，通常可能对一致性要求低一些 5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。 Zookeeper 保证的是 CP —&gt; 满足一致性，分区容错的系统，通常性能不是特别高 Eureka 保证的是 AP —&gt; 满足可用性，分区容错的系统，通常可能对一致性要求低一些 Zookeeper保证的是CP 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。 Eureka保证的是AP Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其他节点中 因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪 Ribbon：负载均衡(基于客户端)Ribbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如**Nginx(反向代理服务器)**，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式 LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 6.2 集成Ribbonspringcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 123456789101112&lt;!--Ribbon--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在application.yml文件中配置Eureka 123456# Eureka配置eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 主启动类加上@EnableEurekaClient注解，开启Eureka 12345678//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号@SpringBootApplication@EnableEurekaClient //开启Eureka 客户端public class DeptConsumer_80 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer_80.class, args); &#125;&#125; 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate 123456789@Configurationpublic class ConfigBean &#123; //@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 修改conroller：DeptConsumerController.java 123//Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问//private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;; 使用Ribbon实现负载均衡流程图： 1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002 2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码 3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka7001.com:7002/查看结果 测试访问http://localhost/consumer/dept/list 这时候随机访问的是服务提供者8003 以上这种每次访问http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询，轮询算法在SpringCloud中可以自定义。 如何切换或者自定义规则呢？ 在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则 123456789101112131415161718@Configurationpublic class ConfigBean &#123; //@Configuration -- spring applicationContext.xml /** * IRule: * RoundRobinRule 轮询策略 * RandomRule 随机策略 * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 */ @Bean public IRule myRule() &#123; return new RandomRule();//使用随机策略 //return new RoundRobinRule();//使用轮询策略 //return new AvailabilityFilteringRule();//使用轮询策略 //return new RetryRule();//使用轮询策略 &#125;&#125; 也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：该包不要和主启动类所在的包同级，要跟启动类所在包同级 MyRule.java 123456789101112/** * @Auther: csp1999 * @Date: 2020/05/19/11:58 * @Description: 自定义规则 */@Configurationpublic class MyRule &#123; @Bean public IRule myRule()&#123; return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的 &#125;&#125; 主启动类开启负载均衡并指定自定义的MyRule配置类 12345678910//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号@SpringBootApplication@EnableEurekaClient//在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则)@RibbonClient(name = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,configuration = MyRule.class)//开启负载均衡,并指定自定义的规则public class DeptConsumer_80 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumer_80.class, args); &#125;&#125; 自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MyRandomRule extends AbstractLoadBalancerRule &#123; /** * 每个服务访问5次则换下一个服务(总共3个服务) * &lt;p&gt; * total=0,默认=0,如果=5,指向下一个服务节点 * index=0,默认=0,如果total=5,index+1 */ private int total = 0;//被调用的次数 private int currentIndex = 0;//当前是谁在提供服务 //@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;) public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers();//获得当前活着的服务 List&lt;Server&gt; allList = lb.getAllServers();//获取所有的服务 int serverCount = allList.size(); if (serverCount == 0) &#123; /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; &#125; //int index = chooseRandomInt(serverCount);//生成区间随机数 //server = upList.get(index);//从或活着的服务中,随机获取一个 //=====================自定义代码========================= if (total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125; else &#123; total = 0; currentIndex++; if (currentIndex &gt; upList.size()) &#123; currentIndex = 0; &#125; server = upList.get(currentIndex);//从活着的服务中,获取指定的服务来进行操作 &#125; //====================================================== if (server == null) &#123; /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Shouldn&#x27;t actually happen.. but must be transient or a bug. server = null; Thread.yield(); &#125; return server; &#125; protected int chooseRandomInt(int serverCount) &#123; return ThreadLocalRandom.current().nextInt(serverCount); &#125; @Override public Server choose(Object key) &#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; // TODO Auto-generated method stub &#125;&#125; Feign：负载均衡(基于服务端)1 Feign简介Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 123456&lt;!--Feign的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 通过Ribbon实现：—原来的controller：DeptConsumerController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Auther: csp1999@Date: 2020/05/17/22:44@Description:*/@RestControllerpublic class DeptConsumerController &#123; /** * 理解：消费者，不应该有service层~ * RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 * (地址：url, 实体：Map ,Class&lt;T&gt; responseType) * &lt;p&gt; * 提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ */ @Autowired private RestTemplate restTemplate; /** * 服务提供方地址前缀 * &lt;p&gt; * Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 */// private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;; private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;; /** * 消费方添加部门信息 * @param dept * @return */ @RequestMapping(&quot;/consumer/dept/add&quot;) public boolean add(Dept dept) &#123; // postForObject(服务提供方地址(接口),参数实体,返回类型.class) return restTemplate.postForObject(REST_URL_PREFIX + &quot;/dept/add&quot;, dept, Boolean.class); &#125; /** * 消费方根据id查询部门信息 * @param id * @return */ @RequestMapping(&quot;/consumer/dept/get/&#123;id&#125;&quot;) public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123; // getForObject(服务提供方地址(接口),返回类型.class) return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/get/&quot; + id, Dept.class); &#125; /** * 消费方查询部门信息列表 * @return */ @RequestMapping(&quot;/consumer/dept/list&quot;) public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/list&quot;, List.class); &#125;&#125; 通过Feign实现：—改造后controller：DeptConsumerController.java 123456789101112131415161718192021222324252627282930313233343536/** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */@RestControllerpublic class DeptConsumerController &#123; @Autowired private DeptClientService deptClientService; /** * 消费方添加部门信息 * @param dept * @return */ @RequestMapping(&quot;/consumer/dept/add&quot;) public boolean add(Dept dept) &#123; return deptClientService.addDept(dept); &#125; /** * 消费方根据id查询部门信息 * @param id * @return */ @RequestMapping(&quot;/consumer/dept/get/&#123;id&#125;&quot;) public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123; return deptClientService.queryById(id); &#125; /** * 消费方查询部门信息列表 * @return */ @RequestMapping(&quot;/consumer/dept/list&quot;) public List&lt;Dept&gt; list() &#123; return deptClientService.queryAll(); &#125;&#125; Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽，而且Feign调用方式更符合我们之前在做SSM或者SprngBoot项目时，Controller层调用Service层的编程习惯！主配置类： 1234567891011121314151617/** * @Auther: csp1999 * @Date: 2020/05/17/22:47 * @Description: */@SpringBootApplication@EnableEurekaClient// feign客户端注解,并指定要扫描的包以及配置接口DeptClientService@EnableFeignClients(basePackages = &#123; &quot;com.haust.springcloud&quot;&#125;)// 切记不要加这个注解，不然会出现404访问不到//@ComponentScan(&quot;com.haust.springcloud&quot;)public class FeignDeptConsumer_80 &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignDeptConsumer_80.class, args); &#125;&#125; 改造springcloud-api模块 pom.xml添加feign依赖 123456&lt;!--Feign的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 新建service包，并新建DeptClientService.java接口， 12345678910// @FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务@FeignClient(value = “SPRINGCLOUD-PROVIDER-DEPT”)public interface DeptClientService &#123; @GetMapping(&quot;/dept/get/&#123;id&#125;&quot;) public Dept queryById(@PathVariable(&quot;id&quot;) Long id); @GetMapping(&quot;/dept/list&quot;) public Dept queryAll(); @GetMapping(&quot;/dept/add&quot;) public Dept addDept(Dept dept);&#125; Feign和Ribbon如何选择？根据个人习惯而定，如果喜欢REST风格使用Ribbon；如果喜欢社区版的面向接口风格使用Feign. Feign 本质上也是实现了 Ribbon，只不过后者是在调用方式上，为了满足一些开发者习惯的接口调用习惯！ 下面我们关闭springcloud-consumer-dept-80 这个服务消费方，换用springcloud-consumer-dept-feign(端口还是80) 来代替：(依然可以正常访问，就是调用方式相比于Ribbon变化了) Hystrix：服务熔断分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免失败 服务雪崩多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上某个微服务的调用响应时间过长，或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以达到单个依赖关系的失败而不影响整个应用程序或系统运行。 我们需要，弃车保帅！ 什么是Hystrix？Hystrix是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。 “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，向调用方返回一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 Hystrix能干嘛？ 服务降级 服务熔断 服务限流 接近实时的监控 … 随着大容量通信量的增加，单个后端依赖项的潜在性会导致所有服务器上的所有资源在几秒钟内饱和。 应用程序中通过网络或客户端库可能导致网络请求的每个点都是潜在故障的来源。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，从而备份队列、线程和其他系统资源，从而导致更多跨系统的级联故障。 当使用Hystrix包装每个基础依赖项时，上面的图表中所示的体系结构会发生类似于以下关系图的变化。每个依赖项是相互隔离的，限制在延迟发生时它可以填充的资源中，并包含在回退逻辑中，该逻辑决定在依赖项中发生任何类型的故障时要做出什么样的响应： 官网资料：https://github.com/Netflix/Hystrix/wiki 服务熔断什么是服务熔断?熔断机制是赌赢雪崩效应的一种微服务链路保护机制。 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是：@HystrixCommand。 服务熔断解决如下问题： 当所依赖的对象不稳定时，能够起到快速失败的目的； 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。 入门案例新建springcloud-provider-dept-hystrix-8001模块并拷贝springcloud-provider-dept–8001内的pom.xml、resource和Java代码进行初始化并调整。 导入hystrix依赖 123456&lt;!--导入Hystrix依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 调整yml配置文件 1234567891011121314151617181920212223242526272829303132333435server: port: 8001# mybatis配置mybatis: # springcloud-api 模块下的pojo包 type-aliases-package: com.haust.springcloud.pojo # 本模块下的mybatis-config.xml核心配置文件类路径 config-location: classpath:mybatis/mybatis-config.xml # 本模块下的mapper配置文件类路径 mapper-locations: classpath:mybatis/mapper/*.xml# spring配置spring: application: #项目名 name: springcloud-provider-dept datasource: # 德鲁伊数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root# Eureka配置：配置服务注册中心地址eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-hystrix-8001 #修改Eureka上的默认描述信息 prefer-ip-address: true #改为true后默认显示的是ip地址而不再是localhost#info配置info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称 修改controller 1234567891011121314151617181920212223242526272829303132333435/** * @Auther: csp1999 * @Date: 2020/05/17/22:06 * @Description: 提供Restful服务 */@RestControllerpublic class DeptController &#123; @Autowired private DeptService deptService; /** * 根据id查询部门信息 * 如果根据id查询出现异常,则走hystrixGet这段备选代码 * @param id * @return */ @HystrixCommand(fallbackMethod = &quot;hystrixGet&quot;) @RequestMapping(&quot;/dept/get/&#123;id&#125;&quot;)//根据id查询 public Dept get(@PathVariable(&quot;id&quot;) Long id)&#123; Dept dept = deptService.queryById(id); if (dept==null)&#123; throw new RuntimeException(&quot;这个id=&gt;&quot;+id+&quot;,不存在该用户，或信息无法找到~&quot;); &#125; return dept; &#125; /** * 根据id查询备选方案(熔断) * @param id * @return */ public Dept hystrixGet(@PathVariable(&quot;id&quot;) Long id)&#123; return new Dept().setDeptno(id) .setDname(&quot;这个id=&gt;&quot;+id+&quot;,没有对应的信息,null---@Hystrix~&quot;) .setDb_source(&quot;在MySQL中没有这个数据库&quot;); &#125;&#125; 为主启动类添加对熔断的支持注解@EnableCircuitBreaker 1234567891011121314/** * @Auther: csp1999 * @Date: 2020/05/17/22:09 * @Description: 启动类 */@SpringBootApplication@EnableEurekaClient // EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务@EnableDiscoveryClient // 服务发现~@EnableCircuitBreaker // 添加对熔断的支持注解public class HystrixDeptProvider_8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDeptProvider_8001.class,args); &#125;&#125; 测试： 使用熔断后，当访问一个不存在的id时，前台页展示数据如下: 而不适用熔断的springcloud-provider-dept–8001模块访问相同地址会出现下面状况 因此，为了避免因某个微服务后台出现异常或错误而导致整个应用或网页报错，使用熔断是必要的 服务降级什么是服务降级?服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理，或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。 资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。 服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。 降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。 由上图可得，当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级。 服务降级需要考虑的问题 1）那些服务是核心服务，哪些服务是非核心服务 2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么 3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？ 自动降级分类1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况 2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况 3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据） 4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。 入门案例在springcloud-api模块下的service包中新建降级配置类DeptClientServiceFallBackFactory.java 12345678910111213141516171819202122232425262728/** * @Auther: csp1999 * @Date: 2020/05/20/9:18 * @Description: Hystrix服务降级 ~ */@Componentpublic class DeptClientServiceFallBackFactory implements FallbackFactory &#123; @Override public DeptClientService create(Throwable cause) &#123; return new DeptClientService() &#123; @Override public Dept queryById(Long id) &#123; return new Dept() .setDeptno(id) .setDname(&quot;id=&gt;&quot; + id + &quot;没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭&quot;) .setDb_source(&quot;没有数据~&quot;); &#125; @Override public List&lt;Dept&gt; queryAll() &#123; return null; &#125; @Override public Boolean addDept(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; 在DeptClientService中指定降级配置类DeptClientServiceFallBackFactory 1234567891011@Component //注册到spring容器中//@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务@FeignClient(value = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,fallbackFactory = DeptClientServiceFallBackFactory.class)//fallbackFactory指定降级配置类public interface DeptClientService &#123; @GetMapping(&quot;/dept/get/&#123;id&#125;&quot;) public Dept queryById(@PathVariable(&quot;id&quot;) Long id); @GetMapping(&quot;/dept/list&quot;) public List&lt;Dept&gt; queryAll(); @GetMapping(&quot;/dept/add&quot;) public Boolean addDept(Dept dept);&#125; 在springcloud-consumer-dept-feign模块中开启降级： 123456789101112server: port: 80# Eureka配置eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/# 开启降级feign.hystrixfeign: hystrix: enabled: true 服务熔断和降级的区别 服务熔断—&gt;服务端：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断) 服务降级—&gt;客户端：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始） 实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。 熔断，降级，限流： 限流：限制并发的请求访问量，超过阈值则拒绝； 降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑； 熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复 Dashboard 流监控新建springcloud-consumer-hystrix-dashboard模块 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--Hystrix依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--dashboard依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Ribbon--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Eureka--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--实体类+web--&gt;&lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 主启动类 123456789101112131415161718192021222324252627@SpringBootApplication// 开启Dashboard@EnableHystrixDashboardpublic class DeptConsumerDashboard_9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumerDashboard_9001.class,args); &#125;&#125;给springcloud-provider-dept-hystrix-8001模块下的主启动类添加如下代码,添加监控​```java@SpringBootApplication@EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务public class DeptProvider_8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider_8001.class,args); &#125; //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); //访问该页面就是监控页面 registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); return registrationBean; &#125;&#125; 访问：http://localhost:9001/hystrix 进入监控页面： 效果如下图： Zull路由网关什么是zuul? Zull包含了对请求的路由(用来跳转的)和过滤两个最主要功能： 其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。 注意：Zuul 服务最终还是会注册进 Eureka 提供：代理 + 路由 + 过滤 三大功能！ Zuul 能干嘛？ 路由 过滤 官方文档：https://github.com/Netflix/zuul/ 入门案例新建springcloud-zuul模块，并导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;dependencies&gt; &lt;!--导入zuul依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboar&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.yml 12345678910111213141516171819202122232425262728server: port: 9527spring: application: name: springcloud-zuul #微服务名称# eureka 注册中心配置eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: #实例的id instance-id: zuul9527.com prefer-ip-address: true # 显示ipinfo: app.name: haust.springcloud # 项目名称 company.name: 河南科技大学西苑校区 # 公司名称# zull 路由网关配置zuul: # 路由相关配置 # 原来访问路由 eg:http://www.cspStudy.com:9527/springcloud-provider-dept/dept/get/1 # zull路由配置后访问路由 eg:http://www.cspstudy.com:9527/haust/mydept/dept/get/1 routes: mydept.serviceId: springcloud-provider-dept # eureka注册中心的服务提供方路由名称 mydept.path: /mydept/** # 将eureka注册中心的服务提供方路由名称 改为自定义路由名称 # 不能再使用这个路径访问了，*： 忽略,隐藏全部的服务名称~ ignored-services: &quot;*&quot; # 设置公共的前缀 prefix: /haust 主启动类 123456789101112/** * @Auther: csp1999 * @Date: 2020/05/20/20:53 * @Description: Zull路由网关主启动类 */@SpringBootApplication@EnableZuulProxy // 开启Zuulpublic class ZuulApplication_9527 &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication_9527.class,args); &#125;&#125; 上图是没有经过Zull路由网关配置时，服务接口访问的路由，可以看出直接用微服务(服务提供方)名称去访问，这样不安全，不能将微服务名称暴露！ 所以经过Zull路由网关配置后，访问的路由为： 我们看到，微服务名称被替换并隐藏，换成了我们自定义的微服务名称mydept，同时加上了前缀haust，这样就做到了对路由fan访问的加密处理！ 详情参考springcloud中文社区zuul组件 :https://www.springcloud.cc/spring-cloud-greenwich.html#_router_and_filter_zuul Spring Cloud Config 分布式配置Dalston.RELEASE Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。 概述分布式系统面临的–配置文件问题 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！ 什么是SpringCloud config分布式配置中心？ spring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。 spring cloud config 分为服务端和客户端两部分。 服务端也称为 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。 spring cloud config 分布式配置中心能干嘛？ 集中式管理配置文件 不同环境，不同配置，动态化的配置更新，分环境部署，比如 /dev /test /prod /beta /release 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置 将配置信息以REST接口的形式暴露 spring cloud config 分布式配置中心与GitHub整合 由于spring cloud config 默认使用git来存储配置文件 (也有其他方式，比如自持SVN 和本地文件)，但是最推荐的还是git ，而且使用的是 http / https 访问的形式。 入门案例服务端新建springcloud-config-server-3344模块导入pom.xml依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--config--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resource下创建application.yml配置文件，Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置： 12345678910111213141516171819server: port: 3344spring: application: name: springcloud-config-server # 连接码云远程仓库 cloud: config: server: git: # 注意是https的而不是ssh uri: https://gitee.com/cao_shi_peng/springcloud-config.git # 通过 config-server可以连接到git，访问其中的资源以及配置~# 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对# 或者直接注释掉eureka依赖 这里暂时用不到eurekaeureka: client: register-with-eureka: false fetch-registry: false 主启动类 1234567@EnableConfigServer // 开启spring cloud config server服务@SpringBootApplicationpublic class Config_server_3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(Config_server_3344.class,args); &#125;&#125; 将本地git仓库springcloud-config文件夹下新建的application.yml提交到码云仓库： 定位资源的默认策略是克隆一个git仓库（在spring.cloud.config.server.git.uri），并使用它来初始化一个迷你SpringApplication。小应用程序的Environment用于枚举属性源并通过JSON端点发布。 HTTP服务具有以下格式的资源： 123456789101112131415161718/&#123; application&#125;/&#123; profile&#125;[/&#123; label&#125;]/&#123; application&#125;-&#123; profile&#125;.yml/&#123; label&#125;/&#123; application&#125;-&#123; profile&#125;.yml/&#123; application&#125;-&#123; profile&#125;.properties/&#123; label&#125;/&#123; application&#125;-&#123; profile&#125;.properties 其中“应用程序”作为SpringApplication中的spring.config.name注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。 测试访问http://localhost:3344/application-dev.yml 测试访问 http://localhost:3344/application/test/master 测试访问 http://localhost:3344/master/application-dev.yml 客户端将本地git仓库springcloud-config文件夹下新建的config-client.yml提交到码云仓库： 新建一个springcloud-config-client-3355模块，并导入依赖 123456789101112131415&lt;!--config--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-start --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; resources下创建application.yml和bootstrap.yml配置文件 bootstrap.yml 是系统级别的配置 12345678# 系统级别的配置spring: cloud: config: name: config-client # 需要从git上读取的资源名称，不要后缀 profile: dev label: master uri: http://localhost:3344 application.yml 是用户级别的配置 1234# 用户级别的配置spring: application: name: springcloud-config-client 创建controller包下的ConfigClientController.java 用于测试 123456789101112131415@RestControllerpublic class ConfigClientController &#123; @Value(&quot;$&#123;spring.application.name&#125;&quot;) private String applicationName; //获取微服务名称 @Value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;) private String eurekaServer; //获取Eureka服务 @Value(&quot;$&#123;server.port&#125;&quot;) private String port; //获取服务端的端口号 @RequestMapping(&quot;/config&quot;) public String getConfig()&#123; return &quot;applicationName:&quot;+applicationName + &quot;eurekaServer:&quot;+eurekaServer + &quot;port:&quot;+port; &#125;&#125; 主启动类 123456@SpringBootApplicationpublic class ConfigClient &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClient.class,args); &#125;&#125; 测试： 启动服务端Config_server_3344 再启动客户端ConfigClient 访问：http://localhost:8201/config/ 小案例 本地新建config-dept.yml和config-eureka.yml并提交到码云仓库 这里配置文件内容不再列举直接到代码中看把。 新建springcloud-config-eureka-7001模块，并将原来的springcloud-eureka-7001模块下的内容拷贝的该模块。 1.清空该模块的application.yml配置，并新建bootstrap.yml连接远程配置 1234567spring: cloud: config: name: config-eureka # 仓库中的配置文件名称 label: master profile: dev uri: http://localhost:3344 2.在pom.xml中添加spring cloud config依赖 1234567&lt;!--config--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 3.主启动类 1234567@SpringBootApplication@EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~public class ConfigEurekaServer_7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigEurekaServer_7001.class,args); &#125;&#125; 4.测试 第一步：启动 Config_Server_3344，并访问 http://localhost:3344/master/config-eureka-dev.yml 测试 第二部：启动ConfigEurekaServer_7001，访问 http://localhost:7001/ 测试 显示上图则成功 新建springcloud-config-dept-8001模块并拷贝springcloud-provider-dept-8001的内容 同理导入spring cloud config依赖、清空application.yml 、新建bootstrap.yml配置文件并配置 1234567spring: cloud: config: name: config-dept label: master profile: dev uri: http://localhost:3344 主启动类 12345678910111213141516@SpringBootApplication@EnableEurekaClient //在服务启动后自动注册到Eureka中！@EnableDiscoveryClient //服务发现~@EnableCircuitBreaker //public class ConfigDeptProvider_8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigDeptProvider_8001.class,args); &#125; //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); return registrationBean; &#125;&#125; 转载自:https://www.kuangstudy.com/bbs/1374942542566551554，遵循[CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/)版权协议","categories":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://stary2020.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"springCloud","slug":"springCloud","permalink":"http://stary2020.gitee.io/tags/springCloud/"}],"author":null},{"title":"面试题(第一季)","slug":"java-2021-08-02-faceQuestion","date":"2021-08-02T07:12:51.000Z","updated":"2021-08-19T02:35:04.922Z","comments":true,"path":"2021/08/02/java-2021-08-02-faceQuestion/","link":"","permalink":"http://stary2020.gitee.io/2021/08/02/java-2021-08-02-faceQuestion/","excerpt":"","text":"参考尚硅谷教学视频:https://www.bilibili.com/video/BV1Eb411P7bP?spm_id_from=333.788.b_636f6d6d656e74.25 转载自:https://blog.csdn.net/qq_42999092/article/details/109068522 Java SE自增变量i++与++i 12345678910public void test01()&#123; int i = 1; i=i++; int j=i++; int k=i+ ++i*i++; System.out.println(&quot;i=&quot;+i); System.out.println(&quot;j=&quot;+j); System.out.println(&quot;k=&quot;+k);&#125; 结果: 123i=4j=1k=11 int k=i+ ++i*i++;过程: 小结: 赋值=，最后计算 =右边的从左到右加载值依次压入操作数栈 实际先算哪个，看运算符优先级 自增、自减操作都是直接修改变量值，不经过操作数栈 最后的赋值之前，临时结果也是存储在操作数栈中。 详情参考JVM虚拟机指令 单例设计模式(具体可参见设计模式，必须掌握)单例模式:Singleton，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。如代表JVM运行环境的Runtime类。 要点: 一是某个类只能有一个实例，构造器私有化。二是他必须自行创建实例，含有一个该类的静态变量来保存这个唯一的实例。三是他必须自行向整个系统提供这个实例，对外提供该类实例的方式:直接暴露、用静态变量的get方法获取。 1. 饿汉式直接创建对象，不存在线程安全问题 直接实例化饿汉式(简介直观) 12345678910111213public class Singleton1 &#123; /** * 1、构造器私有化 * 2、自行创建，并且用静态变量保存 * 3、向外提供实例 * 4、强调这是一个单例，我们可以用final修改 */ private Singleton1() &#123; &#125; public static final Singleton1 INSTANCE = new Singleton1();&#125; 枚举式(最简洁) 123456public enum Singleton2 &#123; /** * 枚举类型：表示该类型是有限的几个 */ INSTANCE&#125; 静态代码块饿汉式(适合复杂实例化对象) 12345678910111213141516171819public class Singleton3 &#123; /** * 静态代码块 */ public static final Singleton3 INSTANCE; private String info; static &#123; try &#123; INSTANCE = new Singleton3(&quot;123&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; private Singleton3(String info) &#123; this.info = info; &#125;&#125; 2. 懒汉式延迟创建对象 线程不安全(使用于单线程) 1234567891011121314151617public class Singleton4 &#123; /** * 1、构造器私有化 * 2、用一个静态变量保存这个唯一的实例 * 3、提供一个静态方法，获取这个实例对象 */ static Singleton4 instance; private Singleton4() &#123;&#125; public static Singleton4 getInstance() &#123; if (instance == null) &#123; instance = new Singleton4(); &#125; return instance; &#125;&#125; 线程安全(使用于多线程) 123456789101112131415161718192021public class Singleton5 &#123; /** * 1、构造器私有化 * 2、用一个静态变量保存这个唯一的实例 * 3、提供一个静态方法，获取这个实例对象 */ static Singleton5 instance; private Singleton5() &#123;&#125; public static Singleton5 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton5.class) &#123; if (instance == null) &#123; instance = new Singleton5(); &#125; return instance; &#125; &#125; return instance; &#125;&#125; 静态内部类模式 (适用于多线程) 123456789101112131415public class Singleton6 &#123; /** * 1、内部类被加载和初始化时，才创建INSTANCE实例对象 * 2、静态内部类不会自动创建,随着外部类的加载初始化而初始化，他是要单独去加载和实例化的 * 3、因为是在内部类加载和初始化时，创建的，因此线程安全 */ private Singleton6()&#123;&#125; public static class Inner&#123; private static final Singleton6 INSTANCE = new Singleton6(); &#125; public static Singleton6 getInstance() &#123; return Inner.INSTANCE; &#125;&#125; 类初始化实例初始化类初始化 一个类要创建实例需要先加载并初始化该类main方法所在的类需要先加载和初始化一个子类要初始化需要先初始化父类一个类初始化就是执行 clinit 方法clinit 方法由静态类变量显示赋值代码和静态代码块组成类变量显示赋值代码和静态代码块代码从上到下执行clinit 方法只调用一次 实例初始化过程 实例初始化就是执行 init() 方法init () 方法可能重载有多个，有几个构造器就有几个 init() 方法init() 方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码组成非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而对应构造器的代码最后执行每次创建实例对象，调用对应构造器，执行的就是对应的 ini方法init 方法的首行是super()和super(实参列表) ,即对应父类的 init 方法 Father.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.classLoader;/** * 父类初始化&lt;clinit&gt; * 1、j = method() * 2、 父类的静态代码块 * * 父类实例化方法: * 1、super()（最前） * 2、i = test() (9) * 3、子类的非静态代码块 (3) * 4、子类的无参构造（最后）(2) * * * 非静态方法前面其实有一个默认的对象this * this在构造器或&lt;init&gt; 他表示的是正在创建的对象，因为咱们这里是正在创建Son对象，所以 * test()执行的就是子类重写的代码(面向对象多态) * * 这里i=test() 执行的就是子类重写的test()方法 * @author gcq * @Create 2020-09-25 */public class Father &#123; private int i = test(); private static int j = method(); static&#123; System.out.println(&quot;(1)&quot;); &#125; Father() &#123; System.out.println(&quot;(2)&quot;); &#125; &#123; System.out.println(&quot;(3)&quot;); &#125; public int test()&#123; System.out.println(&quot;(4)&quot;); return 1; &#125; public static int method() &#123; System.out.println(&quot;(5)&quot;); return 1; &#125;&#125; Son.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.classLoader;/** * 子类的初始化&lt;clinit&gt; * 1、j = method() * 2、子类的静态代码块 * * 先初始化父类 (5)(1) * 初始化子类 (10) (6) * * 子类实例化方法: * 1、super()（最前 * 2、i = test() (9) * 3、子类的非静态代码块 (8) * 4、子类的无参构造（最后）(7) * @author gcq * @Create 2020-09-25 */public class Son extends Father &#123; private int i = test(); private static int j = method(); static &#123; System.out.println(&quot;(6)&quot;); &#125; Son() &#123; super(); System.out.println(&quot;(7)&quot;); &#125; &#123; System.out.println(&quot;(8)&quot;); &#125; public int test()&#123; System.out.println(&quot;(9)&quot;); return 1; &#125; public static int method() &#123; System.out.println(&quot;(10)&quot;); return 1; &#125; public static void main(String[] args) &#123; Son son = new Son(); System.out.println(); Son son1 = new Son(); &#125;&#125; 方法参数传递机制1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.methodParam;import java.util.Arrays;/** * @author gcq * @Create 2020-09-28 */public class Exam4 &#123; public static void main(String[] args) &#123; int i = 1; String str = &quot;hello&quot;; Integer num = 200; int[] arr = &#123;1,2,3,4,5&#125;; MyData my = new MyData(); change(i,str,num,arr,my); // arr my变了 System.out.println(&quot;i= &quot; + i); System.out.println(&quot;str= &quot; + str); System.out.println(&quot;num= &quot; + num); System.out.println(&quot;arr= &quot; + Arrays.toString(arr)); System.out.println(&quot;my.a= &quot; + my.a); &#125; public static void change(int j, String s, Integer n, int[] a, MyData m) &#123; j += 1; s += &quot;world&quot;; n += 1; a[0] += 1; m.a += 1; &#125;&#125;class MyData &#123; int a = 10;&#125; 考点:方法的参数传递机制 String、包装类等对象的不可变性 方法的参数传递机制1、形参是基本的数据类型:传递数据值 2、实参是引用数据类型:传递值地址 递归与迭代成员变量和局部变量考点:就近原则 变量的分类 成员变量:类变量、实例变量 局部变量 非静态代码块的执行:每次创建实例对象都会执行 方法的调用规则:调用一次执行一次 局部变量与成员变量区别 声明的位置 局部变量:方法体{}中，形参，代码块{}中 成员变量:类方法外 类变量:有static修饰 实例变量:没有static修饰 修饰符 局部变量:final 成员变量:public、protected、private、final、static、volatile、transient、 值存储位置 局部变量:栈 实例变量:堆 类变量:方法区 堆(heap)，此内存区域的唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。 提倡所说的栈(stack)，是指虚拟机栈。虚拟机栈用于存储局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，是对象在堆内存的首地址)。方法执行完，自动释放。 方法区(Method Area)用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 作用域: 局部变量从声明处开始，到所属的}号结束 实例变量:在当前类中this(有时候this可以省略)，在其他类对象中，对象名.访问 类变量:在当前类中，类名(有时类名可以省略)，在其他类中:类名.(或对象名.访问) 生命周期 局部变量:每一个线程，每一次调用执行都是新的生命周期 实例变量:随着对象的初始化而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的类变量:随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的 当局部变量与某变量重名时如姐区分? 与实例变量重名:在成员变量前加this 与类变量重名:在类变量前加类名 SSMSpring中支持的常用数据库事务传播属性和事务隔离级别1. 事务的传播行为当事务方法被另一个事务方法调用时，必须指定事务应该如何传播，例如方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，事务传播的行为有传播属性指定，spring中定义了7种类传播行为 传播属性 描述 REQUIRED 如果有事务在运行，当前的方法就在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行 REQUIRED_NEW 当前方法必须启动事务，并在它自己的事务内运行，如果有事务正在运行，应该将他挂起 SUPPORTS 如果有事务在运行，当前的方法就在这个事务内运行，否则他可以不运行在事务中 NOT_SUPPORTE 当前的方法不应该运行在事务中，如果有运行的事务，将他挂起 MANDATORY 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 NEVER 当前方法不应该运行在事务中，如果有运行的事务，就抛出异常 NESTED 如果有事务在运行，当前的方法就应该在这个事物的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行 事务传播属性可以在@Transactional注解的propagation属性中定义 2. 事务隔离级别数据库事务并发问题:假设现在有两个事务:Transaction01和Transaction02并发执行 脏读02读取了01更新后的值后，01回滚，此时02读取到的值便无效了 不可重复读01读取值后，02将该值修改，01再次读数，两次读数不一致 幻读01读取了一部分数据，然后02又插入了一些新的数据，01再读时，数据增加 隔离级别:数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同的隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 读未提交:READ UNCOMMITTED允许Transaction01读取Transaction02未提交的修改。 读已提交：READ COMMITTED 要求Transaction01只能读取Transaction02已提交的修改。 可重复读：REPEATABLE READ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。 串行化：SERIALIZABLE 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。 各个隔离级别解决并发问题的能力见下表 总结12345678910111213//1.请简单介绍Spring支持的常用数据库事务传播属性和事务隔离级别？ /** * 事务的属性： * 1.★propagation：用来设置事务的传播行为 * 事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务 * -Propagation.REQUIRED：默认值，使用原来的事务 * -Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务 * 2.★isolation：用来设置事务的隔离级别 * -Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别 * -Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，开发时通常使用的隔离级别 */ SpringMVC工作流程整体流程 SpringMVC框架是一个基于请求驱动的Web框架，并且使用了”前端控制器”模型来进行设计，再根据”请求映射规则”分发给响应的页面控制器进行处理。 具体步骤: 首先晕乎乎发送请求到前端控制器，前端控制器根据请求信息(如URL)来决定选择哪一个页面控制器进行处理并把请求托付给它，即以前的控制器的逻辑控制部分 页面控制器收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在Spring web MVC中叫命令，并进行验证，然后将命令对象委托给业务对象进行处理，处理完毕后返回一个ModelAndView 前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染 前端控制器再次收回控制权，将响应返回给用户，至此整个结束 步骤: 发起请求到前端控制器(DispatcherServlet) 前端控制器请求HandlerMapping查找Handle(可以根据xml配置、注解进行查找) 处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象(包含一个Handler处理器(页面控制)对象，对个HandlerInterceptor拦截器)，通过这种策略模式，很容易添加新的映射策略 前端控制器调用处理器适配器去执行Handler 处理器适配器HandlerAdapter将会根据适配的结果去执行Handler Handler执行完成给适配器返回ModelAndView 处理器适配器向前端控制器返回ModelAndView 前端控制器请求视图解析器去进行视图解析(根据逻辑视图名解析成为真正的视图)，通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可。 视图解析器向前端控制器返回View 前端控制器进行视图渲染(视图渲染将模型数据(在ModelAndView对象中)填充到request域) 前端控制器向用户响应结果 核心开发步骤 DispatcherServlet在web.xml中的部署描述，从而拦截请求到Spring web MVC HandlerMapping的配置，从而将请求映射到处理器 HandlerAdapter的配置，从而支持多种类型的处理器ps:处理器映射和适配器使用纾解的话包含在了注解驱动中，不需要再单独配置 ViewResolver的配置，从而将逻辑视图名解析为具体视图技术 处理器(页面控制器)的配置，从而解析功能处理View是一个接口，实现类支持不同的View类型 MyBatisMyBatis中当实体类中的属性名和表中的字段不一样，怎么办?解决方案: 写SQL语句的时候，写别名 在MyBatis的全局配置文件中开启驼峰命名规则 1234&lt;!-- 开启驼峰命名规则，可以将数据库中下划线映射为驼峰命名 列如 last_name 可以映射为 lastName--&gt;&lt;setting name=&quot;mapUnderscoreToCameLCase&quot; value=&quot;true&quot; /&gt; 要求:数据库字段中含有下划线 在Mapper映射文件中使用resultMap自定义映射 123456789101112&lt;!-- 自定义映射--&gt;&lt;resultMap type=&quot;com.atguigu.pojo.Employee&quot; id=&quot;myMap&quot;&gt; &lt;!-- 映射主键 --&gt; &lt;id cloumn=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- 映射其他列 --&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;salary&quot; property=&quot;salary&quot; /&gt; &lt;result column=&quot;dept_id&quot; property=&quot;deptId&quot; /&gt;&lt;/resultMap&gt; Java高级面试题Linux常用命令:进程类Service(centos6) 注册在系统中的标准化程序，有方便统一的管理方式 1234567891011service服务名startservice服务名stopservice服务名restartservice服务名reloadservice服务名status#查看服务的方法 /etc/init.d/ 服务名#通过 chkconfig 命令设置自启动#查看服务 chkconfig -list l grepXXXchkconfig -level 5 服务名on 运行级别:runlevel(centos6) linux系统有7种运行级别(runlevel)，最常用的是3和5 1234567运行级别0:系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1:单用户工作状态，root权限，用于系统维护，禁止远程登陆运行级别2:多用户状态(没有NFS),不支持网络运行级别3:完全的多用户状态(有NFS),登陆后进入控制台命令行模式运行级别4:系统未使用，保留运行级别5: X11控制台，登陆后进入图形GUI模式运行级别6:系统正常关闭并重启，默认运行级别不能设为6,否则不能正常启动. Systemctl(centos7) 注册在系统中的标准化程序，有方便统一的管理方式 12345678910111213141516systemctl start 服务名(xxx.servicesystemct restart 服务名(xxxx.service)systemctl stop 服务名(xxxx.service)systemctl reload 服务名(xxxx.service)systemctl status 服务名(xxxx.service)#查看服务的方法 /usr/lib/systemd/system#查看服务的命令systemctl list-unit-filessystemctl --type service#通过systemctl命令设置自启动自启动systemctl enable service_ _name不自启动systemctl disable service_ name Git创建分支 12git branch &lt;分支名&gt;git branch -v 查看分支 切换分支 12git checkout &lt;分支名&gt;一步完成: git checkout -b &lt;分支名&gt; 合并分支 12先切换到主干 git checkout mastergit merge &lt;分支名&gt; 删除分支 12先切换到主干 git checkout mastergit branch -D &lt;分支名&gt; Git工作流: RedisRedis持久化有几种类型，他们的区别? Redis提供了2个不同形式的持久化方式 RDB(Redis DataBase) AOF(Append OF File) RDB在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 备份如何执行? Redis会单独创建(fork)个子进程来进行持久化，先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何的IO操作，这就确保了极高的性能，如果需要进行大规模数据的恢复，若对数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 RDB的保存文件 在Redis.conf中配置文件名称，默认为dump.rdb。rdb文件的保存路径，也可以修改，默认为Redis启动命令所在的目录下 RDB的备份 先通过config get dir查询RDB文件的目录，将*.rdb的文件拷贝到别的地方 RDB的恢复 关闭Redis，先把备份文件拷贝到工作目录下，启动Redis，备份数据会直接加载。 RDB的优点 节省磁盘空间 恢复速度更快 RDB的缺点 虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时，还是比较消耗性能。在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改 AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次，以完成数据的恢复工作 Rewrite AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集可以使用命令bgrewriteaof Redis如何实现重写 AOF文件持续增长而过大时，会fork出一条新进程来将文件写(也是先写临时文件最后在rename)，遍历新进程的内存中数据，记录每一条的set语句。写AAOF文件的操作，并读取旧的AOF文件，将整个内存中的数据库内容用命令的方式写一个新的aof文件，这点和快照优点类似。 何时重写 写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是由一定的负担的，因此设定Redis要满足一定的条件才会重写。 12auto- aof- rewrite- percentage 100auto- aof- rewrite-min-size 64mb 系统载入时或上次重写完毕时，Redis会记录此时AOF大小，设为base size，如果Redis的AOF当前大小&gt;=base size+base_size*100%(默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 AOF的优点 备份机制更稳健，丢失数据概率更低。可读的日志文本，通过操作AOF文件，可以处理误操作。 AOF的缺点 比起RDB占用更多的磁盘空间。恢复备份速度要慢。每次读写都同步的话，有一定的性能压力。存在个别bug，造成不能恢复。 MySQLMySQL什么时候建立索引、什么时候不适合建立索引? 那些情况需要创建索引: 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段，外检关系建立索引 频繁更新的字段不适合创建索引，因为每次更新不单是更新了记录还会更新索引 单键组索引的选择问题，who?在高并发下领向创建组合索引 查询中排序的字段，排序字段若通过索引法访问将大大提高排序速度 查询中统计或者分组字段 那些情况下不要建立索引 表记录太少。原因:提高了查询速度，同时却会降低更新表的速度，如对表进行INSTER、UPDATE和DELETE 经常增删改的表。原因:更新表时，MySQL不仅要保存数据，还要保存一下索引文件数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。 注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 JVMJVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么 GC发生在JVM的堆里面 有Monit GC、Major GC。具体有:CMS、G1、serial、……，算法有标记压缩、标记复制、标记清除。 项目面试题Redis在项目中的使用场景 数据类型 使用场景 String 比如说，我想知道什么时候封锁一个 IP 地址 Incrby 命令 Hash 存储用户信息[ id, name , age]Hset( key ,field, value)Hset( key ,id, 101)Hset( key ,name, admin)Hset( key ,age, 23)修改案例———Hget(userKev,jd)+Hset(userKey,id,102)为什么不使用String类型来存储 String拿到对象值之后需要反序列化，我们只需要更改id name, age 没有意义反序列化Set(userKey;用信息的字符串)Get(userKey)不建议使用String 类型。 List 实现最新消息的排行，还可以利用 List 的 push 命令，将任务存在list集合中，同时使用另-个命令，将任务从集合中取出[ pop ]。。Redis - List 数据类型来模拟消息队列。[电商中的秒杀就可以采用这种方式来完成一个秒杀活动]。 Set 特殊之处:可以自动排重。比如说微博中将每个人的好友存在集合( Set) 中，+这样求两个人的共通好友的操作。我们只需要求交集即可。 Zset 以某一个条件为权重，进行排序。京东:商品详情的时候，都会有一个综合排名，还可以按照价格进行排名 Elasticsearch与solr的区别背景:他们都是基于Lucene搜索服务器基础上开发的，一款优秀的高性能企业级搜索服务器(都是基于分词技术构建的倒排索引的方式进行查询) 开发语言:java。Solr2004年诞生，ES2010年诞生，ES更新，功能更强大(新技术的出现，会弥补老技术的缺点，吸取老技术的优点)。 区别: 当建立索引的时候，solr会产生io阻塞，而es不会，es查询性能要高于solr 在不断动态添加数据的时候，solr的检索效率会变得低下，而es没有什么变化 Solr利用zookeeper进行分布式管理，而es自带有分布式系统的管理功能，Solr一般都要部署到web服务器上，比如tomcat，启动tomcat的时候需要配置tomcat和solr的关联(Solr的本质，是一个动态的web项目) solr支持更多格式的数据(XML、json、csv等)，而es仅仅支持json文件格式 solr是传统搜索应用的有利解决方案，但是es更加适用于新兴的实时搜索应用。单纯对已有的数据进行检索，solr效率更好，高于es。 solr官网提供的功能更多，而es本身更加注重于核心功能，高级功能都有的第三方插件完成 单点登录单点登录:一处登录多处使用! 前提:单点登录使用在分布式系统中，一处登录，处处运行。 实例: 12京东：单点登录，是将 token 放入到 cookie 中案例：将浏览器的 cookie 禁用，则在登录京东则失效，无论如何登录不了 购物车实现过程购物车： 1、购物车跟用户的关系 ？ 一个用户必须对应一个购物车【一个用户不管买多少商品，都会存在属于自己的购物车中】 单点登录一定要在购车前 2、跟购物车有关的操作有那些？ 0 用户未登录状态 添加到什么地方，未登录将数据保存到什么地方？ Redis —京东 Cookie 自己开发项目的时候【如果浏览器禁用Cookie】 用户登录状态。Redis 缓存中 【读写速度快】:Hash: Hset(key,field,value)、 Key:user:userId,cart、 Hset(key,skuId,value); 存在数据库中 【Oracle，mysql】 展示购物车 未登录状态显示:直接从 cookie 中 取得数据展示即可 登录状态:用户一旦登录，必须显示数据库【redis】 + cookie 中的购物车的数据。Cookie 中有三条记录，Redis 中有五条记录，真正展示的时候应该是八条记录 消息队列在项目中的使用背景:在分布式系统中如何处理高并发的 由于在高并发的环境下，来不及同步处理用户发送的请求，则会导致请求发生阻塞，比如说，大量的insert、update之类的请求同时到达数据库，直接导致无数的行锁表锁，甚至会导致请求堆积过多，从而触发too many connections(连接数太多)错误，使用消息队列可以解决(异步通信) 异步: 并行: 排队 消息队列在电商中的使用场景: 消息队列的弊端 消息的不确定性:延迟队列和轮询技术来解决问题即可 推荐使用activeMQ","categories":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://stary2020.gitee.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"笔记","slug":"笔记","permalink":"http://stary2020.gitee.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":null},{"title":"面试题2","slug":"java-2021-08-15-faceQuestions2","date":"2021-08-01T12:56:06.000Z","updated":"2021-08-19T02:34:03.632Z","comments":true,"path":"2021/08/01/java-2021-08-15-faceQuestions2/","link":"","permalink":"http://stary2020.gitee.io/2021/08/01/java-2021-08-15-faceQuestions2/","excerpt":"","text":"4、GitHub常用词含义watch: 会持续收到该项目的动态 fork，复制某个项目到自己的github仓库中 star,可以理解为点赞 clone，将项目下载至本地 follow，关注你感兴趣的作者，会收到他们的动态 in关键词限制搜索范围 公式 xxx关键词 in:name或description或readme xxx in:name项目名包含xxx的 xxx in:description项目描述包含xxx的 xxx in:readme项目的readme文件中包含xxx的 组合使用 搜索项目名或者readme中包含秒杀的项目 seckill in:name,readme stars或fork数量关键词去查找公式xxx关键词 stars 通配符 :&gt; 或者 :&gt;= 区间范围数字数字1..数字2 查找stars数大于等于5000的springboot项目springboot stars:&gt;=5000 查找forks数大于500的springcloud项目springcloud forks:&gt;500 组合使用 查找ifork在100到200之间并且stars数在80到100之间的springboot项目springboot forks:100..200 stars:80..100 awesome加强搜索公式awesome 关键字 awesome 系列 一般是用来收集学习，工具，书籍类相关的项目 搜索优秀的redis相关的项目，包括框架，教程等 高亮显示某一行代码公式1行地址后面紧跟#L数字 多行地址后面紧跟#L数字-L数字2 项目内搜索 英文 https://help.github.com/en/articles/using-keyboard-shortcuts 搜索某个地区内的大佬公式location:地区language:语言 地区北京的java方向的用户location:beijing language:java 5、消息中间件之MQ常见面试题1、作为技术选型的时候，你们是怎么判断的？还是说你进去公司以后，公司要你用这个你就用这个？请问你有没有自己的独立见解和思考？答: 我刚入行的时候，人为年轻，也没有这个能力这个权限去做我们公司项目的技术选型，经理让我们用什么我们就用什么，但是我现在深度了解过ActiveMQ。我在公司用ActiveMQ的时候都接触过api发送和接收，MQ的高可用性，集群容错，持久化等功能，如果贵公司用ActiveMQ这款产品最好，如果不用，我也相信其他MQ也会支持像ActiveMQ的高可用，集群容错等功能，因为技术维度都是相通的。 2、对于这个消息里面，两大经典的Queue队列和Topic主题，这两者有什么区别？请谈谈你的理解？答: Queue队列是以数据默认存储在MQ服务器上文件形式保存起来，也可以用数据库进行存储。它采用的是负载均衡的模式，若当前没有消费者，消息也不会被丢弃。如果有多个消费者，那一个消息就只会发送给其中一个消费者。 Topic它是无状态的发布订阅模式，若没有订阅者，那么消息就直接被丢弃，如果有多个订阅者，那么这些订阅者就都会收到消息，但是性能会降低，因为它是按照订阅者数量进行复制数据来发送的。 3、ActiveMQ的默认端口是什么？ActiveMQ两大经典默认的端口是61616和8161 4、消息队列的主要作用是什么？削锋解耦异步 它能对多个模块进行解耦，对相关高并发场景进行削峰以及消息的异步处理 5、你生产上的链接协议如何配置的？是使用tcp吗？答：还用过NIO，它类似于TCP传输协议，但是它是用的是非阻塞型NIO，它有比TCP更好的性能 6、默认的61616端口以及web页面的端口在哪修改答：可以在ActiveMQ的conf文件夹下的ActiveMQ.xml当中进行修改61616进程端口，以及在conf文件夹下的jetty.xml进行修改web页面的端口 7、kafka activemq，rabbitmq，rocketmq都有什么区别？1、我就说说我用过的ActiveMQ，ActiveMQ是Apache下的产品，它支持JAVA，它自身是JAVA开发出来的产品，而Apache跟我们JAVA程序员是耍不掉的，我们用的很多产品也都是Apache下的，比如Tomcat这些产品，所以它对于我们的入门学习的提升非常有帮助。它有较低的概念数据丢失，但是这个可以控制的。可能等到ActiveMQ6.0出来了以后，可能会更完善了一些，但现在如果比起阿里巴巴的RocketMQ，这个ActiveMQ没有RocketMQ好。2、因为RocketMQ是阿里的产品，它模仿了kafka的精华，进行改造出来的产品，也是得到阿里双十一验证的较为成熟的产品。 3、而kafka是大数据场景下用到的产品，它是支持十万级别的吞吐量，但是它似乎会丢失一些数据的概率大一些吧 4、而RabbitMQ是其他语言开发的，若改它源码可能使我们JAVA程序员较为麻烦。扩展性可能就不是很好。 8、你们为什么不用其他的MQ，最终选择了用ActiveMQ？因为ActiveMQ是Apache下的产品，它支持JAVA，它自身是JAVA开发出来的产品，而Apache 跟我们JAVA程序员是耍不掉的，我们用的很多 产品也都是Apache的，比如Tomcat这些产品，所以它对于我们的入门学习的提升非常有帮助并且扩展性较好。它有较低的概念数据丢失，但是这个可以控制的。可能等到下一代的ActiveMQ6.0出来了以后，可能会更加完善了一些 9、ActiveMQ的持久化机制请你谈谈？答：MQ自身也带有持久化机制，并且MQ默认的就是KahaDB以日志文件进行存储的，但是这种自带的持久化机制也不可靠，因为若一旦MQ宕机了，就算自带可持久化机制也需要重启恢复，所以为了保证高可用，为了保证可靠性。MQ一般都会采用数据库存储等方式进行更为保障的持久化。 10、请你谈谈ActiveMQ默认存储机制KahaDB的原理是什么？1、KahaDB里面有四类文件一把锁，其中一个db-1.log是日志文件，当这个日志文件满了以后，会新增一个新的日志文件，并在日志文件名称中按照数字进行编号，若不再引用该日志文件了，该日志文件就会被删除或者是归档。 2、db.data是索引，他用来存储日志文件记录的具体索引位置的。 3、db.free是看db.data索引文件当中是有有空闲 4、lock是读取该KahaDB的一把权限锁。 11、你是如何保证生产端发送消息比较快，并且要保证消息能发送成功？1、若生产端发送的大量消息，消费端消费的比较慢，可以开启异步投递的方式， 有三种方法可以开启生产端的异步投递，使其性能提高，发送消息会更快 2、但是同时也会导致丢失数据的风险，因为生产端直接生产了消息就直接丢给了MQ，也不管MQ收到没收到，生产端这边就自认为自己已经完成了工作。但MQ一旦宕机等了，那么数据可能会丢失。 3、想保证消息能发送成功，要加入异步投递的同时，再加入异步接收回调方法，使其再判断是否都发送成功，若失败了就需要人工干预，继续重发。 12、请你谈谈MQ当中具体哪些情况会引发消息的重发？1、消费端使用事务，但是在session中调用了rollback回滚,没有真正的提交数据 2、消费端使用事务，但是没有提交或者是之前关闭了 3、消费端在使用签收的模式下，在session中调用了recover()重试的方法 这以上三种情况都会导致消息的重发。 13、请说说消息重发时间间隔和重发次数？默认是间隔每一秒钟，消息会重发6次 14、MQ的有毒消息谈谈你的理解？我的理解是：这个消息重发了6次以后，还是发送不出去，消费端就会自动给MQ一个标识，表明这个消息是有毒的消息，告诉MQ实例（broker），不要再发这个消息了。MQ实例（broker）就会把这个消息放到死信队列当中。 15、谈谈你对死信队列的理解？若MQ发送的消息，发送了6次都未能发送成功，会将该消息放入到死信队列当中，相关工程师可以在这个MQ的网页端的Queue队列中查看出错的消息，然后进行人工的干预处理 16、你在项目中是如何保证消息队列的高可用？答：是用事务，签收，持久化和zookeeper+replicated-leveldb-store的主从集群来保证MQ的高可用 17、消费者消费消息，如何保证MQ幂等性？1、若MQ的消息是可以落盘到数据库的，可以在数据库当中设置唯一的ID主键，这样就算出现了重复消费的情况，也会导致主键的冲突。避免数据库会出现脏数据。不过这个并不推荐 2、推荐用redis缓存来做，给消息分配一个全局的id，只要是消费过的消息，就放入redis当中，那么消费者在开始消费前，先去redis中查询有没有消费的记录。 18、为什么要在系统里引入消息中间件?1、它能够解决系统耦合调用的问题 2、它能够解决系统RPC同步调用的问题异步模型 3、它能够抵御洪峰流量，达到保护主业务的目的。 19、何种场景下使用了消息中间件？1、只要是消息发送，尽量都是异步，所以可以引入消息中间件 2、只要是系统解耦，尽量都可以引入消息中间件 20、如果消息中间件的消息大量积压了，你是如何处理的？为什么会导致消息大量的积压？如果生产者发送消息给消息队列MQ，消费者会连上消息队列MQ服务器，进行消费消息，但是消息队列MQ里面存的消息太多，那肯定会影响很多的性能，所以消息的积压会导致MQ性能的下降，所以一定要解决消息积压的问题。 什么情况下会导致消息的积压？1、比如消费者宕机，相当于MQ服务器没有连上任何一个消费者或者连的消费者太少了，消费者宕机了，没有消费者去消费MQ服务器当中的消息，而生产者源源不断的在生产着消息，那可能导致MQ服务器里面会有上万的消息在等着被消费 2、消费者消费的能力不足，假设原本有10个消费者，结果有9个消费者宕机了，最终一个消费者消费消息的效率太慢了 3、生产者发送的消息比较猛，消费者在消费MQ服务器当中的消息，导致可能消费者跟不上生产者生产的消息，而最终导致MQ大量的消息积压 怎么解决消息积压的问题？解决方案1：可以限制生产者的发送流量，但是要限制流量，就要限制业务，只要业务不执行，就不发这个消息出去 解决方案2：更可以在消费者来解决消息积压的问题，既然MQ服务器里面的消息积压了，就可以上线更多的消费者来消费消息 解决方案3：由于可能数据量太大，如果上线更多的消费者的话，那么这个消费者如果是正常来消费消息，还要来处理，那么这个处理可能还要一段时间，就会有点慢，那么就可以上线一个专门处理消息的消费者，假设MQ有百万的消息积压，可以直接从这个专门处理消息的消费者把百万积压的消息全部批量拿出来存到数据库，然后存到数据库以后，再来编写一个离线处理消息的业务功能，从数据库里面，慢慢取出一条一条的数据进行处理。 21、MQ在高并发情况下假设队列满了如何防止消息的丢失？为什么会导致消息的丢失？消息的丢失是一个非常严重的现象，特别是做类似电商的业务，只要有一个消息丢失，可能会影响到后边一连串的操作都会出现问题。 一般使用消息事务，也就是用可靠消息+最终一致性方案，那么就应该首先保证消息的不丢失。 什么情况下会导致消息的丢失？1、消息发出去，但由于网络的问题没有抵达到MQ服务器 2、消息发送到MQ服务器，MQ服务器要将消息写入到磁盘才能算成功，但此时MQ服务器还没持久化这个数据也即可能还没处理这个数据，就宕机了，MQ服务器一旦宕机了以后再次启动，那么这个没有处理的数据就丢失了。 解决方案1：使用生产者发送消息的确认机制，每一个确认成功的消息，都去数据库MQ表里面修改一下状态，改为：已收到的状态 3、比如生产者发送一个消息给MQ服务器，确认抵达机制已经到了MQ服务器，那么消费者此时就在消费消息，消息者刚把消息拿到，还没来得及消费，消费者却宕机了，宕机以后，此时这个消息，如果是自动确认(也即自动ACK机制的)情况下，相当于消费者已上线拿到消息就默认回复给MQ服务器：消费者已经收到了，但是其实最终却没有消费成功这个消息，那么这个消息就相当于走了一般过场而已 解决方案1: 一定要开启手动确认机制(也即手动开启ACK机制)，消费真正成功才移除，失败或者没来得及处理就让消息重新入消息队列 怎么解决消息丢失的问题？那么如何保证消息一定发出去呢？解决方案1：可以做好容错方案，也即发送消息可能会导致网络原因而发不出去，那么就将没发送出去的消息进行重试发送 解决方案2:做好日志记录，只要每发一个消息，都做好相应的日志记录，可以给每一个业务的数据库里面创建一张MQ的表，这个表主要保存每一个消息的详细信息，只要发送失败了，就可以定期去扫描这个MQ日志表的数据库，把这些失败的消息拿出来再发一遍 解决方案3: 一定要开启手动确认机制(也即手动开启ACK机制)，消费真正成功才移除，失败或者没来得及处理就让消息重新入消息队列 解决方案4：使用生产者发送消息的确认机制，每一个确认成功的消息，都去数据库MQ表里面修改一下状态，改为：已收到的状态 总结：做好消息的确认机制，要做两端的确认（也即消费者和生产者） 特别是消费者一定要开启手动确认机制(也即手动开启ACK机制),否则只要一收到消息，但还没有处理消息就宕机了，那么这个消息就直接被删除了。一旦做了确认机制，那么每一个发送的消息都在数据库做好记录，然后将定期所有失败的消息再次发送一遍 22、MQ在高并发下若消息重复了，你是如何处理的？为什么会导致消息的重复？所谓的消息重复就是一个消息给消费者发了两次，相当于消费者收到了两次相同的消息 什么情况下会导致消息的重复？1、消费者一般会用监听器来收到消息，一旦监听器收到消息以后，会调用业务逻辑进行处理，假设消息消费成功了，业务逻辑也处理完了，此时突然宕机了，那么下面的一些方法可能还没走完，也相当于没有给MQ服务器回复这个消息已经消费成功了，消费者就跟MQ服务器断开连接了，那么一旦断开连接，那么MQ服务器就认为消费者没有把消息消费成功，因为设置的是手动确认（ACK）机制，那么此时消息就会从Unack（正在处理）状态变成Ready（重新处理的），那么变成Ready状态，就会发给其他的消费者，相当于其他消费者收到以后，再处理，那么这个消息就相当于被处理了两遍。 2、消息消费失败了，然后告诉MQ服务器，拒绝消息，让这个消息重新回到队列里面，然后再来接收到进行处理，这种的消息重复处理是被允许的，因为第一遍是失败了，那么消息再次进入队列，来重新尝试消费。 怎么解决消息重复的问题？解决方案1：将业务逻辑方法设计成幂等性的。 解决方案2：也可以使用防重表，每一个消息由于都有一个唯一的id，只要它被处理过了，就可以去防重表里面记录一下。 解决方案3：也可以使用RabbitMQ的消息的属性字段，来看看是不是消息是重新派发过来的，那么就可以不处理了，但是这样做太暴力了，万一上一次是失败的，没有消费成功，那么再派送过来也丢失了 总结:如果消息重复了，把业务设计成幂等性的就行了，即使消息发上一万遍，那都是最终执行一遍的结果。 6、MySQL相关(待更新)面试题1、mysql5.5以上的存储引擎是什么 答:默认的是InnoDB存储引擎, 2、为什么mysql5.5以后的存储引擎会选择这个作为存储引擎呢？答：因为它支持事务，行锁，支持外键，InnoDB它的高并发支持的比较好，因为要锁也只是锁一行，不是锁整张表.所以InnoDB的功能和性能会更强一些。 3、请谈谈InnoDB和MyISAM优点和缺点，并谈谈你的理解？答：现在最常用的存储引擎是InnoDB，它从Mysql5.5.5版本开始以后就成为了默认的存储引擎 InnoDB支持主外键，事务，行表锁，缓存，表的空间，而MyISAM是不支持主外键以及事务的，它在锁方面也仅仅只是支持表锁，它并不适合做高并发的操作，因为它操作一个记录的时候，会锁住整个表。 MyISAM的关注点是在性能,它偏向于查询，而InnoDB的关注点是在事务方面，它偏向于数据的稳定和持久 4、请问当你写了一个sql以后，在Mysql数据库底层是如何加载并运行的？答：Mysql默认是从FROM 先开始加载表，再从ON。然后就是JOIN，WHERE,GROUP BY, HAVING, SELECT,DISTINCT, ORDER BY ,LIMIT等其他这种顺序运行的 5、请问Join是有几种？答：粗分是有四种，左连接，右连接，内连接，外连接 6、索引是什么？Mysql官方对索引的定义是：索引(Index)是帮助Mysql高效获取数据的数据结构。 为什么要建索引？索引的目的在于提高查询效率。 索引有两大功能：查找快，排好序。也即建的索引将会影响到Sql的两部分。 第一部分：就是where条件后面这部分的条件约束是否用到索引，这部分就是负责查找的条件过滤。 第二部分：索引会影响到where后面的查找以及order by后面的排序。 哪些情况下适合建索引？1.主键自动建立唯一索引。 2.频繁作为查询条件的字段应该建索引。 3.查询中与其他表关联的字段，外键关系建立索引。 4.频繁更新的字段不适合创建索引：因为每次更新不单单只是更新了记录，还会更新索引，加重了IO负担。 5.Where条件里用不到的字段不创建索引。 6.单键/组合索引的选择问题(高并发下倾向创建组合索引)。 7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。 8.查询中统计或者分组字段。 哪些情况下不适合建索引？1.表记录太少。 2.经常增删改的表：提高了查询效率，但是同时却会降低了更新表的速度，如对表进行INSERT,UPDATE以及DELETE。因为更新表时，MySql不仅要保存数据，还要保存索引文件。 3.数据重复并且分布平均的表字段，因此应该只给最经常查询和最经常排序的数据列建立索引，但如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 7、NoSQL数据库Redis实现分布式锁基础补充1、查询缓存为了系统性能的提升，我们一般都会将数据放入缓存中，加速访问。而db承担数据落盘工作整合jedis 2、缓存问题1。缓存穿透缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中， 将去查询数据库，但是数据库也无此记录，并且处于容错考虑， 我们没有将这次查询的null写入缓存， 这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决：空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 2。缓存雪崩缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 3。缓存击穿对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。 这个时候，需要考虑一个问题：如果这个key在大量请求同时进来前正好失效，那么所有对这个key的数据查询都落到db，我们称为缓存击穿。 与缓存雪崩的区别： 缓存击穿是一个热点key失效，缓存雪崩是很多key集体失效 解决分布式锁 3、分布式锁1、我们想要的效果 2、分布式锁第一阶段&amp;出现的问题 3、分布式锁第二阶段&amp;出现的问题 4、分布式锁第三阶段&amp;出现的问题 5、分布式锁第四阶段&amp;出现的问题 6、分布式锁核心代码 加锁 123String token = UUID.randomUUID().toString(); String lock = jedis.set(key, token, &quot;NX&quot;, &quot;EX&quot;,20); More Actions 解锁 12String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; jedis.eval(script, Collections.singletonList(key), Collections.singletonList(token)); 进入redis测试 docker exec –it redis redis-cli docker exec –it redis redis-benchmark 4、缓存使用模式Cache-Aside即业务代码围绕Cache编写，由业务代码维护缓存； 读场景 12345data = cache.getIfPresent(key);if(data == null)&#123; data = loadFromSoR(key); cache.put(key,data)&#125; 先从缓存中获取，没有查询SoR，再放入缓存 写场景 双写模式 1234//1、先将数据写入SoRwriteToSoR(k,v);//2、执行成功后立即同步写入缓存cache.put(k,v) 失效模式 1234//1、先将数据写入SoRwriteToSoR(k,v);//2、失效缓存，下次读取时从缓存中加载（进入读场景），cache.invalidate(k); 并发更新问题与解决 （多个缓存实例，同时更新自己里面的同样数据） canal 1、考虑使用中间件如Canal订阅binlog，进行增量更新分布式缓存，不会存在缓存数据不一致问题。但是会有延迟，我们可以调整合理的过期时间来容忍这个延迟 2、读服务，可以考虑一致性哈希，相同的操作负载均衡到同一个实例，从而减少并发几率。 自定义数据分片规则，实现一致性hash Cache As SoR即把Cache当做SoR，所有操作都是对Cache进行，然后Cache委托SoR进行数据的真实读写。 即业务代码只看到Cache的操作，看不到关于SoR的代码；三种实现模式：read-through、 write-through、write-behind read-through 业务代码首先调用Cache，Cache不命中，由Cache回源到SoR（类似回调的方式或者Cache配置的方式）， 而不是业务代码。【Guava、Ehcache均支持这种模式】 优点：业务代码整洁； MyBatis缓存机制；userMapper.get(1); write-through 称为穿透写模式/直写模式。业务代码调用Cache写数据，然后由Cache负责写缓存和写SoR，而不是业务代码。 MyBatis缓存机制：userMapper.update(1); 1)、直接把缓存删了或者改了 2）、再去改数据 write-behind（write-back） 也叫write-back；回写模式。不同于write-through的是，write-through是同步写，而write-back是异步写，异步成功后可以实现批量写、合并写、延时写等 123db.update(1); //1snew Thread(()-&gt;&#123; cache.update() //3s&#125;).start();sout(&quot;&quot;);//1s后 Copy-Pattern（缓存数据复制方式） 缓存使用两种复制模式，注意。Copy-On-Read（读时复制）、Copy-On-Write（写时复制）。 有些进程内缓存很多是基于引用的，所以拿到缓存中的数据如果进行修改，可能发生不可预测的问题。 读时复制：读取到的缓存的值，复制内容封装一个新的对象。 写时复制：给缓存中写的值，复制一个新的对象写入 名词 SoR（system-of-record）：记录系统，或者可以叫数据源，实际存储原始数据的系统 Cache：缓存，是SoR的快照数据，Cache的访问速度比SoR要快，放入Cache的目的是提升系统速度，减少回源到SoR的次数 回源：回到数据源头检索数据，Cache没有命中需要回到SoR读取数据，这叫做回源 5、分布式锁&amp;集合落地实现—-Redisson1、简介 Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。 2、整合 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.10.5&lt;/version&gt; &lt;/dependency&gt; 2、配置 配置redis 12spring.redis.host=192.168.159.130spring.redis.port=6379 配置redisson 1234567891011121314151617@Configurationpublic class GmallRedissonConfig &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private String port; @Bean public RedissonClient redissonClient()&#123; Config config = new Config(); config.useSingleServer().setAddress(&quot;redis://&quot;+host+&quot;:&quot;+port); RedissonClient redisson = Redisson.create(config); return redisson; &#125;&#125; 3、文档 https://github.com/redisson/redisson/wiki/1.-Overview 4、分布式锁 5、分布式集合 6、各种锁锁的基本问题 1、锁是什么？干什么用？锁主要用来实现资源共享的同步。只有获取到了锁才能访问该同步代码，否则等待其他线程使用结束释放锁。 一句话：限制多线程资源竞争 2、知道下面这些锁吗？自旋锁、阻塞锁、可重入锁、读写锁、互斥锁、悲观锁、乐观锁、公平锁、偏向锁、 对象锁、线程锁、锁粗化、锁消除、轻量级锁、重量级锁、信号量、 独享锁、共享锁、分段锁、闭锁 锁分类 其实我们真正用到的锁也就那么两三种，只不过依据设计方案和性质对其进行了大量的划分。 常见（kao）的锁 SynchronizedSynchronized，它就是一个：非公平，悲观，独享，互斥，可重入，重量级 1234567Synchronized a ()&#123; b();&#125; Synchronized b ()&#123;&#125; Lock以下两个锁都在JUC包下，是API层面上的实现 ReentrantLock，它是一个：默认非公平但可实现公平的，悲观，独享，互斥，可重入，重量级锁。 ReentrantReadWriteLocK，它是一个，默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入，重量级锁。 1234ReentrantLock lock = new ReentrantLock();lock .lock(); &#123;&#125;lock .unlock(); 公平锁：排队机制 AQS：百度 ReentrantLock与synchronized 的区别ReentrantLock（可重入锁） 中断等待 ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候。 线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断 如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 ReentrantLock获取锁定有三种方式lock(),如果获取了锁立即返回，如果别的线程持有锁， 当前线程则一直处于休眠状态，直到获取锁 tryLock(),如果获取了锁立即返回true， 如果别的线程正持有锁，立即返回false tryLock(long timeout,TimeUnit unit)如果获取了锁定立即返回true， 如果别的线程正持有锁， 会等待参数给定的时间， 在等待的过程中，如果获取了锁定，就返回true， 如果等待超时，返回false； lockInterruptibly:如果获取了锁定立即返回， 如果没有获取锁定，当前线程处于休眠状态， 直到获取锁定，或者当前线程被别的线程中断 可实现公平锁对于ReentrantLock而言， 通过构造函数指定该锁是否是公平锁， 默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。 锁绑定多个条件锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可。 公平锁AbstractQueuedSynchronizer AQS；抽象的队列同步器； 所有抢锁的线程都去queue里面； synchronized（也可重入） 优势synchronized是在JVM层面上实现的， 不但可以通过一些监控工具监控synchronized的锁定， 而且在代码执行时出现异常，JVM会自动释放锁定， 但是使用Lock则不行，lock是通过代码实现的， 要保证锁定一定会被释放，就必须将unLock()放到finally{}中 场景在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock， 但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态； 实际上，我推荐大家以压力测试为准 按照性质分类 公平锁/非公平锁公平锁:公平锁是指多个线程按照申请锁的顺序来获取锁。 非公平锁:非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序， 有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。 ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁 非公平锁的优点在于吞吐量比公平锁大。 对于Synchronized而言，也是一种非公平锁。 ReentrantLock是通过AQS的来实现线程调度，实现公平锁（AbstractQueuedSynchronizer） 乐观锁/悲观锁乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度 悲观锁悲观锁认为对于同一个数据的并发操作， 一定是会发生修改的，哪怕没有修改，也会认为修改。 因此对于同一个数据的并发操作，悲观锁采取加锁的形式 悲观锁适合写操作非常多的场景 悲观锁在Java中的使用，就是利用各种锁。 乐观锁乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。 在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。 乐观的认为，不加锁的并发操作是没有事情的 乐观锁适合读操作非常多的场景 不加锁会带来大量的性能提升 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法， 典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。 独享锁/共享锁独享锁独享锁是指该锁一次只能被一个线程所持有。 ReentrantLock是独享锁。 Synchronized是独享锁 共享锁共享锁是指该锁可被多个线程所持有 ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的， 通过实现不同的方法，来实现独享或者共享。 互斥锁/读写锁独享锁/共享锁是一种广义的说法，互斥锁/读写锁就是具体的实现。 互斥锁 ReentrantLock 读写锁读写锁在Java中的具体实现就是ReentrantReadWriteLock 可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层加锁方法会自动获取锁。 1234567a()&#123; if(lock.lock())&#123; &#125;else&#123; // a(); 递归 //while true；自旋 &#125;&#125; ReentrantLock、Synchronized都是可重入锁，可重入锁的一个好处是可一定程度避免死锁。 1234567public sychrnozied void test() &#123; xxxxxx; test2();&#125;public sychronized void test2() &#123; yyyyy;&#125; 在上面代码段中，执行 test 方法需要获得当前对象作为监视器的对象锁，但方法中又调用了 test2 的同步方法。 如果锁是具有可重入性的话，那么该线程在调用 test2 时并不需要再次获得当前对象的锁，可以直接进入 test2 方法进行操作。 如果锁是不具有可重入性的话，那么该线程在调用 test2 前会等待当前对象锁的释放，实际上该对象锁已被当前线程所持有，不可能再次获得。 如果锁是不具有可重入性特点的话，那么线程在调用同步方法、含有锁的方法时就会产生死锁。 所以所有的锁都应该被设计成可重入的 按照设计分类 自旋锁/自适应自旋锁在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞， 而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 非阻塞方式获取锁 自适应自旋 如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。 在JDK1.6中引入了自适应的自旋锁。 自旋的时间不固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长时间，比如100个循环。 如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源 什么是阻塞方式获取锁 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪） sleep()：睡眠 Thread.sleep (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。 顺序进入同步块的，不释放锁，持有monitor对象锁，其他线程是不能进入的。//忍让一段时间 阻塞而不释放锁 wait()：等待 wait() 与 notify/notifyAll()都是放在同步代码块中才能够执行的。 Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait() 一样。 wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用. 当调用wait方法后，当前线程会释放持有的monitor对象锁，因此，其他线程还可以进入到同步方法，线程被唤醒后（如果加时间参数的话，则会在时间被消耗后唤醒，否则需要通过notify或notifyall唤醒），需要竞争锁，获取到锁之后再继续执行。//无条件忍让一段时间 阻塞并释放锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Service &#123; public void testMethod(Object lock) &#123; try &#123; synchronized (lock) &#123; System.out.println(&quot;begin wait() ThreadName=&quot; + Thread.currentThread().getName()); lock.wait(); System.out.println(&quot; end wait() ThreadName=&quot; + Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void synNotifyMethod(Object lock) &#123; try &#123; synchronized (lock) &#123; System.out.println(&quot;begin notify() ThreadName=&quot; + Thread.currentThread().getName() + &quot; time=&quot; + System.currentTimeMillis()); lock.notify(); Thread.sleep(5000); System.out.println(&quot; end notify() ThreadName=&quot; + Thread.currentThread().getName() + &quot; time=&quot; + System.currentTimeMillis()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;==================public class ThreadA extends Thread &#123; private Object lock; public ThreadA(Object lock) &#123; super(); this.lock = lock; &#125; @Override public void run() &#123; Service service = new Service(); service.testMethod(lock); &#125;&#125; public class SynNotifyMethodThread extends Thread &#123; private Object lock; public SynNotifyMethodThread(Object lock) &#123; super(); this.lock = lock; &#125; @Override public void run() &#123; Service service = new Service(); service.synNotifyMethod(lock); &#125;&#125;==================public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Object lock = new Object(); ThreadA a = new ThreadA(lock); a.start(); //NotifyThread notifyThread = new NotifyThread(lock); // notifyThread.start(); SynNotifyMethodThread c = new SynNotifyMethodThread(lock); c.start(); &#125;&#125; yield()：礼让 Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程. 放弃当前时间片，将Running状态转变为Runnable状态，不能指定多长时间。//假装忍让，完成具有不确定性不受监督的切换 暂停当前线程，主动让出自己的CPU时间 join()：插队 类似sleep，停止当前线程，让join线程先执行完毕，或执行指定的时间。//插队拼接 ==main线程要等到t1线程运行结束后，才会输出“main end”。如果不加t1.join(),main线程和t1线程是并行的。而加上t1.join(),程序就变成是顺序执行了。== 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws InterruptedException &#123; System.out.println(&quot;main start&quot;); Thread t1 = new Thread(new Worker(&quot;thread-1&quot;)); t1.start(); t1.join(); System.out.println(&quot;main end&quot;); &#125;============================ ==============线程是顺序执行的。=============================public static void main(String[] args) throws InterruptedException &#123; System.out.println(&quot;main start&quot;); Thread t1 = new Thread(new Worker(&quot;thread-1&quot;)); Thread t2 = new Thread(new Worker(&quot;thread-2&quot;)); t1.start(); //等待t1结束，这时候t2线程并未启动 t1.join(); //t1结束后，启动t2线程 t2.start(); //等待t2结束 t2.join(); System.out.println(&quot;main end&quot;); &#125; 当前线程等待join进来的执行完，再继续 suspend()和resume()：暂停/恢复 两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。 有死锁倾向 线程类常用方法 sleep(): 强迫一个线程睡眠Ｎ毫秒。 isAlive(): 判断一个线程是否存活。 join(): 等待线程终止。 activeCount(): 程序中活跃的线程数。 enumerate(): 枚举程序中的线程。 currentThread(): 得到当前线程。 isDaemon(): 一个线程是否为守护线程。 setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName(): 为线程设置一个名称。 wait(): 强迫一个线程等待。 notify(): 通知一个线程继续运行。 setPriority(): 设置一个线程的优先级。 锁粗化/锁消除锁粗化和消除其实设计原理都差不多，都是为了减少没必要的加锁 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 锁粗化 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部 偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对Synchronized 偏向锁偏向锁是指一段同步代码一直被一个线程所访问， 那么该线程会自动获取锁。降低获取锁的代价。 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问， 偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。 重量级锁当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去， 当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。 重量级锁会让其他申请的线程进入阻塞，性能降低。 分段锁分段锁是一种锁的设计，并不是具体的一种锁 ConcurrentHashMap并发的实现就是通过分段锁的形式来实现高效的并发操作 ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 分布式锁Redisson 数据库锁http://hedengcheng.com/?p=771#_Toc374698307 表锁、行锁、间隙锁、悲观锁、乐观锁、共享锁（读锁）、排他锁（写锁） 8、分布式协调技术Zookeeper实现分布式锁zookeeper实现过分布式锁吗？分布式情况下，怎么解决订单号生成的重复问题？问题产生 真分布式/伪分布式式 分布式优缺点 解决 1.使用分布式锁 1、mysql数据库的乐观锁实现 2、redis–redission 3、zookeeper 2.提前生成好订单号，存放在内存取。获取订单号，直接从内存中取 实现思路 设计思想 对于单进程的并发场景，我们可以使用synchronized关键字和Reentrantlock类等 对于分布式场景，我们可以使用分布式锁 创建锁多个jvm服务器之间，同时在zookeeper上创建相同的一个临时节点，因为临时节点路径是保证唯一。只要谁能够创建节点成功，谁就能够获取到锁没有创建成功节点，只能注册个监听器监听这个锁并进行等待，当锁释放的时候，采用事件通知给其他客户端重新获取锁的资源，这时客户端使用事件监听，如果该临时节点被删除的话，重新进入获取锁的步骤 释放锁Zookeeper使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一起如果session会话连续关闭的话，该临时节点也会被删除，这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入到获取锁的步骤。 回顾我们的zookeeper临时节点的创建 zkClient端的事件监控通知demo 步骤方案 启动Linux系统下的zk服务器并设置好防火墙 pom 123456789101112131415&lt;dependencies&gt; &lt;!-- zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; log4j.xml 1234567891011121314log4j.appender.atguigu.File=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.atguigu.File.file=d:\\\\atguigu.loglog4j.appender.atguigu.File.DatePattern=.yyyy-MM-ddlog4j.appender.atguigu.File.layout=org.apache.log4j.PatternLayoutlog4j.appender.atguigu.File.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p (%C:%M) - %m%nlog4j.appender.atguigu.Console=org.apache.log4j.ConsoleAppender log4j.appender.atguigu.Console.layout=org.apache.log4j.PatternLayout log4j.appender.atguigu.Console.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p (%C:%M) - %m%n log4j.rootLogger=error,atguigu.Consolelog4j.logger.com.atguigu=error 模拟订单的工具类 12345678910111213package com.hhf.distributed.lock.util;/** * @author: hhf * @create: 2020-05-10 22:18 **/public class OrderNumCreateUtil &#123; private static int number = 0; public String getOrdNumber()&#123; return &quot;\\t 生产订单号:&quot;+(++number); &#125;&#125; ZK接口ZKLock 123456789101112package com.hhf.distributed.lock.zk;/** * @author: hhf * @create: 2020-05-10 22:45 **/public interface ZkLock &#123; public void zklock(); public void zkUnlock();&#125; 模版模式抽象类ZkAbstractTemplateLock 模版模式 在模板模式(Template Pattern)设计模式中，用一个抽象类公开定义了执行它的方法的方式、模板，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 意图:定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决:一些方法通用，却在每一个子类都重写了这一方法。 何时使用:有一些通用的方法 如何解决:将这些通用的算法抽象出来 关键代码:在抽象父类中实现通用的方法，其他步骤下放到子类中实现。 应用实例: 1、西游记中菩萨定好的81难就是一个顶层的逻辑骨架 2、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取session、关闭session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 优点:1、封装不变部分，扩展可变部分。2、提取公共代码，便于维护3、行为由父类控制，子类实现 缺点:每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景:1、有多个子类共用的方法，且逻辑相同2、重要的、复杂的方法，可以考虑作为模板方法。 ZkAbstractTemplateLock 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hhf.distributed.lock.zk;import org.I0Itec.zkclient.ZkClient;import java.util.concurrent.CountDownLatch;/** * @author: hhf * @create: 2020-05-10 22:50 **/public abstract class ZkAbstractTemplateLock implements ZkLock &#123; public static final String ZKSERVER = &quot;localhost:2181&quot;; public static final Integer TIME_OUT = 45 * 1000; protected String path = &quot;/zklock0510&quot;; protected CountDownLatch countDownLatch = null; ZkClient zkClient = new ZkClient(ZKSERVER,TIME_OUT); /** * 抢锁方法 */ @Override public void zklock() &#123; //先看看有没有人已经用有锁了 if (tryZkLock())&#123; //如果返回true就说明没有人拥有锁 System.out.println(Thread.currentThread().getName()+&quot;\\t占用锁成功&quot;); &#125;else &#123; //如果抢不到锁，就等待 waitZkLock(); //等待 zklock(); //递归思想，若有人释放锁了，那么重新调用这个方法，去抢锁， &#125; &#125; public abstract void waitZkLock(); public abstract boolean tryZkLock(); @Override public void zkUnlock() &#123; if (zkClient != null)&#123; zkClient.close(); &#125; System.out.println(Thread.currentThread().getName()+&quot;\\t释放锁成功&quot;); System.out.println(); System.out.println(); &#125;&#125; 实现分布式锁的类ZkDistributedLock 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.hhf.distributed.lock.zk;import org.I0Itec.zkclient.IZkDataListener;import java.util.concurrent.CountDownLatch;/** * @author: hhf * @create: 2020-05-10 23:17 **/public class ZkDistributedLock extends ZkAbstractTemplateLock &#123; @Override public void waitZkLock() &#123; IZkDataListener iZkDataListener = new IZkDataListener() &#123; /** * 监听的zk临时节点看看有没有改变 * @param dataPath * @param data * @throws Exception */ @Override public void handleDataChange(String dataPath, Object data) throws Exception &#123; &#125; /** * 看看监听的zk临时节点有没有被删除 * @param datapath * @throws Exception */ @Override public void handleDataDeleted(String datapath) throws Exception &#123; if (countDownLatch != null)&#123; countDownLatch.countDown(); &#125; &#125; &#125;; //zk的监听方法，监听zk的这个方法handleDataDeleted()有没有执行删除临时节点的方法,如果有就去抢锁 zkClient.subscribeDataChanges(path,iZkDataListener); //如果没有抢到锁，就监听这个zk的这个临时节点的路径 if (zkClient.exists(path))&#123;//如果有这个节点了，就说明这个节点已被抢了 //那么只能等待，不能往下执行，除非被占用的资源删掉了 countDownLatch = new CountDownLatch(1);//临时节点只有1个 try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; zkClient.unsubscribeDataChanges(path,iZkDataListener);//解除对zk相应临时节点的监听 &#125; &#125; @Override public boolean tryZkLock() &#123; try&#123; zkClient.createEphemeral(path); //在某个路径下面创建临时节点 return true; //创建成功返回true &#125;catch (Exception e) &#123; return false; //创建失败返回false &#125; &#125;&#125; 业务实现类OrderZkService 123456789101112131415161718192021222324252627282930313233package com.hhf.distributed.lock.common;import com.hhf.distributed.lock.util.OrderNumCreateUtil;import com.hhf.distributed.lock.zk.ZkDistributedLock;import com.hhf.distributed.lock.zk.ZkLock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author: hhf * @create: 2020-05-10 22:25 * * **/public class OrderService &#123; private OrderNumCreateUtil orderNumCreateUtil = new OrderNumCreateUtil(); private ZkLock zkLock = new ZkDistributedLock(); //手写的zk版的分布式锁 public void getOrdNumber()&#123; zkLock.zklock(); try&#123; System.out.println(&quot;获得编号:-----&gt;:&quot;+ orderNumCreateUtil.getOrdNumber()); //线程值 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; zkLock.zkUnlock(); &#125; &#125;&#125; 最终效果图 9、SpringCloud Alibaba系列1. Nacos[spring cloud alibaba]简介Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 文档https://nacos.io/zh-cn/docs/what-is-nacos.html 安装https://nacos.io/zh-cn/docs/quick-start.html 1、windows 2、linux 3、docker化 使用 1、核心概念 namespace**(命名空间)** namespace 的设计是 nacos 基于此做多环境以及多租户数据(配置和服务)隔离的 从一个租户(用户)的角度来看，如果有多套不同的环境，那么这个时候可以根据指定的环境来创建不同的 namespce，以此来实现多环境的隔离。例如，你可能有日常，预发和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。如下图所示： 从多个租户(用户)的角度来看，每个租户(用户)可能会有自己的 namespace,每个租户(用户)的配置数据以及注册的服务数据都会归属到自己的 namespace 下，以此来实现多租户间的数据隔离。例如超级管理员分配了三个租户，分别为张三、李四和王五。分配好了之后，各租户用自己的账户名和密码登录后，创建自己的命名空间。如下图所示： 注意: 该功能还在规划中。 用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。 配置在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。 配置管理系统配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动。 配置项 一个具体的可配置的参数与其值域，通常以 param-key=param-value 的形式存在。例如我们常配置系统的日志输出级别（logLevel=INFO|WARN|ERROR） 就是一个配置项。 配置集一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。 配置集 ID**(data-id)**Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。 配置分组Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。 endpoint当 nacos server 集群需要扩缩容时，客户端需要有一种能力能够及时感知到集群发生变化。及时感知到集群的变化是通过 endpoint来实现的。也即客户端会定时的向endpoint发送请求来更新客户端内存中的集群列表。 其他查看官方文档 2、nacos-discovery服务注册、发现 创建provider应用（cloud选择ribbon，一会儿要测试调用） 引入nacos-discovery 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;$&#123;nacos.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;--!注意:版本0.2xReLEASE对应的是spring boot2.x 版本，0.1.x对应的是springboot1.x--&gt; 修改application.properties 1234server.port=8070spring.application.name=service-provider #指定应用名字spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #指定nacos地址 启用服务注册发现功能 @EnableDiscoveryClient 在nacos控制台查看注册的服务 创建consumer应用（cloud选择ribbon，测试调用） 1、引入nacos-discovery依赖 2、修改application.properties指定nacos地址 3、启用服务注册发现 4、利用ribbon测试远程调用 123456789101112@LoadBalanced@Beanpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125;@RequestMapping(value = &quot;/echo/&#123;str&#125;&quot;, method = RequestMethod.GET)public String echo(@PathVariable String str) &#123; return restTemplate.getForObject(&quot;http://service-provider/echo/&quot; + str, String.class);&#125; 3、nacos-config配置管理（配置的动态变更） · 1、引入nacos-config 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;$&#123;nacos.version&#125;&lt;/version&gt;&lt;/dependency&gt; · 2、创建bootstrap.properties文件，指定nacos配置 12spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.application.name=xxxxxx · 3、我们需要了解的默认规则 之所以需要配置 spring.application.name ，是因为它是构成 Nacos 配置管理 dataId字段的一部分。 在 Nacos Spring Cloud 中，dataId 的完整格式如下： 1$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125; prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 · 1、spring.application.name很重要 ，是因为它是构成 Nacos 配置管理 dataId字段的一部分。 · 2、dataId 的完整格式 ${prefix}-${spring.profile.active}.${file-extension} · prefix · 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 · spring.profile.active · 当前环境对应的 profile。当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension} · file-exetension · 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 · 4、通过 Spring Cloud 原生注解 @RefreshScope 实现配置自动更新： 1234567891011121314@RestController@RequestMapping(&quot;/config&quot;)@RefreshScopepublic class ConfigController &#123; @Value(&quot;$&#123;useLocalCache:false&#125;&quot;) private boolean useLocalCache; @RequestMapping(&quot;/get&quot;) public boolean get() &#123; return useLocalCache; &#125;&#125; · 5、修改配置文件，查看是否实时变更 · 6、高级：nacos，指定namespace&amp;多data-id加载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859spring.application.name=gulimall-pmsspring.cloud.nacos.config.server-addr=127.0.0.1:8848#spring.application.name=multi-data-ids-example#spring.cloud.nacos.config.server-addr=127.0.0.1:8848# 0.2.1.RELEASE 以上支持多个配置，文档：https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/Nacos-config# Nacos 控制台添加配置：# Data ID：app.properties# Group：multi-data-ids# 配置内容：app.user.cache=falsespring.cloud.nacos.config.namespace=ef1c9ca2-40d7-4eb6-ad7f-c12c5751c193spring.cloud.nacos.config.ext-config[0].data-id=app.properties#spring.cloud.nacos.config.ext-config[0].group=multi-data-idsspring.cloud.nacos.config.ext-config[0].refresh=true# 1. 本地安装 MySQL# 2. Nacos 控制台添加配置：# Data ID：datasource.properties# Group：multi-data-ids# 配置内容示例：# spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false# spring.datasource.username=root# spring.datasource.password=root# spring.datasource.initial-size=10# spring.datasource.max-active=20spring.cloud.nacos.config.ext-config[1].data-id=datasource.propertiesspring.cloud.nacos.config.ext-config[1].refresh=true#spring.cloud.nacos.config.ext-config[1].group=multi-data-ids# 1. 本地安装 Redis# 2. Nacos 控制台添加配置：# Data ID：redis.properties# Group：multi-data-ids# 配置内容示例：# spring.redis.host=localhost# spring.redis.password=20190101# spring.redis.timeout=5000# spring.redis.max-idle=5# spring.redis.max-active=10# spring.redis.max-wait=3000# spring.redis.test-on-borrow=falsespring.cloud.nacos.config.ext-config[2].data-id=redis.propertiesspring.cloud.nacos.config.ext-config[2].refresh=true#spring.cloud.nacos.config.ext-config[2].group=multi-data-ids · 7、当一个配置在本地文件和nacos中都有时，优先使用nacos的，如果nacos中娶不到值，则用本地配置的 2. SpringCloud Gateway简介 Spring Cloud Gateway旨在提供一种简单而有效的方式来对API进行路由，并为他们提供切面，例如：安全性，监控/指标 和弹性等。 为什么使用API 网关？ API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题： 客户端会多次请求不同的微服务，增加了客户端的复杂性。存在跨域请求，在一定场景下处理相对复杂。认证复杂，每个服务都需要独立认证。难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。 以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性： 使用 API 网关后的优点如下： 易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。 易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。 减少了客户端与各个微服务之间的交互次数。 API 网关选型： 业界情况 gateway性能高于zuul，在高吞吐量，高并发情况下表现很好。 注意 Spring Cloud Gateway依赖Spring Boot和Spring Webflux提供的Netty runtime。它不能在传统的Servlet容器中工作或构建为WAR Webflux: https://blog.51cto.com/liukang/2090163 特性 基于Spring 5，Reactor 和 Spring Boot 2.0 能够在任何请求属性上匹配路由 断言和过滤器是特定于路由的 Hystrix断路器集成 Spring Cloud DiscoveryClient集成 易于编写断言和过滤器 请求速率限制 路径重写 文档 https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html#_cors_configuration 概念 Route 路由 gateway的基本构建模块。它由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则匹配到该路由。 Predicate 断言 这是一个Java 8 Function Predicate。输入类型是 Spring Framework ServerWebExchange。这允许开发人员可以匹配来自HTTP请求的任何内容，例如Header或参数。 Filter 过滤器 这些是使用特定工厂构建的 Spring FrameworkGatewayFilter实例。所以可以在返回请求之前或之后修改请求和响应的内容。 入门示例 1234567891011121314151617181920212223242526@SpringBootApplicationpublic class DemogatewayApplication &#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes() .route(&quot;path_route&quot;, r -&gt; r.path(&quot;/get&quot;) .uri(&quot;http://httpbin.org&quot;)) .route(&quot;host_route&quot;, r -&gt; r.host(&quot;*.myhost.org&quot;) .uri(&quot;http://httpbin.org&quot;)) .route(&quot;rewrite_route&quot;, r -&gt; r.host(&quot;*.rewrite.org&quot;) .filters(f -&gt; f.rewritePath(&quot;/foo/(?&lt;segment&gt;.*)&quot;, &quot;/$&#123;segment&#125;&quot;)) .uri(&quot;http://httpbin.org&quot;)) .route(&quot;hystrix_route&quot;, r -&gt; r.host(&quot;*.hystrix.org&quot;) .filters(f -&gt; f.hystrix(c -&gt; c.setName(&quot;slowcmd&quot;))) .uri(&quot;http://httpbin.org&quot;)) .route(&quot;hystrix_fallback_route&quot;, r -&gt; r.host(&quot;*.hystrixfallback.org&quot;) .filters(f -&gt; f.hystrix(c -&gt; c.setName(&quot;slowcmd&quot;).setFallbackUri(&quot;forward:/hystrixfallback&quot;))) .uri(&quot;http://httpbin.org&quot;)) .route(&quot;limit_route&quot;, r -&gt; r .host(&quot;*.limited.org&quot;).and().path(&quot;/anything/**&quot;) .filters(f -&gt; f.requestRateLimiter(c -&gt; c.setRateLimiter(redisRateLimiter()))) .uri(&quot;http://httpbin.org&quot;)) .build(); &#125;&#125; 核心 Predicate 断言 · RoutePredicateFactory Filter 过滤器 · GatewayFilterFactory · GlobalFilter 应用 1、网关项目的pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;gulimall-gateway&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;gulimall-gateway&lt;/name&gt; &lt;description&gt;谷粒商城网关&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;swagger.version&gt;2.9.2&lt;/swagger.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;0.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;0.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、整合各个项目的统一swagger接口（后来做） · GulimallSwaggerResourceProvider 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.atguigu.gulimall.gateway.component;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.TypeReference;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.stereotype.Component;import org.springframework.web.client.RestTemplate;import springfox.documentation.swagger.web.SwaggerResource;import springfox.documentation.swagger.web.SwaggerResourcesProvider;import java.util.*;@Componentpublic class GulimallSwaggerResourceProvider implements SwaggerResourcesProvider &#123; @Autowired private RestTemplate restTemplate; /** * swagger2默认的url后缀 */ private static final String SWAGGER2RESOURCESURL = &quot;/swagger-resources&quot;;// private static final String SWAGGER2URL = &quot;/v2/api-docs&quot;; /** * 网关路由 */ private final RouteLocator routeLocator; /** * 网关应用名称 */ @Value(&quot;$&#123;spring.application.name&#125;&quot;) private String self; @Autowired public GulimallSwaggerResourceProvider(RouteLocator routeLocator) &#123; this.routeLocator = routeLocator; &#125; @Override public List&lt;SwaggerResource&gt; get() &#123; List&lt;SwaggerResource&gt; resources = new ArrayList&lt;&gt;(); List&lt;String&gt; routeHosts = new ArrayList&lt;&gt;(); // 由于我的网关采用的是负载均衡的方式，因此我需要拿到所有应用的serviceId // 获取所有可用的host：serviceId routeLocator.getRoutes().filter(route -&gt; route.getUri().getHost() != null) .filter(route -&gt; !self.equals(route.getUri().getHost())) .subscribe(route -&gt; routeHosts.add(route.getUri().getHost())); // 记录已经添加过的server，存在同一个应用注册了多个服务在nacos上 Set&lt;String&gt; dealed = new HashSet&lt;&gt;(); routeHosts.forEach(instance -&gt; &#123; //String url = &quot;/&quot; + instance + SWAGGER2URL; String url = &quot;http://&quot;+instance+&quot;/&quot;+SWAGGER2RESOURCESURL; if (!dealed.contains(url)) &#123; dealed.add(url); String forObject = restTemplate.getForObject(url, String.class); List&lt;Map&lt;String, String&gt;&gt; list = JSON.parseObject(forObject, new TypeReference&lt;List&lt;Map&lt;String, String&gt;&gt;&gt;() &#123; &#125;); //要获取每个swagger-resource从而得出真正的v2/docs；所以加上ribbon； SwaggerResource swaggerResource = new SwaggerResource(); // 拼接url，样式为/serviceId/v2/api-info，当网关调用这个接口时，网关就需要配置路由，则会自动通过负载均衡寻找对应的主机 //有编码问题； try&#123; swaggerResource.setUrl(&quot;/&quot;+instance+list.get(0).get(&quot;url&quot;)); swaggerResource.setName(list.get(0).get(&quot;name&quot;)); swaggerResource.setSwaggerVersion(list.get(0).get(&quot;swaggerVersion&quot;)); resources.add(swaggerResource); &#125;catch (Exception e)&#123; &#125; &#125; &#125;); return resources; &#125;&#125; SwaggerResourceController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.atguigu.gulimall.gateway.component;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import springfox.documentation.swagger.web.*;import java.util.List;/** * gateway整合swagger的核心 * 1）、每一个微服务/swagger-resources;都可以获取自己微服务的swagger信息 * [ * &#123; * &quot;name&quot;: &quot;商品平台&quot;, * &quot;url&quot;: &quot;/v2/api-docs?group=商品平台&quot;,[这个很重要] * &quot;swaggerVersion&quot;: &quot;2.0&quot;, * &quot;location&quot;: &quot;/v2/api-docs?group=商品平台&quot; * &#125; * ] * 2）、我们通过网关，发现出所有上线的微服务以及他们的/swagger-resources，获取到每个微服务的swagger的url * 3）、给每一个微服务发送刚才url( /v2/api-docs?group=商品平台)就可以获取到服务的swagger接口文档信息 * 4）、GulimallSwaggerResourceProvider可以帮我们 */@RestController@RequestMapping(&quot;/swagger-resources&quot;)public class SwaggerResourceController &#123; private GulimallSwaggerResourceProvider swaggerResourceProvider; @Autowired public SwaggerResourceController(GulimallSwaggerResourceProvider swaggerResourceProvider) &#123; this.swaggerResourceProvider = swaggerResourceProvider; &#125; @RequestMapping(value = &quot;/configuration/security&quot;) public ResponseEntity&lt;SecurityConfiguration&gt; securityConfiguration() &#123; return new ResponseEntity&lt;&gt;(SecurityConfigurationBuilder.builder().build(), HttpStatus.OK); &#125; @RequestMapping(value = &quot;/configuration/ui&quot;) public ResponseEntity&lt;UiConfiguration&gt; uiConfiguration() &#123; return new ResponseEntity&lt;&gt;(UiConfigurationBuilder.builder().build(), HttpStatus.OK); &#125; @RequestMapping public ResponseEntity&lt;List&lt;SwaggerResource&gt;&gt; swaggerResources() &#123; return new ResponseEntity&lt;&gt;(swaggerResourceProvider.get(), HttpStatus.OK); &#125;&#125; 3、路由各个请求到相应的服务配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162spring: application: name: gulimall-gateway cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: routes:# =======pms==== - id: pms_route uri: lb://gulimall-pms predicates: - Path=/pms/**,/gulimall-pms/**# - Path=/gulimall-pms/** filters: - RewritePath=/gulimall-pms/(?&lt;segment&gt;.*), /$\\&#123;segment&#125;# =======oms==== - id: oms_route uri: lb://gulimall-oms predicates: - Path=/oms/**,/gulimall-oms/** filters: - RewritePath=/gulimall-oms/(?&lt;segment&gt;.*), /$\\&#123;segment&#125;# =======sms==== - id: sms_route uri: lb://gulimall-sms predicates: - Path=/sms/**,/gulimall-sms/** filters: - RewritePath=/gulimall-sms/(?&lt;segment&gt;.*), /$\\&#123;segment&#125;# =======tms==== - id: tms_route uri: lb://gulimall-tms predicates: - Path=/tms/**,/gulimall-tms/** filters: - RewritePath=/gulimall-tms/(?&lt;segment&gt;.*), /$\\&#123;segment&#125;# ======ums===== - id: ums_route uri: lb://gulimall-ums predicates: - Path=/ums/**,/gulimall-ums/** filters: - RewritePath=/gulimall-ums/(?&lt;segment&gt;.*), /$\\&#123;segment&#125;# ======wms==== - id: wms_route uri: lb://gulimall-wms predicates: - Path=/wms/**,/gulimall-wms/** filters: - RewritePath=/gulimall-wms/(?&lt;segment&gt;.*), /$\\&#123;segment&#125;server: port: 88 4、整合Hystrix进行容错 · 0、导入Hystrix依赖，并开启断路保护@EnableHystrix或者@EnableCircuitBreaker 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; · 1、Gateway配置各个微服务服务容错 1234567891011121314spring: cloud: gateway: routes: - id: hystrix_route uri: lb://backing-service:8088 predicates: - Path=/consumingserviceendpoint filters: - name: Hystrix args: name: fallbackcmd fallbackUri: forward:/incaseoffailureusethis · 2、Gateway配置全局容错 123456789spring: cloud: gateway: default-filters: - name: Hystrix args: name: fallbackcmd fallbackUri: forward:/incaseoffailureusethis 在gateway中写一个controller。来映射incaseoffailureusethis即可 面试3.你是怎么解决分布式事务？答：我是用SpringCloudAlibaba开源的Seata 4.那请你说说你对Seata的理解？答：seata它是由1+3的套件所组成，所谓的1+3的1就是全局唯一事务的id，只要在同一ID下不管几个库，都能证明是一套的全局下面的统一体，3就是3大组件，主要是指TC，TM，RM三个概念。 5.那TC，TM，RM是怎么协作的？答:请你谈谈什么是服务的降级，服务的熔断，服务的限流？ 6.SpringCloud Alibaba和Spring团队研发的SpringCloud有什么区别？答：SpringCloud原生的很多组件已经不维护了，而springcloudalibaba是借鉴了原生的springcloud技术，开发出的新产品。而且更加的方便易用，springcloudalibaba已能提供微服务治理的整套解决方案并经过了双十一的验证 7.SpringCloud和SpringBoot的区别和关系？SpringBoot专注于快速，方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。 什么是服务的熔断？熔断机制是应对雪崩效应的一种微服务链路保护机制。 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。 什么是服务的降级？整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。 服务降级处理是在客户端实现完成的，与服务端没有关系。 熔断和降级的区别： 服务熔断一般是指某个服务故障或者异常引起，类似现实世界中的”保险丝”，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时 服务降级所谓降级，一般是从整体负荷考虑，就是当某个服务熔断后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然整体服务水平下降，但是好歹可用，比直接挂掉要强。 10、本地事务&amp;&amp;分布式事务基础本地事务1.本地事务的简介 本地事务是在单个数据源上进行数据的访问和更新等操作的 2.ACID的特性 · ACID 原子性（Atomicity）,一致性(Consistency),隔离性或者独立性(Isolation)和持久性(Durabilily)。简称就是:ACID 原子性（Atomicity）：一系列的操作整体不可拆分，要么同时成功，要么同时失败。 一致性(Consistency)：数据在事务的前后，业务整体一致。 隔离性或者独立性(Isolation)：事务之间是互相隔离的。 持久性(Durabilily)：一旦事务成功，数据一定会落盘在数据库中。 3.事务的传播行为 Propagation propagation() default Propagation是事务的传播行为: 其意思就是： 当事务里面还有其他事务方法的时候，其他事务方法就有以下这么多种可能来运行。 REQUIRED【无论如何这个方法都必须在事务内运行】： 需要一个事物，如果外层已经存在了事务。就用已经存在的事务，否则就创建一个事务 REQUIRES_NEW【总是需要创建新的事务】：无论外层有没有存在事务，都自己创建一个事务，在自己的事物内进行运行。 《以上两个是最常用》 SUPPORTS【支持事务】：如果外层有事务，就在该事务内运行，否则就可以不以事务的方式运行。 MANDATORY【强制运行在已经存在的事务内】： 必须在事务内运行，如果外层已存在事务，就在这个事务内运行，如果外层没有事务，就将抛出异常。 NOT_SUPPORTED【不支持运行在事务内】： 必须以非事务的方式运行。如果外层已经有事务了，就把外层的事务暂停。 NEVER【必须以非事务方式运行】： 如果外层有事务，就会抛出异常，否则就会正常运行。 NESTED【嵌入式的事务】： 基于存档点的事物 4.事务的隔离级别 隔离级别产生的原因：是因为数据库同时存在即读又写，所以得防止在写的过程中，读这条数据是要读到，还是怎么去读，隔离级别就是为了保证同时对一个数据进行读写该要怎么处理。 读未提交【read uncommitted】（可以读到没有提交的数据） 读已提交【read committed】（只能读到提交了的数据） Oracle数据库默认的隔离级别 可重复读【Repeatable read】（同一个事务内，之前读到的数据是多少，以后还是多少，只要事物不结束的情况下） Mysql数据库默认的隔离级别 串行化【Serializable】（已经不用） 以上不同隔离级别可能会导致以下现象 · 1.脏读：若把隔离级别调为读未提交，那么读到没有生效的数据（读未提交）就会发生脏读，这是不允许发生的 · 2.幻读：同一个事物内下次读到的和上次读到的不一样（读未提交，读已提交）是允许发生的 · 3.可重复读：可重复多次读取数据，多次读取到的都一样，就不会有幻读的问题 · 4.不可重复读：不能多次重复读取数据，多次读取会读到不一样的，这会有幻读的问题。 5.事务的回滚策略 rollbackFor：指定的异常必须回滚 noRollbackFor：发生指定的异常不用回滚 异常运行时异常（不受检查异常，没有强制要求try-catch的）：都会回滚 123456ArrayOutofIndexMath...OutofMemoryNullPointException编译异常（受检查异常）【必须进行处理，要么try-catch要么throws】的：都不回滚FileNotFoundException 6.SpringBoot本地事务之大坑 SpringBoot在做事务的时候，在某些情况下有可能会不起作用，特别是使用@Transactional(propagation = Propagation.REQUIRES_NEW)的隔离级别的时候，有可能不起事务的作用。 因为 @Transactional的底层是AOP，那么事务想要生效必须是使用代理对象来调用才行： 如果你的业务代码中，有使用事务的隔离级别，尽量不要使用this来调用,防止事务的失效。 因为this并不是代理对象，就相当于代码粘到了大方法里面，this.方法（）是跟外层用的同一个事务，所以事务失效了。 解决方案：开启AOP来进行代理，导入aop-starter，暴露代理对象来解决 1231.开启自动代理:@EnableAspectJAutoProxy2.暴露代理对象：@EnableAspectJAutoProxy(exposeProxy=true)3.获取代理对象：AopContext.getCurrent() 分布式事务7.什么是分布式事务 分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。 简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。 本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 分布式系统经常出现的异常如： 机器宕机，网络异常，消息丢失，消息乱序，数据错误，不可靠的TCP，存储数据丢失等问题。 8.BASE【柔性的事务： 最终一致，基本可用，软状态】 · 分布式事务的相关解决方案 · 基于XA协议的两阶段提交 数据库支持的2PC【2 phase commit】，又叫做 XA Transactions。 MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段： 1234第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.第二阶段：事务协调器要求每个数据库提交数据。其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。可用率 a%*b% = 99%*99%=98% 总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。 · TCC编程模式 所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。 分布式事务框架； 买东西： 1234567891011121314151617181920212223242526272829303132333435wms&#123; //扣库存 koukucun()&#123; //预准备 &#125; tijiaokoukucun()&#123; //update stock set stock=stock-1; commit; &#125; cancelkoukucun()&#123; //反向扣库存。update stock set stock=stock+1; commit; //undo_log； &#125;&#125; oms&#123; //创建订单 预准备()&#123; &#125; 保存订单()&#123; &#125; 取消订单()&#123; //delete&#125;&#125; ums&#123; //扣余额 准备扣()&#123; &#125; 真正扣余额（）&#123;&#125; 取消扣余额()&#123;&#125;&#125; · 消息事务+最终一致性 基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。 虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。 9.分布式事务解决方案Seata · 1.核心概念 1234Distributed Transaction：分布式事务Global Transaction：全局事务Branch Transaction：分支事务Local Transaction：本地事务 以上四个的关系 官方文档说明：a Distributed Transaction is a Global Transaction which is made up with a batch of Branch Transaction, and normally Branch Transaction is just Local Transaction. 其意思：分布式事务是由一批分支事务组成的全局事务，通常分支事务只是本地事务。 123Transaction Coordinator(TC)：事务协调器Transaction Manager(TM)：事务管理器Resource Manager(RM): 资源管理器 · 2.示例工程的代码: https://github.com/seata/seata-samples/tree/master/springcloud-jpa-seata · 3.如何使用Seata 1.每一个微服务的数据库，都建立一个seata的undo_log日志表。来记录各个事务的记录 123456789101112131415DROP TABLE IF EXISTS `undo_log`;CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 2.下载并启动seata服务器 https://github.com/seata/seata/ 3.调整自己的微服务 4.seata其他相关文档 SpringCloud+Seata+Feign案例： https://github.com/seata/seata-samples/tree/master/springcloud-jpa-seata Seata官方文档： https://github.com/seata/seata Seata-wiki：https://github.com/seata/seata/wiki/Home_Chinese 5、整合到业务 · 1.每一个微服的数据库必须有undo_log表 1234567891011121314151617DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; · 2.导包 · seata的starter 123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-seata&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; · seata-all 1234567891011121314151617181920212223242526272829303132## transaction log storestore &#123; ## store mode: file、db mode = &quot;db&quot; ## file store file &#123; dir = &quot;sessionStore&quot; # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size , if exceeded throws exceptions max-global-session-size = 512 # file buffer size , if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size = 100 # async, sync flush-disk-mode = async &#125; ## database store db &#123; driver_class = &quot;com.mysql.jdbc.Driver&quot; url = &quot;jdbc:mysql://192.168.128.130:3306/xx&quot; user = &quot;root&quot; password = &quot;123456&quot; &#125; &#125; · 3.写配置 · 1.我们原来的DataSource要用seata的 · 2.file.conf · 定义seata客户端核心工作规则信息 123456vgroup_mapping.gulimall-pms-fescar-service-group = &quot;default&quot; vgroup_mapping.前缀.后缀(-fescar-service-group)=&quot;默认名称空间&quot;； $&#123;spring.application.name&#125;-fescar-service-group；必须和但是必须和file.conf中的配置保持一致 · 事务日志 12345678910111213141516171819202122232425262728293031## transaction log storestore &#123; ## store mode: file、db mode = &quot;db&quot; ## file store file &#123; dir = &quot;sessionStore&quot; # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size , if exceeded throws exceptions max-global-session-size = 512 # file buffer size , if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size = 100 # async, sync flush-disk-mode = async &#125; ## database store db &#123; driver_class = &quot;com.mysql.jdbc.Driver&quot; url = &quot;jdbc:mysql://192.168.128.130:3306/xx&quot; user = &quot;root&quot; password = &quot;123456&quot; &#125; &#125; · 当前微服务在seata服务器中注册的信息配置 123456789101112service &#123; #vgroup-&gt;rgroup vgroup_mapping.-xxx-fescar-service-group = &quot;default&quot; ##当前应用名 #only support single node default.grouplist = &quot;127.0.0.1:8091&quot; # seata服务器地址 #degrade current not support enableDegrade = false #disable disable = false&#125; · 客户端相关工作的机制 12345678client &#123; async.commit.buffer.limit = 10000 lock &#123; retry.internal = 10 retry.times = 30 &#125;&#125; · 3.registry.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253registry &#123; # file 、nacos 、eureka、redis、zk type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;public&quot; cluster = &quot;default&quot; &#125; eureka &#123; serviceUrl = &quot;http://localhost:1001/eureka&quot; application = &quot;default&quot; weight = &quot;1&quot; &#125; redis &#123; serverAddr = &quot;localhost:6381&quot; db = &quot;0&quot; &#125; zk &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; config &#123; # file、nacos 、apollo、zk type = &quot;file&quot; nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;public&quot; cluster = &quot;default&quot; &#125; apollo &#123; app.id = &quot;fescar-server&quot; apollo.meta = &quot;http://192.168.1.204:8801&quot; &#125; zk &#123; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; · 定义让seata知道微服务在其他注册中心的一些配置。 · 1、指定注册中心信息 123456789101112131415161718192021222324252627282930registry &#123; # file 、nacos 、eureka、redis、zk type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;public&quot; cluster = &quot;default&quot; &#125; eureka &#123; serviceUrl = &quot;http://localhost:1001/eureka&quot; application = &quot;default&quot; weight = &quot;1&quot; &#125; redis &#123; serverAddr = &quot;localhost:6381&quot; db = &quot;0&quot; &#125; zk &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; · 2、seata客户端的配置【这些也是可以放在配置中心中】 1234567891011121314151617181920212223config &#123; # file、nacos 、apollo、zk type = &quot;file&quot; #我们使用的是配置文件。 nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;public&quot; cluster = &quot;default&quot; &#125; apollo &#123; app.id = &quot;fescar-server&quot; apollo.meta = &quot;http://192.168.1.204:8801&quot; &#125; zk &#123; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; · 4.每一个微服务原来自己的数据源都必须使用DataSourceProxy来进行代理 1234567891011121314151617181920212223242526@Configurationpublic class MyBatisConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); return paginationInterceptor; &#125; //@ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource originDataSource(@Value(&quot;$&#123;spring.datasource.jdbcUrl&#125;&quot;) String url, @Value(&quot;$&#123;spring.datasource.username&#125;&quot;)String Username ,@Value(&quot;$&#123;spring.datasource.password&#125;&quot;)String Password,@Value(&quot;$&#123;spring.datasource.driverClassName&#125;&quot;) String DriverClass)&#123; HikariDataSource hikariDataSource = new HikariDataSource(); hikariDataSource.setJdbcUrl(url); hikariDataSource.setUsername(Username); hikariDataSource.setPassword(Password); hikariDataSource.setDriverClassName(DriverClass); return hikariDataSource; &#125; @Bean @Primary public DataSource dataSource(DataSource dataSource)&#123; return new DataSourceProxy(dataSource); &#125; · 5.若我们使用注册中心，进行服务的发现，seata服务器也得配置放在注册中心，去seata服务器配置registry.conf 11、Spring等高级框架复习SpringMVC1、SpringMVC的图解原理分析 完整的原理图： 2、简单先分析一下上图的流程是怎么样的 首先发了一个请求过来 那么就要看这个请求能不能发给在web.xml配置的SpringDispatcherServlet，若能够发过来到SpringDispatcherServlet，那么此时这个请求就跟SpringDispatcherServlet的url-pattern相对应。 然后再看SpringMVC里面有没有对应的映射？也即有没有使用@RequestMapping注解映射过，如果要是没有映射过的话，那么就还要来看有没有配置&lt;mvc:default-servlet-handler/&gt; 如果也没有配置&lt;mvc:default-servlet-handler/&gt;的话，控制台就会有一个报错，报错将提示没有对应的映射，同时将会给一个404页面。 如果有配置&lt;mvc:default-servlet-handler/&gt;的话，就会去找目标资源，若目标资源没有的话可能也会给一个404页面，而控制台不会显示：没有对应的映射这样的报错信息。 如果此时要是有对应的@RequestMapping注解映射过，那么这个时候会由HandlerMapping获取一个HandlerExecutionChain对象。 然后再获取一个HandlerAdapter对象。 再调拦截器的PreHandle方法 再调用目标Handler的目标方法得到ModelAndView对象，再调用拦截器的PostHandle方法。 这个时候查看在调用目标方法的过程中是否存在异常，要是有异常的话，将使用异常解析器(HandlerExceptionResolver)去解析这个异常，得到一个新的ModelAndView对象。 然后再由ViewResolver组件根据ModelAndView对象得到实际的View对象 然后去渲染视图。 渲染视图后响应就会得到，然后再调用拦截器的afterCompletion方法。 以上就是整个SpringMVC的运行流程。 SpringBoot1.SpringBoot自动配置原理:1、当SpringBoot应用启动的时候，就从主方法里面进行启动的。 12345678@SpringBootApplicationpublic class SpringBoot02ConfigAutoconfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02ConfigAutoconfigApplication.class, args); &#125;&#125; 它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。 2、@EnableAutoConfiguration作用： 它主要利用了一个EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。 123@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration 3、那导入了什么组件呢？ 来看EnableAutoConfigurationImportSelector这个类的父类selectImports。 123456@Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; 父类里面规定了一个方法叫selectImports这个方法，查看了selectImports这个方法里面的代码内容就能知道导入了哪些组件了。 在selectImports这个方法里面主要有个configurations，并且这个configurations最终会被返回。 123456789101112131415161718192021@Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; try &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); configurations = sort(configurations, autoConfigurationMetadata); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return configurations.toArray(new String[configurations.size()]); &#125; 这个configurations它是获取候选的配置。 1List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,attributes); 这个configurations方法的作用就是利用SpringFactoriesLoader.loadFactoryNames从类路径下得到一个资源。 123456public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); 4、那得到了哪些资源呢？ 它是扫描javajar包类路径下的“META-INF/spring.factories”这个文件。 123456/** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 那么扫描到的这些文件作用：是把这个文件的urls拿到之后并把这些urls每一个遍历，最终把这些文件整成一个properties对象。 1234567891011121314public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result; 然后它从properties对象里边获取一些值，把这些获取到的值来加载我们最终要返回的这个结果，这个结果就是我们要交给Spring容器中的所有组件，这相当于这factoryClassName就是我们传过来的Class的这个类名。 而传过来的Class是调用这个getSpringFactoriesLoaderFactoryClass()这个方法得到从properties中获取到EnableAutoConfiguration.class类名对应的值。 1234protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class; &#125; 然后把它们添加在容器中 5、按照它的这个意思，来到第二个Springjar包的META-INF下的spring.factories这个文件找到配置所有EnableAutoConfiguration的值加入到Spring容器中 所以说我们容器中最终会添加很多的类 比如： 1234567# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\。。。。。。 每一个xxxAutoConfiguration类都是容器中的一个组件，并都加入到容器中。 加入到容器中之后的作用就是用它们来做自动配置 这就是Springboot自动配置之源，也就是自动配置的开始 只有这些自动配置类进入到容器中以后，接下来这个自动配置类才开始进行启动 6、每一个自动配置类进行自动配置功能 以一个自动配置类HttpEncodingAutoConfiguration（HTTP的编码自动配置）为例子来解释SpringBoot的自动配置之原理： 这个HttpEncodingAutoConfiguration类上面标注了一大堆的注解： 123456789@Configuration //表示这是一个配置类，类似于以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启用ConfigurationProperties功能：//这个ConfigurationProperties里面引入了一个类，这个类就是启用指定类的ConfigurationProperties功能//有了这个@EnableConfigurationPropertie注解以后相当于把配置文件中对应值就和这个HttpEncodingProperties.class类绑定起来了。@ConditionalOnWebApplication //这个注解的意思就是判断当前是不是web应用，@Conditional是spring底层，意思就是根据不同的条件，来进行自己不同的条件判断，如果满足指定的条件，那么整个配置类里边的配置才会生效。@ConditionalOnClass(CharacterEncodingFilter.class)//看这个类里边有没有这个过滤器，就是判断当前项目里边有没有CharacterEncodingFilter这个类，这个CharacterEncodingFilter类是Springmvc中乱码解决的过滤器。@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)//@ConditionalOnProperty注解是来判断配置文件中是否存在某个配置，就是是否存在spring.http.encoding.enabled这个配置，matchIfMissing的意思就是如果不存在也认为这个判断是正确的//即使配置文件中不配置spring.http.encoding.enabled=true这个属性，也是默认生效的public class HttpEncodingAutoConfiguration &#123; 点进去HttpEncodingProperties这个类，发现这个HttpEncodingProperties类上面标注了@ConfigurationProperties注解。 123@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;) //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123;public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); 所以说配置文件中该配置什么，我们就按照它的这个旨意，它要配spring.http.encoding这个属性，这个属性里边能配置什么值，就对应HttpEncodingProperties这个类来配置，所有的配置文件中能配置的属性都是在xxx.Properties类中封装着。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); /** * Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not * set explicitly. */ private Charset charset = DEFAULT_CHARSET; /** * Force the encoding to the configured charset on HTTP requests and responses. */ private Boolean force; /** * Force the encoding to the configured charset on HTTP requests. Defaults to true * when &quot;force&quot; has not been specified. */ private Boolean forceRequest; /** * Force the encoding to the configured charset on HTTP responses. */ private Boolean forceResponse; /** * Locale to Encoding mapping. */ private Map&lt;Locale, Charset&gt; mapping; public Charset getCharset() &#123; return this.charset; &#125; public void setCharset(Charset charset) &#123; this.charset = charset; &#125; public boolean isForce() &#123; return Boolean.TRUE.equals(this.force); &#125; public void setForce(boolean force) &#123; this.force = force; &#125; public boolean isForceRequest() &#123; return Boolean.TRUE.equals(this.forceRequest); &#125; public void setForceRequest(boolean forceRequest) &#123; this.forceRequest = forceRequest; &#125; public boolean isForceResponse() &#123; return Boolean.TRUE.equals(this.forceResponse); &#125; public void setForceResponse(boolean forceResponse) &#123; this.forceResponse = forceResponse; &#125; public Map&lt;Locale, Charset&gt; getMapping() &#123; return this.mapping; &#125; public void setMapping(Map&lt;Locale, Charset&gt; mapping) &#123; this.mapping = mapping; &#125; 所以说配置文件能配置什么就可以参照某一个功能对应的这个属性类 7、这个HttpEncodingProperties类就是根据当前不同的条件判断，决定这个配置类是否生效。 如果一旦生效了，所有的配置类都成功了，就给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，而这properties类里边的每一个属性又是和配置文件绑定的。 12@Bean //给容器中添加一个组件。@ConditionalOnMissingBean(CharacterEncodingFilter.class) //添加一个我们自己来new这个 CharacterEncodingFilter，把这个filter添加过去，但是注意这个filter里边要获取字符集的名字（filter.setEncoding(this.properties.getCharset().name());)，你是UTF8编码还是什么编码，它要从properties中进行获取，意思就是这个组件的某些值需要从properties中获取 12345678public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 我们再深入的看一下properties。 1private final HttpEncodingProperties properties; //它已经和SpringBoot配置文件进行映射了。 我们看到properties是HttpEncodingProperties，也就是说HttpEncodingProperties这个对象的值它是获取配置文件的值的，所以我们在配置这个filter到底要用什么编码的时候是从properties获取的。 而且值得注意的是： 12345678910111213@Configuration@EnableConfigurationProperties(HttpEncodingProperties.class)@ConditionalOnWebApplication@ConditionalOnClass(CharacterEncodingFilter.class)@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; private final HttpEncodingProperties properties; //只有一个有参构造器 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; 这个HttpEncodingAutoConfiguration只有一个有参构造器，在只有一个有参构造器的情况下，参数的值就会从容器中拿 8、而容器中它怎么去拿到呢？ 相当于是前面的这个@EnableConfigurationProperties(HttpEncodingProperties.class) 注解，这个@EnableConfigurationProperties注解的作用就是把HttpEncodingProperties.class和配置文件进行绑定起来并把HttpEncodingProperties加入到容器中。 接下来这个自动配置类，通过一个有参构造器把这个属性拿到，而这个属性已经和SpringBoot映射了，接下来要用什么编码，就是拿到HttpEncodingProperties这个类里边的属性。 所以SpringBoot能配置什么，它要设置编码，它是获取properties里边getCharset里边的name值。 1filter.setEncoding(this.properties.getCharset().name()); 所以就以此类推，配置一个Spring配置，就可以照着HttpEncodingProperties这里边的来配置。 比如在application.properties配置文件下配置一个http.encoding.enabled属性： 1spring.http.encoding.enabled=true //能配置这个就相当于是我们之前的判断属性 还能配置其他的一些属性。比如： 1spring.http.encoding.charset=UTF-8 所以我们能够配置哪些属性，都是来源于这个功能的properties类 有了这个自动配置类，自动配置类就给容器中添加这个filter，然后这个filter就会起作用了。 用好SpringBoot只要把握这几点： 12341）.SpringBoot启动会加载大量的自动配置类2）.所要做的就是我们需要的功能SpringBoot有没有帮我们写好的自动配置类：3）.如果有就再来看这个自动配置类中到底配置了哪些组件，Springboot自动配置类里边只要我们要用的组件有，我们就不需要再来配置了，但是如果说没有我们所需要的组件，那么我们就需要自己来写一个配置类来把我们相应的组件配置起来。4）.给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，而这些属性我们就可以在配置文件指定这些属性的值 以上内容就是SpringBoot自动配置原理的整个精髓，只要掌握了SpringBoot的原理，我们才能随心所欲的运用。 2.SpringBoot创建及运行原理:12、2020谷粒商城项目复习基础分布式Session不共享不同步的问题1、你是如何在这个电商系统当中解决Session不共享不同步的问题的？ · 1、如何解决多台同个服务在不同机器上运行的session不同步之问题 第一种解决方案：可以使用session复制来解决Session不同步的问题 123其优点是：Tomcat原生是支持的，只需要修改一下配置文件即可其缺点是：session复制需要数据的传输，可能会有延迟问题，也会占用大量的网络带宽，降级了服务器群的业务处理的能力。在比较大型的分布式集群下，每一个tomcat可能都会全量保存相应的session数据，所以此方案是不可取的。 第二种解决方案：可以让客户端进行存储session 123优点：服务器不需存储session，浏览器自己保存session信息到cookie当中，这样能够节省服务器端的资源缺点：每次的HTTP请求，携带用户在cookie中的完整信息，会浪费网络的带宽。而且全部session数据都放在cookie当中，cookie只能限制保存4K，不能保存大量的信息，并且session放在cookie当中也会有不安全的隐患。所以这个方案也不可用 第三种解决方案：可以使用ip的hash一致性，主要是来源于同一个IP访问的，那么就给他永远访问一台服务器就行了 123优点：只需要改nginx的相应配置，不需要去修改应用的代码，也可以支持web-server的水平扩展，但session同步就不行了，因为受内存的限制缺点：session其实还是存在了web-server中，如果web-server重启，也就会导致大量的session丢失。如果web-server进行水平的扩展，hash后session重新分布，也会导致一部分用户路由不到正确的session。 不过以上缺点问题都不是很大，因为session本来都是有效期的 第四种解决方案：统一存储session 1234567全部session都存到数据库或者是缓存当中优点：没有安全的隐患，还可以水平扩展，web-server重启也都不会丢失数据缺点：又增加了一次网络的调用，并且可能还需要修改后端的代码不过以上统一存储session的缺点，都可以使用SpringSession进行解决 2、如何不同域名的情况下，session不共享的问题 解决方案 1放大session的作用域，不能只是属于某个服务的，将其放大，使其能够在不同子域都能获得这个session 3、使用SpringSession和redis来解决Session的共享问题 4、SpringSession的官网：https://docs.spring.io/spring-session/docs/2.2.1.RELEASE/reference/html5/#httpsession-redis-jc 电商登录后session共享的整个过程1、所有登录后的状态信息是存到session里面的，而任何一个服务都整合了Spring Session，并且将Session统一存储到redis里面 2、让session第一次存储数据的时候，会给浏览器进行发卡，这个卡就标识了session的id是什么，而发的这个卡也放大了整个作用域，让某一个服务发的卡，这个卡可以让全系统服务通用，也即夸整个父子域，不论是父域系统旗下的所有域名，都可以全使用这个session的id，这就是整合Spring Session达到的效果 3、但是在更大的系统里面也会出现一些问题 · 1、一家公司旗下的多个不同网站系统的session共享同步问题，该如何解决？也即在多个系统里面，一旦一个用户已经登录一个网站，那么其他不同系统的网站是否还需要重新登录或者注册？ · 2、在多系统里面，能够希望达到一个效果，只要是一家公司旗下的不同网站系统，在某个网站系统注册和登录过了，就其他网站系统直接能全部自动登录并显示该用户的登录信息，而无需到了其他网站系统还需要重新登录注册。 · 3、解决这问题：可以抽取一个登录注册的认证中心，专门处理不同系统的登录以及注册请求的。一旦用户想要在某个网站系统登录成功了，那么任何其他的网站系统都能使用。但是SpringSession是实现不了这个功能的 · 4、举个例子，在某个电商系统里面登录，如果都用session，那么在发卡的时候，放大了该卡的作用域，也最多放大到该卡的一级域名。但不能放大到更大的域名，比如.com，所以只能放大到一个系统里面服务的域名，那么相当于如果浏览器要访问其他网站，就带不上在电商系统里面发的卡，所以就不能通过简单的SpringSession来解决多系统的单点登录问题 单点登录。怎么实现在不同域名当中其一次登录，处处可用？有一个核心服务器1.中央认证服务器 所有的登录请求都应该发给中央认证服务器 其他客户端 2.想要登录，都会先去中央认证服务器进行登录，而且登录成功以后跳转回来客户端系统 3.客户端系统只要有一个登录了，那么其他的都不用登录，会自动登录成功 4.在全局任何系统，都统一了一个cookie的唯一标识，这样才能标识哪个用户登录成功的了，这样的话无论是其他系统还是中央认证服务器都不是相同域名旗下的，所以所有系统域名都不相同 怎么解决所有系统域名都不相同，还能达到一处登录，处处自动登录呢？单点登录流程 1、浏览器第一次访问到客户端中受保护的请求资源以后 2、客户端就来判断浏览器是否已经登录过 12345678910111、按照以往常规的流程也即判断session里面有没有这个用户的会话信息，如果有就说明登录了，没有就说明没有登录，没有登录就去登录中心认证服务器登录2、如果客户端去中心认证服务器登录成功了就要跳转回来，也即从哪跳过来的就从哪跳回去3、如果当前系统没有保存当前登录的用户，也即客户端没有人登录，如果没有登录就要去访问登陆服务器进行登录4、由于没登录就给浏览器重定向到登录服务器的登录页面进行登录5、如果在登录的认证服务器中登录页面登录成功了，就得跳回去6、那么一旦登录成功以后，怎么跳回去？ 1、可以跳到登录页的时候，在页面路径后面加一个原来的地址 这样相当于重定向到登录页的时候，也告诉登录服务器之前原来的地址是哪个地址，这样的话登录服务器，登录成功也就知道跳回哪了 2、所以为了能登录成功后，能跳回原来的页面，可以在客户端的跳转登录页的控制器请求那加一个重定向原来的地址 3、这样登录服务器登录成功以后。想要重新跳回客户端以前的页面，就把请求地址那后面的参数地址拿过来就行了，也即客户端得告诉登录服务器，我登录以后想要跳转到哪里 4、此时登录服务器就能感知到客户端发过来的重定向地址 3、登录认证服务器开始处理登录功能 12345671、首先登录服务器展示它的登录页面，而且输入相应的帐号密码登录成功以后还要跳回去2、为了能跳回去，在方面登录页的时候，登录页是能取到客户端给的登录成功后的URL地址3、但是我们再来登录，那么上一步的地址就会丢失，所以为了防止这个客户端给的跳转地址丢失，在登录的控制器中将URL地址放到请求域中，可以在登录页面里面可以添加一个隐藏的input输入框，让它自己取出请求域的地址就行了4、用户在浏览器的登录页面中输入帐号密码进行登录，并且这个登录页也有重定向的地址，也即登录成功以后跳转到客户端给的地址，当登录以后，就会提交登录请求（含用户名，密码，客户端给的登录成功后要重定向跳转的url地址）给登录认证服务器5、登录认证服务器，就开始处理登录请求6、登录成功后，就会跳转到客户端在登录请求发来的URL地址7、登录成功后，无法跳转到客户端指定的URL地址 ```1、访问客户端指定的URL地址，又要遵循上面的逻辑，也即访问这个客户端的时候，又要看有没有登录，因为客户端总是显示没登录，所以这块就算登录成功后也无法跳转到指定的页面，这就导致了死循环2、如何解决上面这个问题：在认证服务器登录成功以后，重定向跳转回去以后的时候客户端指定地址的时候，客户端要能感知到是已经登录成功以后跳转回来的，而不是直接访问的3、那么能让客户端感知已经登录的业务代码怎么写？1234567891011121314151617* ``` 1、用redis或者session来存储已经登录的用户信息，在本系统当中我们就用了redis来存储的登录成功的用户信息 2、那么如果是用session来存储已经登录的用户信息，那么就要发一个卡，类似于银行卡的卡号。 3、若是在redis存的话key，因为redis会存好多登录的用户，所以要为每一个用户生成一个唯一的key来进行存储，比如可以用UUID来存储key，值就存用户信息 4、把登录成功后的用户信息存到redis，但是得让其他客户端知道这个用户已经登录过的了 5、在登录页，登录成功后返回客户端给的重定向URL地址后面再加上一个用户的URL参数（类似于token令牌，token令牌就是UUID）使其能够告诉客户端这个用户已经登录过的了，然后跳转到客户端指定的URL地址 6、只要登录成功后，带了token令牌，就认为它是已经登录了的。 7、那么在客户端，只要你登录成功了，返回了客户端指定的URL地址，这URL地址当中还带了token令牌，那么就给你跳转回客户端指定的页面地址 8、但是token是不一定带的，因为第一次进来访问，就是没有带token的，只有去登录服务器登录回来以后才会有token 9、登录成功不成功，有两个判断，第一个是先看看session里面有没有用户信息如果有就说明已经登录成功，第二个只要是登录成功后跳回来客户端指定的页面的还带了token的，就说明也是登录成功 10、有了token，那么登录成功的用户再放到session里面，session的值放的是认证服务器登录后的用户信息，也即在客户端获取认证服务器当前token真正对应的用户信息，拿到了用户信息了，才能说明是成功的。 11、就成功跳转到客户端指定的URL页面地址 12、那么在下一次再访问客户端指定的URL页面地址就不用再跳转到认证服务器进行登录了，也是直接能访问到想要访问的资源了 13、不用登录的原因就是由于在认证服务器登录成功以后跳回去，带了这个token，有了这个token以后，客户端就会去拿到这个token，来证明是登录过的用户 14、最大的一个问题就是，如果访问其他的客户端域名，会有域名不同的情况，就说明一个客户端登录了，不代表另外一个客户端域名就直接不用登录了 15、就应该一个客户端登录了，其他客户端就不用再登录了。 18、一个客户端已经成功登录了，但是怎么能让其他客户端就不用再登录，而直接去访问想要访问的受保护资源？ ```1、由于某一个客户端已经在认证服务器登录过了，那么其他的客户端是互相授信的系统，彼此是信任的，那么就希望第二个客户端系统不用去登录就直接能够访问想要访问的受保护的资源2、访问第二个客户端，默认访问第二个客户端是需要重新登录的，但是第一个客户端已经登录了，就想希望第二个客户端能通过第一个客户端已经登录完成的状态进行免登录3、第二个客户端需要重新登录的原因就是在认证服务器这一块，认证服务器它并没有记住哪些用户已经登录了。4、认证服务器需要保存哪些用户已经登录了的 1234* ``` 1、只要登录成功以后，就会去客户端提供的页面地址重定向过去，还会把当前用户保存过来，也就是重定向的时候带上这个令牌信息 2、为了下一次别的客户端系统想要登录，得知道上一个客户端系统已经登录过了，就只有一种做法 ```1、客户端访问认证服务器会带上认证服务器的所有的cookie2、假设只要有了登录了，就搞一个cookie，来保存上一个用户登录的用户令牌信息3、所以无论是第一个客户端还是其他多个客户端没有登录，只要能跳到认证服务器的登录页面，浏览器就会带上这个认证服务器下的所有cookie。4、也就是说为了能记住登录的状态信息，即使是上一个人登录，就应该给我们登录服务器留一个痕迹，这个痕迹就是留给客户端浏览器的，告诉客户端浏览器之前这个在认证服务器已经登录过了，痕迹就是cookie5、所以唯一要做的一件事就是处理登录请求和用户状态信息的token返回出去外，还要给当前系统留一个记号，这个记号可以是一个cookie来表示曾经登录过 123* ``` 3、单点登录的整个令牌是在登录认证服务器保存的 ```1、登录服务器只要有任何的客户端浏览器登录成功了，那么就给这个客户端浏览器留一个令牌2、登录后的用户信息是在redis当中存起来的，但是为了有标识，认证服务器就命令客户端浏览器保存一个cookie，这个cookie的键是自己定义，值是用户信息的唯一id。3、此时客户端浏览器就应该将认证服务器发过来的cookie保存在认证服务器当中4、只要访问认证服务器，那么认证服务器就会有相应的cookie5、也即某个客户端浏览器没有登录，就会跳转到登录认证服务器进行登录，只要在登录服务器做了登录请求，那么登录服务器关键的一步就是 1234* ``` 1、只要进行登录的请求，它会做两件事，把用户信息存到redis里面，并且给当前服务器留一个cookie标识 2、登录成功就会做两件事 ```1、不止要执行浏览器指定的重定向到地址，并且重定向的时候，还带了token2、登录成功以后，还给当前认证服务器保存了一个用户信息的cookie3、此时又重定向到受保护的资源页面 1234* ``` 6、客户端浏览器去认证服务器登录，登录后不仅重定向到浏览器指定的页面，但在重定向之前，客户端浏览器要给认证服务器的域名下保存一个cookie。因为这个登录请求是发给认证服务器的 7、客户端浏览器在认证服务器登录后，还留了一个cookie的在认证服务器，这个cookie的作用？ ```1、保存cookie的作用就是，客户端浏览器只要以后访问认证服务器的域名，都会带上这个域名下的所有cookie。 1234* ``` 8、目前看到的效果就是：不仅登录成功，跳回客户端浏览器指定的页面地址，还在请求路径上带了一个token，并在域名下面留了一个cookie，cookie和token的值都是一样的 9、接下来第二个客户端浏览器去访问，显示没有登录，就会重定向跳转到了认证服务器的登录页进行登录 ```1、但是已经有一个客户端浏览器登录过了，登录了以后还给认证服务器留了一个用户的cookie信息2、所以其他客户端浏览器下一次再来访问登录页的时候，就显示没有登录，浏览器就命令去访问登录页。3、但是在访问登录页的时候，这个请求还带上了之前保存的Cookie，这个Cookie就是上一个客户端浏览器登录成功后在认证服务器留下的cookie，所以其他客户端浏览器请求的时候都会带上这个cookie4、登录页的重新处理应该就是：如果客户端浏览器带了这个Cookie，就说明是上一个客户端浏览器留下来的痕迹，那么就可以说明新来的客户端浏览器可以不用登录了5、也即在后台代码的登录页的控制器当中拿到这个Cookie的值6、核心就是：在展示登录页面的时候判断这个客户端浏览器是否已经登录过，判断是否有关键的cookie，如果没有这个cookie，那就展示登录页，如果有就直接免登录，跳回受保护的资源页面 123* ``` 10、为了让客户端浏览器知道，访问认证服务器登录成功以后，那么重定向跳回来的时候就会加一个token，如果有token就认为是登录回来的，就把登录后的信息放到session里面，否则就是直接访问的，那么就要拒绝，并要求它跳回到认证服务器的登录页进行登录 ```5、此时已经达到了一个客户端浏览器去认证服务器登录后，其他客户端浏览器就已经不用再登录了，直接免登录跳回指定的页面资源地址 1234567* ``` 1、其他客户端访问资源地址，先判断是否已经登录过，此时客户端浏览器会重定向到认证服务器的登录页面去登录，当然还带着一个cookie。 2、客户端浏览器就去访问认证服务器的登录页面 3、其他客户端浏览器访问登录页面的时候，结果登录页面，其他客户端浏览器只要带了这个cookie，因为可能上一次有其他客户端浏览器登录过，那么其他客户端浏览器访问认证服务器就会带上以前浏览器留下的cookie。 4、如果客户端浏览器带了这个cookie就拿着，直接可以跳回客户端浏览器指定的页面。 5、那么一旦跳回到客户端浏览器指定的页面 4、整个单点登录流程图 购物车1、购物车数据存储在redis中 2、购物车数据存在redis的好处是什么？ · 1、购物车是一个读写都是高并发的操作，那么如果使用Mysql数据库，那么读写都高并发的情况下，就会让mysql数据库都承担非常大的压力 · 2、所以可以选择一些nosql来存储购物车的数据，比如可以使用mongodb，但是使用mongodb的话，它的性能也并不能带来很大的提升 · 3、所以选择了Nosql的redis来存储购物车的数据 · 4、放在redis的好处就是 121、数据结构好组织2、redis拥有极高的读写并发性能 · 5、不过存在redis里面也会出现一个问题 12341、也就是登录以后的购物车是需要持久化保存的2、但是redis默认是内存数据库，所有数据是存在内存的，一旦redis宕机了，那么所有的数据就丢失了3、但是mysql就不一样了，只要保存了，即使宕机了也还在4、不过这种问题也可以得到解决 12345671、在安装redis的时候，可以指定好redis的持久化策略2、那么在redis的每一条数据，都能持久化到磁盘里面，即使redis宕机，下次重新启动，数据还会在。3、这样虽然能损失一定的性能，就相当于没有那么高的吞吐量了，但是即使redis的数据存在磁盘里面，也会比mysql快很多。4、所以用户登录以后，那么在购物车当中的数据存在redis里面5、如果用户没登录，没有登录的购物车，最大的特点就是一个临时的购物车，其关闭了浏览器，下次打开浏览器还是会有以前保存的临时购物车的数据6、那么临时购物车，也用redis来存储7、当然临时购物车也可以存到很多的地方。比如放到cookie当中 11、但是如果放在cookie当中，那么也就是浏览器存储，后台不存，那么这样的话。在大数据的时代下，想统计一些用户购买了哪些商品，甚至是做一些用户购买的热度高的商品推荐，都是没有办法做到的 18、最终无论用户登录了的购物车还是没有登录的购物车，都统一存在redis当中 · 6、购物车存在redis的数据应该以什么数据类型来进行存储 1234561、一个用户等于两个购物车，一个登录后的购物车，一个是没登录的临时购物车2、但是不管是哪个购物车，购物车里面数据应该都是有非常多的购物项，也就是添加的那些商品3、每一个购物项都应该有当期商品的id,因为添加商品都是按照sku销售属性来进行添加的4、包括每一个购物项是被选中还是没有选中，这个状态也要进行存储5、保存商品的标题信息和商品的默认图片等信息也要进行存储6、购物车有很多的购物项，那么使用redis的五种数据类型的哪一种进行一个购物车的存储呢？ 1231、一个购物车里面就应该是一个数组，数组里面都是一个个的购物项，也就是一个个的对象2、但是redis里面保存的数据都是以键值对的结构进行存储3、那么假设用redis的list类型来存储的话，key应该是存用户的标识，代表哪个用户的购物车 1231、这个用户的购物车应该是一个数组类型，数组里面放一个个的购物项2、也即value值存购物车里面的购物项，就是存具体的商品信息3、如果按照list的数据类型来存储购物车的信息，会有缺点 123451、如果来修改某个购物车里面的购物项2、那么就相当于redis里面存储的购物项也得修改3、那么就得去redis里面在list数据类型下找这个页面被修改的购物项数据4、因为是用list来存储购物项，那么问题可能会添加了很多的购物项，在某个购物项修改了相关的信息，那么怎么知道要改购物车里面的哪个商品？5、可能会有两种办法： 12341、得先知道选的是第几个购物项修改的商品信息，在list中来找相应被修改的元素，前提是页面跟后台redis存储的数据顺序是一模一样的，那么就比较容易找到2、但是会非常的麻烦。所以为了后来的方便快速找购物项的数据并且进行修改3、可以把购物车里面的list类型存储的购物项改为hash进行存储4、使用redis的hash进行存储购物车当中的购物项 121、key还是代表某个用户的购物车，这样方便定位到具体的用户的购物车2、那么hash的value值是有两个值 1231、第一个值存储商品的id2、第二个值存储商品的具体信息3、那么hash结构的数据类型最终的存储结构应该是这样 11号用户的购物车里面，存了每一个购物项，数据值是某个商品的id，它的信息是具体的商品信息 12344、那么在修改购物项就直接去redis里面找到相应用户的购物车，也不用挨个去遍历来去修改，也可以不用按照其索引来找，因为这样很麻烦，只需要类似于map的方式，按照某个商品的id来修改具体的商品信息。5、所以在redis里面存购物车的商品不能直接用list方式来存储，因为list来找商品得遍历循环，看是哪个商品6、但是用于redis的hash结构来存储购物车的商品，也就是map的方式，那么找商品，直接拿key商品的id就能找到7、最终就应该是以类似于Map 这样的方式来进行存储购物车里面的数据 数据格式：Map&lt;String,Map&lt;String,CartItem&gt;&gt; 有两个key，这个最前面的key是String类型，是存储每一个用户的购物车标识，而Map就是存储整个购物车，这个购物车里面存储每一个的购物项，为了方便找购物项，这个Map的key也是String类型,这个String类型用来存储购物项的商品id，而Map的CartItem对象类型就是存储购物车的详情信息 所以真正的购物车信息应该是以Map&lt;String,Map&lt;String,CartItem&gt;&gt;这样的Hash方式进行存储的 3、离线购物车4、在线购物车目前整个2020谷粒商城我已经学习和开发完毕，但是我只分享以上三个技术点的笔记，剩下的暂不分享，谢谢理解","categories":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://stary2020.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":null},{"title":"SpringCloud 尚硅谷版","slug":"java-2021-07-31-SpringCloud","date":"2021-07-31T10:59:30.000Z","updated":"2021-08-27T10:28:24.912Z","comments":true,"path":"2021/07/31/java-2021-07-31-SpringCloud/","link":"","permalink":"http://stary2020.gitee.io/2021/07/31/java-2021-07-31-SpringCloud/","excerpt":"","text":"一、 概述1.微服务架构零基础理论入门（小白必看） 零基础小白，2020.1春节期间预习过第一季的，理解微服务概念的可以不看 2.理论介绍见&lt;&lt;微服务架构2020.pptx&gt;&gt; 3.回顾2018年第一季SpringCloud版本 别再用了 4.副主题 二、从2.2.x和H版开始说起1.1. 本次的SpringCloud第二季分为上半场和下半场1.1.1. 上篇 · SpringBoot2.X版和SpringCloud H版 1.1.2. 下篇 · SpringCloud Alibaba 1.1.3. 大纲 1.2. Springboot版本选择1.2.1. git源码地址： · https://github.com/spring-projects/spring-boot/releases/ 1.2.2. SpringBoot2.0新特性： · https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes 1.2.3. 通过上面官网发现，Boot官方强烈建议你升级到2.X以上版本 1.2.4. 官网看Boot版本 · springboot(截至2019.10.26) · springboot(截至2020.2.15) 1.3. SpringCloud版本选择1.3.1. git源码地址 · https://github.com/spring-projects/spring-cloud/wiki 1.3.2. 官网： · https://spring.io/projects/spring-cloud 1.3.3. 官网看Cloud版本 · Cloud命名规则 ​ SpringCloud的多版本 ​ ​ · springcloud(截至2019.10.26) · springboot(截至2020.2.15) 1.4. SpringCloud和Springboot之间的依赖关系如何看1.4.1. https://spring.io/projects/spring-cloud#overview 1.4.2. 依赖 1.4.3. 更详细的版本对应查看方法 · https://start.spring.io/actuator/info · 结果 · 查看json串返回结果 1.5. SpringCloud第二季定稿版（截止2020.2.15）1.5.1. cloud · Hoxton.SR1 1.5.2. boot · 2.2.2.RELEASE 1.5.3. cloud Alibaba · 2.1.0.RELEASE 1.5.4. java · JAVA8 1.5.5. maven · 3.5及以上 1.5.6. mysql · 5.7及以上 1.5.7. 不许捣蛋，上述全部版本必须和阳哥一致 1.5.8. 题外话 · boot版已经到2.2.4为最新，为什么选2.2.2？ · 只用boot，直接用最新 · 同时用boot和cloud，需要照顾cloud，由cloud决定boot版本 · 结果 · SpringCloud和SpringBoot版本对应关系 · 2.X版本常用的组件pom 三、关于Cloud各种组件的停更/升级/替换1.1. 由停更引发的“升级惨案”1.1.1. 停更不停用 · 被动修复bugs · 不再接受合并请求 · 不再发布新版本 1.1.2. 补充，哈哈 · 停课不停学 1.1.3. 明细条目 · 以前 · now2020 1.2. 参考资料见官网1.2.1. Spring Cloud · https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/ · Spring Cloud中文文档 · https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md 1.2.2. Spring Boot · https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/ 四、微服务架构编码构建4.微服务架构编码构建 约定 &gt; 配置 &gt; 编码 IDEA新建project工作空间 微服务cloud整体聚合父工程Project 父工程步骤 1.New Project 2.聚合总工程名字 3.Maven选版本 4.工程名字 5.字符编码 6.注解生效激活 7.java编译版本选8 8.File Type过滤 父工程POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud Hoxton.SR1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ​ 解决maven下载不了jar的问题请复制这个链接到浏览器自行解决：​ https://blog.csdn.net/HeyWeCome/article/details/104543411​ Maven工程落地细节复习​ Maven中的dependencyManagement和dependencies​ maven中跳过单元测试​ 父工程创建完成执行mvn:install将父工程发布到仓库方便子工程继承​ Rest微服务工程构建​ 构建步骤​ 1.cloud-provider-payment8001微服务提供者支付Module模块​ 建cloud-provider-payment8001​ 创建完成后请回到父工程查看pom文件变化​ 改POM文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ 写YML 1234567891011121314151617server: port: 8001spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: org.gjt.mm.mysql.Driver url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.atguigu.springcloud.entities ​ 主启动​ 业务类​ 1.建表SQL 1234567 CREATE TABLE payment ( id BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT ID, &#x27;serial&#x27; VARCHAR(200) DEFAULT, PRIMARY KEY(id)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ​ 2.entitles​ 主实体Payment 123456789101112131415161718package com.atguigu.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@AllArgsConstructor@NoArgsConstructorpublic class Payment implements Serializable &#123; private Long id; private String serial;&#125; ​ Json封装体CommonResult 12345678910111213141516171819202122package com.atguigu.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult &lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code,String message)&#123; this(code,message,null); &#125;&#125; ​ 3.dao​ 接口PaymentDao​ mybatis的映射文件PaymentMapper.xml​ 路径​ src\\main\\resources\\mapper\\PaymentMapper.xml​ 文件头 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.springcloud.dao.PaymentDao&quot;&gt;&lt;/mapper&gt; ​ PaymentMapper.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.springcloud.dao.PaymentDao&quot;&gt; &lt;insert id=&quot;create&quot; parameterType=&quot;Payment&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into payment(serial) values($&#123;serial&#125;); &lt;/insert&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.springcloud.entities.Payment&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;&gt;&lt;/id&gt; &lt;id column=&quot;serial&quot; property=&quot;serial&quot; jdbcType=&quot;VARCHAR&quot;&gt;&lt;/id&gt; &lt;/resultMap&gt; &lt;select id=&quot;getPaymentById&quot; parameterType=&quot;Long&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from payment where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; ​ 4.service​ 接口PaymentService 1234567891011121314package com.atguigu.springcloud.service;import com.atguigu.springcloud.entities.Payment;import org.apache.ibatis.annotations.Param;public interface PaymentService &#123; public int create(Payment payment); //写 public Payment getPaymentById(@Param(&quot;id&quot;) Long id); //读取&#125; ​ 实现类 1234567891011121314151617181920212223242526package com.atguigu.springcloud.service.impl;import com.atguigu.springcloud.dao.PaymentDao;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentService;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class PaymentServiceImpl implements PaymentService &#123; @Resource private PaymentDao paymentDao; public int create(Payment payment)&#123; return paymentDao.create(payment); &#125; public Payment getPaymentById( Long id)&#123; return paymentDao.getPaymentById(id); &#125;&#125; ​ 5.controller 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(Payment payment)&#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果：&quot;+result); if (result&gt;0)&#123; //成功 return new CommonResult(200,&quot;插入数据库成功&quot;,result); &#125;else &#123; return new CommonResult(444,&quot;插入数据库失败&quot;,null); &#125; &#125; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;*****查询结果：&quot;+payment); if (payment!=null)&#123; //说明有数据，能查询成功 return new CommonResult(200,&quot;查询成功&quot;,payment); &#125;else &#123; return new CommonResult(444,&quot;没有对应记录，查询ID：&quot;+id,null); &#125; &#125;&#125; ​ 测试​ http://localhost:8001/payment/get/31​ postman模拟post​ 运行​ 通过修改idea的workpace.xml的方式来快速打开Run DashBoard窗口​ 开启Run DashBoard 1234567891011121314 填入以下内容：&lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; ​ 部分同学可能由于idea版本不同，需要关闭重启​ 小总结​ 1.建module​ 2.改POM​ 3.写YML​ 4.主启动​ 5.业务类​ 2.热部署Devtools​ 1.Adding devtools to your project 123456789&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ​ 2.Adding plugin to your pom.xml 12345678910111213141516下一段配置黏贴到父工程当中的pom里 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ​ 3.Enabling automatic build 4.Update the value of ​ 5.重启IDEA​ 3.cloud-consumer-order80微服务消费者订单Module模块​ 建cloud-consumer-order80​ 改POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ 写YML 12345server: port: 80 ​ 主启动 123456789101112131415package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; ​ 业务类​ 创建entities(将cloud-provider-payment8001工程下的entities包下的两个实体类复制过来)​ 首说RestTemplate​ 是什么​ 官网及使用：https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html config配置类 ApplicationContextConfig 123456789101112131415161718package com.atguigu.springcloud.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; ​ 创建controller 12345678910111213141516171819202122232425262728293031323334package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class OrderController &#123; public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;; @Resource private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/create&quot;) public CommonResult&lt;Payment&gt; create(Payment payment)&#123; return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class); //写操作 &#125; @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123; return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class); &#125;&#125; ​ 测试​ 先启动cloud-provider-payment8001​ 再启动cloud-consumer-order80​ http://localhost/consumer/payment/get/32​不要忘记@RequestBody注解​ 4.工程重构​ 观察问题​ 系统中有重复部分，重构​ 新建​ cloud-api-commons​ POM 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ entities​ Payment实体​ CommonResult通用封装类​ maven命令clean install​ 订单80和支付8001分别改造​ 删除各自的原先有过的entities文件夹​ 各自黏贴POM内容 1234567&lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; ​ 80​ 8001​ 目前工程样图 五、Eureka服务注册与发现5.Eureka服务注册与发现 Eureka基础知识 什么是服务治理 什么是服务注册 Eureka两组件 单机Eureka构建步骤 IDEA生成eurekaServer端服务注册中心类似物业公司 建Module cloud-eureka-server7001 改POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-eureka-server7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ 1.X和2.X的对比说明​ 写YML 1234567891011121314server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名字 client: register-with-eureka: false #表识不向注册中心注册自己 fetch-registry: false #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址 ​ 主启动 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class,args); &#125;&#125; ​ @EnableEurekaServer​ 测试​ http://localhost:7001/​ 结果页面​ EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似尚硅谷学校对外提供授课服务​ cloud-provider-payment8001​ 改POM 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; ​ 1.X和2.X的对比说明​ 写YML 12345678910eureka: client: register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka ​ 主启动 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class,args); &#125;&#125; ​ @EnableEurekaClient​ 测试​ 先要启动EurekaServer​ http://localhost:7001/![image-20210731195338345](2021-07-31-SpringCloud/image-20210731195338345.png)​ 微服务注册名配置说明​ 自我保护机制​ EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer,类似来尚硅谷上课消费的各位同学​ cloud-consumer-order80​ POM 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; ​ 写YML 12345678910111213spring: application: name: cloud-order-serviceeureka: client: register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka ​ 主启动 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class,args); &#125;&#125; ​ @EnableEurekaClient​ 测试​ 先要启动EurekaServer，7001服务​ 再要启动服务提供者provider，8001服务​ eureka服务器​ http://localhost/consumer/payment/get/31​ bug​ 集群Eureka构建步骤​ Eureka集群原理说明 解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错 ​ EurekaServer集群环境构建步骤​ 参考cloud-eureka-server7001​ 新建cloud-eureka-server7002​ 改POM​ 修改映射配置​ 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件​ Subtopic​ 修改映射配置添加进hosts文件​ 127.0.0.1 eureka7001.com​ 127.0.0.1 eureka7002.com​ 写YML（以前单机） ​ 7001​ 7002 1234567891011121314server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名字 client: register-with-eureka: false #表识不向注册中心注册自己 fetch-registry: false #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/ #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址 ​ 主启动(复制cloud-eureka-server7001的主启动类到7002即可)​ 将支付服务8001微服务发布到上面2台Eureka集群配置中 ​ YML 123service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版 ​ 将订单服务80微服务发布到上面2台Eureka集群配置中​ YML 123service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版 ​ 测试01​ 先要启动EurekaServer，7001/7002服务​ 再要启动服务提供者provider，8001服务​ 再要启动消费者，80​ http://localhost/consumer/payment/get/31​ 支付服务提供者8001集群环境构建​ 参考cloud-provider-payment8001​ 新建cloud-provider-payment8002​ 改POM​ 写YML ​ 7001 1234567891011121314server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名字 client: register-with-eureka: false #表识不向注册中心注册自己 fetch-registry: false #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7002.com:7002/eureka/ #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址 ​ 7002 1234567891011121314server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名字 client: register-with-eureka: false #表识不向注册中心注册自己 fetch-registry: false #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/ #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址 ​ 主启动类​ 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件 Subtopic 修改映射配置添加进hosts文件 127.0.0.1 eureka7001.com 127.0.0.1 eureka7002.com 修改8001/8002的Controller 8001 8002 负载均衡 bug 订单服务访问地址不能写死 123456 改为这个： public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;; ​ 使用@LoadBalanced注解赋予RestTemplate负载均衡的能力​ ApplicationContextBean​ 提前说一下Ribbon的负载均衡功能​ 测试02​ 先要启动EurekaServer，7001/7002服务​ 再要启动服务提供者provider，8001/8002服务​ http://localhost/consumer/payment/get/31​ 结果​ 负载均衡效果达到​ 8001/8002端口交替出现​ Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能了​ actuator微服务信息完善​ 主机名称：服务名称修改​ 当前问题​ 修改cloud-provider-payment8001​ YML​ 修改部分 123instance: instance-id: payment8001 ​ 完整部分​ 修改之后​ 访问信息有ip信息提示​ 当前问题​ 没有ip提示​ 修改cloud-provider-payment8001​ YML​ 修改部分 1prefer-ip-address: true ​ 完整内容 1234567891011121314eureka: client: register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版 instance: instance-id: payment8001 prefer-ip-address: true ​ 修改之后​ 服务发现Discovery​ 对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息​ 修改cloud-provider-payment8001的Controller 12345678910111213141516@Resourceprivate DiscoveryClient discoveryClient; @GetMapping(value = &quot;/payment/discovery&quot;)public Object discovery()&#123; List&lt;String&gt; services = discoveryClient.getServices(); for (String element : services) &#123; log.info(&quot;***** element:&quot;+element); &#125; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); for (ServiceInstance instance : instances) &#123; log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri()); &#125; return this.discoveryClient;&#125; ​ 8001主启动类​ @EnableDiscoveryClient​ 自测​ 先要启动EurekaServer，7001/7002服务​ 再启动8001主启动类，需要稍等一会​ http://localhost:8001/payment/discovery​ Eureka自我保护​ 故障现象​ 导致原因 一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存​ 属于CAP里面的AP分支​ 怎么禁止自我保护（一般生产环境中不会禁止自我保护）​ 注册中心eureakeServer端7001​ 出厂默认，自我保护机制是开启的​ eureka.server.enable-self-preservation = true​ 使用eureka.server.enable-self-preservation = false可以禁用自我保护模式 123456server: enable-self-preservation: false eviction-interval-timer-in-ms: 2000 ​ 关闭效果​ 在eurekaServer端7001处设置关闭自我保护机制​ 生产者客户端eureakeClient端8001​ 默认​ eureka.instance.lease-renewal-interval-in-seconds=30​ 单位为秒（默认是30秒）​ eureka.instance.lease-expiration-duration-in-seconds=90​ 单位为秒（默认是90秒)​ 配置 1234instance: lease-renewal-interval-in-seconds: 1 lease-expiration-duration-in-seconds: 2 测试 7001和8001都配置完成 先启动7001再启动8001 先关闭8001 马上被删除了 六、Zookeeper服务注册与发现6.Zookeeper服务注册与发现 Eureka停止更新了你怎么办 https://github.com/Netflix/eureka/wiki SpringCloud整合Zookeeper代替Eureka 注册中心Zookeeper zookeeper是一个分布式协调工具，可以实现注册中心功能 关闭Linux服务器防火墙后启动zookeeper服务器 zookeeper服务器取代Eureka服务器，zk作为服务注册中心 服务提供者 新建cloud-provider-payment8004 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ YML 123456789101112server: port: 8004spring: application: name: cloud-provider-payment cloud: zookeeper: connect-string: 192.168.136.140:2181 ​ 主启动类 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain8004 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8004.class,args); &#125;&#125; ​ Controller 12345678910111213141516171819202122232425package com.atguigu.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/zk&quot;) public String paymentzk()&#123; return &quot;springcloud with zookeeper:&quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; ​ 启动8004注册进zookeeper​ 启动后问题​ why​ 解决zookeeper版本jar包冲突问题​ 排出zk冲突后的新POM 12345678910111213141516171819202122 &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!--排除zk3.5.3--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加zk 3.4,9版本--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt; ​ 验证测试​ http://localhost:8004/payment/zk​ 验证测试2​ 获得json串后用在线工具查看试试​ 思考​ 服务节点是临时节点还是持久节点::::是临时节点​ 服务消费者​ 新建cloud-consumerzk-order80​ POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ YML 1234567891011121314server: port: 80spring: application: name: cloud-consumer-order cloud: zookeeper: connect-string: 192.168.136.140:2181 ​ 主启动 1234567891011121314151617package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class OrderZKMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderZKMain80.class,args); &#125;&#125; ​ 业务类 12345678910111213141516171819202122232425package com.atguigu.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/zk&quot;) public String paymentzk()&#123; return &quot;springcloud with zookeeper:&quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; ​ 配置Bean 1234567891011121314151617181920package com.atguigu.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123; @LoadBalanced @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; ​ Controller 12345678910111213141516171819202122232425262728293031package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class OrderZKController &#123; public static final String INVOME_URL = &quot;http://cloud-provider-payment&quot;; @Resource private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/zk&quot;) public String payment ()&#123; String result = restTemplate.getForObject(INVOME_URL+&quot;/payment/zk&quot;,String.class); return result; &#125;&#125; ​ 启动8004注册进zookeeper​ 启动后问题​ why​ 解决zookeeper版本jar包冲突问题​ 排出zk冲突后的新POM 12345678910111213141516171819202122 &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!--排除zk3.5.3--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加zk 3.4,9版本--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt; ​ 验证测试​ http://localhost:8004/payment/zk​ 访问测试地址​ http://localhost/consumer/payment/zk 七、Consul服务注册与发现7.Consul服务注册与发现 Consul简介 是什么 https://www.consul.io/intro/index.html 能干嘛 服务发现 提供HTTP和DNS两种发现方式 健康监测 支持多种协议，HTTP、TCP、Docker、Shell脚本定制化 KV存储 key , Value的存储方式 多数据中心 Consul支持多数据中心 可视化Web界面 去哪下 https://www.consul.io/downloads.html 怎么玩 https://www.springcloud.cc/spring-cloud-consul.html 安装并运行Consul 官网安装说明 https://learn.hashicorp.com/consul/getting-started/install.html 下载完成后只有一个consul.exe文件，硬盘路径下双击运行，查看版本信息 使用开发模式启动 consul agent -dev 通过以下地址可以访问Consul的首页：http;//localhost:8500 结果页面 服务提供者 新建Module支付服务provider8006 cloud-providerconsul-payment8006 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ YML 12345678910111213141516server: port: 8006spring: application: name: consul-provider-payment cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; ​ 主启动类 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain8006 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8006.class,args); &#125;&#125; ​ 业务类Controller 123456789101112131415161718192021222324package com.atguigu.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/consul&quot;) public String paymentConsul()&#123; return &quot;springcloud with consul: &quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; ​ 验证测试​ http://localhost:8006/payment/consul​ 服务消费者​ 新建Module消费服务order8006​ cloud-consumerconsul-order80​ POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ YML 12345678910111213141516server: port: 80spring: application: name: consul-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; ​ 主启动类 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class OrderConsulMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderConsulMain80.class,args); &#125;&#125; ​ 配置Bean 1234567891011121314151617181920package com.atguigu.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123; @LoadBalanced @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; ​ Controller 1234567891011121314151617181920212223242526272829package com.atguigu.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class OrderConsulController &#123; public static final String INVOME_URL = &quot;http://consul-provider-payment&quot;; @Resource private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/consul&quot;) public String payment ()&#123; String result = restTemplate.getForObject(INVOME_URL+&quot;/payment/consul&quot;,String.class); return result; &#125;&#125; ​ 验证测试​ 访问测试地址​ http://localhost/consumer/payment/consul​ 三个注册中心异同点​ CAP​ C:Consistency(强一致性)​ A:Availability(可用性)​ P:Partition tolerance(分区容错)​ CAP理论关注粒度是数据，而不是整体系统设计的策略​ 经典CAP图​ AP(Eureka)​ CP(Zookeeper/Consul) 八、Ribbon负载均衡服务调用1.1. 概述1.1.1. 是什么 1.1.2. 官网资料 · https://github.com/Netflix/ribbon/wiki/Getting-Started · Ribbon目前也进入维护模式 · 未来替换方案 1.1.3. 能干嘛 · LB（负载均衡） · 集中式LB · 进程内LB · 前面我们讲解过了80通过轮询负载访问8001/8002 · 一句话 · 负载均衡+RestTemplate调用 1.2. Ribbon负载均衡演示1.2.1. 架构说明 · 总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。 1.2.2. POM 1.2.3. 二说RestTemplate的使用 · 官网 https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html · getForObject方法/getForEntity方法 · postForObject/postForEntity · GET请求方法 · POST请求方法 1.3. Ribbon核心组件IRule1.3.1. IRule:根据特定算法从服务列表中选取一个要访问的服务 · com.netflix.loadbalancer.RoundRobinRule · 轮询 · com.netflix.loadbalancer.RandomRule · 随机 · com.netflix.loadbalancer.RetryRule · 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试 · WeightedResponseTimeRule · 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 · BestAvailableRule · 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 · AvailabilityFilteringRule · 先过滤掉故障实例，再选择并发较小的实例 · ZoneAvoidanceRule · 默认规则，复合判断server所在区域的性能和server的可用性选择服务器 1.3.2. 如何替换 · 修改cloud-consumer-order80 · 注意配置细节 · 新建package · com.atguigu.myrule · 上面包下新建MySelfRule规则类 123456789101112131415package com.atguigu.myrule; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.RandomRule; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MySelfRule &#123; @Bean public IRule myRule()&#123; return new RandomRule();//定义为随机 &#125; &#125; · 主启动类添加@RibbonClient 12345678910111213141516171819package com.atguigu.springcloud;import com.atguigu.myrule.MySelfRule;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.ribbon.RibbonClient;@EnableEurekaClient@SpringBootApplication@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)public class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; · 测试 · http://localhost/consumer/payment/get/31 1.4. Ribbon负载均衡算法 1.4.1. 原理 1.4.2. RoundRobinRule源码 1.4.3. 手写 · 自己试着写一个本地负载均衡器试试 · 7001/7002集群启动 · 8001/8002微服务改造 · controller 1234@GetMapping(value = &quot;/payment/lb&quot;)public String getPaymentLB()&#123; return serverPort;&#125; · 80订单微服务改造 · 1.ApplicationContextBean去掉@LoadBalanced · 2.LoadBalancer接口 1234567891011package com.atguigu.springcloud.lb;import org.springframework.cloud.client.ServiceInstance;import java.util.List;public interface LoadBalancer &#123; //收集服务器总共有多少台能够提供服务的机器，并放到list里面 ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances);&#125; · 3.MyLB 1234567891011121314151617181920212223242526272829303132package com.atguigu.springcloud.lb;import org.springframework.cloud.client.ServiceInstance;import org.springframework.stereotype.Component;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;@Componentpublic class MyLB implements LoadBalancer &#123; private AtomicInteger atomicInteger = new AtomicInteger(0); //坐标 private final int getAndIncrement()&#123; int current; int next; do &#123; current = this.atomicInteger.get(); next = current &gt;= 2147483647 ? 0 : current + 1; &#125;while (!this.atomicInteger.compareAndSet(current,next)); //第一个参数是期望值，第二个参数是修改值是 System.out.println(&quot;*******第几次访问，次数next: &quot;+next); return next; &#125; @Override public ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances) &#123; //得到机器的列表 int index = getAndIncrement() % serviceInstances.size(); //得到服务器的下标位置 return serviceInstances.get(index); &#125;&#125; · 4.OrderController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.lb.LoadBalancer;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;import java.net.URI;import java.util.List;@RestController@Slf4jpublic class OrderController &#123; // public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;; public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;; @Resource private RestTemplate restTemplate; @Resource private LoadBalancer loadBalancer; @Resource private DiscoveryClient discoveryClient; @GetMapping(&quot;/consumer/payment/create&quot;) public CommonResult&lt;Payment&gt; create( Payment payment)&#123; return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class); //写操作 &#125; @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123; return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class); &#125; @GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPayment2(@PathVariable(&quot;id&quot;) Long id)&#123; ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class); if (entity.getStatusCode().is2xxSuccessful())&#123; // log.info(entity.getStatusCode()+&quot;\\t&quot;+entity.getHeaders()); return entity.getBody(); &#125;else &#123; return new CommonResult&lt;&gt;(444,&quot;操作失败&quot;); &#125; &#125; @GetMapping(value = &quot;/consumer/payment/lb&quot;) public String getPaymentLB()&#123; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); if (instances == null || instances.size() &lt;= 0)&#123; return null; &#125; ServiceInstance serviceInstance = loadBalancer.instances(instances); URI uri = serviceInstance.getUri(); return restTemplate.getForObject(uri+&quot;/payment/lb&quot;,String.class); &#125;&#125; · 5.测试 · http://localhost/consumer/payment/lb 九、OpenFeign服务接口调用1.1. 概述1.1.1. OpenFeign是什么 · Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可 · GitHub · https://github.com/spring-cloud/spring-cloud-openfeign 1.1.2. 能干嘛 1.1.3. Feign和OpenFeign两者区别 1.2. OpenFeign使用步骤1.2.1. 接口+注解 · 微服务调用接口+@FeignClient 1.2.2. 新建cloud-consumer-feign-order80 · Feign在消费端使用 1.2.3. POM 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-order80&lt;/artifactId&gt; &lt;!--openfeign--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 1.2.4. YML 1234567server: port: 80 eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka 1.2.5. 主启动类 12345678910111213package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClientspublic class OrderFeignMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderFeignMain80.class,args); &#125;&#125; · @EnableFeignClients 1.2.6. 业务类 · 业务逻辑接口+@FeignClient配置调用provider服务 · 新建PaymentFeignService接口并新增注解@FeignClient 1234567891011121314151617package com.atguigu.springcloud.service;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import feign.Param;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Component@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)public interface PaymentFeignService &#123; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125; · 控制层Controller 1234567891011121314151617181920212223package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentFeignService;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestControllerpublic class OrderFeignController &#123; @Resource private PaymentFeignService paymentFeignService; @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; return paymentFeignService.getPaymentById(id); &#125;&#125; 1.2.7. 测试 · 先启动2个eureka集群7001/7002 · 再启动2个微服务8001/8002 · 启动OpenFeign启动 · http://localhost/consumer/payment/get/31 · Feign自带负载均衡配置项 1.2.8. 小总结 1.3. OpenFeign超时控制1.3.1. 超时设置，故意设置超时演示出错情况 · 服务提供方8001故意写暂停程序 123456@GetMapping(value = &quot;/payment/feign/timeout&quot;)public String paymentFeignTimeout()&#123; try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; return serverPort;&#125; · 服务消费方80添加超时方法PaymentFeignService 123@GetMapping(value = &quot;/payment/feign/timeout&quot;)public String paymentFeignTimeout(); · 服务消费方80添加超时方法OrderFeignController 12345@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)public String paymentFeignTimeout()&#123; return paymentFeignService.paymentFeignTimeout();&#125; · 测试 · http://localhost/consumer/payment/feign/timeout · 错误页面 1.3.2. OpenFeign默认等待一秒钟，超过后报错 1.3.3. 是什么 · OpenFeign默认支持Ribbon 1.3.4. YML文件里需要开启OpenFeign客户端超时控制 123ribbon: ReadTimeout: 5000 ConnectTimeout: 5000 1.4. OpenFeign日志打印功能 1.4.1. 日志打印功能 1.4.2. 是什么 1.4.3. 日志级别 1.4.4. 配置日志bean 123456789101112131415package com.atguigu.springcloud.config;import feign.Logger;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 1.4.5. YML文件里需要开启日志的Feign客户端 123logging: level: com.atguigu.springcloud.service.PaymentFeignService: debug 1.4.6. 后台日志查看 十、Hystrix断路器1.1. 概述1.1.1. 分布式系统面临的问题 1.1.2. 是什么 1.1.3. 能干嘛 · 服务降级 · 服务熔断 · 接近实时的监控 · 。。。。。 1.1.4. 官网资料 · https://github.com/Netflix/Hystrix/wiki/How-To-Use 1.1.5. Hystrix官宣，停更进维 · https://github.com/Netflix/Hystrix · 被动修复bugs · 不再接受合并请求 · 不再发布新版本 1.2. Hystrix重要概念1.2.1. 服务降级 · 服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback · 哪些情况会触发降级 · 程序运行异常 · 超时 · 服务熔断触发服务降级 · 线程池/信号量打满也会导致服务降级 1.2.2. 服务熔断 · 类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示 · 就是保险丝 · 服务的降级-&gt;进而熔断-&gt;恢复调用链路 1.2.3. 服务限流 · 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行 1.3. hystrix案例 1.3.1. 构建 · 新建cloud-provider-hystrix-payment8001 · POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 123456789101112131415161718server: port: 8001eureka: client: register-with-eureka: true #表识不向注册中心注册自己 fetch-registry: true #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: # defaultZone: http://eureka7002.com:7002/eureka/ #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http://eureka7001.com:7001/eureka/# server:# enable-self-preservation: falsespring: application: name: cloud-provider-hystrix-payment# eviction-interval-timer-in-ms: 2000 · 主启动 123456789101112131415package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class,args); &#125;&#125; · 业务类 · service 1234567891011121314151617181920212223package com.atguigu.springcloud.service;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class PaymentService &#123; //成功 public String paymentInfo_OK(Integer id)&#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id： &quot;+id+&quot;\\t&quot;+&quot;哈哈哈&quot; ; &#125; //失败 public String paymentInfo_TimeOut(Integer id)&#123; int timeNumber = 3; try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_TimeOut,id： &quot;+id+&quot;\\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber; &#125;&#125; · controller 12345678910111213141516171819202122232425262728293031323334package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_OK(id); log.info(&quot;*******result:&quot;+result); return result; &#125; @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_TimeOut(id); log.info(&quot;*******result:&quot;+result); return result; &#125;&#125; · 正常测试 · 启动eureka7001 · 启动cloud-provider-hystrix-payment8001 · 访问 · 访问 · http://localhost:8001/payment/hystrix/ok/31 · 每次调用耗费5秒钟 · http://localhost:8001/payment/hystrix/timeout/31 · 上述module均OK · 以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复 1.3.2. 高并发测试 · 上述在非高并发情形下，还能勉强满足 but….. · Jmeter压测测试 · 开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务 · 再来一个访问 · http://localhost:8001/payment/hystrix/ok/31 · http://localhost:8001/payment/hystrix/timeout/31 · 看演示结果 · 两个都在自己转圈圈 · 为什么会被卡死 tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。 · Jmeter压测结论 · 上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死 · 看热闹不嫌弃事大，80新建加入 · cloud-consumer-feign-hystrix-order80 · 新建 · cloud-consumer-feign-hystrix-order80 · POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 1234567891011121314151617server: port: 8001eureka: client: register-with-eureka: true #表识不向注册中心注册自己 fetch-registry: true #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/spring: application: name: cloud-provider-hystrix-payment · 主启动 12345678910111213package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class,args); &#125;&#125; · 业务类 · PaymentHystrixService 123456789101112131415161718192021222324package com.atguigu.springcloud.service;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class PaymentService &#123; //成功 public String paymentInfo_OK(Integer id)&#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id： &quot;+id+&quot;\\t&quot;+&quot;哈哈哈&quot; ; &#125; //失败 public String paymentInfo_TimeOut(Integer id)&#123; int timeNumber = 3; try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_TimeOut,id： &quot;+id+&quot;\\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber; &#125;&#125; · OrderHystrixController 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_OK(id); log.info(&quot;*******result:&quot;+result); return result; &#125; @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_TimeOut(id); log.info(&quot;*******result:&quot;+result); return result; &#125;&#125; · 正常测试 · http://localhost/consumer/payment/hystrix/ok/31 · 高并发测试 · 2W个线程压8001 · 消费端80微服务再去访问正常的OK微服务8001地址 · http://localhost/consumer/payment/hystrix/timeout/31 · 消费者80，呜呜呜 · 要么转圈圈等待 · 要么消费端报超时错误 1.3.3. 故障现象和导致原因 · 8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕 · 80此时调用8001，客户端访问响应缓慢，转圈圈 1.3.4. 上诉结论 · 正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生 1.3.5. 如何解决？解决的要求 · 超时导致服务器变慢（转圈） · 超时不再等待 · 出错（宕机或程序运行出错） · 出错要有兜底 · 解决 · 对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级 · 对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级 · 对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级 1.3.6. 服务降级 · 降低配置 · @HystrixCommand · 8001先从自身找问题 · 设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback · 8001fallback · 业务类启用 · @HystrixCommand报异常后如何处理 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.springcloud.service;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class PaymentService &#123; //成功 public String paymentInfo_OK(Integer id)&#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id： &quot;+id+&quot;\\t&quot;+&quot;哈哈哈&quot; ; &#125; //失败 @HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties = &#123; @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;) //3秒钟以内就是正常的业务逻辑 &#125;) public String paymentInfo_TimeOut(Integer id)&#123; // int timeNumber = 5; int age = 10/0; // try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; //return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_TimeOut,id： &quot;+id+&quot;\\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_TimeOut,id： &quot;+id+&quot;\\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;; &#125; //兜底方法 public String paymentInfo_TimeOutHandler(Integer id)&#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; 系统繁忙, 请稍候再试 ,id： &quot;+id+&quot;\\t&quot;+&quot;哭了哇呜&quot;; &#125;&#125; · 一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法 · 图示 · 主启动类激活 · 添加新注解@EnableCircuitBreaker · 80fallback · 80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护 · 题外话，切记 · 我们自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务 · YML 123feign hystrix: enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。 · 主启动 · @EnableHystrix · 业务类 12345678910111213@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123; @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;) //3秒钟以内就是正常的业务逻辑&#125;)public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentHystrixService.paymentInfo_TimeOut(id); return result;&#125;//兜底方法public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;&#125; · 目前问题 · 每个业务方法对应一个兜底的方法，代码膨胀 · 统一和自定义的分开 · 解决问题 · 每个方法配置一个？？？膨胀 · feign接口系列 · @DefaultProperties(defaultFallback = “”) · 说明 · controller配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.PaymentHystrixService;import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4j@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;) //全局的public class OrderHystrixController &#123; @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentHystrixService.paymentInfo_OK(id); return result; &#125;// @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)// public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;// String result = paymentHystrixService.paymentInfo_TimeOut(id);// return result;// &#125; @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)// @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;// @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;) //1.5秒钟以内就是正常的业务逻辑// &#125;) @HystrixCommand public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; int age = 10/0; String result = paymentHystrixService.paymentInfo_TimeOut(id); return result; &#125; //兜底方法 public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;; &#125; //下面是全局fallback方法 public String payment_Global_FallbackMethod()&#123; return &quot;Global异常处理信息，请稍后再试,(┬＿┬)&quot;; &#125;&#125; · 和业务逻辑混一起？？？混乱 · 服务降级，客户端去调用服务端，碰上服务端宕机或关闭 · 本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦 · 未来我们要面对的异常 · 运行 · 超时 · 宕机 · 再看我们的业务类PaymentController · 修改cloud-consumer-feign-hystrix-order80 · 根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类（PaymentFallbackService）实现该接口，统一为接口里面的方法进行异常处理 · PaymentFallbackService类实现PaymentFeignClientService接口 123456789101112131415161718package com.atguigu.springcloud.service;import org.springframework.stereotype.Component;@Componentpublic class PaymentFallbackService implements PaymentHystrixService &#123; @Override public String paymentInfo_OK(Integer id) &#123; return &quot;-----PaymentFallbackService fall back-paymentInfo_OK , (┬＿┬)&quot;; &#125; @Override public String paymentInfo_TimeOut(Integer id) &#123; return &quot;-----PaymentFallbackService fall back-paymentInfo_TimeOut , (┬＿┬)&quot;; &#125;&#125; · YML 123feign: hystrix: enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。 · PaymentFeignClientService接口 12345678910111213141516171819package com.atguigu.springcloud.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Component@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class)public interface PaymentHystrixService &#123; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);&#125; · 测试 · 单个eureka先启动7001 · PaymentHystrixMain8001启动 · 正常访问测试 · http://localhost/consumer/payment/hystrix/ok/31 · 故意关闭微服务8001 · 客户端自己调用提升 · 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器 1.3.7. 服务熔断 · 断路器 · 一句话就是家里保险丝 · 熔断是什么 · 大神论文 · https://martinfowler.com/bliki/CircuitBreaker.html · 实操 · 修改cloud-provider-hystrix-payment8001 · PaymentService 12345678910111213141516171819//服务熔断@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123; @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;), //是否开启断路器 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), //请求次数 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), //时间范围 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;), //失败率达到多少后跳闸&#125;)public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123; if (id &lt; 0)&#123; throw new RuntimeException(&quot;*****id 不能负数&quot;); &#125; String serialNumber = IdUtil.simpleUUID(); return Thread.currentThread().getName()+&quot;\\t&quot;+&quot;调用成功,流水号：&quot;+serialNumber;&#125;public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;id 不能负数，请稍候再试,(┬＿┬)/~~ id: &quot; +id;&#125; · why配置这些参数 · PaymentController 12345678//===服务熔断@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentCircuitBreaker(id); log.info(&quot;*******result:&quot;+result); return result;&#125; · 测试 · 自测cloud-provider-hystrix-payment8001 · 正确 · http://localhost:8001/payment/circuit/31 · 错误 · http://localhost:8001/payment/circuit/-31 · 一次正确一次错误trytry · 重点测试 · 多次错误,然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行访问，需要慢慢的恢复链路 · 原理（小总结） · 大神结论 · 熔断类型 · 熔断打开 · 请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入熔断状态 · 熔断关闭 · 熔断关闭不会对服务进行熔断 · 熔断半开 · 部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断 · 官网断路器流程图 · 官网步骤 · 断路器在什么情况下开始起作用 · 断路器开启或者关闭的条件 · 当满足一定阀值的时候（默认10秒内超过20个请求次数） · 当失败率达到一定的时候（默认10秒内超过50%请求失败） · 到达以上阀值，断路器将会开启 · 当开启的时候，所有请求都不会进行转发 · 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5 · 断路器打开之后 · All配置 1.3.8. 服务限流 · 后面高级篇讲解alibaba的Sentinel说明 1.4. hystrix工作流程1.4.1. https://github.com/Netflix/Hystrix/wiki/How-it-Works 1.4.2. hystrix工作流程 · 官网图例 · 步骤说明 1.5. 服务监控hystrixDashboard1.5.1. 概述 1.5.2. 仪表盘9001 · 新建cloud-consumer-hystrix-dashboard9001 · POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增hystrix dashboard--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 12server: port: 9001 · HystrixDashboardMain9001+新注解@EnableHystrixDashboard 1234567891011121314package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;@SpringBootApplication@EnableHystrixDashboardpublic class HystrixDashboardMain9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardMain9001.class,args); &#125;&#125; · 所有Provider微服务提供类（8001/8002/8003）都需要监控依赖配置 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; · 启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001 · http://localhost:9001/hystrix 1.5.3. 断路器演示 · 修改cloud-provider-hystrix-payment8001 · 注意：新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径 12345678910@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean;&#125; · Unable to connect to Command Metric Stream · 404 · 监控测试 · 启动1个eureka或者3个eureka集群均可 · 观察监控窗口 · 9001监控8001 · 填写监控地址 · http://localhost:8001/hystrix.stream · 测试地址 · http://localhost:8001/payment/circuit/31 · http://localhost:8001/payment/circuit/-31 · 上述测试通过 · ok · 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的 · 监控结果，成功 · 监控结果，失败 · 如何看 · 7色 · 1圈 · 1线 · 整图说明 · 整图说明2 · 搞懂一个才能看懂复杂的 十一、zuul路由网关(没讲)11.zuul路由网关（没讲） 十二、Gateway新一代网关1.1. 概述简介1.1.1. 官网 · 上一代zuul 1.X · https://github.com/Netflix/zuul/wiki · 当前gateway · https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/ 1.1.2. 是什么 · 概述 · 一句话 · Spring Cloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架 · 源码架构 1.1.3. 能干嘛 · 反向代理 · 鉴权 · 流量控制 · 熔断 · 日志监控 · 。。。。。。 1.1.4. 微服务架构中网关在哪里 1.1.5. 有了Zuul了怎么又出来了gateway · 我们为什么选择Gatway? · 1.neflix不太靠谱，zuul2.0一直跳票,迟迟不发布 · 2.SpringCloud Gateway具有如下特性 · 3.SpringCloud Gateway与Zuul的区别 · Zuul1.x模型 · GateWay模型 · WebFlux是什么？ · 说明 1.2. 三大核心概念1.2.1. Route(路由) · 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由 1.2.2. Predicate（断言） · 参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由 1.2.3. Filter(过滤) · 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 1.2.4. 总体 1.3. Gateway工作流程1.3.1. 官网总结 1.3.2. 核心逻辑 · 路由转发+执行过滤器链 1.4. 入门配置 1.4.1. 新建Module · cloud-gateway-gateway9527 · POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-gateway-gateway9527&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增gateway--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 12345678910111213141516171819202122232425262728server: port: 9527spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言,路径相匹配的进行路由 - id: payment_routh2 uri: http://localhost:8001 predicates: - Path=/payment/lb/** #断言,路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka · 业务类 · 无 · 主启动类 1234567891011121314package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class GateWayMain9527 &#123; public static void main(String[] args) &#123; SpringApplication.run( GateWayMain9527.class,args); &#125;&#125; · 9527网关如何做路由映射那？？？ · cloud-provider-payment8001看看controller的访问地址 · get · lb · 我们目前不想暴露8001端口，希望在8001外面套一层9527 · YML新增网关配置 1234567891011121314151617181920212223242526272829server: port: 9527spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言,路径相匹配的进行路由 - id: payment_routh2 uri: http://localhost:8001 predicates: - Path=/payment/lb/** #断言,路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka · 测试 · 启动7001 · 启动8001 · cloud-provider-payment8001 · 启动9527网关 · 访问说明 · 添加网关前 · http://localhost:8001/payment/get/31 · 添加网关后 · http://localhost:9527/payment/get/31 · YML配置说明 · Gateway网关路由有两种配置方式 · 在配置文件yml中配置 · 见前面步骤 · 代码中注入RouteLocator的Bean · 官网案例 · 百度国内新闻网址，需要外网 · http://news.baidu.com/guoji · 自己写一个 · 百度新闻 · 业务需求 · 通过9527网关访问到外网的百度新闻网址 · 编码 · cloud-gateway-gateway9527 · 实现业务 · config 12345678910111213141516171819package com.atguigu.springcloud.config;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class GateWayConfig &#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) &#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(&quot;path_rote_atguigu&quot;, r -&gt; r.path(&quot;/guonei&quot;).uri(&quot;http://news.baidu.com/guonei&quot;)).build(); return routes.build(); &#125;&#125; 1.5. 通过微服务名实现动态路由1.5.1. 默认情况下Gateway会根据注册中心的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能 1.5.2. 启动 · 一个eureka7001+两个服务提供者8001/8002 1.5.3. POM 1.5.4. YML 12345678910111213141516171819202122232425262728293031323334server: port: 9527spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名 #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service predicates: - Path=/payment/get/** #断言,路径相匹配的进行路由 - id: payment_routh2 #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service predicates: - Path=/payment/lb/** #断言,路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka · 需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。 · lb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri 1.5.5. 测试 · http://localhost:9527/payment/lb · 8001/8002两个端口切换 1.6. Predicate的使用1.6.1. 是什么 · 启动我们的gatewat9527 1.6.2. Route Predicate Factories这个是什么东东？ 1.6.3. 常用的Route Predicate · 1.After Route Predicate ​ ZonedDateTime zonedDateTime = ZonedDateTime.now(); ​ System.out.println(zonedDateTime); · YML 1- After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai] · 2.Before Route Predicate · YML 12- After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]- Before=2020-03-08T10:59:34.102+08:00[Asia/Shanghai] · 3.Between Route Predicate · YML 1- Between=2020-03-08T10:59:34.102+08:00[Asia/Shanghai] , 2020-03-08T10:59:34.102+08:00[Asia/Shanghai] · 4. Cookie Route Predicate · 不带cookies访问 · 带上cookies访问 · 加入curl返回中文乱码 https://blog.csdn.net/leedee/article/details/82685636 · YML 1- Cookie=username,atguigu #并且Cookie是username=zhangshuai才能访问 · 5. Header Route Predicate · YML 1- Header=X-Request-Id, \\d+ #请求头中要有X-Request-Id属性并且值为整数的正则表达式 · 6.Host Route Predicate · YML 1- Host=**.atguigu.com · 7.Method Route Predicate · YML 1- Method=GET · 8.Path Route Predicate · YML · 9. Query Route Predicate · YML 1- Query=username, \\d+ #要有参数名称并且是正整数才能路由 · 10.小总结 · All 1234567891011121314151617181920212223242526272829303132333435363738394041server: port: 9527spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名 #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service predicates: - Path=/payment/get/** #断言,路径相匹配的进行路由 - id: payment_routh2 #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service predicates: - Path=/payment/lb/** #断言,路径相匹配的进行路由 #- After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai] #- Cookie=username,zhangshuai #并且Cookie是username=zhangshuai才能访问 #- Header=X-Request-Id, \\d+ #请求头中要有X-Request-Id属性并且值为整数的正则表达式 #- Host=**.atguigu.com #- Method=GET #- Query=username, \\d+ #要有参数名称并且是正整数才能路由 eureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka · 说白了，Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理 1.7. Filter的使用1.7.1. 是什么 1.7.2. Spring Cloud Gateway的Filter · 生命周期，Only Two · pre · 在业务逻辑之前 · post · 在业务逻辑之后 · 种类，Only Two · GatewayFilter · 单一 · GlobalFilter · 全局 1.7.3. 常用的GatewayFilter · AddRequestParameter · YML · 省略 1.7.4. 自定义过滤器 · 自定义全局GlobalFilter · 两个主要接口介绍 · impiemerts GlobalFilter ，Ordered · 能干嘛 · 全局日志记录 · 统一网关鉴权 · 。。。。。。 · 案例代码 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.springcloud.filter;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.util.Date;@Component@Slf4jpublic class MyLogGateWayFilter implements GlobalFilter,Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;*********come in MyLogGateWayFilter: &quot;+new Date()); String uname = exchange.getRequest().getQueryParams().getFirst(&quot;username&quot;); if(StringUtils.isEmpty(username))&#123; log.info(&quot;*****用户名为Null 非法用户,(┬＿┬)&quot;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);//给人家一个回应 return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; · 测试 · 启动 · 正确 · http://localhost:9527/payment/lb?uname=z3 · 错误 十三、SpringCloud config分布式配置中心1.1. 概述1.1.1. 分布式系统面临的配置问题 1.1.2. 是什么 1.1.3. 能干嘛 · 集中管理配置文件 · 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release · 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 · 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置 · 将配置信息以REST接口的形式暴露 · post、curl访问刷新均可…. 1.1.4. 与Github整合配置 · 由于SpringCloud Config默认使用Git来存储配置文件（也有其它方式，比如支持svn和本地文件，但最推荐的还是Git，而且使用的是http/https访问的形式） 1.1.5. 官网 · https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/ 1.2. Config服务端配置与测试1.2.1. 用你自己的账号在Github上新建一个名为sprincloud-config的新Repository 1.2.2. 由上一步获得刚新建的git地址 · 写你自己的仓库地址 1.2.3. 本地硬盘上新建git仓库并clone · 本地地址：D:\\44\\SpringCloud2020 · git命令 · git clone xxx 1.2.4. 此时在本地D盘符下D:\\44\\SpringCloud2020\\springcloud-config · 表示多个环境的配置文件 · 保存格式必须为UTF-8 · 如果需要修改，此处模拟运维人员操作git和github · git add · git commit -m “init yml” · git push origin master 1.2.5. 新建Module模块cloud-config-center-3344它既为Cloud的配置中心模块cloudConfig Center 1.2.6. POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-center-3344&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2.7. YML 12345678910111213141516171819server: port: 3344spring: application: name: cloud-config-center cloud: config: server: git: uri: 填写你自己的github路径 search-paths: - springcloud-config label: mastereureka: client: service-url: defaultZone: http://localhost:7001/eureka 1.2.8. 主启动类 · ConfigCenterMain3344 123456789101112131415package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class ConfigCenterMain3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigCenterMain3344 .class,args); &#125;&#125; · @EnableConfigServer 1.2.9. windows下修改hosts文件，增加映射 · 127.0.0.1 config-3344.com 1.2.10. 测试通过Config微服务是否可以从Github上获取配置内容 · 启动微服务3344 · http://config-3344.com:3344/master/config-dev.yml 1.2.11. 配置读取规则 · 官网 · /{label}/{application}-{profile}.yml（最推荐使用这种方式） · master分支 · http://config-3344.com:3344/master/config-dev.yml · http://config-3344.com:3344/master/config-test.yml · http://config-3344.com:3344/master/config-prod.yml · dev分支 · http://config-3344.com:3344/dev/config-dev.yml · http://config-3344.com:3344/dev/config-test.yml · http://config-3344.com:3344/dev/config-prod.yml · /{application}-{profile}.yml · http://config-3344.com:3344/config-dev.yml · http://config-3344.com:3344/config-test.yml · http://config-3344.com:3344/config-prod.yml · http://config-3344.com:3344/config-xxxx.yml(不存在的配置) · /{application}-{profile}[/{label}] · http://config-3344.com:3344/config/dev/master · http://config-3344.com:3344/config/test/master · http://config-3344.com:3344/config/prod/master · 重要配置细节总结 1.2.12. 成功实现了用SpringCloud Config 通过GitHub获取配置信息 1.3. Config客户端配置与测试1.3.1. 新建cloud-config-client-3355 1.3.2. POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.3.3. bootstap.yml · 是什么 · 内容 123456789101112131415161718server: port: 3355spring: application: name: config-client cloud: config: label: master name: config profile: dev uri: http://localhost:3344eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka · 说明 1.3.4. 修改config-dev.yml配置并提交到GitHub中，比如加个变量age或者版本号version 1.3.5. 主启动 1234567891011package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ConfigClientMain3355 &#123; public static void main(String[] args) &#123; SpringApplication.run( ConfigClientMain3355.class,args); &#125;&#125; · 类ConfigClientMain3355 1.3.6. 业务类 1234567891011121314151617181920package com.atguigu.springcloud.Controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo()&#123; return configInfo; &#125;&#125; 1.3.7. 测试 · 启动Config配置中心3344微服务并自测 · http://config-3344.com:3344/master/config-dev.yml · http://config-3344.com:3344/master/config-test.yml · 启动3355作为Client准备访问 · http://localhost:3355/configInfo 1.3.8. 成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息 1.3.9. 问题随时而来，分布式配置的动态刷新 · Linux运维修改GitHub上的配置文件内容做调整 · 刷新3344，发现ConfigServer配置中心立刻响应 · 刷新3355，发现ConfigServer客户端没有任何响应 · 3355没有变化除非自己重启或者重新加载 · 难道每次运维修改配置文件，客户端都需要重启？？噩梦 1.4. Config客户端之动态刷新1.4.1. 避免每次更新配置都要重启客户端微服务3355 1.4.2. 动态刷新 · 步骤 · 修改3355模块 · POM引入actuator监控 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; · 修改YML，暴露监控端口 123456789101112131415161718192021222324server: port: 3355spring: application: name: config-client cloud: config: label: master name: config profile: dev uri: http://localhost:3344eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eurekamanagement: endpoints: web: exposure: include: &quot;*&quot; · @RefreshScope业务类Controller修改 1234567891011121314151617181920package com.atguigu.springcloud.Controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RefreshScope@RestControllerpublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo()&#123; return configInfo; &#125;&#125; · 此时修改github—&gt; 3344 —&gt; 3355 · http://localhost:3355/configInfo · 3355改变了没有？？？ · 没有改变，(┬＿┬) · How · 需要运维人员发送Post请求刷新3355 · 必须是Post请求 · curl -X POST “http://localhost:3355/actuator/refresh&quot; · 再次 · http://localhost:3355/configInfo · OK · 成功实现了客户端3355刷新到最新配置内容 · 避免了服务的重启 1.4.3. 想想还有什么问题？ · 假如有多个微服务客户端3355/3366/3377。。。。 · 每个微服务都要执行一次post请求，手动刷新？ · 可否广播，一次通知，处处生效？ · 我们想大范围的自动刷新，求方法 十四、SpringCloud Bus消息总线1.1. 概述1.1.1. 上一讲解的加深和扩充，一言以蔽之 · 分布式自动刷新配置功能 · Spring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新 1.1.2. 是什么 · Bus支持两种消息代理：RabbitMQ和Kafka 1.1.3. 能干嘛 1.1.4. 为何被称为总线 1.2. RabbitMQ环境配置1.2.1. 安装Erlang，下载地址： · http://erlang.org/download/otp_win64_21.3.exe · 步骤 1.2.2. 安装RabbitMQ，下载地址 · https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe · 步骤 1.2.3. 进入RabbitMQ安装目录下的sbin目录 · 如例我自己本机 · D:\\scmq\\rabbitmq_server-3.7.14\\sbin 1.2.4. 输入以下命令启动管理功能 · rabbitmq-plugins enable rabbitmq_management · 可视化插件 1.2.5. 访问地址查看是否安装成功 · http://localhost:15672/ 1.2.6. 输入账号密码并登录: guest guest 1.3. SpringCloud Bus动态刷新全局广播1.3.1. 必须先具备良好的RabbitMQ环境先 1.3.2. 演示广播效果，增加复杂度，再以3355为模板再制作一个3366 · 新建 · cloud-config-client-3366 · POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; · YML 12345678910111213141516171819202122server: port: 3366spring: application: name: config-client cloud: config: label: master name: config profile: dev uri: http://localhost:3344eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eurekamanagement: endpoints: web: exposure: include: &quot;*&quot; · 主启动 123456789101112131415package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class ConfigClientMain3366 &#123; public static void main(String[] args) &#123; SpringApplication.run( ConfigClientMain3366.class,args); &#125;&#125; · controller 12345678910111213141516171819202122232425package com.atguigu.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo()&#123; return &quot;serverPort:&quot;+serverPort+&quot;\\t\\n\\n configInfo: &quot;+configInfo; &#125;&#125; 1.3.3. 设计思想 · 1) 利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置 ​ · 2) 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点,而刷新所有客户端的配置（更加推荐） ​ · 图二的架构显然更加合适，图一不适合的原因如下 · 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新职责 · 破坏了微服务各节点的对等性 · 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改 1.3.4. 给cloud-config-center-3344配置中心服务端添加消息总线支持 · POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; · YML 123456789101112131415161718192021222324252627282930313233server: port: 3344spring: application: name: cloud-config-center cloud: config: server: git: uri: https://github.com/hhf19906/springcloud-config.git #git@github.com:hhf19906/springcloud-config.git search-paths: - springcloud-config label: masterrabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://localhost:7001/eurekamanagement: endpoints: web: exposure: include: &#x27;bus-refresh&#x27; 1.3.5. 给cloud-config-center-3355客户端添加消息总线支持 · POM 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; · YML 123456789101112131415161718192021222324252627282930server: port: 3355spring: application: name: config-client cloud: config: label: master name: config profile: dev uri: http://localhost:3344rabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://eureka7001.com:7001/eurekamanagement: endpoints: web: exposure: include: &quot;*&quot; 1.3.6. 给cloud-config-center-3366客户端添加消息总线支持 · POM 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; · YML 123456789101112131415161718192021222324252627282930server: port: 3366spring: application: name: cloud-config-center cloud: config: server: git: uri: https://github.com/hhf19906/springcloud-config.git #git@github.com:hhf19906/springcloud-config.git search-paths: - springcloud-config label: masterrabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://localhost:7001/eurekamanagement: endpoints: web: exposure: include: &#x27;bus-refresh&#x27; 1.3.7. 测试 · 运维工程师 · 修改Github上配置文件增加版本号 · 发送Post请求 · curl -X POST “http://localhost:3344/actuator/bus-refresh&quot; · 一次发送，处处生效 · 配置中心 · http://config-3344.com/config-dev.yml · 客户端 · http://localhost:3355/configInfo · http://localhost:3366/configInfo · 获取配置信息，发现都已经刷新了 1.3.8. 一次修改，广播通知，处处生效 1.4. SpringCloud Bus动态刷新定点通知1.4.1. 不想全部通知，只想定点通知 · 只通知3355 · 不通知3366 1.4.2. 简单一句话 · 指定具体某一个实例生效而不是全部 · 公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination} · /bus/refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例 1.4.3. 案例 · 我们这里以刷新运行在3355端口上的config-client为例 · 只通知3355 · 不通知3366 · curl -X POST “http://localhost:3344/actuator/bus-refresh/config-client:3355&quot; 1.4.4. 通知总结All 十五、SpringCloud Stream 消息驱动1.1. 消息驱动概述1.1.1. 是什么 · 一句话 · 屏蔽底层消息中间件的差异，降低切换版本，统一消息的编程模型 · 官网 · https://spring.io/projects/spring-cloud-stream#overview · https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/ · Spring Cloud Stream中文指导手册 · https://m.wang1314.com/doc/webapp/topic/20971999.html 1.1.2. 设计思想 · 标准MQ · 生产者/消费者之间靠消息媒介传递信息内容 · Message · 消息必须走特定的通道 · 消息通道MessageChannel · 消息通道里的消息如何被消费呢，谁负责收发处理 · 消息通道MessageChannel的子接口SubscribableChannel,由MessageHandler消息处理器订阅 · 为什么用Cloud Stream · stream凭什么可以统一底层差异 · Binder · INPUT对应于消费者 · OUTPUT对应于生产者 · Stream中的消息通信方式遵循了发布-订阅模式 · Topic主题进行广播 · 在RabbitMQ就是Exchange · 在kafka中就是Topic 1.1.3. Spring Cloud Stream标准流程套路 · Binder · 很方便的连接中间件，屏蔽差异 · Channel · 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过对Channel对队列进行配置 · Source和Sink · 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入 1.1.4. 编码API和常用注解 1.2. 案例说明1.2.1. RabbitMQ环境已经OK 1.2.2. 工程中新建三个子模块 · cloud-stream-rabbitmq-provider8801,作为生产者进行发消息模块 · cloud-stream-rabbitmq-consumer8802,作为消息接收模块 · cloud-stream-rabbitmq-consumer8803,作为消息接收模块 1.3. 消息驱动之生产者1.3.1. 新建Module · cloud-stream-rabbitmq-provider8801 1.3.2. POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-provider8801&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.3.3. YML 123456789101112131415161718192021222324252627282930313233server: port: 8801spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 1.3.4. 主启动类StreamMQMain8801 1.3.5. 业务类 · 发送消息接口 12345678package com.atguigu.springcloud.service;public interface IMessageProvider&#123; public String send();&#125; · 发送消息接口实现类 12345678910111213141516171819202122232425262728293031package com.atguigu.springcloud.service.impl;import com.atguigu.springcloud.service.IMessageProvider;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.integration.support.MessageBuilderFactory;import org.springframework.messaging.MessageChannel;import org.springframework.integration.support.MessageBuilder;import javax.annotation.Resource;import org.springframework.cloud.stream.messaging.Source;import javax.annotation.Resource;import java.util.UUID;@EnableBinding(Source.class) //定义消息的推送管道public class MessageProviderImpl implements IMessageProvider&#123; @Resource private MessageChannel output; // 消息发送管道 @Override public String send() &#123; String serial = UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); System.out.println(&quot;*****serial: &quot;+serial); return null; &#125;&#125; · Controller 123456789101112131415161718192021222324package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.IMessageProvider;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestControllerpublic class SendMessageController&#123; @Resource private IMessageProvider messageProvider; @GetMapping(value = &quot;/sendMessage&quot;) public String sendMessage() &#123; return messageProvider.send(); &#125;&#125; 1.3.6. 测试 · 启动7001eureka · 启动rabbitmq · rabbitmq-plugins enable rabbitmq_management · http://localhost:15672/ · 启动8801 · 访问 · http://localhost:8801/sendMessage 1.4. 消息驱动之消费者1.4.1. 新建Module · cloud-stream-rabbitmq-consumer8802 1.4.2. POM 1.4.3. YML 1.4.4. 主启动类StreamMQMain8802 1.4.5. 业务类 1.4.6. 测试8801发送8802接收消息 · http://localhost:8801/sendMessage 1.5. 分组消费与持久化1.5.1. 依照8802，clone出来一份运行8803 · cloud-stream-rabbitmq-consumer8803 · POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8803&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 12345678910111213141516171819202122232425262728293031323334server: port: 8803spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 group: atguiguAeureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8803.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 · 主启动类 12345678910111213141516package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StreamMQMain8803&#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8803.class,args); &#125;&#125; · 业务类 12345678910111213141516171819202122232425package com.atguigu.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.messaging.Message;import org.springframework.stereotype.Component; @Component@EnableBinding(Sink.class)public class ReceiveMessageListenerController&#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message) &#123; System.out.println(&quot;消费者2号,-----&gt;接受到的消息: &quot;+message.getPayload()+&quot;\\t port: &quot;+serverPort); &#125;&#125; 1.5.2. 启动 · RabbitMQ · 7001 · 服务注册 · 8801 · 消息生产 · 8802 · 消息消费 · 8803 · 消息消费 1.5.3. 运行后两个问题 · 有重复消费问题 · 消息持久化问题 1.5.4. 消费 · 目前是8802/8803同时都收到了，存在重复消费问题 · http://localhost:8801/sendMessage · 如何解决 · 分组和持久化属性group · 重要 · 生产实际案例 1.5.5. 分组 · 原理 · 微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费。 · 8802/8803都变成不同组，group两个不同 · group: atguiguA、atguiguB · 8802修改YML group: atguiguA · 8803修改YML group: atguiguB · 我们自己配置 · 结论 · 还是重复消费 · 8802/8803实现了轮询分组，每次只有一个消费者 8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费 · 8802/8803都变成相同组，group两个相同 · group: atguiguA · 8802修改YML group: atguiguA · 8803修改YML group: atguiguA · 结论 · 同一个组的多个微服务实例，每次只会有一个拿到 1.5.6. 持久化 · 通过上述，解决了重复消费问题，再看看持久化 · 停止8802/8803并去除掉8802的分组group:atguiguA · 8803的分组group:atguiguA没有去掉 · 8801先发送4条信息到rabbitmq · 先启动8802，无分组属性配置，后台没有打出来消息 · 先启动8803，有分组属性配置，后台打出来了MQ上的消息 十六、SpringCloud Sleuth 分布式请求链路追踪1.1. 概述1.1.1. 为什么会出现这个技术？需要解决哪些问题？ · 问题 ​ 1.1.2. 是什么 · https://github.com/spring-cloud/spring-cloud-sleuth · Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案 · 在分布式系统中提供追踪解决方案并且兼容支持了zipkin 1.1.3. 解决 1.2. 搭建链路监控步骤1.2.1. 1.zipkin · 下载 · SpringCloud从F版起已不需要自己构建Zipkin server了，只需要调用jar包即可 · https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/ · zipkin-server-2.12.9.exec.jar · 运行jar java -jar zipkin-server-2.12.9-exec.jar · 运行控制台 · http://localhost:9411/zipkin/ · 术语 · 完整的调用链路 · 上图what · 名词解释 · Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识 · span:表示调用链路来源，通俗的理解span就是一次请求信息 1.2.2. 2.服务提供者 · cloud-provider-payment8001 · POM 123456&lt;!--包含了sleuth+zipkin--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; · YML 1234567891011121314151617181920212223242526272829303132333435server: port: 8001spring: application: name: cloud-payment-service zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: org.gjt.mm.mysql.Driver url: username: root password: mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.atguigu.springcloud.entitieseureka: client: register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版 instance: instance-id: payment8001 prefer-ip-address: true · 业务类PaymentController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.client.ServiceInstance;import org.springframework.web.bind.annotation.*;import org.springframework.cloud.client.discovery.DiscoveryClient; import javax.annotation.Resource;import java.util.List;import java.util.concurrent.TimeUnit; @RestController@Slf4jpublic class PaymentController&#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @Resource private DiscoveryClient discoveryClient; @PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(@RequestBody Payment payment) &#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果：&quot;+result); if(result &gt; 0) &#123; return new CommonResult(200,&quot;插入数据库成功,serverPort: &quot;+serverPort,result); &#125;else&#123; return new CommonResult(444,&quot;插入数据库失败&quot;,null); &#125; &#125; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id) &#123; Payment payment = paymentService.getPaymentById(id); if(payment != null) &#123; return new CommonResult(200,&quot;查询成功,serverPort: &quot;+serverPort,payment); &#125;else&#123; return new CommonResult(444,&quot;没有对应记录,查询ID: &quot;+id,null); &#125; &#125; @GetMapping(value = &quot;/payment/discovery&quot;) public Object discovery() &#123; List&lt;String&gt; services = discoveryClient.getServices(); for (String element : services) &#123; log.info(&quot;*****element: &quot;+element); &#125; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); for (ServiceInstance instance : instances) &#123; log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri()); &#125; return this.discoveryClient; &#125; @GetMapping(value = &quot;/payment/lb&quot;) public String getPaymentLB() &#123; return serverPort; &#125; @GetMapping(value = &quot;/payment/feign/timeout&quot;) public String paymentFeignTimeout() &#123; // 业务逻辑处理正确，但是需要耗费3秒钟 try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return serverPort; &#125; @GetMapping(&quot;/payment/zipkin&quot;) public String paymentZipkin() &#123; return &quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to atguigu，O(∩_∩)O哈哈~&quot;; &#125;&#125; 1.2.3. 3.服务消费者（调用方） · cloud-consumer-order80 · POM 12345&lt;!--包含了sleuth+zipkin--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; · YML 1234567891011121314151617181920212223server: port: 80 spring: application: name: cloud-order-service zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: false #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: #单机 #defaultZone: http://localhost:7001/eureka # 集群 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 · 业务类PaymentController 12345678// ====================&gt; zipkin+sleuth @GetMapping(&quot;/consumer/payment/zipkin&quot;) public String paymentZipkin() &#123; String result = restTemplate.getForObject(&quot;http://localhost:8001&quot;+&quot;/payment/zipkin/&quot;, String.class); return result; &#125; 1.2.4. 4.依次启动eureka7001/8001/80 · 80调用8001几次测试下 1.2.5. 5.打开浏览器访问:http:localhost:9411 · 会出现以下界面 · 查看 · 查看依赖关系 · 原理 十七、SpringCloud Alibaba入门简介1.1. why会出现SpringCloud alibaba1.1.1. Spring Cloud Netflix项目进入维护模式 · https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now · 说明 1.1.2. SpringCloud NetFlix Projects Entering Maintenance Mode · 什么是维护模式 · 进入维护模式意味着什么呢？ 1.2. SpringCloud alibaba带来了什么？1.2.1. 是什么 https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md 1.2.2. 能干嘛 1.2.3. 去哪下 · https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md 1.2.4. 怎么玩 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 1.3. SpringCloud alibaba学习资料获取1.3.1. 官网 · https://spring.io/projects/spring-cloud-alibaba#overview 1.3.2. 英文 · https://github.com/alibaba/spring-cloud-alibaba · https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html 1.3.3. 中文 · https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md 十八、SpringCloud Alibaba Nacos 服务注册和配置中心1.1. Nacos简介1.1.1. 为什么叫Nacos · 前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service 1.1.2. 是什么 · 一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心 · Nacos：Dynamic Naming and Configuration Service · Nacos就是注册中心+配置中心的组合 · 等价于 · Nacos = Eureka+Config+Bus 1.1.3. 能干嘛 · 替代Eureka做服务注册中心 · 替代Config做服务配置中心 1.1.4. 去哪下 · https://github.com/alibaba/Nacos · 官网文档 · https://nacos.io/zh-cn/index.html · https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery 1.1.5. 各种注册中心比较 1.2. 安装并运行Nacos1.2.1. 本地Java8+Maven环境已经OK 1.2.2. 先从官网下载Nacos · https://github.com/alibaba/nacos/releases/tag/1.1.4 1.2.3. 解压安装包，直接运行bin目录下的startup.cmd 1.2.4. 命令运行成功后直接访问http://localhost:8848/nacos · 默认账号密码都是nacos 1.2.5. 结果页面 1.3. Nacos作为服务注册中心演示1.3.1. 官网文档 1.3.2. 基于Nacos的服务提供者 · 新建Module · cloudalibaba-provider-payment9001 · POM · 父POM 123456789&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; · 本模块POM 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; · YML 12345678910111213141516server: port: 9001spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址management: endpoints: web: exposure: include: &#x27;*&#x27; · 主启动 12345678910111213package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class PaymentMain9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain9001.class,args); &#125;&#125; · 业务类 1234567891011121314151617181920package com.atguigu.springcloud.alibaba.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class PaymentController&#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;) public String getPayment(@PathVariable(&quot;id&quot;) Integer id) &#123; return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\\t id&quot;+id; &#125;&#125; · 测试 · http://lcoalhost:9001/payment/nacos/1 · nacos控制台 · nacos服务注册中心+服务提供者9001都ok了 · 为了下一章节演示nacos的负载均衡，参照9001新建9002 · 新建cloudalibaba-provider-payment9002 · 9002其他步骤你懂的 · 或者取巧不想新建重复体力劳动，直接拷贝虚拟端口映射 1.3.3. 基于Nacos的服务消费者 · 新建Module · cloudalibaba-consumer-nacos-order83 · POM 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; · 为什么nacos支持负载均衡 · YML 123456789101112131415server: port: 83spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848service-url: nacos-user-service: http://nacos-payment-provider · 主启动 12345678910111213141516package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class OrderNacosMain83&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain83.class,args); &#125;&#125; · 业务类 · ApplicationContextBean 1234567891011121314151617181920package com.atguigu.springcloud.alibaba.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig&#123; @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; · OrderNacosController 12345678910111213141516171819202122232425262728293031package com.atguigu.springcloud.alibaba.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class OrderNacosController&#123; @Resource private RestTemplate restTemplate; @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;) private String serverURL; @GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;) public String paymentInfo(@PathVariable(&quot;id&quot;) Long id) &#123; return restTemplate.getForObject(serverURL+&quot;/payment/nacos/&quot;+id,String.class); &#125;&#125; · 测试 · nacos控制台 · http://localhost:83/consumer/payment/nacos/13 · 83访问9001/9002，轮询负载OK 1.3.4. 服务注册中心对比 · 各种注册中心对比 · Nacos全景图所示 · Nacos和CAP · 切换 · Nacos支持AP和CP模式的切换 1.4. Nacos作为服务配置中心演示1.4.1. Nacos作为配置中心-基础配置 · cloudalibaba-config-nacos-client3377 · POM 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;!--nacos-config--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos-discovery--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web + actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; · YML · why配置两个 · YML · bootstrap 12345678910111213141516server: port: 3377spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #服务注册中心地址 config: server-addr: localhost:8848 #配置中心地址 file-extension: yaml #指定yaml格式的配置 · application 123spring: profiles: active: dev · 主启动 123456789101112131415161718package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class NacosConfigClientMain3377&#123; public static void main(String[] args) &#123; SpringApplication.run(NacosConfigClientMain3377.class, args); &#125;&#125; · 业务类 12345678910111213141516171819202122package com.atguigu.springcloud.alibaba.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RefreshScopepublic class ConfigClientController&#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/config/info&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; · ConfigClientController 12345678910111213141516171819202122package com.atguigu.springcloud.alibaba.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RefreshScopepublic class ConfigClientController&#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/config/info&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; · @RefreshScope · 在Nacos中添加配置信息 · Nacos中的匹配规则 · 理论 · Nacos中的dataid的组成格式与SpringBoot配置文件中的匹配规则 · 官网 https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html · 实操 · 配置新增 nacos-config-client-dev · Nacos界面配置对应 123config: info: nacos config center,version = 1from nacos config center, nacos-config-client-dev.yaml, version=1 · 设置DataId · 公式 1$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125; · prefix默认为spring.application.name的值 · spring.profile.active既为当前环境对应的profile,可以通过配置项spring.profile.active 来配置 · file-exetension为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension配置 · 小总结说明 · 历史配置 · 测试 · 启动前需要在nacos客户端-配置管理-配置管理栏目下有没有对应的yaml配置文件 · 运行cloud-config-nacos-client3377的主启动类 · 调用接口查看配置信息 · http://localhost:3377/config/info · 自带动态刷新 · 修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新 1.4.2. Nacos作为配置中心-分类配置 · 问题 · 多环境多项目管理 · Nacos的图形化管理界面 · 配置管理 · 命名空间 · Namespace+Group+Data ID三者关系？为什么这么设计？ · Case · DataID方案 · 指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置 · 默认空间+默认分组+新建dev和test两个DataID · 新建dev配置DataID · 新建test配置DataID · 通过spring.profile.active属性就能进行多环境下配置文件的读取 · 测试 · http://localhost:3377/config/info · 配置是什么就加载什么 · test · Group方案 · 通过Group实现环境区分 · 新建Group · 在nacos图形界面控制台上面新建配置文件DataID · bootstrap+application · 在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST_GROUP · Namespace方案 · 新建dev/test的Namespace · 回到服务管理-服务列表查看 · 按照域名配置填写 · YML · bootstrap 1namespace: · application 1.5. Nacos集群和持久化配置（重要） 1.5.1. 官网说明 · https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html · 官网架构图（写的(┬＿┬)） · 上图官网翻译，真实情况 ​ · 说明 · 按照上述，我们需要mysql数据库 · 官网说明 · https://nacos.io/zh-cn/docs/deployment.html · 重点说明 1.5.2. Nacos持久化配置解释 · Nacos默认自带的是嵌入式数据库derby · https://github.com/alibaba/nacos/blob/develop/config/pom.xml · derby到mysql切换配置步骤 · nacos-server-1.1.4\\nacos\\conf目录下找到sql脚本 · nacos-mysql.sql · 执行脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197CREATE DATABASE nacos_config;USE nacos_config; /* 数据库全名 = nacos_config *//* 表名称 = config_info *//******************************************/CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) NOT NULL COMMENT &#x27;group_id&#x27;, `datum_id` varchar(255) NOT NULL COMMENT &#x27;datum_id&#x27;, `content` longtext NOT NULL COMMENT &#x27;内容&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#x27;betaIps&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tag_id` varchar(128) NOT NULL COMMENT &#x27;tag_id&#x27;, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT &#x27;id&#x27;, `tag_name` varchar(128) NOT NULL COMMENT &#x27;tag_name&#x27;, `tag_type` varchar(64) DEFAULT NULL COMMENT &#x27;tag_type&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `group_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;, `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27;, `src_user` text, `src_ip` varchar(20) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;; /******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `tenant_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;, `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;; CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `kp` varchar(128) NOT NULL COMMENT &#x27;kp&#x27;, `tenant_id` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tenant_name` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;, `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;, `create_source` varchar(32) DEFAULT NULL COMMENT &#x27;create_source&#x27;, `gmt_create` bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;; CREATE TABLE users ( username varchar(50) NOT NULL PRIMARY KEY, password varchar(500) NOT NULL, enabled boolean NOT NULL); CREATE TABLE roles ( username varchar(50) NOT NULL, role varchar(50) NOT NULL); INSERT INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, TRUE); INSERT INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;); · nacos-server-1.1.4\\nacos\\conf目录下找到application.properties 1234567spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=nacos_devtestdb.password=youdontknow · 启动nacos，可以看到是个全新的空记录界面，以前是记录进derby 1.5.3. Linux版Nacos+MySQL生产环境配置 · 预计需要，1个nginx+3个nacos注册中心+1个mysql · Nacos下载linux版本 · https://github.com/alibaba/nacos/releases/tag/1.1.4 · nacos-server-1.1.4.tar.gz · 解压后安装 · 集群配置步骤（重点） · 1.Linux服务器上mysql数据库配置 · SQL脚本在哪里 · sql语句源文件 · nacos-mysql.sql · 自己Linux机器上的Mysql数据库黏贴 · 执行后结果 · 2.application.properties配置 · 位置 · 内容 12345678spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://1.7.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=HF_mysql_654321 · 3.Linux服务器上nacos的集群配置cluster.conf · 梳理出3台nacos机器的不同服务端口号 · 复制出cluster.conf · 内容 · 这个IP不能写127.0.0.1,必须是Linux命令hostname -i能够识别的IP · 4.编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端 · /mynacos/nacos/bin目录下有startup.sh · 在什么地方，修改什么，怎么修改 · 思考 · 修改内容 · 执行方式 · 5.Nginx的配置，由它作为负载均衡器 · 修改nginx的配置文件 · nginx.conf upstream cluster{ server 127.0.0.1:3333; server 127.0.0.1:4444; server 127.0.0.1:5555; } server{ listen 1111; server_name localhost; location /{ proxy_pass http://cluster; } ….省略 · 按照指定启动 · 6.截止到此处，1个Nginx+3个nacos注册中心+1个mysql · 测试通过nginx访问nacos · https://写你自己虚拟机的ip:1111/nacos/#/login · 新建一个配置测试 · linux服务器的mysql插入一条记录 · 测试 · 微服务cloudalibaba-provider-payment9002启动注册进nacos集群 · yml server-addr: 写你自己的虚拟机ip:1111 · 结果 · 高可用小总结 十九、SpringCloud Alibaba Sentinel1.1. Sentinel1.1.1. 官网 · https://github.com/alibaba/Sentinel · 中文 · https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D 1.1.2. 是什么 · 一句话解释，之前我们讲解过的Hystrix 1.1.3. 去哪下 · https://github.com/alibaba/Sentinel/releases 1.1.4. 能干嘛 1.1.5. 怎么玩 · https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel · 服务使用中的各种问题 · 服务雪崩 · 服务降级 · 服务熔断 · 服务限流 1.2. 安装Sentinel控制台1.2.1. sentinel组件由2部分组成 · 后台 · 前台8080 1.2.2. 安装步骤 · 下载 · https://github.com/alibaba/Sentinel/releases · 下载到本地sentinel-dashboard-1.7.0.jar · 运行命令 · 前提 · java8环境OK · 8080端口不能被占用 · 命令 · java -jar sentinel-dashboard-1.7.0.jar · 访问sentinel管理界面 · http://localhost:8080 · 登录账号密码均为sentinel 1.3. 初始化演示工程1.3.1. 启动Nacos8848成功 · http://localhost:8848/nacos/#/login 1.3.2. Module · cloudalibaba-sentinel-service8401 · POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-sentinel-service8401&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.6.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 12345678910111213141516171819202122server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 port: 8719 #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口management: endpoints: web: exposure: include: &#x27;*&#x27; · 主启动 1234567891011121314151617package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401&#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp8401.class, args); &#125;&#125; · 业务类FlowLimitController 12345678910111213141516171819202122232425262728package com.atguigu.springcloud.alibaba.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class FlowLimitController&#123; @GetMapping(&quot;/testA&quot;) public String testA() &#123; return &quot;------testA&quot;; &#125; @GetMapping(&quot;/testB&quot;) public String testB() &#123; return &quot;------testB&quot;; &#125;&#125; 1.3.3. 启动Sentinel8080 · java -jar sentinel-dashboard-1.7.0 1.3.4. 启动微服务8401 1.3.5. 启动8401微服务后查看sentienl控制台 · 空空如也，啥都没有 · Sentinel采用的懒加载说明 · 执行一次访问即可 · http://localhost:8401/testA · http://localhost:8401/testB · 效果 · 结论 · sentinel8080正在监控微服务8401 1.4. 流控规则 1.4.1. 基本介绍 · 进一步解释说明 1.4.2. 流控模式 · 直接（默认） · 直接-&gt;快速失败 · 系统默认 · 配置及说明 · 测试 · 快速点击访问http://localhost:8401/testA · 结果 · Blocked by Sentinel (flow limiting) · 思考？？？ · 直接调用默认报错信息，技术方面OK but，是否应该有我们自己的后续处理？ · 类似有一个fallback的兜底方法？ · 关联 · 是什么？ · 当关联的资源达到阈值时，就限流自己 · 当与A关联的资源B达到阈值后，就限流自己 · B惹事，A挂了 · 配置A · postman模拟并发密集访问testB · 访问testB成功 · postman里新建多线程集合组 · 将访问地址添加进新线程组 · Run · 大批量线程高并发访问B，导致A失效了 · 运行后发现testA挂了 · 点击访问http://localhost:8401/testA · 结果 · Blocked by Sentinel (flow limiting) · 链路 · 多个请求调用了同一个微服务 · 家庭作业试试 1.4.3. 流控效果 · 直接-&gt;快速失败（默认的流控处理） · 直接失败，抛出异常 · Blocked by Sentinel (flow limiting) · 源码 · com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController · 预热 · 说明 · 公式：阈值除以coldFactor（默认值为3），经过预热时长后才会达到阈值 · 官网 · 默认coldFactor为3，即请求QPS从threshold/3开始，经预热时长逐渐升至设定的QPS阈值。 · 限流 冷启动 · https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8 · 源码 · com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController · Warmup配置 · 多次点击http://localhost:8401/testB · 刚开始不行，后续慢慢OK · 应用场景 · 排队等待 · 匀速排队，阈值必须设置为QPS · 官网 · 源码 · com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController · 测试 1.5. 降级规则1.5.1. 官网 1.5.2. 基本介绍 · 进一步说明 · Sentinel的断路器是没有半开状态的 · 半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。具体可以参考Hystrix · 复习Hystrix 1.5.3. 降级策略实战 · RT · 是什么 · 测试 · 代码 12345678@GetMapping(&quot;/testD&quot;)public String testD()&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;testD 测试RT&quot;); return &quot;------testD&quot;;&#125; · 配置 · jmeter压测 · 结论 · 异常比例 · 是什么 · 测试 · 代码 12345678@GetMapping(&quot;/testD&quot;) public String testD() &#123; log.info(&quot;testD 测试RT&quot;); int age = 10/0; return &quot;------testD&quot;; &#125; · 配置 · jmeter · 结论 · 异常数 · 是什么 · 异常数是按照分钟统计的 · 测试 · 代码 1234567@GetMapping(&quot;/testE&quot;)public String testE()&#123; log.info(&quot;testE 测试异常数&quot;); int age = 10/0; return &quot;------testE 测试异常数&quot;;&#125; · 配置 http://localhost:8401/testE · jmeter 1.6. 热点key限流1.6.1. 基本介绍 · 是什么 1.6.2. 官网 · https://github.com/alibaba/Sentinel/wiki/热点参数限流 1.6.3. 承上启下复习start · @SentinelResource 1.6.4. 代码 123456789101112@GetMapping(&quot;/testHotKey&quot;)@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1, @RequestParam(value = &quot;p2&quot;,required = false) String p2) &#123; //int age = 10/0; return &quot;------testHotKey&quot;;&#125; //兜底方法public String deal_testHotKey (String p1, String p2, BlockException exception)&#123; return &quot;------deal_testHotKey,o(╥﹏╥)o&quot;; &#125; · com.alibaba.csp.sentinel.slots.block.BlockException 1.6.5. 配置 · 配置 · 1 · @SentinelResource(value = “testHotKey”) · 异常打到了前台用户界面看不到，不友好 · 2 · @SentinelResource(value = “testHotKey”,blockHandler = “deal_testHotKey”) · 方法testHostKey里面第一个参数只要QPS超过每秒1次，马上降级处理 · 用了我们自己定义的 1.6.6. 测试 · error Single Icons StockIcon-69; [“mmStockIconBrokenConnection”, “”] · http://localhost:8401/testHotKey?p1=abc · error Single Icons StockIcon-69; [“mmStockIconBrokenConnection”, “”] · http://localhost:8401/testHotKey?p1=abc&amp;p2=33 · right Single Icons StockIcon-62; [“mmStockIconCheck”, “”] · http://localhost:8401/testHotKey?p2=abc 1.6.7. 参数例外项 · 上述案例演示了第一个参数p1,当QPS超过1秒1次点击后马上被限流 · 特殊情况 · 普通 · 超过1秒钟一个后，达到阈值1后马上被限流 · 我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样 · 特例 · 假如当p1的值等于5时，它的阈值可以达到200 · 配置 · 添加按钮不能忘 · 测试 · http://localhost:8401/testHotKey?p1=5 Single Icons StockIcon-62; [“mmStockIconCheck”, “”] · http://localhost:8401/testHotKey?p1=3 Single Icons StockIcon-69; [“mmStockIconBrokenConnection”, “”] · 当p1等于5的时候，阈值变为200 · 当p1不等于5的时候，阈值就是平常的1 · 前提条件 · 热点参数的注意点，参数必须是基本类型或者String 1.6.8. 其他 · 手贱添加异常看看…. · 后面讲 1.7. 系统规则1.7.1. 是什么 · https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81 1.7.2. 各项配置参数说明 1.7.3. 配置全局QPS 1.8. @SentinelResource1.8.1. 按资源名称限流+后续处理 · 启动Nacos成功 · 启动Sentinel成功 · Module · cloudalibaba-sentinel-service8401 · POM 12345&lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; · YML 1234567891011121314151617181920server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 port: 8719 #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口management: endpoints: web: exposure: include: &#x27;*&#x27; · 业务类RateLimitController 123456789101112131415161718192021222324package com.atguigu.springcloud.alibaba.controller;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.atguigu.springcloud.alibaba.entities.CommonResult;import com.atguigu.springcloud.alibaba.entities.Payment;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RateLimitController&#123; @GetMapping(&quot;/byResource&quot;) @SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;) public CommonResult byResource() &#123; return new CommonResult(200,&quot;按资源名称限流测试OK&quot;,new Payment(2020L,&quot;serial001&quot;)); &#125; public CommonResult handleException(BlockException exception) &#123; return new CommonResult(444,exception.getClass().getCanonicalName()+&quot;\\t 服务不可用&quot;); &#125; · 主启动 12345678910111213141516package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401&#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp8401.class, args); &#125;&#125; · 配置流控规则 · 配置步骤 · 图形配置和代码关系 · 表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流 · 测试 · 1秒钟点击1下，OK · 超过上述问题，疯狂点击，返回了自己定义的限流处理信息，限流发送 · 额外问题 · 此时关闭微服务8401看看 · Sentinel控制台，流控规则消失了？？？？？ · 临时/持久？ 1.8.2. 按照Url地址限流+后续处理 · 通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息 · 业务类RateLimitController 12345678@GetMapping(&quot;/rateLimit/byUrl&quot;)@SentinelResource(value = &quot;byUrl&quot;)public CommonResult byUrl()&#123; return new CommonResult(200,&quot;按url限流测试OK&quot;,new Payment(2020L,&quot;serial002&quot;));&#125; · 访问一次 · Sentinel控制台配置 · 测试 · 疯狂点击http://localhost:8401/rateLimit/byUrl · 结果 1.8.3. 上面兜底方法面临的问题 1.8.4. 客户自定义限流处理逻辑 · 创建customerBlockHandler类用于自定义限流处理逻辑 · 自定义限流处理类 · CustomerBlockHandler · RateLimitController 12345678910@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)@SentinelResource(value = &quot;customerBlockHandler&quot;, blockHandlerClass = CustomerBlockHandler.class, blockHandler = &quot;handlerException2&quot;)public CommonResult customerBlockHandler()&#123; return new CommonResult(200,&quot;按客戶自定义&quot;,new Payment(2020L,&quot;serial003&quot;));&#125; · 启动微服务后先调用一次 · http://localhost:8401/rateLimit/customerBlockHandler · Sentinel控制台配置 · 测试后我们自定义的出来了 · 进一步说明 1.8.5. 更多注解属性说明 · 多说一句 · Sentinel主要有三个核心API · SphU定义资源 · Tracer定义统计 · ContextUtil定义了上下文 1.9. 服务熔断功能1.9.1. sentinel整合ribbon+openFeign+fallback 1.9.2. Ribbon系列 · 启动nacos和sentinel · 提供者9003/9004 · 新建cloudalibaba-provider-payment9003/9004 · POM 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; · YML 12345678910111213141516server: port: 9003spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址management: endpoints: web: exposure: include: &#x27;*&#x27; · 记得修改不同的端口号 · 主启动 1234567891011121314151617package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain9003&#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain9003.class, args); &#125;&#125; · 业务类 1234567891011121314151617181920212223242526272829303132package com.atguigu.springcloud.alibaba.controller;import com.atguigu.springcloud.alibaba.entities.CommonResult;import com.atguigu.springcloud.alibaba.entities.Payment;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestControllerpublic class PaymentController&#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; public static HashMap&lt;Long, Payment&gt; hashMap = new HashMap&lt;&gt;(); static&#123; hashMap.put(1L,new Payment(1L,&quot;28a8c1e3bc2742d8848569891fb42181&quot;)); hashMap.put(2L,new Payment(2L,&quot;bba8c1e3bc2742d8848569891ac32182&quot;)); hashMap.put(3L,new Payment(3L,&quot;6ua8c1e3bc2742d8848569891xt92183&quot;)); &#125; @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment = hashMap.get(id); CommonResult&lt;Payment&gt; result = new CommonResult(200,&quot;from mysql,serverPort: &quot;+serverPort,payment); return result; &#125; · 测试地址 · http://localhost:9003/paymentSQL/1 · 消费者84 · 新建cloudalibaba-consumer-nacos-order84 · POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-consumer-nacos-order84&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; · YML 123456789101112131415161718server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 port: 8719service-url: nacos-user-service: http://nacos-payment-provider · 主启动 12345678910111213141516171819package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;@EnableDiscoveryClient@SpringBootApplication@EnableFeignClientspublic class OrderNacosMain84&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain84.class, args); &#125;&#125; · 业务类 · ApplicationContextConfig 1234567891011121314151617181920package com.atguigu.springcloud.alibaba.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig&#123; @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; · CircleBreakerController的全部源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.springcloud.alibaba.controller;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.atguigu.springcloud.alibaba.entities.CommonResult;import com.atguigu.springcloud.alibaba.entities.Payment;import com.atguigu.springcloud.alibaba.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class CircleBreakerController &#123; public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;; @Resource private RestTemplate restTemplate; @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;) //@SentinelResource(value = &quot;fallback&quot;) //没有配置 //@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常 //@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规 @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;, exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;) public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123; CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot;+id, CommonResult.class,id); if (id == 4) &#123; throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;); &#125;else if (result.getData() == null) &#123; throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;); &#125; return result; &#125; //fallback public CommonResult handlerFallback(@PathVariable Long id,Throwable e) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(444,&quot;兜底异常handlerFallback,exception内容 &quot;+e.getMessage(),payment); &#125; //blockHandler public CommonResult blockHandler(@PathVariable Long id,BlockException blockException) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel限流,无此流水: blockException &quot;+blockException.getMessage(),payment); &#125;&#125; · 修改后请重启微服务 · 热部署对java代码级生效及时 · 对@SentinelResource注解内属性，有时效果不好 · 目的 · fallback管运行异常 · blockHandler管配置违规 · 测试地址 · http://localhost:84/consumer/fallback/1 · 没有任何配置 123456789101112131415161718192021222324@RestController@Slf4jpublic class CircleBreakerController&#123; public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;; @Resource private RestTemplate restTemplate; @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;) @SentinelResource(value = &quot;fallback&quot;) public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123; CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot;+id,CommonResult.class,id); if (id == 4) &#123; throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;); &#125;else if (result.getData() == null) &#123; throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;); &#125; return result; &#125; · 给客户error页面，不友好 · 只配置fallback · 编码（那个业务类下面的CircleBreakerController的全部源码） · 只配置blockHandler · 编码（那个业务类下面的CircleBreakerController的全部源码） · fallback和blockHandler都配置 · 结果 · 忽略属性… · 编码（那个业务类下面的CircleBreakerController的全部源码） · 图说 1.9.3. Feign系列 · 修改84模块 · POM 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; · YML 12345678910111213141516171819202122232425server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 port: 8719service-url: nacos-user-service: http://nacos-payment-provider#对Feign的支持feign: sentinel: enabled: true · 业务类 · 带@FeignClient注解的业务接口 12345678910111213141516package com.atguigu.springcloud.alibaba.service;import com.atguigu.springcloud.alibaba.entities.CommonResult;import com.atguigu.springcloud.alibaba.entities.Payment;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)public interface PaymentService&#123; @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);&#125; · fallback = PaymentFallbackService.class · PaymentFallbackService实现类 1234567891011121314151617181920package com.atguigu.springcloud.alibaba.service;import com.atguigu.springcloud.alibaba.entities.CommonResult;import com.atguigu.springcloud.alibaba.entities.Payment;import org.springframework.stereotype.Component;@Componentpublic class PaymentFallbackService implements PaymentService&#123; @Override public CommonResult&lt;Payment&gt; paymentSQL(Long id) &#123; return new CommonResult&lt;&gt;(44444,&quot;服务降级返回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;)); &#125;&#125; · Controller 12345678910// OpenFeign@Resourceprivate PaymentService paymentService;@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id) &#123; return paymentService.paymentSQL(id);&#125; · 主启动 · 添加@EnableFeignClients启动Feign的功能 123456789101112131415161718package com.atguigu.springcloud.alibaba;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;@EnableDiscoveryClient@SpringBootApplication@EnableFeignClientspublic class OrderNacosMain84&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain84.class, args); &#125;&#125; · http://lcoalhost:84/consumer/openfeign/1 · http://lcoalhost:84/consumer/paymentSQL/1 · 测试84调用9003，此时故意关闭9003微服务提供者，看84消费侧自动降级，不会被耗死 1.9.4. 熔断框架比较 1.10. 规则持久化1.10.1. 是什么 · 一旦我们重启应用，Sentinel规则将消失，生产环境需要将配置规则进行持久化 1.10.2. 怎么玩 · 将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上Sentinel上的流控规则持续有效 1.10.3. 步骤 · 修改cloudalibaba-sentinel-service8401 · POM 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; · YML 12345678910111213141516171819202122232425262728293031323334server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard地址 port: 8719 datasource: ds1: nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flowmanagement: endpoints: web: exposure: include: &#x27;*&#x27;feign: sentinel: enabled: true # 激活Sentinel对Feign的支持 · 添加Nacos数据源配置 123456789101112spring: cloud: sentinel: datasource: ds1: nacos: server-addr:localhost:8848 dataid:$&#123;spring.application.name&#125; groupid:DEFAULT_GROUP data-type:json rule-type:flow · 添加Nacos业务规则配置 · 内容解析 123456789101112[ &#123; &quot;resource&quot;: &quot;/retaLimit/byUrl&quot;, &quot;limitApp&quot;: &quot;default&quot;, &quot;grade&quot;: 1, &quot;count&quot;: 1, &quot;strategy&quot;: 0, &quot;controlBehavior&quot;: 0, &quot;clusterMode&quot;: false &#125;] · 启动8401后刷新sentinel发现业务规则有了 · 快速访问测试接口 · http://localhost:8401/rateLimit/byUrl · 默认 · 停止8401再看sentinel · 重新启动8401再看sentinel · 扎一看还是没有，稍等一会儿 · 多次调用 · http://localhost:8401/rateLimit/byUrl · 重新配置出现了，持久化验证通过 二十、SpringCloud Alibaba Seata处理分布式事务1.1. 分布式事务问题1.1.1. 分布式前 · 单机单库没这个问题 · 从1：1 -&gt; 1:N -&gt; N: N 1.1.2. 分布式之后 ​ 1.1.3. 一句话 · 一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题 1.2. Seata简介1.2.1. 是什么 · Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务 · 官网地址 · http://seata.io/zh-cn/ 1.2.2. 能干嘛 · 一个典型的分布式事务过程 · 分布式事务处理过程的-ID+三组件模型 · Transaction ID XID · 全局唯一的事务ID · 3组件概念 · Transaction Coordinator(TC) · 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚; · Transaction Manager(TM) · 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议; · Resource Manager(RM) · 控制分支事务，负责分支注册，状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚； · 处理过程 1.2.3. 去哪下 · 发布说明:https://github.com/seata/seata/releases 1.2.4. 怎么玩 · 本地@Transactional · 全局@GlobalTransactional · SEATA的分布式交易解决方案 1.3. Seata-Server安装1.3.1. 1.官网地址 · http://seata.io/zh-cn/ 1.3.2. 2.下载版本 1.3.3. 3.seata-server-0.9.0.zip解压到指定目录并修改conf目录下的file.conf配置文件 · 先备份原始file.conf文件 · 主要修改：自定义事务组名称+事务日志存储模式为db+数据库连接信息 · file.conf · service模块 vgroup_mapping.my_test_tx_group = “fsp_tx_group” · store模块 mode = “db” url = “jdbc:mysql://127.0.0.1:3306/seata” user = “root” password = “你自己的密码” 1.3.4. 4.mysql5.7数据库新建库seata 1.3.5. 5.在seata库里建表 · 建表db_store.sql在\\seata-server-0.9.0\\seata\\conf目录里面 · db_store.sql · SQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-- the table to store GlobalSession datadrop table if exists `global_table`;create table `global_table` ( `xid` varchar(128) not null, `transaction_id` bigint, `status` tinyint not null, `application_id` varchar(32), `transaction_service_group` varchar(32), `transaction_name` varchar(128), `timeout` int, `begin_time` bigint, `application_data` varchar(2000), `gmt_create` datetime, `gmt_modified` datetime, primary key (`xid`), key `idx_gmt_modified_status` (`gmt_modified`, `status`), key `idx_transaction_id` (`transaction_id`)); -- the table to store BranchSession datadrop table if exists `branch_table`;create table `branch_table` ( `branch_id` bigint not null, `xid` varchar(128) not null, `transaction_id` bigint , `resource_group_id` varchar(32), `resource_id` varchar(256) , `lock_key` varchar(128) , `branch_type` varchar(8) , `status` tinyint, `client_id` varchar(64), `application_data` varchar(2000), `gmt_create` datetime, `gmt_modified` datetime, primary key (`branch_id`), key `idx_xid` (`xid`)); -- the table to store lock datadrop table if exists `lock_table`;create table `lock_table` ( `row_key` varchar(128) not null, `xid` varchar(96), `transaction_id` long , `branch_id` long, `resource_id` varchar(256) , `table_name` varchar(32) , `pk` varchar(36) , `gmt_create` datetime , `gmt_modified` datetime, primary key(`row_key`)); 1.3.6. 6.修改seata-server-0.9.0\\seata\\conf目录下的registry.conf配置文件 12345678910registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; &#125; 目的是：指明注册中心为nacos，及修改nacos连接信息 1.3.7. 7.先启动Nacos端口号8848 1.3.8. 8.再启动seata-server · softs\\seata-server-0.9.0\\seata\\bin · seata-server.bat 1.4. 订单/库存/账户业务数据库准备1.4.1. 以下演示都需要先启动Nacos后启动Seata，保证两个都OK · Seata没启动报错no available server to connect 1.4.2. 分布式事务业务说明 · 业务说明 · 下订单–&gt;扣库存–&gt;减账户（余额） 1.4.3. 创建业务数据库 · seata_order: 存储订单的数据库 · seata_storage:存储库存的数据库 · seata_account: 存储账户信息的数据库 · 建表SQL 123456CREATE DATABASE seata_order； CREATE DATABASE seata_storage； CREATE DATABASE seata_account； 1.4.4. 按照上述3库分别建对应业务表 · seata_order库下建t_order表 1234567891011CREATE TABLE t_order( &#x27;id&#x27; BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, &#x27;user_id&#x27; BIGINT(11) DEFAULT NULL COMMENT &#x27;用户id&#x27;, &#x27;product_id&#x27; BIGINT(11) DEFAULT NULL COMMENT &#x27;产品id&#x27;, &#x27;count&#x27; INT(11) DEFAULT NULL COMMENT &#x27;数量&#x27;, &#x27;money&#x27; DECIMAL(11,0) DEFAULT NULL COMMENT &#x27;金额&#x27;, &#x27;status&#x27; INT(1) DEFAULT NULL COMMENT &#x27;订单状态：0：创建中; 1：已完结&#x27;) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; SELECT * FROM t_order; · seata_storage库下建t_storage表 12345678910111213CREATE TABLE t_storage( &#x27;id&#x27; BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, &#x27;product_id&#x27; BIGINT(11) DEFAULT NULL COMMENT &#x27;产品id&#x27;, &#x27;total&#x27; INT(11) DEFAULT NULL COMMENT &#x27;总库存&#x27;, &#x27;used&#x27; INT(11) DEFAULT NULL COMMENT &#x27;已用库存&#x27;, &#x27;residue&#x27; INT(11) DEFAULT NULL COMMENT &#x27;剩余库存&#x27;) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO seata_storage.t_storage(&#x27;id&#x27;,&#x27;product_id&#x27;,&#x27;total&#x27;,&#x27;used&#x27;,&#x27;residue&#x27;)VALUES(&#x27;1&#x27;,&#x27;1&#x27;,&#x27;100&#x27;,&#x27;0&#x27;,&#x27;100&#x27;); · seata_account库下建t_account表 1234567891011121314CREATE TABLE t_account( &#x27;id&#x27; BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;id&#x27;, &#x27;user_id&#x27; BIGINT(11) DEFAULT NULL COMMENT &#x27;用户id&#x27;, &#x27;total&#x27; DECIMAL(10,0) DEFAULT NULL COMMENT &#x27;总额度&#x27;, &#x27;used&#x27; DECIMAL(10,0) DEFAULT NULL COMMENT &#x27;已用余额&#x27;, &#x27;residue&#x27; DECIMAL(10,0) DEFAULT &#x27;0&#x27; COMMENT &#x27;剩余可用额度&#x27;) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO seata_account.t_account(&#x27;id&#x27;,&#x27;user_id&#x27;,&#x27;total&#x27;,&#x27;used&#x27;,&#x27;residue&#x27;) VALUES(&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1000&#x27;,&#x27;0&#x27;,&#x27;1000&#x27;) SELECT * FROM t_account; 1.4.5. 按照上述3库分别建对应的回滚日志表 · 订单-库存-账户3个库下都需要建各自的回滚日志表 · \\seata-server-0.9.0\\seata\\conf目录下的db_undo_log.sql · 建表SQL 123456789101112131415drop table `undo_log`;CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 1.4.6. 最终效果 1.5. 订单/库存/账户业务微服务准备1.5.1. 业务需求 · 下订单-&gt;减库存-&gt;扣余额-&gt;改（订单）状态 1.5.2. 新建订单Order-Module · 1.seata-order-service2001 · 2.POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web-actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql-druid--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; · 3.YML 1234567891011121314151617181920212223242526272829303132server: port: 2001 spring: application: name: seata-order-service cloud: alibaba: seata: #自定义事务组名称需要与seata-server中的对应 tx-service-group: fsp_tx_group nacos: discovery: server-addr: localhost:8848 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_order username: root password: 1111111 feign: hystrix: enabled: false logging: level: io: seata: info mybatis: mapperLocations: classpath:mapper/*.xml · 4.file.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143transport &#123; # tcp udt unix-domain-socket type = &quot;TCP&quot; #NIO NATIVE server = &quot;NIO&quot; #enable heartbeat heartbeat = true #thread factory for netty thread-factory &#123; boss-thread-prefix = &quot;NettyBoss&quot; worker-thread-prefix = &quot;NettyServerNIOWorker&quot; server-executor-thread-prefix = &quot;NettyServerBizHandler&quot; share-boss-worker = false client-selector-thread-prefix = &quot;NettyClientSelector&quot; client-selector-thread-size = 1 client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot; # netty boss thread size,will not be used for UDT boss-thread-size = 1 #auto default pin or 8 worker-thread-size = 8 &#125; shutdown &#123; # when destroy server, wait seconds wait = 3 &#125; serialization = &quot;seata&quot; compressor = &quot;none&quot;&#125; service &#123; vgroup_mapping.fsp_tx_group = &quot;default&quot; default.grouplist = &quot;127.0.0.1:8091&quot; enableDegrade = false disable = false max.commit.retry.timeout = &quot;-1&quot; max.rollback.retry.timeout = &quot;-1&quot; disableGlobalTransaction = false&#125; client &#123; async.commit.buffer.limit = 10000 lock &#123; retry.internal = 10 retry.times = 30 &#125; report.retry.count = 5 tm.commit.retry.count = 1 tm.rollback.retry.count = 1&#125; ## transaction log storestore &#123; ## store mode: file、db mode = &quot;db&quot; ## file store file &#123; dir = &quot;sessionStore&quot; # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size , if exceeded throws exceptions max-global-session-size = 512 # file buffer size , if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size = 100 # async, sync flush-disk-mode = async &#125; ## database store db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = &quot;dbcp&quot; ## mysql/oracle/h2/oceanbase etc. db-type = &quot;mysql&quot; driver-class-name = &quot;com.mysql.jdbc.Driver&quot; url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot; user = &quot;root&quot; password = &quot;123456&quot; min-conn = 1 max-conn = 3 global.table = &quot;global_table&quot; branch.table = &quot;branch_table&quot; lock-table = &quot;lock_table&quot; query-limit = 100 &#125;&#125;lock &#123; ## the lock store mode: local、remote mode = &quot;remote&quot; local &#123; ## store locks in user&#x27;s database &#125; remote &#123; ## store locks in the seata&#x27;s server &#125;&#125;recovery &#123; #schedule committing retry period in milliseconds committing-retry-period = 1000 #schedule asyn committing retry period in milliseconds asyn-committing-retry-period = 1000 #schedule rollbacking retry period in milliseconds rollbacking-retry-period = 1000 #schedule timeout retry period in milliseconds timeout-retry-period = 1000&#125; transaction &#123; undo.data.validation = true undo.log.serialization = &quot;jackson&quot; undo.log.save.days = 7 #schedule delete expired undo_log in milliseconds undo.log.delete.period = 86400000 undo.log.table = &quot;undo_log&quot;&#125; ## metrics settingsmetrics &#123; enabled = false registry-type = &quot;compact&quot; # multi exporters use comma divided exporter-list = &quot;prometheus&quot; exporter-prometheus-port = 9898&#125; support &#123; ## spring spring &#123; # auto proxy the DataSource bean datasource.autoproxy = false &#125;&#125; · 5.registry.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; &#125; eureka &#123; serviceUrl = &quot;http://localhost:8761/eureka&quot; application = &quot;default&quot; weight = &quot;1&quot; &#125; redis &#123; serverAddr = &quot;localhost:6379&quot; db = &quot;0&quot; &#125; zk &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; consul &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:8500&quot; &#125; etcd3 &#123; cluster = &quot;default&quot; serverAddr = &quot;http://localhost:2379&quot; &#125; sofa &#123; serverAddr = &quot;127.0.0.1:9603&quot; application = &quot;default&quot; region = &quot;DEFAULT_ZONE&quot; datacenter = &quot;DefaultDataCenter&quot; cluster = &quot;default&quot; group = &quot;SEATA_GROUP&quot; addressWaitTime = &quot;3000&quot; &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = &quot;file&quot; nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;&quot; &#125; consul &#123; serverAddr = &quot;127.0.0.1:8500&quot; &#125; apollo &#123; app.id = &quot;seata-server&quot; apollo.meta = &quot;http://192.168.1.204:8801&quot; &#125; zk &#123; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; etcd3 &#123; serverAddr = &quot;http://localhost:2379&quot; &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; · 6.domain · CommonResult 12345678910111213141516171819202122package com.atguigu.springcloud.alibaba.domain; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; @Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; · Order 12345678910111213141516171819202122232425262728package com.atguigu.springcloud.alibaba.domain; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; import java.math.BigDecimal; @Data@AllArgsConstructor@NoArgsConstructorpublic class Order&#123; private Long id; private Long userId; private Long productId; private Integer count; private BigDecimal money; private Integer status; //订单状态：0：创建中；1：已完结&#125; · 7.Dao接口及实现 · OrderDao 12345678910111213141516package com.atguigu.springcloud.alibaba.dao; import com.atguigu.springcloud.alibaba.domain.Order;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param; @Mapperpublic interface OrderDao&#123; //新建订单 void create(Order order); //修改订单状态，从零改为1 void update(@Param(&quot;userId&quot;) Long userId,@Param(&quot;status&quot;) Integer status);&#125; · resources文件夹下新建mapper文件夹后添加 · OrderMapper.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; &lt;mapper namespace=&quot;com.atguigu.springcloud.alibaba.dao.OrderDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.springcloud.alibaba.domain.Order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;count&quot; property=&quot;count&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;status&quot; property=&quot;status&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;insert id=&quot;create&quot;&gt; insert into t_order (id,user_id,product_id,count,money,status) values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0); &lt;/insert&gt; &lt;update id=&quot;update&quot;&gt; update t_order set status = 1 where user_id=#&#123;userId&#125; and status = #&#123;status&#125;; &lt;/update&gt; &lt;/mapper&gt; · 8.Service接口及实现 · OrderService 123456789package com.atguigu.springcloud.alibaba.service; import com.atguigu.springcloud.alibaba.domain.Order; public interface OrderService&#123; void create(Order order);&#125; · OrderServiceImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.springcloud.alibaba.service.impl; import com.atguigu.springcloud.alibaba.dao.OrderDao;import com.atguigu.springcloud.alibaba.domain.Order;import com.atguigu.springcloud.alibaba.service.AccountService;import com.atguigu.springcloud.alibaba.service.OrderService;import com.atguigu.springcloud.alibaba.service.StorageService;import io.seata.spring.annotation.GlobalTransactional;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service; import javax.annotation.Resource; @Service@Slf4jpublic class OrderServiceImpl implements OrderService&#123; @Resource private OrderDao orderDao; @Resource private StorageService storageService; @Resource private AccountService accountService; /** * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态 */ @Override @GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class) public void create(Order order)&#123; log.info(&quot;-----&gt;开始新建订单&quot;); //新建订单 orderDao.create(order); //扣减库存 log.info(&quot;-----&gt;订单微服务开始调用库存，做扣减Count&quot;); storageService.decrease(order.getProductId(),order.getCount()); log.info(&quot;-----&gt;订单微服务开始调用库存，做扣减end&quot;); //扣减账户 log.info(&quot;-----&gt;订单微服务开始调用账户，做扣减Money&quot;); accountService.decrease(order.getUserId(),order.getMoney()); log.info(&quot;-----&gt;订单微服务开始调用账户，做扣减end&quot;); //修改订单状态，从零到1代表已经完成 log.info(&quot;-----&gt;修改订单状态开始&quot;); orderDao.update(order.getUserId(),0); log.info(&quot;-----&gt;修改订单状态结束&quot;); log.info(&quot;-----&gt;下订单结束了&quot;); &#125;&#125; · StorageService 12345678910111213141516package com.atguigu.springcloud.alibaba.service; import com.atguigu.springcloud.alibaba.domain.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam; import java.math.BigDecimal; @FeignClient(value = &quot;seata-storage-service&quot;)public interface StorageService&#123; @PostMapping(value = &quot;/storage/decrease&quot;) CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId, @RequestParam(&quot;count&quot;) Integer count);&#125; · AccountService 123456789101112131415package com.atguigu.springcloud.alibaba.service; import com.atguigu.springcloud.alibaba.domain.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam; import java.math.BigDecimal; @FeignClient(value = &quot;seata-account-service&quot;)public interface AccountService&#123; @PostMapping(value = &quot;/account/decrease&quot;) CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125; · 9.Controller 12345678910111213141516171819202122232425package com.atguigu.springcloud.alibaba.controller; import com.atguigu.springcloud.alibaba.domain.CommonResult;import com.atguigu.springcloud.alibaba.domain.Order;import com.atguigu.springcloud.alibaba.service.OrderService;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestControllerpublic class OrderController&#123; @Resource private OrderService orderService; @GetMapping(&quot;/order/create&quot;) public CommonResult create(Order order) &#123; orderService.create(order); return new CommonResult(200,&quot;订单创建成功&quot;); &#125;&#125; · 10.Config配置 · MyBatisConfig 123456789101112package com.atguigu.springcloud.alibaba.config; import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration; @Configuration@MapperScan(&#123;&quot;com.atguigu.springcloud.alibaba.dao&quot;&#125;)public class MyBatisConfig &#123; &#125; · DataSourceProxyConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.springcloud.alibaba.config; import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource; @Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125; &#125; · 11.主启动 12345678910111213141516171819package com.atguigu.springcloud.alibaba; import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients; @EnableDiscoveryClient@EnableFeignClients@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)//取消数据源自动创建的配置public class SeataOrderMainApp2001&#123; public static void main(String[] args) &#123; SpringApplication.run(SeataOrderMainApp2001.class, args); &#125;&#125; 1.5.3. 新建库存Storage-Module · 1.seata-order-service2002 · 2.POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; · 3.YML 1234567891011121314151617181920212223242526server: port: 2002 spring: application: name: seata-storage-service cloud: alibaba: seata: tx-service-group: fsp_tx_group nacos: discovery: server-addr: localhost:8848 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_storage username: root password: 111111 logging: level: io: seata: info mybatis: mapperLocations: classpath:mapper/*.xml · 4.file.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475transport &#123; # tcp udt unix-domain-socket type = &quot;TCP&quot; #NIO NATIVE server = &quot;NIO&quot; #enable heartbeat heartbeat = true #thread factory for netty thread-factory &#123; boss-thread-prefix = &quot;NettyBoss&quot; worker-thread-prefix = &quot;NettyServerNIOWorker&quot; server-executor-thread-prefix = &quot;NettyServerBizHandler&quot; share-boss-worker = false client-selector-thread-prefix = &quot;NettyClientSelector&quot; client-selector-thread-size = 1 client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot; # netty boss thread size,will not be used for UDT boss-thread-size = 1 #auto default pin or 8 worker-thread-size = 8 &#125; shutdown &#123; # when destroy server, wait seconds wait = 3 &#125; serialization = &quot;seata&quot; compressor = &quot;none&quot;&#125; service &#123; #vgroup-&gt;rgroup vgroup_mapping.fsp_tx_group = &quot;default&quot; #only support single node default.grouplist = &quot;127.0.0.1:8091&quot; #degrade current not support enableDegrade = false #disable disable = false #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent max.commit.retry.timeout = &quot;-1&quot; max.rollback.retry.timeout = &quot;-1&quot; disableGlobalTransaction = false&#125; client &#123; async.commit.buffer.limit = 10000 lock &#123; retry.internal = 10 retry.times = 30 &#125; report.retry.count = 5 tm.commit.retry.count = 1 tm.rollback.retry.count = 1&#125; transaction &#123; undo.data.validation = true undo.log.serialization = &quot;jackson&quot; undo.log.save.days = 7 #schedule delete expired undo_log in milliseconds undo.log.delete.period = 86400000 undo.log.table = &quot;undo_log&quot;&#125; support &#123; ## spring spring &#123; # auto proxy the DataSource bean datasource.autoproxy = false &#125;&#125; · 5.registry.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556registry &#123; # file 、nacos 、eureka、redis、zk type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; &#125; eureka &#123; serviceUrl = &quot;http://localhost:8761/eureka&quot; application = &quot;default&quot; weight = &quot;1&quot; &#125; redis &#123; serverAddr = &quot;localhost:6381&quot; db = &quot;0&quot; &#125; zk &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; config &#123; # file、nacos 、apollo、zk type = &quot;file&quot; nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;&quot; cluster = &quot;default&quot; &#125; apollo &#123; app.id = &quot;fescar-server&quot; apollo.meta = &quot;http://192.168.1.204:8801&quot; &#125; zk &#123; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; · 6.domain · CommonResult 123456789101112131415161718192021package com.atguigu.springcloud.alibaba.domain; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; @Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; · Storage 12345678910111213141516171819202122232425package com.atguigu.springcloud.alibaba.domain; import lombok.Data; @Datapublic class Storage &#123; private Long id; // 产品id private Long productId; //总库存 private Integer total; //已用库存 private Integer used; //剩余库存 private Integer residue;&#125; · 7.Dao接口及实现 · StorageDao 12345678910111213package com.atguigu.springcloud.alibaba.dao; import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param; @Mapperpublic interface StorageDao &#123; //扣减库存信息 void decrease(@Param(&quot;productId&quot;) Long productId, @Param(&quot;count&quot;) Integer count);&#125; · resources文件夹下新建mapper文件夹后添加 · StorageMapper.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; &lt;mapper namespace=&quot;com.atguigu.springcloud.alibaba.dao.StorageDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.springcloud.alibaba.domain.Storage&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;used&quot; property=&quot;used&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;residue&quot; property=&quot;residue&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;update id=&quot;decrease&quot;&gt; UPDATE t_storage SET used = used + #&#123;count&#125;,residue = residue - #&#123;count&#125; WHERE product_id = #&#123;productId&#125; &lt;/update&gt; &lt;/mapper&gt; · 8.Service接口及实现 · StorageService 12345678package com.atguigu.springcloud.alibaba.service; public interface StorageService &#123; // 扣减库存 void decrease(Long productId, Integer count);&#125; · StorageServiceImpl 1234567891011121314151617181920212223242526272829package com.atguigu.springcloud.alibaba.service.impl; import com.atguigu.springcloud.alibaba.dao.StorageDao;import com.atguigu.springcloud.alibaba.service.StorageService ;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service; import javax.annotation.Resource; @Servicepublic class StorageServiceImpl implements StorageService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class); @Resource private StorageDao storageDao; // 扣减库存 @Override public void decrease(Long productId, Integer count) &#123; LOGGER.info(&quot;-------&gt;storage-service中扣减库存开始&quot;); storageDao.decrease(productId,count); LOGGER.info(&quot;-------&gt;storage-service中扣减库存结束&quot;); &#125;&#125; · 9.Controller 123456789101112131415161718192021222324package com.atguigu.springcloud.alibaba.controller; import com.atguigu.springcloud.alibaba.domain.CommonResult ;import com.atguigu.springcloud.alibaba.service.StorageService ;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class StorageController &#123; @Autowired private StorageService storageService; //扣减库存 @RequestMapping(&quot;/storage/decrease&quot;) public CommonResult decrease(Long productId, Integer count) &#123; storageService.decrease(productId, count); return new CommonResult(200,&quot;扣减库存成功！&quot;); &#125;&#125; · 10.Config配置 · MyBatisConfig 123456789101112package com.atguigu.springcloud.alibaba.config; import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration; @Configuration@MapperScan(&#123;&quot;com.atguigu.springcloud.alibaba.dao&quot;&#125;)public class MyBatisConfig &#123;&#125; · DataSourceProxyConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.springcloud.alibaba.config; import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import javax.sql.DataSource; @Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125; &#125; · 11.主启动 12345678910111213141516171819202122232425package com.atguigu.springcloud.alibaba; import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients; import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.concurrent.ForkJoinWorkerThread; @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableDiscoveryClient@EnableFeignClientspublic class SeataStorageServiceApplication2002&#123; public static void main(String[] args) &#123; SpringApplication.run(SeataStorageServiceApplication2002.class, args); &#125;&#125; 1.5.4. 新建账户Account-Module · 副主题 · 1.seata-order-service2003 · 2.POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; · 3.YML 123456789101112131415161718192021222324252627282930server: port: 2003 spring: application: name: seata-account-service cloud: alibaba: seata: tx-service-group: fsp_tx_group nacos: discovery: server-addr: localhost:8848 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_account username: root password: 1111111 feign: hystrix: enabled: false logging: level: io: seata: info mybatis: mapperLocations: classpath:mapper/*.xml · 4.file.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143transport &#123; # tcp udt unix-domain-socket type = &quot;TCP&quot; #NIO NATIVE server = &quot;NIO&quot; #enable heartbeat heartbeat = true #thread factory for netty thread-factory &#123; boss-thread-prefix = &quot;NettyBoss&quot; worker-thread-prefix = &quot;NettyServerNIOWorker&quot; server-executor-thread-prefix = &quot;NettyServerBizHandler&quot; share-boss-worker = false client-selector-thread-prefix = &quot;NettyClientSelector&quot; client-selector-thread-size = 1 client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot; # netty boss thread size,will not be used for UDT boss-thread-size = 1 #auto default pin or 8 worker-thread-size = 8 &#125; shutdown &#123; # when destroy server, wait seconds wait = 3 &#125; serialization = &quot;seata&quot; compressor = &quot;none&quot;&#125; service &#123; vgroup_mapping.fsp_tx_group = &quot;default&quot; #修改自定义事务组名称 default.grouplist = &quot;127.0.0.1:8091&quot; enableDegrade = false disable = false max.commit.retry.timeout = &quot;-1&quot; max.rollback.retry.timeout = &quot;-1&quot; disableGlobalTransaction = false&#125; client &#123; async.commit.buffer.limit = 10000 lock &#123; retry.internal = 10 retry.times = 30 &#125; report.retry.count = 5 tm.commit.retry.count = 1 tm.rollback.retry.count = 1&#125; ## transaction log storestore &#123; ## store mode: file、db mode = &quot;db&quot; ## file store file &#123; dir = &quot;sessionStore&quot; # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size , if exceeded throws exceptions max-global-session-size = 512 # file buffer size , if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size = 100 # async, sync flush-disk-mode = async &#125; ## database store db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = &quot;dbcp&quot; ## mysql/oracle/h2/oceanbase etc. db-type = &quot;mysql&quot; driver-class-name = &quot;com.mysql.jdbc.Driver&quot; url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot; user = &quot;root&quot; password = &quot;123456&quot; min-conn = 1 max-conn = 3 global.table = &quot;global_table&quot; branch.table = &quot;branch_table&quot; lock-table = &quot;lock_table&quot; query-limit = 100 &#125;&#125;lock &#123; ## the lock store mode: local、remote mode = &quot;remote&quot; local &#123; ## store locks in user&#x27;s database &#125; remote &#123; ## store locks in the seata&#x27;s server &#125;&#125;recovery &#123; #schedule committing retry period in milliseconds committing-retry-period = 1000 #schedule asyn committing retry period in milliseconds asyn-committing-retry-period = 1000 #schedule rollbacking retry period in milliseconds rollbacking-retry-period = 1000 #schedule timeout retry period in milliseconds timeout-retry-period = 1000&#125; transaction &#123; undo.data.validation = true undo.log.serialization = &quot;jackson&quot; undo.log.save.days = 7 #schedule delete expired undo_log in milliseconds undo.log.delete.period = 86400000 undo.log.table = &quot;undo_log&quot;&#125; ## metrics settingsmetrics &#123; enabled = false registry-type = &quot;compact&quot; # multi exporters use comma divided exporter-list = &quot;prometheus&quot; exporter-prometheus-port = 9898&#125; support &#123; ## spring spring &#123; # auto proxy the DataSource bean datasource.autoproxy = false &#125;&#125; · 5.registry.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; &#125; eureka &#123; serviceUrl = &quot;http://localhost:8761/eureka&quot; application = &quot;default&quot; weight = &quot;1&quot; &#125; redis &#123; serverAddr = &quot;localhost:6379&quot; db = &quot;0&quot; &#125; zk &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; consul &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:8500&quot; &#125; etcd3 &#123; cluster = &quot;default&quot; serverAddr = &quot;http://localhost:2379&quot; &#125; sofa &#123; serverAddr = &quot;127.0.0.1:9603&quot; application = &quot;default&quot; region = &quot;DEFAULT_ZONE&quot; datacenter = &quot;DefaultDataCenter&quot; cluster = &quot;default&quot; group = &quot;SEATA_GROUP&quot; addressWaitTime = &quot;3000&quot; &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = &quot;file&quot; nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;&quot; &#125; consul &#123; serverAddr = &quot;127.0.0.1:8500&quot; &#125; apollo &#123; app.id = &quot;seata-server&quot; apollo.meta = &quot;http://192.168.1.204:8801&quot; &#125; zk &#123; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; etcd3 &#123; serverAddr = &quot;http://localhost:2379&quot; &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125; · 6.domain · CommonResult 12345678910111213141516171819202122package com.atguigu.springcloud.alibaba.domain; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; @Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; · Account 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.springcloud.alibaba.domain; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; import java.math.BigDecimal; @Data@AllArgsConstructor@NoArgsConstructorpublic class Account &#123; private Long id; /** * 用户id */ private Long userId; /** * 总额度 */ private BigDecimal total; /** * 已用额度 */ private BigDecimal used; /** * 剩余额度 */ private BigDecimal residue;&#125; · 7.Dao接口及实现 · AccountDao 123456789101112131415161718package com.atguigu.springcloud.alibaba.dao; import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository; import java.math.BigDecimal; @Mapperpublic interface AccountDao &#123; /** * 扣减账户余额 */ void decrease(@Param(&quot;userId&quot;) Long userId, @Param(&quot;money&quot;) BigDecimal money);&#125; · resources文件夹下新建mapper文件夹后添加 · AccountMapper.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; &lt;mapper namespace=&quot;com.atguigu.springcloud.alibaba.dao.AccountDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.springcloud.alibaba.domain.Account&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;used&quot; property=&quot;used&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;residue&quot; property=&quot;residue&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;/resultMap&gt; &lt;update id=&quot;decrease&quot;&gt; UPDATE t_account SET residue = residue - #&#123;money&#125;,used = used + #&#123;money&#125; WHERE user_id = #&#123;userId&#125;; &lt;/update&gt; &lt;/mapper&gt; · 8.Service接口及实现 · AccountService 1234567891011121314151617package com.atguigu.springcloud.alibaba.service; import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody; import java.math.BigDecimal; public interface AccountService &#123; /** * 扣减账户余额 */ void decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125; · AccountServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.springcloud.alibaba.service.impl; import com.atguigu.springcloud.alibaba.dao.AccountDao;import com.atguigu.springcloud.alibaba.service.AccountService ;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service; import javax.annotation.Resource;import java.math.BigDecimal;import java.util.concurrent.TimeUnit; /** * 账户业务实现类 */@Servicepublic class AccountServiceImpl implements AccountService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AccountServiceImpl.class); @Resource AccountDao accountDao; /** * 扣减账户余额 */ @Override public void decrease(Long userId, BigDecimal money) &#123; LOGGER.info(&quot;-------&gt;account-service中扣减账户余额开始&quot;); try &#123; TimeUnit.SECONDS.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; accountDao.decrease(userId,money); LOGGER.info(&quot;-------&gt;account-service中扣减账户余额结束&quot;); &#125;&#125; · 9.Controller 12345678910111213141516171819202122232425262728package com.atguigu.springcloud.alibaba.controller; import com.atguigu.springcloud.alibaba.domain.CommonResult ;import com.atguigu.springcloud.alibaba.service.AccountService ;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource;import java.math.BigDecimal; @RestControllerpublic class AccountController &#123; @Resource AccountService accountService; /** * 扣减账户余额 */ @RequestMapping(&quot;/account/decrease&quot;) public CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money)&#123; accountService.decrease(userId,money); return new CommonResult(200,&quot;扣减账户余额成功！&quot;); &#125;&#125; · 10.Config配置 · MyBatisConfig 1234567891011package com.atguigu.springcloud.alibaba.config; import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration; @Configuration@MapperScan(&#123;&quot;com.atguigu.springcloud.alibaba.dao&quot;&#125;)public class MyBatisConfig &#123; &#125; · DataSourceProxyConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.springcloud.alibaba.config; import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import javax.sql.DataSource; @Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125; &#125; · 11.主启动 123456789101112131415161718192021package com.atguigu.springcloud.alibaba; import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableDiscoveryClient@EnableFeignClientspublic class SeataAccountMainApp2003&#123; public static void main(String[] args) &#123; SpringApplication.run(SeataAccountMainApp2003.class, args); &#125;&#125; 1.6. Test1.6.1. 下订单-&gt;减库存-&gt;扣余额-&gt;改（订单）状态 1.6.2. 数据库初始情况 1.6.3. 正常下单 · http://localhost:2001/order/create?userid=1&amp;producrid=1&amp;counr=10&amp;money=100 · 数据库情况 1.6.4. 超时异常，没加@GlobalTransactional · AccountServiceImpl添加超时 · 数据库情况 · 故障情况 · 当库存和账户余额扣减后，订单状态并没有设置为已经完成，没有从零改为1 · 而且由于feign的重试机制，账户余额还有可能被多次扣减 1.6.5. 超时异常，添加@GlobalTransactional · AccountServiceImpl添加超时 · OrderServiceImpl@GlobalTransactional · 下单后数据库数据并没有任何改变 · 记录都添加不进来 1.7. Seata之原理简介1.7.1. Seata · 2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案 · Simple Extensible Autonomous Transaction Architecture,简单可扩展自治事务框架 · 2020起初，参加工作后用1.0以后的版本 1.7.2. 再看TC/TM/RM三大组件 · 分布式事务的执行流程 · TM开启分布式事务(TM向TC注册全局事务记录) · 换业务场景，编排数据库，服务等事务内资源（RM向TC汇报资源准备状态） · TM结束分布式事务，事务一阶段结束（TM通知TC提交/回滚分布式事务） · TC汇总事务信息，决定分布式事务是提交还是回滚 · TC通知所有RM提交/回滚资源，事务二阶段结束。 1.7.3. AT模式如何做到对业务的无侵入 · 是什么 · 一阶段加载 · 二阶段提交 · 二阶段回滚 1.7.4. debug 1.7.5. 补充","categories":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://stary2020.gitee.io/tags/SpringCloud/"}],"author":null},{"title":"多设备协同工作","slug":"default-2021-07-29-phoneAndCloud","date":"2021-07-29T10:54:09.000Z","updated":"2021-08-20T06:32:28.572Z","comments":true,"path":"2021/07/29/default-2021-07-29-phoneAndCloud/","link":"","permalink":"http://stary2020.gitee.io/2021/07/29/default-2021-07-29-phoneAndCloud/","excerpt":"","text":"概述设备协调物理设备平板，华为账号 手机，华为账号(荣耀) 笔记本，联想系 手机重置核心XyKey， 备忘录， 便签， nian， 华为主题， 软件第一屏:网易云，网易账号同步 微信，电脑备份 QQ，无需备份，(说说导出待，整理QQ收藏)，注意三个号 系统工具:需要备份主题文件::备份至华为云空间”备份”目录 常用:图库开启自动备份， 彩云天气，使用7037账号登录 一键锁屏功能， 支付宝，无需备份，注意三个账号。 起点读书，无需备份，2517304640账号登录 第二屏:必须:PU口袋校园，账号:147 WPS，账号:同微信 百度网盘，账号147 学习通，账号XyKey ==XyKey，无账号，备份至华为云空间”备份”目录== ==nian，无账号，备份至华为云空间”备份”目录== ==便签，账号XyKey，备份至坚果云== ==阅读，账号XyKey，备份至坚果云== ES文件浏览器，无账号，P版，备份至华为云空间”备份”目录 YES PDF，无账号，阅读器 哔哩哔哩，账号，147，密码不详 酷安，账号XyKey 非必须建设银行，手机登录， 钉钉，现阶段不怎么用，支付宝账号， 学小易，账号随意 交管12123，账号XyKey 微博，QQ账号登录 墨墨背单词，微信账号 每日英语听力，华为账号 云闪付，账号XyKey 知乎，微信账号 Code+，坚果云备份 牛客，账号XyKey 第三屏工具箱:QMD，下载音乐，备份至华为云空间”备份”目录 手机性能排行榜，备份至华为云空间”备份”目录 坚果云，账号XyKey IDM+，下载器，备份至华为云空间”备份”目录 v2ray，备份至华为云空间”备份”目录 人工桌面，酷安取 李跳跳，酷安取 古典诗词，微信账号登录 其他:腾讯地图，QQ登录 掌上营业厅，中国移动，手机认证登录 白马地图，无需登录， VMOS pro，??P版，备份至华为云空间”备份”目录 Mx，无账号 携程，账号XyKey 淘宝，账号支付宝， 腾讯视频，QQ登录，PS:25 央视频，微信登录 Edge，账号XyKey，微软账号 京东，微信登录 实习僧，手机认证登录 应用宝，不登录 饿了么，手机认证 TapTap，微信登录 第四屏想不想修真，华为账号 王者荣耀 文件图片，自动同步 音乐，电脑+U盘+百度网盘+华为云空间，以云空间数据为主 文档，文档存于电脑，定期备份至百度网盘， 其他备忘录自动备份， 电脑重置概述软件基础浏览器：Chrome，装c盘，打开v2，链接，然后登录Chrome账号，自动同步，将预先备份的tampermonkey从Google云盘恢复，浏览器部分OK，附加：更新edge，下载firefox 解压软件：Bandizip，必需，重新安装，删除旧文件夹 视频播放软件：potplayer，非必需， office：2016合集+2019visiowps可替代， 编辑器：notepad++，或editplus 输入法：搜狗？ 安全：火绒 VMware：必需 腾讯系：tim，微信，软件管家？ 下载：Xdown，迅雷，百度网盘 辅助，非必需，格式工厂，护眼宝translucentTB软媒魔方设置大师ccleanocameverythingeDiaryw3cschooltrays截屏：Snipaste 生产力远程连接：xshell，mobaxterm 开发环境：java8java14Python微软常用库 开发ideidea 2021eclipsevscodeMATLABmysql","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"快捷键设置","slug":"tools-2021-07-27-keySoon","date":"2021-07-27T02:52:59.000Z","updated":"2021-08-19T02:34:15.411Z","comments":true,"path":"2021/07/27/tools-2021-07-27-keySoon/","link":"","permalink":"http://stary2020.gitee.io/2021/07/27/tools-2021-07-27-keySoon/","excerpt":"","text":"搜狗输入法半角&amp;全角设置，中文输入法下使用英文字符（对编程极度友好），但是在英文字符中打不出顿号。 折中方案，设置自定义标点设置，将需要的、常用的设置成英文标点，保留部分。注意区分全角半角。 将常用的双引号、方括号和反引号、逗号设置成英文半角,编程常用,保留顿号,句号。在中文里常用。 网易云配置全局快捷键: 仅保留播放上一曲,下一曲三个操作","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"面试题","slug":"java-2021-07-23-faceQuestions","date":"2021-07-23T12:56:06.000Z","updated":"2021-08-19T02:33:47.169Z","comments":true,"path":"2021/07/23/java-2021-07-23-faceQuestions/","link":"","permalink":"http://stary2020.gitee.io/2021/07/23/java-2021-07-23-faceQuestions/","excerpt":"","text":"五、JVM IO 面向字符的IO流：保证字符的呈现形式相同，不管什么编码，输出的“汉字”保持不变。 面向字节的IO流：不改变IO过程中的0、1顺序，适合于图片、音频等文件 i++ 类型转换 程序结构 java面试题，第二季 0、java基础集合Map的实现类12345Map:双列数据，存储key value数据HashMap:作为map主要实现类,线程不安全的，效率高,可存储null的key和valueLinkedHashMap:线程安全的，对于频繁遍历操作，此类执行效率高于HashMapTreeMap:保证按照添加的key value对进行排序，实现排序遍历Hashtable:作为古老的实现类，线程安全，效率低,不可存储null的key和value 1.hashMap的底层实现原理：先以JDK7为例说明： 1、HashMap map = new HashMap(); 2、在实例化以后，底层创建了长度是16的一维数组，这个数组的类型是Entry[]，数组名字是table 3、map.put(key1,value 1); 4、首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry[]数组中的存放位置 5、如果此位置上的数据为空，此时的key1-value1添加成功 —情况1 6、如果此位置上的数据不为空，意味着此位置上存在一个或多个数据（以链表的形式存在），比较key1和已经存在的一个或多个数据的哈希值： 7、如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功 —- 情况2 8、如果key1的哈希值和已经存在的某个数据（key2-value2）的哈希值相同，继续比较，调用key1所在类的equals(key2) 9、 如果equals()返回false:此时key1-value1添加成功 —–情况3 10 如果equals()返回true:使用value1的值来替换value2的值 11、关于情况2和情况3，此时key1-value1和原来的数据以链表的方式存储数据 12、在不断的添加过程中，会涉及到扩容问题，默认的扩容方式是：扩容为原来容量的2倍，并扩容完以后，将原有的数据复制过来。 JDK8 jdk8相较于jdk7在底层实现方面的不同: 1.一开始当我们new HashMap的时候，底层并没有帮我们创建一个长度为16的数组 2.jdk8底层的数组不再叫Entry[]的数组，而是叫Node[]数组 3.首次调用put()方式时，底层创建长度为16的数组 4.jdk7的底层结构只有数组+链表，在jdk8当中的底层结构是数组+链表+红黑树 1、什么时候涉及到红黑树？答：当数组的某一个索引位置上的元素以链表形式存在的数据个数大于8且当前数组的长度大于64时 2、此时此索引位置上的所有数据改为使用红黑树来存储。 2、谈谈你对HashMap中put/get方法的认识，如果了解再谈谈HashMap的扩容机制，默认大小是多少？什么是负载因子（或填充比）？ 1、JUC多线程及并发包 JUC多线程及并发包 1.java.util.concurrent。 concurrent是并发的意思 2.java.util.concurrent.atomic。 atomic 是原子性的意思 3.java.util.concurrent.locks。 locks是锁的意思 volatile1.谈谈你对volatile的理解答: 1.volatile是Java虚拟机提供的轻量级的同步机制，是基本上遵守了JMM的规范，主要是保证可见性和禁止指令重排，但是它并不保证原子性 2.volatile主要有以下三大特性： 保证可见性 不保证原子性 禁止指令重排 JMMJMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式. JMM关于同步规定: 1.线程解锁前,必须把共享变量的值刷新回主内存 2.线程加锁前,必须读取主内存的最新值到自己的工作内存 3.加锁解锁是同一把锁 由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图: 可见性通过前面对JMM的介绍,我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的. 这就可能存在一个线程AAA修改了共享变量X的值还未写回主内存中时 ,另外一个线程BBB又对内存中的一个共享变量X进行操作,但此时A线程工作内存中的共享比那里X对线程B来说并不不可见.这种工作内存与主内存同步延迟现象就造成了可见性问题. 其意思就是多个线程中从主内存拷贝值到各自线程的工作内存，若有一个线程改了当前拷贝过来的这个值，并将修改好的值返回给了主内存，那么此时其他线程不知道这个线程已经把值改了，此时必须要有一种机制，只要有一个线程修改完自己的工作内存的值，并写回给主内存以后要及时通知其他线程，这样即使通知的这种情况，就是JMM内存模型里面第一个重要特性：俗称：可见性。 较为官方的解释JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式. JMM关于同步规定:1.线程解锁前,必须把共享变量的值刷新回主内存2.线程加锁前,必须读取主内存的最新值到自己的工作内存3.加锁解锁是同一把锁 由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图: 可见性面试题那你写一个Demo来证明一下什么叫保证了可见性？ 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.TimeUnit;class MyData&#123; //volatile就是增强了主线程和线程的可见性 volatile int number = 0; public void addTO60()&#123; this.number = 60; &#125;&#125;/** * 1.验证volatile的可见性 * 1.1 假如int number = 0; number变量之前没有添加volatile关键字修饰，没有可见性 * */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData();//线程操作资源类 new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;\\t come in&quot;); //线程暂停3秒钟 try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; //3秒钟以后将把0改为60 myData.addTO60(); System.out.println(Thread.currentThread().getName()+&quot;\\t updated number value:&quot;+myData.number); &#125;,&quot;AAA&quot;).start(); //第二个线程就是我们的main线程 while (myData.number == 0)&#123; //main主线程就一直在这里等待循环，直到number不再等于零 &#125; //若这句话打印出来了，说明main主线程感知到了number的值发生了变化，那么此时可见性就会被触发 System.out.println(Thread.currentThread().getName()+&quot;\\t mission is over,main get number value:&quot;+myData.number); //这个是main线程 &#125;&#125; 原子性JAVA内存模型（JMM）要求保证原子性，但是volatile是不保证原子性的 number++在多线程下是非线程安全的,如何不加synchronized解决? 原子性的案例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.TimeUnit;class MyData&#123; //volatile就是增强了主线程和线程的可见性 volatile int number = 0; public void addTO60()&#123; this.number = 60; &#125; //请注意，此时number前面是加了volatile关键字修饰的，volatile不保证原子性 public void addPlusPlus()&#123; number++; &#125;&#125;/** * 1.验证volatile的可见性 * 1.1 假如int number = 0; number变量之前没有添加volatile关键字修饰，没有可见性 * 1.2 添加了volatile，可以解决可见性问题 * * 2.验证volatile不保证原子性 * 2.1 原子性是什么意思？ 其实就是看最终一致性能不能保证 * 不可分割，完整性， * 也即某个线程正在做某个业务业务的时候，中间不可以被加塞或者被分割，需要整体完整。 * 要么同时成功，要么同时失败。 * * 2.2 volatile不保证原子性的案例演示 * * 2.3 volatile为什么不能保证原子性? * */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData(); for (int i = 1; i &lt;=20 ; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;=1000 ; j++) &#123; myData.addPlusPlus(); &#125; &#125;,String.valueOf(i)).start(); &#125; //需要等待上面20个线程都全部计算完成后，再用main线程取得最终的结果值，看是多少 while (Thread.activeCount()&gt;2)&#123; //说明线程还没有算完 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;\\t finally number value: &quot;+myData.number); &#125;&#125; 如何解决原子性？1.可以加synchronized来解决不保证原子性问题，但是不推荐使用 2.可以使用java.util.concurrent.atomic包下的AtomicInteger(带原子性包装的整型类)来解决不保证原子性问题 解决方案的具体代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;class MyData&#123; //volatile就是增强了主线程和线程的可见性 volatile int number = 0; public void addTO60()&#123; this.number = 60; &#125; //请注意，此时number前面是加了volatile关键字修饰的，volatile不保证原子性 public void addPlusPlus()&#123; number++; &#125; AtomicInteger atomicInteger =new AtomicInteger(); public void addMyAtomic()&#123; atomicInteger.getAndIncrement(); &#125;&#125;/** * 1.验证volatile的可见性 * 1.1 假如int number = 0; number变量之前没有添加volatile关键字修饰，没有可见性 * 1.2 添加了volatile，可以解决可见性问题 * * 2.验证volatile不保证原子性 * 2.1 原子性是什么意思？ 其实就是看最终一致性能不能保证 * 不可分割，完整性， * 也即某个线程正在做某个业务业务的时候，中间不可以被加塞或者被分割，需要整体完整。 * 要么同时成功，要么同时失败。 * * 2.2 volatile不保证原子性的案例演示 * * 2.3 volatile为什么不能保证原子性? * * 2.4 如何解决原子性？ * * 1.可以加synchronized来解决不保证原子性问题，但是不推荐使用 * * 2.可以使用java.util.concurrent.atomic包下的AtomicInteger(带原子包装的整型类)来解决不保证原子性问题 * * */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData(); for (int i = 1; i &lt;=20 ; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;=1000 ; j++) &#123; myData.addPlusPlus(); //不保证原子性 myData.addMyAtomic(); //保证原子性 &#125; &#125;,String.valueOf(i)).start(); &#125; //需要等待上面20个线程都全部计算完成后，再用main线程取得最终的结果值，看是多少 while (Thread.activeCount()&gt;2)&#123; //说明线程还没有算完 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;\\t int type, finally number value: &quot;+myData.number); System.out.println(Thread.currentThread().getName()+&quot;\\t AtomicInteger type, finally number value: &quot;+myData.atomicInteger); &#125; &#125; 原子性面试题： volatile为什么不能保证原子性？而且为什么每次一运行的话，它的值都低于2w呢？答：因为有很多值在putfield这步写回去的时候可能线程的调度被挂起了，刚好也没有收到最新值的通知，有这么一个纳秒级别的时间差，一写就出现了写覆盖，就把人家的值覆盖掉了 凭啥加了AtomicInteger这个就能解决不能保证原子性问题？AtomicInteger这个玩意它的底层原理知道吗？答：知道，AtomicInteger底层是CAS 那再跟我解释一下什么是CAS？ VolatileDemo代码演示可见性+原子性代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.hhf.java8.jvm;import java.util.concurrent.TimeUnit;class MyData&#123; //volatile就是增强了主线程和线程的可见性 volatile int number = 0; public void addTO60()&#123; this.number = 60; &#125; //请注意，此时number前面是加了volatile关键字修饰的，volatile不保证原子性 public void addPlusPlus()&#123; number++; &#125;&#125;/** * 1.验证volatile的可见性 * 1.1 假如int number = 0; number变量之前没有添加volatile关键字修饰，没有可见性 * 1.2 添加了volatile，可以解决可见性问题 * * 2.验证volatile不保证原子性 * 2.1 原子性是什么意思？ 其实就是看最终一致性能不能保证 * 不可分割，完整性， * 也即某个线程正在做某个业务业务的时候，中间不可以被加塞或者被分割，需要整体完整。 * 要么同时成功，要么同时失败。 * * 2.2 volatile不保证原子性的案例演示 * * 2.3 volatile为什么不能保证原子性? */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData(); for (int i = 1; i &lt;=20 ; i++) &#123; new Thread(()-&gt;&#123; for (int j = 1; j &lt;=1000 ; j++) &#123; myData.addPlusPlus(); &#125; &#125;,String.valueOf(i)).start(); &#125; //需要等待上面20个线程都全部计算完成后，再用main线程取得最终的结果值，看是多少 while (Thread.activeCount()&gt;2)&#123; //说明线程还没有算完 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+&quot;\\t finally number value: &quot;+myData.number); &#125; //可以保证可见性，及时通知其他线程 private static void seeOkByVolatile() &#123; MyData myData = new MyData();//线程操作资源类 new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;\\t come in&quot;); //线程暂停3秒钟 try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; //3秒钟以后将把0改为60 myData.addTO60(); System.out.println(Thread.currentThread().getName()+&quot;\\t updated number value:&quot;+myData.number); &#125;,&quot;AAA&quot;).start(); //第二个线程就是我们的main线程 while (myData.number == 0)&#123; //main主线程就一直在这里等待循环，直到number不再等于零 &#125; //若这句话打印出来了，说明main主线程感知到了number的值发生了变化，那么此时可见性就会被触发 System.out.println(Thread.currentThread().getName()+&quot;\\t mission is over,main get number value:&quot;+myData.number); //这个是main线程 &#125;&#125; 有序性计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排,一把分为以下3种 1源代码=》编译器优化的重排=》指令并行的重排=》内存系统的重排=》最终执行的指令 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致. 处理器在进行重新排序是必须要考虑指令之间的数据依赖性 多线程环境中线程交替执行,由于编译器优化重排的存在,两个线程使用的变量能否保持一致性是无法确定的,结果无法预测 重排1 123456789public void mySort()&#123; int x=11;//语句1 int y=12;//语句2 x=x+5;//语句3 y=x*x;//语句4&#125;123421341324 问题: 请问语句4 可以重排后变成第一条码?存在数据的依赖性，没办法排到第一个 重排2 int a ,b ,x,y=0; 线程1 线程2 x=a; y=b; b=1; a=2; x=0 y=0 如果编译器对这段代码进行执行重排优化后,可能出现下列情况: 线程1 线程2 b=1; a=2; x=a; y=b; x=2 y=1 这也就说明在多线程环境下,由于编译器优化重排的存在,两个线程使用的变量能否保持一致是无法确定的. 禁止指令重排小总结(了解) 12345volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象先了解一个概念，内存屏障(Memory Barrier)又称内存栅栏，是一个CPU指令，它的作用有两个:一是保证特定操作的执行顺序二是保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令重排优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本 3.你在哪些地方用到过volatile?单例模式DCL代码 12345678910111213141516171819202122232425262728293031public class SingletonDemo &#123; private static volatile SingletonDemo instance=null; private SingletonDemo()&#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 构造方法&quot;); &#125; /** * 双重检测机制 * @return */ public static SingletonDemo getInstance()&#123; if(instance==null)&#123; synchronized (SingletonDemo.class)&#123; if(instance==null)&#123; instance=new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; for (int i = 1; i &lt;=10; i++) &#123; new Thread(() -&gt;&#123; SingletonDemo.getInstance(); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 代理模式volatile分析 DCL(双端检锁) 机制不一定线程安全,原因是有指令重排的存在,加入volatile可以禁止指令重排 原因在于某一个线程在执行到第一次检测,读取到的instance不为null时,instance的引用对象可能没有完成初始化. 1234instance=new SingletonDem(); 可以分为以下步骤(伪代码)memory=allocate();//1.分配对象内存空间instance(memory);//2.初始化对象instance=memory;//3.设置instance的指向刚分配的内存地址,此时instance!=null 步骤2和步骤3不存在数据依赖关系.而且无论重排前还是重排后程序执行的结果在单线程中并没有改变,因此这种重排优化是允许的. 123memory=allocate();//1.分配对象内存空间instance=memory;//3.设置instance的指向刚分配的内存地址,此时instance!=null 但对象还没有初始化完.instance(memory);//2.初始化对象 但是指令重排只会保证串行语义的执行一致性(单线程) 并不会关心多线程间的语义一致性 所以当一条线程访问instance不为null时,由于instance实例未必完成初始化,也就造成了线程安全问题. 单例模式volatile代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SingletonDemo &#123; /** * 加上volatile来禁止指令重排，就能保证多线程间的语义一致性 * 若不加，那么就会在某一次就会导致线程不安全的问题 */ private static volatile SingletonDemo instance = null; private SingletonDemo()&#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 我是构造方法SingletonDemo()&quot;); &#125; //DCL(双端检索机制) private static SingletonDemo getInstance()&#123; if (instance == null)&#123; //加锁前 synchronized (SingletonDemo.class)&#123; //用同步代码块，进行加锁 if (instance == null)&#123; //加锁后 instance = new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; //单线程（main线程的操作动作。。。。。。。。。。）// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());// System.out.println(SingletonDemo.getInst ance() == SingletonDemo.getInstance());// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance()); //System.out.println(); //并发多线程后 情况发生了很大的变化 for (int i = 1; i &lt;=10 ; i++) &#123; new Thread(()-&gt;&#123; SingletonDemo.getInstance(); &#125;,String.valueOf(i)).start(); &#125; &#125; 加上volatile来禁止指令重排，就能保证多线程间的语义一致性，若不加，那么就会在某一次就会导致线程不安全的问题 如果在高并发多线程的版本里面，那么此时的单例模式最终的写法就是： 1.加入双端检锁机制（也即加入同步代码块） 2.在需要单例的这个对象前面加入volatile来禁止指令重排。 CAS2.CAS你知道吗CAS的两句话概括： 1.如果线程的期望值跟物理内存的真实值一样，就更新值到物理内存当中，并返回true 2.如果线程的期望值跟物理内存的真实值不一样，返回是false，那么本次修改失败，那么此时需要重新获得主物理内存的新值 1.比较并交换 CASDemo代码 12345678910111213141516/** * Description * * @author veliger@163.com * @version 1.0 * @date 2019-04-12 9:57 * 1.什么是CAS ? ===&gt; compareAndSet * 比较并交换 **/public class CASDemo &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(5); System.out.println(atomicInteger.compareAndSet(5, 2019)+&quot;\\t current&quot;+atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(5, 2014)+&quot;\\t current&quot;+atomicInteger.get()); &#125;&#125; 2.CAS底层原理?如果知道,谈谈你对UnSafe的理解· atomicInteger.getAndIncrement(); atomicInteger.getAndIncrement()方法的源代码: 123456789/** * Atomically increments by one the current value. * * @return the previous value */public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 引出来一个问题:UnSafe类是什么? UnSafe 1.UnSafe 是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法. 注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务 2.变量ValueOffset,便是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的 3.变量value和volatile修饰,保证了多线程之间的可见性. CAS是什么 CAS的全称为Compare-And-Swap ,它是一条CPU并发原语. 它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,这个过程是原子的. CAS并发原语提现在Java语言中就是sun.miscUnSaffe类中的各个方法.调用UnSafe类中的CAS方法,JVM会帮我实现CAS汇编指令.这是一种完全依赖于硬件 功能,通过它实现了原子操作,再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题. unSafe.getAndIncrement 假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上): 1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存. 2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这是线程A被挂起. 3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改内存的值为4 线程B打完收工 一切OK. 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了. 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功. 底层汇编 简单版小总结 123456CAS(CompareAndSwap)比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。CAS应用CAS有三个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 底层原理详解 1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存. 2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这是线程A被挂起. 3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改内存的值为4 线程B打完收工 一切OK. 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了. 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功 原子整形之所以在i++这种多线程的环境下面，不用加synchronized，就凭着底层的Unsafe类也能来保证原子性，来保证线程安全，是因为Unsafe是CAS的核心类，CAS是比较并交换 因为Unsafe类是根据内存偏移地址来获取数据的 3.CAS缺点 多次比较循环时间长开销很大 只能保证一个共享变量的原子性 引出来ABA问题??? 二句话讲述： 1、synchronized加锁，一致性保证，并发性下降 2、CAS不加锁，保证一致性，但是它需要多次比较，耗时时间长，开销很大。 3.原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗ABA问题的产生 1234CAS会导致&quot;ABA&quot;问题。CAS算法实现一个重要的前提需要取出内存中某时刻的数据并在当下时刻比较替换，那么在这个时间差内会导致数据的变化。比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，如何线程two又将V位置的数据变成了A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功尽管线程one的CAS操作成功，但是不代表这个过程是没有问题的。 原子引用 时间戳原子引用 ABAdemo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Description: ABA问题的解决 * * @author veliger@163.com * @date 2019-04-12 21:30 **/public class ABADemo &#123; private static AtomicReference&lt;Integer&gt; atomicReference=new AtomicReference&lt;&gt;(100); private static AtomicStampedReference&lt;Integer&gt; stampedReference=new AtomicStampedReference&lt;&gt;(100,1); public static void main(String[] args) &#123; System.out.println(&quot;===以下是ABA问题的产生===&quot;); new Thread(()-&gt;&#123; atomicReference.compareAndSet(100,101); atomicReference.compareAndSet(101,100); &#125;,&quot;t1&quot;).start(); new Thread(()-&gt;&#123; //先暂停1秒 保证完成ABA try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicReference.compareAndSet(100, 2019)+&quot;\\t&quot;+atomicReference.get()); &#125;,&quot;t2&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;===以下是ABA问题的解决===&quot;); new Thread(()-&gt;&#123; int stamp = stampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+&quot;\\t 第1次版本号&quot;+stamp+&quot;\\t值是&quot;+stampedReference.getReference()); //暂停1秒钟t3线程 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; stampedReference.compareAndSet(100,101,stampedReference.getStamp(),stampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+&quot;\\t 第2次版本号&quot;+stampedReference.getStamp()+&quot;\\t值是&quot;+stampedReference.getReference()); stampedReference.compareAndSet(101,100,stampedReference.getStamp(),stampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+&quot;\\t 第3次版本号&quot;+stampedReference.getStamp()+&quot;\\t值是&quot;+stampedReference.getReference()); &#125;,&quot;t3&quot;).start(); new Thread(()-&gt;&#123; int stamp = stampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+&quot;\\t 第1次版本号&quot;+stamp+&quot;\\t值是&quot;+stampedReference.getReference()); //保证线程3完成1次ABA try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean result = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1); System.out.println(Thread.currentThread().getName()+&quot;\\t 修改成功否&quot;+result+&quot;\\t最新版本号&quot;+stampedReference.getStamp()); System.out.println(&quot;最新的值\\t&quot;+stampedReference.getReference()); &#125;,&quot;t4&quot;).start(); &#125; 规避ABA，解决ABA问题 就是新增一种机制，那就是增加时间戳，当时间戳跟要对比的时间戳不一致的话，就说明这个数据在中间被修改过 4.我们知道ArrayList是线程不安全,请编写一个不安全的案例并给出解决方案ContainerNotSafeDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354** * Description: 集合类不安全的问题 * * @author veliger@163.com * @date 2019-04-12 22:15 **/public class ContainerNotSafeDemo &#123; /** * 笔记 * 写时复制 copyOnWrite 容器即写时复制的容器 往容器添加元素的时候,不直接往当前容器object[]添加,而是先将当前容器object[]进行 * copy 复制出一个新的object[] newElements 然后向新容器object[] newElements 里面添加元素 添加元素后, * 再将原容器的引用指向新的容器 setArray(newElements); * 这样的好处是可以对copyOnWrite容器进行并发的读,而不需要加锁 因为当前容器不会添加任何容器.所以copyOnwrite容器也是一种 * 读写分离的思想,读和写不同的容器. * public boolean add(E e) &#123; * final ReentrantLock lock = this.lock; * lock.lock(); * try &#123; * Object[] elements = getArray(); * int len = elements.length; * Object[] newElements = Arrays.copyOf(elements, len + 1); * newElements[len] = e; * setArray(newElements); * return true; * &#125; finally &#123; * lock.unlock(); * &#125; * &#125; * @param args */ public static void main(String[] args) &#123; List&lt;String&gt; list= new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;=30; i++) &#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(1,8)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; /** * 1.故障现象 * java.util.ConcurrentModificationException * 2.导致原因 * 并发争抢修改导致 * 3.解决方案 * 3.1 new Vector&lt;&gt;() * 3.2 Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3.3 new CopyOnWriteArrayList&lt;&gt;(); * * * 4.优化建议 */ &#125; 限制不可以使用vector和Collections工具类解决方案2 List线程copyOnWriteArrayList set线程CopyOnwriteHashSet map线程ConcurrentHashMap 集合的全部讲解代码 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.CopyOnWriteArraySet;public class ContainerNotSafeDemo &#123; public static void main(String[] args) &#123; Map&lt;String,Object&gt; map =new ConcurrentHashMap&lt;&gt;(); for (int i = 1; i &lt;=30 ; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0, 8)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125; private static void setNotSafe() &#123; Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 1; i &lt;=30 ; i++) &#123; new Thread(() -&gt; &#123; set.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(set); &#125;, String.valueOf(i)).start(); &#125; &#125; private static void listNotSafe() &#123; List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); //写时复制技术 for (int i = 1; i &lt;=30 ; i++) &#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 锁5.公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解?请手写一个自旋锁公平锁和非公平锁是什么 公平锁、是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到 非公平锁、是指在多个线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象 两者的区别 公平锁/非公平锁 并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁 1234关于两者的区别:公平锁。Threads acqulre a falr lock in the order which they requested it。就是很公平，在并发环境中，每个线程都在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己非公平锁:a nonfair lock permits barging threads requesting a lock can jump ahead of the queue of waiting threads if the lock happens to be available when it is requested。非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。 题外话 Java ReentrantLock而言, 通过构造哈数指定该锁是否是公平锁 默认是非公平锁 非公平锁的优点在于吞吐量必公平锁大. 对于synchronized而言 也是一种非公平锁. 可重入锁(又名递归锁)是什么 123可重入锁，也叫递归锁指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁也即是说，线程可以进入任何一个它已经拥有的锁所同步者的代码块。 ReentrantLock/synchronized就是一个典型的可重入锁 可重入锁最大的作用就是避免死锁 ReenterLockDemo 参考1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.atguigu.interview.study.thread;class Phone&#123; public synchronized void sendSms() throws Exception&#123; System.out.println(Thread.currentThread().getName()+&quot;\\tsendSms&quot;); sendEmail(); &#125; public synchronized void sendEmail() throws Exception&#123; System.out.println(Thread.currentThread().getName()+&quot;\\tsendEmail&quot;); &#125;&#125;/** * Description: * 可重入锁(也叫做递归锁) * 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码 * 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁 * * 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块 * * @author veliger@163.com * @date 2019-04-12 23:36 **/public class ReenterLockDemo &#123; /** * t1 sendSms * t1 sendEmail * t2 sendSms * t2 sendEmail * @param args */ public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(()-&gt;&#123; try &#123; phone.sendSms(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;t1&quot;).start(); new Thread(()-&gt;&#123; try &#123; phone.sendSms(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;t2&quot;).start(); &#125;&#125; 参考2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.atguigu.interview.study.thread;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Phone implements Runnable &#123; private Lock lock = new ReentrantLock(); @Override public void run() &#123; get(); &#125; private void get() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;\\tget&quot;); set(); &#125; finally &#123; lock.unlock(); &#125; &#125; private void set() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;\\tset&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;/** * Description: * 可重入锁(也叫做递归锁) * 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码 * 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁 * &lt;p&gt; * 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块 * * @author veliger@163.com * @date 2019-04-12 23:36 **/public class ReenterLockDemo &#123; /** * Thread-0 get * Thread-0 set * Thread-1 get * Thread-1 set * * @param args */ public static void main(String[] args) &#123; Phone phone = new Phone(); Thread t3 = new Thread(phone); Thread t4 = new Thread(phone); t3.start(); t4.start(); &#125;&#125; 自旋锁12自旋锁(spinlock)是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这时候的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU SpinLockDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102```### 独占锁(写)/共享锁(读)/互斥锁```java/** * 资源类 */class MyCaChe &#123; /** * 保证可见性 */ private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(); /** * 写 * * @param key * @param value */ public void put(String key, Object value) &#123; reentrantReadWriteLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t正在写入&quot; + key); //模拟网络延时 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); System.out.println(Thread.currentThread().getName() + &quot;\\t正在完成&quot;); &#125; finally &#123; reentrantReadWriteLock.writeLock().unlock(); &#125; &#125; /** * 读 * * @param key */ public void get(String key) &#123; reentrantReadWriteLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t正在读取&quot;); //模拟网络延时 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object result = map.get(key); System.out.println(Thread.currentThread().getName() + &quot;\\t正在完成&quot; + result); &#125; finally &#123; reentrantReadWriteLock.readLock().unlock(); &#125; &#125; public void clearCaChe() &#123; map.clear(); &#125;&#125;/** * Description: * 多个线程同时操作 一个资源类没有任何问题 所以为了满足并发量 * 读取共享资源应该可以同时进行 * 但是 * 如果有一个线程想去写共享资源来 就不应该有其他线程可以对资源进行读或写 * &lt;p&gt; * 小总结: * 读 读能共存 * 读 写不能共存 * 写 写不能共存 * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断 * * @author veliger@163.com * @date 2019-04-13 0:45 **/public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCaChe myCaChe = new MyCaChe(); for (int i = 1; i &lt;= 5; i++) &#123; final int temp = i; new Thread(() -&gt; &#123; myCaChe.put(temp + &quot;&quot;, temp); &#125;, String.valueOf(i)).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; myCaChe.get(finalI + &quot;&quot;); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 读写锁6.CountDownLatch/CyclicBarrier/Semaphore使用过吗?CountDownLatch让一些线程阻塞直到另外一些完成后才被唤醒 CountDownLatch主要有两个方法,当一个或多个线程调用await方法时,调用线程会被阻塞.其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行 CountDownLatchDemo 关门案例 12345678910111213141516171819202122232425public class CountDownLatchDemo &#123; public static void main(String[] args) throws Exception &#123; closeDoor(); &#125; /** * 关门案例 * @throws InterruptedException */ private static void closeDoor() throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;上完自习&quot;); countDownLatch.countDown(); &#125;, String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName() + &quot;\\t班长锁门离开教室&quot;); &#125; &#125; 枚举的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Description * 枚举的使用 * * @author veliger@163.com * @version 1.0 * @date 2019-04-13 10:14 **/public enum CountryEnum &#123; /** * */ ONE(1, &quot;齐&quot;), /** * */ TWO(2, &quot;楚&quot;), /** * */ THREE(3, &quot;燕&quot;), /** * */ FOUR(4, &quot;赵&quot;), /** * */ FIVE(5, &quot;魏&quot;), /** * */ SIX(6, &quot;韩&quot;); CountryEnum(Integer code, String name) &#123; this.code = code; this.name = name; &#125; @Getter private Integer code; @Getter private String name; public static CountryEnum forEach(int index) &#123; CountryEnum[] countryEnums = CountryEnum.values(); for (CountryEnum countryEnum : countryEnums) &#123; if (index == countryEnum.getCode()) &#123; return countryEnum; &#125; &#125; return null; &#125;&#125; 秦灭六国 12345678910111213141516171819202122232425public class CountDownLatchDemo &#123; public static void main(String[] args) throws Exception &#123; sixCountry(); &#125; /** * 秦灭六国 一统华夏 * @throws InterruptedException */ private static void sixCountry() throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;国,灭亡&quot;); countDownLatch.countDown(); &#125;, CountryEnum.forEach(i).getName()).start(); &#125; countDownLatch.await(); System.out.println(&quot;秦统一&quot;); &#125; &#125; CyclicBarrierCyclicBarrier的字面意思是可循环(Cyclic) 使用的屏障(barrier).它要做的事情是,让一组线程到达一个屏障(也可以叫做同步点)时被阻塞,知道最后一个线程到达屏障时,屏障才会开门,所有被屏障拦截的线程才会继续干活,线程进入屏障通过CyclicBarrier的await()方法. CyclicBarrierDemo 12345678910111213141516171819202122public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()-&gt;&#123; System.out.println(&quot;召唤神龙&quot;); &#125;); for (int i = 1; i &lt;=7; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 收集到第&quot;+ temp +&quot;颗龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; Semaphore信号量的主要用户两个目的,一个是用于多喝共享资源的相互排斥使用,另一个用于并发资源数的控制. SemaphoreDemo 123456789101112131415161718192021222324252627282930313233343536/** * Description * * @author veliger@163.com * @version 1.0 * @date 2019-04-13 11:08 **/public class SemaphoreDemo &#123; public static void main(String[] args) &#123; //模拟3个停车位 Semaphore semaphore = new Semaphore(3); //模拟6部汽车 for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; try &#123; //抢到资源 semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;\\t抢到车位&quot;); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t 停3秒离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 semaphore.release(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 7.阻塞队列知道吗?队列+阻塞队列阻塞队列,顾名思义,首先它是一个队列,而一个阻塞队列在数据结构中所起的作用 线程1往阻塞队列中添加元素二线程2从队列中移除元素 当阻塞队列是空时,从队列中获取元素的操作将会被阻塞. 当阻塞队列是满时,往队列中添加元素的操作将会被阻塞. 同样 试图往已满的阻塞队列中添加新圆度的线程同样也会被阻塞,知道其他线程从队列中移除一个或者多个元素或者全清空队列后使队列重新变得空闲起来并后续新增. 为什么用?有什么好处? 在多线程领域:所谓阻塞,在某些情况下会挂起线程(即线程阻塞),一旦条件满足,被挂起的线程优惠被自动唤醒 为什么需要使用BlockingQueue 好处是我们不需要关心什么时候需要阻塞线程,什么时候需要唤醒线程,因为BlockingQueue都一手给你包办好了 在concurrent包 发布以前,在多线程环境下,我们每个程序员都必须自己去控制这些细节,尤其还要兼顾效率和线程安全,而这会给我们的程序带来不小的复杂度. BlockingQueue的核心方法 方法类型 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e,time,unit) 移除 remove() poll() take() poll(time,unit) 检查 element() peek() 不可用 不可用 抛出异常 当阻塞队列满时,再往队列里面add插入元素会抛IllegalStateException: Queue full 当阻塞队列空时,再往队列Remove元素时候回抛出NoSuchElementException 特殊值 插入方法,成功返回true 失败返回false 移除方法,成功返回元素,队列里面没有就返回null 一直阻塞 当阻塞队列满时,生产者继续往队列里面put元素,队列会一直阻塞直到put数据or响应中断退出 当阻塞队列空时,消费者试图从队列take元素,队列会一直阻塞消费者线程直到队列可用. 超时退出 当阻塞队列满时,队列会阻塞生产者线程一定时间,超过后限时后生产者线程就会退出 架构梳理+种类分析 架构介绍 种类分析 12345ArrayBlockingQueue: 由数组结构组成的有界阻塞队列.LinkedBlockingQueue: 由链表结构组成的有界(但大小默认值Integer&gt;MAX_VALUE)阻塞队列.PriorityBlockingQueue:支持优先级排序的无界阻塞队列.DelayQueue: 使用优先级队列实现的延迟无界阻塞队列.SynchronousQueue:不存储元素的阻塞队列,也即是单个元素的队列. 理论 SynchronousQueue没有容量 与其他BlcokingQueue不同,SynchronousQueue是一个不存储元素的BlcokingQueue 每个put操作必须要等待一个take操作,否则不能继续添加元素,反之亦然. SynchronousQueueDemo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Description * 阻塞队列SynchronousQueue演示 * * @author veliger@163.com * @version 1.0 * @date 2019-04-13 13:49 **/public class SynchronousQueueDemo &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t put 1&quot;); blockingQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName() + &quot;\\t put 2&quot;); blockingQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName() + &quot;\\t put 3&quot;); blockingQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;AAA&quot;).start(); new Thread(() -&gt; &#123; try &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + blockingQueue.take()); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + blockingQueue.take()); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + blockingQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;BBB&quot;).start(); &#125;&#125; LinkedTransferQueue:由链表结构组成的无界阻塞队列. LinkedBlockingDeque:由了解结构组成的双向阻塞队列 用在哪里 生产者消费者模式 传统版 ProdConsumerTraditionDemo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.hhf.interview.study.thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ShareData&#123; private int number = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); //加 public void increment()throws Exception &#123; lock.lock(); try&#123; //1.判断 while (number != 0)&#123; //等待，不能生产 condition.await(); &#125; //2.干活 number++; System.out.println(Thread.currentThread().getName()+&quot;\\t&quot;+number); //3.通知唤醒 condition.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; //减 public void decrement()throws Exception &#123; lock.lock(); try&#123; //1.判断 while (number == 0)&#123; //等待，不能生产 condition.await(); &#125; //2.干活 number--; System.out.println(Thread.currentThread().getName()+&quot;\\t&quot;+number); //3.通知唤醒 condition.signalAll(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;/** * * 传统的消费者和生产者Demo * 题目：一个初始值为零的变量，两个线程对其交替操作，一个加一个减一，来五轮 */public class ProdConsumer_TraditionDemo &#123; public static void main(String[] args) &#123; ShareData shareData = new ShareData(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;=5 ; i++) &#123; try &#123; shareData.increment();//增加 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;AAA&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;=5 ; i++) &#123; try &#123; shareData.decrement();//减 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;BBB&quot;).start(); &#125;&#125; 阻塞队列版 ProdConsumerBlockQueueDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.hhf.interview.study.thread;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;/** * @author: hhf * @create: 2020-05-07 17:03 * * valatile/cas/atomicInteger/BlockQueue/线程交互/原子引用整合的生产者消费者案例 **/class MyResource&#123; private volatile boolean FLAG = true; //默认开启，进行生产+消费 private AtomicInteger atomicInteger = new AtomicInteger(); BlockingQueue&lt;String&gt; blockingQueue = null; public MyResource(BlockingQueue&lt;String&gt; blockingQueue) &#123; this.blockingQueue = blockingQueue; System.out.println(blockingQueue.getClass().getName()); &#125; //生产者 public void MyProd() throws Exception&#123; String data = null; boolean retValue ; //默认是false while (FLAG) &#123; //往阻塞队列填充数据 data = atomicInteger.incrementAndGet()+&quot;&quot;;//等于++i的意思 retValue = blockingQueue.offer(data,2L, TimeUnit.SECONDS); if (retValue)&#123; //如果是true，那么代表当前这个线程插入数据成功 System.out.println(Thread.currentThread().getName()+&quot;\\t插入队列&quot;+data+&quot;成功&quot;); &#125;else &#123; //那么就是插入失败 System.out.println(Thread.currentThread().getName()+&quot;\\t插入队列&quot;+data+&quot;失败&quot;); &#125; TimeUnit.SECONDS.sleep(1); &#125; //如果FLAG是false了，马上打印 System.out.println(Thread.currentThread().getName()+&quot;\\t大老板叫停了，表示FLAG=false,生产结束&quot;); &#125; //消费者 public void MyConsumer() throws Exception &#123; String result = null; while (FLAG) &#123; //开始消费 //两秒钟等不到生产者生产出来的数据就不取了 result = blockingQueue.poll(2L,TimeUnit.SECONDS); if (null == result || result.equalsIgnoreCase(&quot;&quot;))&#123; //如果取不到数据了 FLAG = false; System.out.println(Thread.currentThread().getName()+&quot;\\t 超过两秒钟没有取到数据，消费退出&quot;); System.out.println(); System.out.println(); return;//退出 &#125; System.out.println(Thread.currentThread().getName()+&quot;\\t消费队列数据&quot;+result+&quot;成功&quot;); &#125; &#125; //叫停方法 public void stop() throws Exception&#123; this.FLAG = false; &#125;&#125;public class ProdConsumer_BlockQueueDemo &#123; public static void main(String[] args) throws Exception&#123; MyResource myResource = new MyResource(new ArrayBlockingQueue&lt;&gt;(10)); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 生产线程启动&quot;); try &#123; myResource.MyProd(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;Prod&quot;).start(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 消费线程启动&quot;); System.out.println(); System.out.println(); try &#123; myResource.MyConsumer(); System.out.println(); System.out.println(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;Consumer&quot;).start(); try &#123; TimeUnit.SECONDS.sleep(5); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; System.out.println(); System.out.println(); System.out.println(); System.out.println(&quot;5秒钟时间到，大bossMain主线程叫停，活动结束&quot;); myResource.stop(); &#125;&#125; 线程池 消息中间件 8.请您说说synchronized和Lock的区别？用lock有什么好处？synchronized1、synchronized是JVM层面，它是JAVA的关键字 2、synchronized是不需要手动释放锁，当synchronized代码执行完以后，系统会自动让线程释放对锁的占用 3、synchronized不能中断，除非是抛出了异常或者是正常执行完成 4、synchronized是非公平锁 5、synchronized不支持精确唤醒，只能随机唤醒或者是唤醒全部线程 Lock1、Lock是API层面的具体类，它是java5以后新出的一个类 2、lock就需要手动去释放锁，若没有主动的去释放锁，就可能导致死锁的现象 3、lock是可以中断的，主要是设置超时的方法， 4、lock默认是非公平锁，但是也支持公平锁 5、lock可支持精确唤醒 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152```用lock的好处就是：lock可以支持锁绑定多个Condition，进行精确唤醒，并且还可中断lock#### 9.已经有Runnable接口，为什么还要出现Callable接口？请你谈谈它的诞生的前身背景？1、因为并发，异步导致Callable接口的出现2、主要是用Callable，能够实现当多个任务执行当中，若有一个任务完成的耗时时间比较长3、那么可以先将其他任务先完成，然后等待这个耗时比较长的任务结束以后一起进行总的计算#### 10.线程池用过吗?ThreadPoolExecutor谈谈你的理解?为什么使用线程池,优势线程池做的工作主要是控制运行的线程的数量,处理过程中将任务加入队列,然后在线程创建后启动这些任务,如果先生超过了最大数量,超出的数量的线程排队等候,等其他线程执行完毕,再从队列中取出任务来执行.他的主要特点为:线程复用:控制最大并发数:管理线程.第一:降低资源消耗.通过重复利用自己创建的线程降低线程创建和销毁造成的消耗.第二: 提高响应速度.当任务到达时,任务可以不需要等到线程和粗昂就爱你就能立即执行.第三: 提高线程的可管理性.线程是稀缺资源,如果无限的创阿金,不仅会消耗资源,还会较低系统的稳定性,使用线程池可以进行统一分配,调优和监控.#### 线程池如何使用?架构实现Java中的线程池是通过Executor框架实现的,该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这几个类.编码实现了解Executors.newCachedThreadPool();java8新出Executors.newWorkStealingPool(int);java8新增,使用目前机器上可以的处理器作为他的并行级别重点Executors.newFixedThreadPool(int)主要特点如下: 1.创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.2.newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是 相等的,它使用的的LinkedBlockingQueue固定线程数的线程池，执行一个长期的任务,性能好很多 12345Executors.newSingleThreadExecutor()主要特点如下: 1.创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.2.newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1,它使用的的LinkedBlockingQueue一池一线程，一个任务一个线程执行的任务场景 12345Executors.newCachedThreadPool() 主要特点如下: 1.创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.2.newCachedThreadPool将corePoolSize设置为0MaxmumPoolSize设置为Integer.*MAX_VALUE*,它使用的是SynchronousQUeue,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程一池多线程，可扩容，带缓冲缓存的，适用:执行很多短期异步的小程序或者负载较轻的服务器 123456789101112131415161718192021222324252627282930313233ThreadPoolExecutor线程池几个重要参数介绍?7大参数![image-20210815103623389](2021-07-23-faceQuestions/image-20210815103623389.png)1.corePoolSize:线程池中的常驻核心线程数1.在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近视理解为今日当值线程2.当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中.2.maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于13.keepAliveTime:多余的空闲线程存活时间,当空间时间达到keepAliveTime值时,多余的线程会被销毁直到只剩下corePoolSize个线程为止默认情况下:只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,知道线程中的线程数不大于corepoolSIze,4.unit:keepAliveTime的单位5.workQueue:任务队列,被提交但尚未被执行的任务.6.threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可7.handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大显示 数(maxnumPoolSize)时如何来拒绝.#### 说说线程池的底层工作原理? 1.在创建了线程池后，等待提交过来的任务请求。2.当调用execute()方法添加一个请求任务时，线程池会做如下判断， 1、如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务 2、如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列 3、如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务 4、如果这时候队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。3.当一个线程完成任务时，它会从队列中取下中取下一个任务来执行。4.当一个线程无事可做超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程会被停掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116更加容易理解的工作原理解释1.假设一开始只有两个核心线程（既corePoolSize），请求的数量也只能两个，但在后面请求的数量越来越多，在队列（既BlockingQueue）这里等待的人爆满了2.那么maximumPool就会开启最大非核心线程数来进行处理请求的数量，但是若在BlockingQueue这里等待的人已经爆满了，最大线程数和队列都爆满了，3.那么handler就会开始拒绝其他正在大量的请求进来。4.如果后期慢慢的请求量越来越少，也即请求量的数量开始少于目前线程的数量，那么此时线程池就会开始对目前已经空余的线程进行一段时间的等待， 若此时这等待的时间中，无再有更多更大量的请求量进来，也即现在来的请求数量里只需核心线程就能够处理的话，那么就会把多余的线程进行销毁，直至剩下两个核心线程（既corePoolSize）。#### 线程池用过吗?生产上你是如何设置合理参数线程池的拒绝策略请你谈谈是什么等待队列也已经排满了,再也塞不下新的任务了同时，线程池的max也到达了,无法接续为新任务服务，这时我们需要拒绝策略机制合理的处理这个问题.JDK内置的拒绝策略AbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行CallerRunPolicy:&quot;调用者运行&quot;一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者，从而降低新任务的流量。DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交当前任务DiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的一种拒绝策略方案以上内置策略均实现了RejectExecutionHandler接口#### 你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑答案是一个都不用,我们生产上只能使用自定义的线程池，也即手写线程池Executors中JDK给你提供了，为什么不用?参考阿里巴巴java开发手册【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：Executors返回的线程池对象的弊端如下：1）FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。2）CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。#### 你在工作中是如何创建线程池的,是否自定义过线程池使用```javapackage com.hhf.interview.study.thread;import java.util.concurrent.*;/** * @author: hhf * @create: 2020-05-08 09:34 * * ThreadPoolExecutor * 第四种获得/使用java多线程的方式，线程池 **/public class MyThreadPoolDemo &#123; public static void main(String[] args) &#123; /** * 手写线程池 */ ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardPolicy()); //最多几个人来办理业务，线程池会爆？ try&#123; //模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程 for (int i = 1; i &lt;=15 ; i++) &#123; threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 办理业务&quot;); &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; threadPool.shutdown(); &#125; &#125; /** * jdk自带的线程池 */ private static void threadPoolInit() &#123; // System.out.println(Runtime.getRuntime().availableProcessors()); ExecutorService threadPool = Executors.newFixedThreadPool(5);//一池5个处理线程 //ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个处理线程 //ExecutorService threadPool = Executors.newCachedThreadPool();//一池N个处理线程 try&#123; //模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程 for (int i = 1; i &lt;=10 ; i++) &#123; threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;\\t 办理业务&quot;); &#125;); try &#123; TimeUnit.MILLISECONDS.sleep(200); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 合理配置线程池你是如何考虑的?CPU密集型 System.out.println(Runtime.getRuntime().availableProcessors());查看CPU核数 12345CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)而在单核CPU上，无论开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那些。CPU密集型任务配置尽可能少的线程数量:一般公式:CPU核数+1个线程的线程池。 IO密集型 1、由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2 2、 1234567IO密集型，即该任务需要大量的IO，即大量的阻塞在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待所以在IO密集型任务中使用多线程可以大大的加速程序的运行，即是在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞实践。IO密集型时，大部分线程都阻塞，顾需要配置多线程数:参考公式:CPU核数/1-阻塞系数，阻塞系数在0.8-0.9之间比如8核CPU:8/1-0.9=80个线程数 1、看公司业务是CPU密集型还是IO密集型的，这两种不一样，来决定线程池线程数的最佳合理配置数 2、先查看服务器是几核的，调用Runtime.getRuntime().availableProcessors()这个方法来查看核数。 死锁编码及定位分析是什么 1死锁是指两个或两个以上的进程在执行过程中，因争夺资源而操作的一种互相等待的现象，若无外力干涉，那他们都将无法推进下去。如果系统资源足够充足，进程的资源请求都能得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 产生死锁的主要原因 123系统资源不足进程运行推进的顺序不合适资源分配不当 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class HoldThread implements Runnable &#123; private String lockA; private String lockB; public HoldThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t 自己持有锁&quot; + lockA + &quot;尝试获得&quot; + lockB); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t 自己持有锁&quot; + lockB + &quot;尝试获得&quot; + lockA); &#125; &#125; &#125;&#125;/** * Description: * 死锁是指两个或者以上的进程在执行过程中, * 因争夺资源而造成的一种相互等待的现象, * 若无外力干涉那他们都将无法推进下去 * * @author veliger@163.com * @date 2019-04-14 0:05 **/public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = &quot;lockA&quot;; String lockB = &quot;lockB&quot;; new Thread(new HoldThread(lockA, lockB), &quot;threadAAA&quot;).start(); new Thread(new HoldThread(lockB, lockA), &quot;threadBBB&quot;).start(); &#125;&#125; 解决 jps命令定位进程编号 jstack找到死锁查看 多线程常问面试题创建多线程的方式有多少种？答：创建多线程的方式以前有两种，现在有四种。 .start()以后是不是马上就启动这个线程？答： 不是 因为多线程是跟操作系统有关系的，一旦.start()以后这个线程就变成了就绪状态 那什么时候运行这个.start()方法？ 答：不知道的，这个要等待CPU操作系统的底层调度通知 JAVA多线程有几种状态？NEW 新建 RUNNABLE, 就绪，可运行 BLOCKED, 阻塞 什么时候进入到这个阻塞状态？ Thread.sleep();和t1.wait();都会导致阻塞，那么请说说他们之间的区别？ wait/sleep 功能都是当前线程暂停，有什么区别？ wait放开手去睡，放开手里的锁 不放权 sleep握紧手去睡，醒了手里还有锁 放权 WAITING, 一直等 TIMED_WAITING 设置时间的等 TIMED_WAITING和WAITING,的区别： 答:在于一个没有设置时间，一个设置了时间 TERMINATED 接口能不能new？可以new，创建匿名内部类 接口里面能不能有方法的实现？在java8以前是不可以的，但是在java8以后就支持了 java8之前规定接口里面只允许有方法的声明，不能有方法的实现，但是java8以后允许有部分的方法实现 说说你对lock的理解？答：Lock是跟Condition配合起来用的，精准通知，精准唤醒 多线程的8锁 8锁的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.TimeUnit;class Phone&#123; public static synchronized void sendEmail()throws Exception&#123; //tsleep try &#123; TimeUnit.SECONDS.sleep(4); &#125;catch (Exception e) &#123;e.printStackTrace();&#125; System.out.println(&quot;-----sendEmail&quot;); &#125; public synchronized void sendSMS()throws Exception&#123; System.out.println(&quot;-----sendSMS&quot;); &#125; public void hello()&#123; System.out.println(&quot;-----hello&quot;); &#125;&#125;/** * 多线程8锁 * 1.标准访问：请问先打印邮件还是短信？ //先打印邮件 * 2.邮件方法暂停4秒钟 请问先打印邮件还是短信？ 先打印邮件 * 3.新增一个普通方法hello()，请问先打印邮件还是hello？ 先打印hello * 4.有两部手机，请问先打印邮件还是短信？ 先打印短信 * 5.两个静态同步方法，同一部手机，请问先打印邮件还是短信？ 先打印邮件 * 6.两个静态同步方法，两部手机，请问先打印邮件还是短信？ 先打印邮件 * 7.一个普通同步方法,一个静态同步方法，一部手机，请问先打印邮件还是短信？ 先打印短信 * 8.一个普通同步方法,一个静态同步方法，两部手机，请问先打印邮件还是短信？ 先打印短信 */public class Lock8 &#123; public static void main(String[] args) throws Exception&#123; Phone phone = new Phone(); Phone phone2 = new Phone(); new Thread(() -&gt; &#123; try &#123; phone.sendEmail(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;A&quot;).start(); Thread.sleep(100); new Thread(() -&gt; &#123; try &#123; //phone.sendSMS(); // phone.hello(); phone2.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,&quot;B&quot;).start(); &#125;&#125; 1.标准访问：请问先打印邮件还是短信？ 解答：先打印邮件 Relationship 一个对象里面如果有多个synchronized方法，那么在某一时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待 换句话说，某一时刻内，只能有唯一一个线程去访问这些synchronized方法，锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法 - points to 解答：先打印邮件 2.邮件方法暂停4秒钟 请问先打印邮件还是短信？ 解答：先打印邮件 Relationship 一个对象里面如果有多个synchronized方法，那么在某一时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待 ，换句话说，某一时刻内，只能有唯一一个线程去访问这些synchronized方法，锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法 - begins at 解答：先打印邮件 3.新增一个普通方法hello()，请问先打印邮件还是hello？ 答：先打印hello，因为加个普通方法后发现和同步锁无关 4.有两部手机，请问先打印邮件还是短信？ 答：先打印短信 因为换成两个对象后，不是同一把锁了，情况就立刻发生变化 5.两个静态同步方法，同一部手机，请问先打印邮件还是短信？ 答：先打印邮件，因为都换成静态同步方法后，情况又变化 6.两个静态同步方法，两部手机，请问先打印邮件还是短信？ 答：先打印邮件 7.一个普通同步方法,一个静态同步方法，一部手机，请问先打印邮件还是短信？ 答：先打印短信 8.一个普通同步方法,一个静态同步方法，两部手机，请问先打印邮件还是短信？ 答：先打印短信 创建多线程的区别Runnable和Callable接口的区别在哪？ ·答；方法不同，一个叫run方法无泛型并无返回值并且不带异常，一个叫call带有泛型并有返回值且带异常 为啥Runnable好端端的不用，用Callable接口？ 为什么要用CAS，而不是用synchronized？1、synchronized加锁，同一时间段只允许有一个线程来访问，一致性确实得到了保障，但是并发性下降 2、用CAS的话，是没有加锁的，可以反复的通过CAS进行比较，直到比较成功为止，这样既保证了一致性又提高了并发性 其他集合等的常问面试题集合类安全与不安全 ArrayList是线程不安全的 如何解决？ 答：使用CopyOnWriteArrayList来解决 扩容 ArrayList扩容到原来的一半 Vector是线程安全的。它是线程安全的，能保证数据的一致性，但是性能慢 HashMap是线程不安全 如何解决？ 答：使用ConcurrentHashMap来解决 怎么优化HashMap? 可以把它的hash值设大一点来避免原始的扩容 HashSet是线程不安全 如何解决？ 答：使用CopyOnWriteArraySet解决 请说一下你遇过的印象深刻的故障java.util.ConcurrentModificationException 俗称：并发修改异常 原理： CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后新的容器Object[] newElements里添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements);。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器 导致的原因？ 因为ArrayList.add线程是不安全的，并发的时候，没加锁 解决方案： 1、用 Vector来解决 它是线程安全的，能保证数据的一致性，但是性能慢 2、 Collections.synchronizedList(new ArrayList&lt;&gt;()); 把线程不安全的ArrayList转换成线程安全的 小数据量的时候可以用这种解决方案 3、 用CopyOnWriteArrayList来解决， 性能很高（优先推荐） 请告诉我五个常见的java异常 我主要在高并发多线程的电商系统里面遇到过java.util.ConcurrentModificationException这种并发修改异常 请问HashSet底层数据结构是啥？答：HashSet底层是HashMap。 那么请你回答我，为啥HashSet只需要填一个数据进去，而HashMap是要填两个数据进去的，但HashMap是键值对这种的，这根本不匹配啊？ 答：HashSet底层一定是HashMap，这个我看过源码，不可能错。 因为HashSet底层的add添加方法调的就是HashMap的put方法 HashSet填一个数据进去，而HashMap是要填两个数据进去的，这是因为HashSet当中添加进去的一个元素就是HashMap的key，那么value永远就是一个object的常量固定写死的 请问HashMap的底层结构是啥？ 答：HashMap&lt;&gt;()存储的不是键值对类型的，是存储一个个的node类型的节点; 这个node里面存键值对，底层是node的数组+node的链表+node的红黑树 HashMap&lt;&gt;的初始值数组长度是：16，负载因子是0.75。 负载因子能不能改？ 答：可以改，但一般很少人去改这个负载因子，因为够用 负载因子 12345负载因子是和扩容机制有关的，意思是如果当前容器的容量，达到了我们设定的最大值，就要开始执行扩容操作。举个例子来解释，避免小白听不懂：比如说当前的容器容量是16，负载因子是0.75,16*0.75=12，也就是说，当容量达到了12的时候就会进行扩容操作。他的作用很简单，相当于是一个扩容机制的阈值。当超过了这个阈值，就会触发扩容机制。HashMap源码已经为我们默认指定了负载因子是0.75。 2、JUC多线程之异步编排基础创建线程无法拿到返回值 继承Thread 实现Runable 可以拿到返回值 Callable Future CompletableFuture 1、创建CompletableFuture对象 1234public static CompletableFuture&lt;Void&gt; **runAsync**(Runnable runnable);public static CompletableFuture&lt;Void&gt; **runAsync**(Runnable runnable, Executor executor);public static &lt;U&gt; CompletableFuture&lt;U&gt; **supplyAsync**(Supplier&lt;U&gt; supplier);public static &lt;U&gt; CompletableFuture&lt;U&gt; **supplyAsync**(Supplier&lt;U&gt; supplier, Executor executor) 总结 1234以Async结尾并且没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。runAsync方法：它以Runnabel函数式接口类型为参数，所以CompletableFuture的计算结果为空。supplyAsync方法以Supplier&lt;U&gt;函数式接口类型为参数，CompletableFuture的计算结果类型为U。这些线程都是Daemon线程，主线程结束Daemon线程不结束，只有JVM关闭时，生命周期终止。 · 示例 123456789101112131415public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; //长时间的计算任务 try &#123; System.out.println(&quot;计算型任务开始&quot;); Thread.sleep(2000); return &quot;计算型任务结束&quot;; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;·00&quot;; &#125;); System.out.println(future.get()); &#125; 2、计算结果完成时的处理 1234567· public CompletableFuture&lt;T&gt; **whenComplete**(BiConsumer&lt;? super T,? super Throwable&gt; action)· public CompletableFuture&lt;T&gt; **whenCompleteAsync**(BiConsumer&lt;? super T,? super Throwable&gt; action)· public CompletableFuture&lt;T&gt; **whenCompleteAsync**(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)· public CompletableFuture&lt;T&gt; **exceptionally**(Function&lt;Throwable,? extends T&gt; fn) 可以看到Action的类型是BiConsumer&lt;? super T,? super Throwable&gt;它可以处理正常的计算结果，或者异常情况。 方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行） · 示例 1234567CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(xxxxxxxxxx); Future&lt;Integer&gt; f = future.whenComplete((v, e) -&gt; &#123; System.out.println(v); System.out.println(e); &#125;); System.out.println(f.get()); 3、thenApply 当前阶段正常完成以后执行，而且当前阶段的执行的结果会作为下一阶段的输入参数。thenApplyAsync默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。 4、thenAccept与thenRun thenAccept和thenRun都是无返回值的。thenApply生产，那么thenAccept和thenRun是在消费。它们是整个计算的最后两个阶段。 同样是执行指定的动作，同样是消耗，二者也有区别： thenAccept接收上一阶段的输出作为本阶段的输入thenRun根本不关心前一阶段的输出，根本不不关心前一阶段的计算结果，因为它不需要输入参数 5、thenCombine整合两个计算结果 例如此阶段与其它阶段一起完成，进而触发下一阶段： 6、异常处理completeExceptionally 为了能获取任务线程内发生的异常，需要使用 CompletableFuture的completeExceptionally方法将导致CompletableFuture内发生问题的异常抛出。这样，当执行任务发生异常时，调用get()方法的线程将会收到一个 ExecutionException异常，该异常接收了一个包含失败原因的Exception 参数。 7、异步编排（多任务组合方法allOf和anyOf） allOf是等待所有任务完成 anyOf是只要有一个任务完成 3、全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204import java.util.concurrent.*; public class ThreadTest &#123; public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;main....start....&quot;);// CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;// System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());// int i = 10 / 2;// System.out.println(&quot;运行结果:&quot; + i);// &#125;, executor); // CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;// System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());// int i = 10 / 0;// System.out.println(&quot;运行结果:&quot; + i);// return i;// &#125;, executor).whenComplete((res,excption)-&gt;&#123; //虽然能得到异常信息，但是没法修改返回数据// System.out.println(&quot;异步任务成功完成了...结果是:&quot;+res+&quot;；异常信息是&quot;+excption);// &#125;).exceptionally(throwable -&gt; &#123; //可以感知异常，同时返回默认值// return 10;// &#125;); //成功以后干啥事 // CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;// System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());// int i = 10 / 4;// System.out.println(&quot;运行结果:&quot; + i);// return i;// &#125;, executor).handle((res,thr)-&gt;&#123;// if (res!=null)&#123;// return res * 2;// &#125;// if (thr!=null)&#123; //异常不等于空了，就返回0// return 0;// &#125;// return 0;// &#125;); /** * 线程的串行化 * 1.thenRun:不能获取到上一步的执行结果 * .thenRunAsync(() -&gt; &#123; * System.out.println(&quot;任务2启动了...&quot;); * &#125;, executor); * * 2.thenAcceptAsync 能接受上一步的结果，但是没有返回值 * .thenAcceptAsync(res-&gt;&#123; * System.out.println(&quot;任务2启动了...&quot;+res); * &#125;,executor); * * 3. thenApplyAsync 能获取到上一步的结果 同时也有返回值 *// */// CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;// System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());// int i = 10 / 4;// System.out.println(&quot;运行结果:&quot; + i);// return i;// &#125;, executor).thenApplyAsync(res -&gt; &#123;// System.out.println(&quot;任务2启动了...&quot; + res);// return &quot;Hello&quot; + res;// &#125;, executor); //Integer integer = future1.get(); // /**// * 两任务组合// */// CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;// System.out.println(&quot;任务1线程：&quot; + Thread.currentThread().getId());// int i = 10 / 4;// System.out.println(&quot;任务1结束:&quot; + i);// return i;// &#125;, executor);//// CompletableFuture&lt;String&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;// System.out.println(&quot;任务2线程：&quot; + Thread.currentThread().getId());// System.out.println(&quot;任务2结束:&quot;);// return &quot;hello&quot;;// &#125;, executor); // future01.runAfterBothAsync(future02,()-&gt;&#123;// System.out.println(&quot;任务3开始&quot; );// &#125;,executor); // future01.thenAcceptBothAsync(future02,(f1,f2)-&gt;&#123;// System.out.println(&quot;任务3开始 之前的结果:&quot;+f1+&quot;--&gt;&quot;+f2 );// &#125;,executor);// CompletableFuture&lt;String&gt; future = future01.thenCombineAsync(future02, (f1, f2) -&gt; &#123;// return f1 + &quot;:&quot; + f2 + &quot;-&gt;haha&quot;;// &#125;, executor);// future01.runAfterEitherAsync(future02,()-&gt;&#123;// System.out.println(&quot;任务3开始 之前的结果:&quot;);// &#125;,executor); CompletableFuture&lt;String&gt; futureImg = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;查询商品的图片信息&quot;); return &quot;hello.jpg&quot;; &#125;,executor); CompletableFuture&lt;String&gt; futureAttr = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;查询商品的属性&quot;); return &quot;黑色+256G&quot;; &#125;,executor); CompletableFuture&lt;String&gt; futureDesc = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;查询商品的介绍&quot;); return &quot;华为&quot;; &#125;,executor); // futureImg.get();futureAttr.get();futureDesc.get(); //CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(futureImg, futureAttr, futureDesc); //System.out.println(&quot;main....end...&quot;+futureImg.get()+&quot;=&gt;&quot;+futureAttr.get()+&quot;=&gt;&quot;+futureDesc.get()); CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(futureImg, futureAttr, futureDesc); anyOf.get();//等待所有结果完成 System.out.println(&quot;main....end...&quot;+anyOf.get()); &#125; public void thread(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;main....start....&quot;);// Thread01 thread01 = new Thread01();// thread01.start();//启动线程// System.out.println(&quot;main....end...&quot;); // Runable01 runable01 = new Runable01();// new Thread(runable01).start();// System.out.println(&quot;main....end...&quot;); // FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable01());// new Thread(futureTask).start();// Integer integer = futureTask.get();//阻塞等待 // System.out.println(&quot;main....end...&quot;+integer); /** * 线程池： * 给线程池直接提交任务 * 1.创建线程池的方式 * 1.1.使用Executors线程池工具类来创建线程池 service.execute(new Runable01()); * 1.2.使用原生的线程池创建方式 * * */ /** * 原生线程池的七大参数解释 * int corePoolSize, 核心线程数｛只要线程池不销毁，核心线程数一直在｝，线程池创建好以后就准备就绪的线程数量，就等待来接收异步任务去来执行 * int maximumPoolSize, 最大线程数，控制资源并发的 * long keepAliveTime, 存活时间，如果当前线程数量大于核心数量，只要线程空闲到一定时间内，就会释放空闲的最大线程数当中的线程 * TimeUnit unit, 具体最大线程数的存活时间的时间单位 * BlockingQueue&lt;Runnable&gt; workQueue, 阻塞队列 如果任务有很多，就会将目前多的任务放在队列里面，只要有空闲的线程，就会去阻塞队列去拿新的任务 * ThreadFactory threadFactory, 线程的创建工厂 默认 也可以自定义 * RejectedExecutionHandler handler 拒绝策略，就是处理阻塞队列当中任务已满了，不能再加入其他的任务进来阻塞队列当中了，就进行指定的拒绝策略进行拒绝任务 * * 工作顺序： * 1. 线程池创建，准备好核心数量的线程，准备接受任务 * 2. 核心线程数量若满了，就把新进来的任务放到阻塞队列当中，等到核心线程空闲了就去阻塞队列拿新任务并进行执行 * 3. 如果阻塞队列满了，会开启指定的最大线程数量进行执行阻塞队列当中的任务，并若在指定的时间内最大线程数空闲了，就会释放资源 * 4.如果阻塞队列和最大现场数量都满了，那么就会使用指定的拒绝策略，来拒绝接受新进来的任务 * * * 线程池的其他方法： * Executors.newCachedThreadPool() //核心数是0，所有都可回收 * Executors.newFixedThreadPool() //固定大小，核心数=最大值都不可回收 * Executors.newScheduledThreadPool() //定时任务的线程池 * Executors.newSingleThreadExecutor() //单线程的线程池，后台从队列里面获取任务，挨个执行 * */ ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 200, 10, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(100000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); System.out.println(&quot;main....end...&quot;); &#125; public static class Thread01 extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果:&quot;+i); &#125; &#125; public static class Runable01 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果:&quot;+i); &#125; &#125; public static class Callable01 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果:&quot;+i); return i; &#125; &#125;&#125; 3、JVM+GC解析基础JVM内存结构jVM体系概述 Java8以后的JVM GC作用域 常见的垃圾回收算法引用计数 复制 标记清除 标记整理 题目JVM垃圾回收的时候如何确定垃圾?是否知道什么是 GC Roots什么是垃圾? 简单的说就是内存中已经不再被使用到的空间就是垃圾 要进行垃圾回收，如何判断一个对象是否可以被回收? 引用计数法 Java中,引用和对象是有关联的。如果要操作对象则必须用引用进行因此,很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说,给对象中添加一个引用计数器,每当有一个地方引用它,计数器值加1，每当有一个引用失效时,计数器值减1。任何时刻计数器值为零的对象就是不可能再被使用的,那么这个对象就是可回收对象。 那为什么主流的Java虚拟机里面都没有选用这种算法呢?其中最主要的原因是它很难解决对象之间相互循环引用的问题 枚举根节点做可达性分析（根搜索路径） 123为了解决引用计数法的循环引用的问题，java使用了可达性分析的方法基本思路是通过一些列名为&quot;GC Roots&quot;的对象作为初始节点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链想通时，则说明此对象不可用，也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的(可到达的)对象就被判定为存活，没有遍历到的自然被判定为死亡。 123456Java 可以做GCRoots的对象虚拟机栈(栈帧中的局部变量区,也叫做局部变量表方法区中的类静态属性引用的对象。方法区中常量引用的对象本地方法栈中N( Native方法)引用的对象 什么是GCRoots ? 答：是一组四种对象(虚拟机栈(栈帧中的局部变量区,也叫做局部变量表,方法区中的类静态属性引用的对象,方法区中常量引用的对象,本地方法栈中N( Native方法)引用的对象)的根集合体，从这四种对象作为垃圾回收扫描的起始点 2、你说你做过JVM调优和参数配置，请问如何盘点查看MM系统默认值 · JVM的参数类型 标配参数 · -verison · -help · java -showversion · X参数（了解） 1234567-Xint。解释执行-Xcomp。第一次使用就编译成本地代码-Xmixed。混合模式XX参数。Boolean类型 · 公式 · -XX：+或者- 某个属性值。 +表示开启 -表示关闭 · Case · 是否打印GC收集细节 123-XX：+PrintGCDetails-XX：-PrintGCDetails · 是否使用串行垃圾收集器 123-XX：-UseSerialGC-XX：+UseSerialGC · KV设值类型 · 公式 · -XX：属性key=属性值value · Case 123-XX:MetaspaceSize=128m-XX:MaxTenuringThreshold=15 · jinfo举例，如何查看当前运行程序的配置 · 公式 · jinfo -flag 配置项 进程编号 题外话（坑题）两个经典参数：-Xms和-Xmx，这个你如何解释 123-Xms。等价于 -XX:InitialHeapSize 初始化堆内存-Xmx。等价于-XX:MaxHeapSize 最大堆内存 这两个参数也还是属于XX参数，只不过这两个参数常用，所以就起了一种别名来代替复杂的名字 - begins at 等价于 -XX:InitialHeapSize 初始化堆内存 查看JVM默认值 1-XX:+PrintFlagsInitial · 查看初始默认值 · 公式 12345java -XX:+PrintFlagsInitial -versionjava -XX:+PrintFlagsInitial-XX:+PrintFlagsFinal · 主要查看修改更新 · 公式 123java -XX:+PirntFlagsFinaljava -XX:+PirntFlagsFinal -version · PrintFlagsFinal举例，运行Java命令的同时打印出参数 1-XX:+PrintCommandLineFlags 3、你平时工作用过的JVM常用基本配置参数有哪些?基础知识复习 12345long totalMemory = Runtime.getRuntime().totalMemory(); //返回java虚拟机中的内存变量long maxMemory = Runtime.getRuntime().maxMemory(); //返回java虚拟机试图使用的最大内存量System.out.println(&quot;TOTAL_MEMORY(-Xms) = &quot; + totalMemory + &quot; (字节) 、&quot; +(totalMemory / (double)1024 / 1024 + &quot;MB&quot;));System.out.println(&quot;MAX_MEMORY(-Xmx) = &quot; + maxMemory + &quot; (字节) 、&quot; +(totalMemory / (double)1024 / 1024 + &quot;MB&quot;)); · 常用参数 12345-Xms。初始大小内存，默认为物理内存1/64。 等价于-XX:InitialHeapSize-Xmx。最大分配内存，默认为物理内存1/4。等价于-XX:MaxHeapSize-Xss。 设置单个线程的大小，一般默认为512K~1024K。等价于-XX:ThreadStackSize 原理： · 系统出厂默认值是跟平台有关，一般生产环境都是部署到linux系统（也即1024 KB） · -Xmn。设置年轻代大小，一般都不用设置，一般都是用默认的即可 · -XX:MetaspaceSize · 设置元空间大小 123元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于，元空间便不再虚拟机中，而是使用本地内存。因此，默认情况下，元空间大小仅受本地内存限制。 · -Xms10m -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal · 不管是几个G的内存，元空间默认都只占用20多M · 典型设置案例 -Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC · -XX:+PrintGCDetails · 输出详细GC收集日志信息 · GC · FullGC · -XX:SurvivoRatio 1234设置新时代中eden和s0/s1的比例。默认:-XX:SurvivorRatio=8，Eden:S0:S1=8:1:1假如:-XX:SurvivorRatio=4，Eden:S0:S1=4:1:1SurvivorRatio值就是设置eden区的比例占多少，S0/S1相同 · -XX:NewRatio 1234配置年轻代与老年代在堆结构的占比默认:-XX:NewRatio=2新时代占1，老年代2，年轻代占整个堆的1/3假如:-XX:NewRatio=4新时代占1，老年代4，年轻代占整个堆的1/5NewRatio值就是设置老年代的占比，剩下的1给新时代 · -XX:MaxTenuringThreshold，设置垃圾最大年龄 123-XX:MaxTenuringThreshold=0，设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率。默认值为15 4、强引用、软引用、弱引用、虚引用分别是什么? · 强引用（默认支持模式） 12345当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不回收。强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还&quot;活着&quot;，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即是该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄露的主要原因之一。对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，一般认为就是可以被垃圾收集的了(具体回收时机看垃圾收集策略)。 12345678910public class StrongReferenceDemo &#123; public static void main(String[] args) &#123; Object obj1 = new Object(); //这样定义的默认就是强引用 Object obj2 = obj1; //obj2引用赋值 obj1 = null; //置空 System.gc(); System.out.println(obj2); &#125;&#125; · 软引用 1234567软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。对于只有软引用的对象来说， 当系统内存充足时，它不会被回收 当系统内存不足时，它会被回收 软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收! · 弱引用 12弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的缓存。 · 软引用和弱应用的适用场景 123456假如有一个应用需要读写大量的本地图片: 如果每次读取图片都从硬盘读取则会严重影响性能 如果一次性全部都加载到内存中有可能造成内存溢出此时使用软引用可以解决这个问题 设计思路是:用一个HashMap来保存图片的路径和相应图片对象关系的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免了OOM问题。Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache=new Map&lt;String,SoftReference&lt;Bitmap&gt;&gt;(); · 你知道弱引用的话，能谈谈WeakHashMap吗？ · 虚引用 12345678910虚引用需要java.lang.ref.PhantomReference类来实现顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，他不能单独使用也不能通过它访问对象，虚引用必须和引用队列(ReferenceQueue)联合使用虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。PhantomReference的get方法总是返回null，因此无法访问对应的引用对象，其意义在于说明一个对象以及进入finalization阶段，可以被gc回收，用来实现比finalization更灵活的回收操作。换句话说，设置虚引用关联的唯一目的，就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理。Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 · 引用队列 · GCRoots和四大引用的小总结 5、请谈谈你对OOM的认识 Java.lang.StackOverflowError。 栈溢出错误 为什么会有StackOverflowError这种错误？ 答 深度的方法调用导致出不来栈，栈爆了 Java.lang.OutOfMemoryError:Java heap space。堆内存不够用 为什么会有Java heap space这种错误？ 答 堆爆了 Java.lang.OutOfMemeoryError:GC overhead limit exceeded 程序在垃圾回收上花费了98%的时间，却收集不回2%的空间，通常这样的异常伴随着CPU的冲高 · Java.lang.OutOfMemeoryError:Direct buffer memory · 内存挂了 · Java.lang.OutOfMemeoryError:unable to create new native thread · 非root用户登录Linux系统测试 · 服务器级别参数调优 · Java.lang.OutOfMemeoryError:Metaspace · 使用Java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:MetaspaceSize为21810376B(约20M) · 元空间溢出 6、G垃圾回收算法和垃圾收集器的关系?分别是什么请你谈谈· GC算法（引用计数/复制/标清/标整）是内存回收的方法论，垃圾收集器就是算法落地实现 · 因为目前为止还没有完美的收集器出现，更加没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集 · 4种主要垃圾收集器 1234567891011串行垃圾回收器（Serial）它为单线程环境设计并且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境并行垃圾回收器（Parallel）多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理等弱交互场景并发垃圾回收器（CMS）用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程 互联网公司多用它，适用于对响应时间有要求的场景G1垃圾回收器G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收 7、怎么查看服务器默认的垃圾收集器是那个? 生产上如何配置垃圾收集器的? 谈谈你对垃圾收集器的理解?· 怎么查看默认的垃圾收集器是哪个？ · 默认的垃圾收集器有哪些 · 垃圾收集器 · 部分参数预先说明 12345678910111213141516171819DefNewDefault New GenerationTenuredOldParNewParallel New GenerationPSYoungGenParallel ScavengeParOldGenParallel Old Generation · Server/Client模式分别是什么意思 · 新生代 · 串行GC（Serial）/（Serial Coping） · 并行GC(ParNew) · 并行回收GC(Parallel)/(Parallel Scavenge) · 老年代 · 串行回收GC(Serial Old)/(Serial MSC) · 并行GC(Parallel Old)/(Parallel MSC) · 并发标记清除GC(CMS) · 4步过程 · 初始标记(CMS initial mark) · 并发标记(CMS concurrent mark)和用户线程一起 · 重新标记(CMS remark) · 并发清除(CMS concurrent sweep)和用户线程一起 · 优缺点 · 优 · 并发收集低停顿 · 缺 · 并发执行，对CPU资源压力大 · 采用的标记清除算法会导致大量碎片 · 如何选择垃圾收集器 G1垃圾收集器 · 以前收集器特点 · 年轻代和老年代是各自独立且连续的内存块 · 年轻代收集使用单eden+S0 +S进行复制算法 · 老年代收集必须扫描整个老年代区域 · 都是以尽可能少而快速地执行GC为设计原则 · G1是什么 · 特点 · 底层原理 · Region区域化垃圾收集器 · 最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可 · 回收步骤 · 4步过程 · 常用配置参数(了解) · -XX:+UseG1GC · -XX:G1HeapRegionSize=n : 设置G1区域的大小。值是2的幂，范围是1M到32M。目标是根据最小的Java堆大小划分出约2048个区域 · -XX:MaxGCPauseMillis=n : 最大停顿时间，这是个软目标，JVM将尽可能（但不保证）停顿时间小于这个时间 · -XX:InitiatingHeapOccupancyPercent=n 堆占用了多少的时候就触发GC，默认是45 · -XX:ConcGCThreads=n 并发GC使用的线程数 · -XX:G1ReservePercent=n 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险，默认值是10% · 和CMS相比的优势 9、生产环境服务器变慢，诊断思路和性能评估谈谈?· 整机：top · uptime,系统性能命令的精简版 · CPU：vmstat 查看CPU(包含不限于 · 查看额外 · 查看所有CPU核信息 · mpstat -P ALL 2 · 每个进程使用cpu的用量分解信息 · pidstat -u 1 -p 进程编号 · 内存：free · 应用程序可用内存数 · 查看额外 · pidstat -p 进程号 -r 采样间隔秒数 · 硬盘：df · 查看磁盘剩余空闲数 · 磁盘IO：iostat · 磁盘I/O性能评估 · 查看额外 · pidstat -d 采样间隔秒数 -p 进程号 · 网络IO：ifstat · 默认本地没有，下载ifstat · 查看网络IO 10、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位· 结合Linux和JDK命令一块分析 · 案例步骤 · 1. 先用top命令找出CPU占比最高的 · 2. ps -ef或者jps进一步定位，得知是一个怎么样的一个后台程序 · 3. 定位到具体线程或者代码 · ps -mp 进程 -o THREAD,tid,time · 参数解释 12345-m 显示所有线程-p pid进程使用cpu的时间-o 该参数后是用户自定义格式 · 4. 将需要的线程ID转换为16进制格式(英文小写格式) · printf “%x\\n” 有问题的线程ID · 5. jstack 进程ID | grep tid(16进制线程ID小写英文) -A60 11、对于JDK自带的JVM监控和性能分析工具用过哪些？一般你是怎么用的？· 是什么 · 性能监控工具 1234567jps(虚拟机进程状况工具)jinfo(Java配置信息工具)jmap(内存映像工具)jstat(统计信息监控工具) 12、JVMGC结合SpringBoot微服务的调参优化· 在实际的工作中，结合SpringBoot进行JVM的调优 · JVMGC对微服务的生产部署调参的优化方案 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseG1GC JVM常问面试题JVM基础什么是JVM？答：Java虚拟机。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。 请谈谈你对JVM的理解？JAVA8的虚拟机有什么更新？错误的回答：是JAVA虚拟机的意思 正确的回答：我对JVM的理解是JVM的内部体系结构分为三部分：类装载器（ClassLoader）子系统和运行时数据区以及执行引擎 java8在虚拟机方面的更新是撤销了java7的永久带，引入了JAVA8的元空间。 什么是类加载器？答：比如是一个Car.class二进制字节码文件被类装载ClassLoader装载进JVM以后，模版就有一份，这个模版就变成了一个大的Car Class文件，锁也是锁这个模版 通过这一个模版，可以创建多个实例对象。 也就是锁的是模版，不是对象。 类装载器的作用就是把读取硬盘上的小class文件，通过类装载器装载进JVM里面，充当快递员的角色。 类加载器有几种？答：粗分就有三种类装载器，细分就有四种类装载器。 java虚拟机自带的加载器有三种（其实细分有四种，但是最后一种在下面进行详解）： 启动类加载器：是用c++语言编写的，就加载java出厂默认的这些类 比如List，Object，String这些都是属于java出厂默认的，是启动类加载器以后自动加载进来的，所以我们能直接使用 扩展类加载器：是用JAVA语言编写的， 应用程序类加载器：用户自己可以定义的，java也叫系统类加载器，加载当前应用的classpath的所有类 什么是双亲委派机制？一句话概括：就是出了事情，往上捅，我爸是李刚，有事找我爹。 详细解释：我要加载一个类，不是从本类开始加载，而是先去启动类加载器去加载去寻找看看有没有，找到了就直接用 找不到就再去扩展类加载器找，扩展类加载器里面找到了直接用，找不到才到应用程序类加载器，这样的好处就是保证大家使用的类是同一套体系，不会错，作用就是保证java源代码不受污染，保证源码干净一致，这也叫沙箱安全 较为官方解释：当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 java虚拟机自带的加载器的第四种解释： 说明：如果启动类加载器和扩展类加载器以及应用程序类加载器都不好，那么可以自己自定义加载器。 用户自定义加载器：java.lang.ClassLoader的子类，用户可以定制类的加载方式。 如何使用？ 只需要继承ClassLoader就可以自己定制类的加载方式。（但是这部分很少会有人自己去定制，除非你去阿里做基础架构，专做JAVAJDK订制开发） 什么是Native？Native在Native本地方法栈主要是调底层的C语言的函数库。 什么叫PC寄存器？（也即程序计数器）一句话概括：就是排版值日表的顺序 详细解释：程序计数器就是记录了程序内部的运行流程和跳转顺序。 较为官方的解释：每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。 方法区一句话概括：就是存放模版的地方，比如什么常量池啊这些静态共有的都存在了方法区 较为官方解释：供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace) 实例变量存在堆内存中,和方法区无关 Stack栈一句话概括：也即程序要运行，需要栈空间，它随程序的申请开辟，程序运行结束，释放。 8种基本类型的变量+对象的引用变量+实例方法都是存放在栈里面 堆请你谈谈对象的生命周期？对象的生命周期我的理解： 1、先从伊甸区有100个对象，第一次经过GC垃圾回收以后，会把活着的对象放入到幸存0区。 2、然后第二次会对伊甸区和幸存0区进行GC回收，第二次GC回收后存活的对象，将复制到幸存1区。 3、然后第三次GC垃圾回收前，幸存0区和幸存1区进行互换位置，然后对伊甸区和原先的幸存1区（也即已经成功与幸存0区交换位置的幸存1区）进行第三次GC的垃圾回收。 4、第三次GC后，会把第三次存活下来的对象，存入互换后的幸存0区。若这样GC垃圾回收15次以后，最终成功逃过15次的GC垃圾回收的对象，将存到养老区。 堆内存在JAVA8是由新生区+养老区+元空间所构成 堆内存调优01用代码测试自己的电脑还能用多少内存等 123456public static void main(String[] args)&#123; long maxMemory = Runtime.getRuntime().maxMemory() ;//返回Java虚拟机试图使用的最大内存量。 long totalMemory = Runtime.getRuntime().totalMemory() ;//返回Java虚拟机中的内存总量。 System.out.println(&quot;MAX_MEMORY = &quot; + maxMemory + &quot;（字节）、&quot; + (maxMemory / (double)1024 / 1024) + &quot;MB&quot;); System.out.println(&quot;TOTAL_MEMORY = &quot; + totalMemory + &quot;（字节）、&quot; + (totalMemory / (double)1024 / 1024) + &quot;MB&quot;); &#125; 堆内存调优： 1234567-Xms 设置初始分配大小，默认为物理内存的1/64-Xmx 最大分配内存，默认为物理内存的1/4VM参数： -Xms1024m -Xmx1024m -XX:+PrintGCDetails-XX:+PrintGCDetails 输出详细的GC处理日志 注意：参数调优一定要初始大小和最大分配内存的大小要一致 堆内存调优02OutOfMemoryError异常 VM参数：-Xms8m -Xmx8m -XX:+PrintGCDetails 能够抛出OutOfMemoryError异常的代码测试 String str = “444555” ;while(true) {str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;} 运行代码后的结果 Full GC都没有养老区的空间了，所以报java.lang.OutOfMemoryError: Java heap space这个异常 GCGC分代收集概念 JVM它是由新生代，养老代，元空间三代构成，每一代有对应着不同的垃圾回收算法，所以叫分代收集。 GC四大算法 1、引用计数法（了解就行，已经不用） 2、复制算法 新生区/伊甸区都是用复制算法 意思也即，对象死的收尸，活的要复制到幸存02区 相关原理 Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden是就变成空的了。 当对象在 Eden出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。 -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数 具体解释： 年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 复制算法的优缺点：答：优点是不会产生内存碎片，缺点是会有空间的浪费 具体解释 复制算法它的缺点也是相当明显的。 1、它浪费了一半的内存，这太要命了。 2、如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 3、标记清除 老年代一般是由标记清除或者是标记清除与标记整理的混合实现 相关原理 用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。 主要进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记遍历先标记出要回收的对象。 清除：遍历整个堆，把标记的对象清除。 缺点：此算法需要暂停整个应用，会产生内存碎片 标记清除的优缺点优点：不需要额外的空间。缺点:两次扫描，耗时严重，会产生内存碎片，具体优缺点解释 1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲。 2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。 而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 4、标记压缩 老年代一般是由标记清除或者是标记清除与标记整理的混合实现 相关原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价 标记压缩的优缺点优点:减少移动对象的成本。缺点 GC面试题请谈谈GC是什么？主要是什么样？答：GC是垃圾回收，主要是分代收集算法的体现 请再说说GC？ 次数上频繁收集Young区，次数上较少收集Old区，基本不动元空间 GC四大算法的优缺点请你谈谈？复制算法的优缺点： 答：优点是不会产生内存碎片 答：缺点是会有空间的浪费 具体解释 复制算法它的缺点也是相当明显的。 1、它浪费了一半的内存，这太要命了。 2、如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 标记清除的优缺点 · 优点：不需要额外的空间 · 缺点: 两次扫描，耗时严重，会产生内存碎片 具体优缺点解释 1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲。 2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。 而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 标记压缩的优缺点 · 优点，减少移动对象的成本 · 缺点 GC四大算法怎么用？哪个代用哪个算法？· 新生代用复制算法 · 养老代用标记清除或者标记压缩","categories":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://stary2020.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":null},{"title":"Redis6","slug":"SQL-2021-07-22-Redis6","date":"2021-07-22T13:46:18.000Z","updated":"2021-08-19T02:34:42.438Z","comments":true,"path":"2021/07/22/SQL-2021-07-22-Redis6/","link":"","permalink":"http://stary2020.gitee.io/2021/07/22/SQL-2021-07-22-Redis6/","excerpt":"","text":"NoSQL数据库简介 Redis6概述和安装 常用五大数据类型 Redis6配置文件详解 Redis6的发布和订阅 Redis6新数据类型 Jedis操作Redis6 Redis6与Spring Boot整合 Redis6的事务操作 Redis6持久化之RDB Redis持久化之AOF Redis6的主从复制 Redis6集群 Redis6应用问题解决 Redis6新功能 一、NoSQL数据库简介 技术发展 NoSQL数据库概述 行式存储数据库 图关型数据库 数据库排名 1.技术发展技术的分类： 解决功能性的问题：java、jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch web 1.0 时代：数据访问量有限，用高性能的单点服务器可以解决大部分问题 web 2.0 时代：用户访问量大幅度提升，同时产生了大量的用户数据。加之移动设备普及，所有的互联网平台面临巨大的性能挑战，包括：CPU及内存压力、IO压力 解决CPU及内存压力——多台服务器条件下session存放问题 方案一：存在cookie中 不安全 网络负担效率低 方案二：存在文件服务器或者数据库里 大量的IO效率问题 方案三：session复制 session数据冗余，节点越多，浪费越大 方案四：缓存数据库 完全在内存中，速度快，数据结构简单 解决IO压力 缓存数据库：减少IO的读操作 水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能 文档数据库 列式数据库 打破了传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能为最优的存储方式 2.NoSQL数据库概述概述：NoSQL（NoSQL=Not Only SQL），意味：不仅仅是SQL，指==非关系型的数据库==。NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准 不支持ACID（事务中的原子性、一致性、隔离性和持久性） 远超于SQL的性能 场景NoSQL适用场景： 对数据高并发的读写 海量数据的读写 对数据高可扩展性的读写 NoSQL不适用的场景： 需要事务支持 基于sql的结构化查询存储，处理复杂的关系，需要即席查询即席查询：（Ad Hoc）是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表。 ==用不着sql和用了SQL也不行的情况下，考虑使用NoSQL== 常见的NoSQL数据库 Memcache 很==早==出现的NoSQL数据库 数据都在内存中，一般==不支持持久化== 支持简单的key-value模式，==支持类型单一== 一般是作为==缓存数据库==辅助持久化的数据库 Redis 几乎覆盖了Memcache的绝大部分功能 数据都在内存，==支持持久化==，主要用作备份恢复 除了支持简单的key-value模式，还==支持多种数据结构的存储==，比如list、set、hash、zset等 一般是作为==缓存数据库==辅助持久化的数据库 MongoDB 高性能、开源、模式自由（schema free）的==文档型数据库== 数据都在内存中，如果内存不足，把不常用的数据保存到硬盘 虽然是key-value模式，但是对value（尤其是==json==）提供了丰富的查询功能 支持二进制数据及大型对象 开源根据数据的特点==替代RDBMS==，成为独立的数据库。或者配合RDBMS，存储特定的数据。RDBMS：关系数据库管理系统。 3.行式存储数据库 行式数据库 列式数据库 常见的数据库： HBase： HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。 HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可以处理有百万列元素的数据表 Cassandra： Apache Cassandra 是一款免费的开源 NoSQL 数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到 PB 级别)。在众多显著特性当中，Cassandra 最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。 1234567891011121314计算机存储单位 计算机存储单位一般用 B，KB，MB，GB，TB，PB，EB，ZB，YB，BB来表示，它们之间的关系是：位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。字节 byte：8 个二进制位为一个字节(B)，最常用的单位。1KB (Kilobyte 千字节)=1024B，1MB (Megabyte 兆字节 简称“兆”)=1024KB，1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中 1024=2^10 ( 2 的 10 次方)，1PB（Petabyte 千万亿字节 拍字节）=1024TB，1EB（Exabyte 百亿亿字节 艾字节）=1024PB，1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.注：“兆”为百万级数量单位。 4.图关型数据库Neo4j： 主要应用：社会关系、公共交通网络、地图及网络拓扑 5.数据库排名网址：https://db-engines.com/en/ranking 二、Redis6概述和安装 Redis 是一个开源的 key-value 存储系统。 和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和 hash（哈希类型）。 这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上，Redis 支持各种不同方式的排序。 与 memcached 一样，为了保证效率，数据都是缓存在内存中。 区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 并且在此基础上实现了 master-slave(主从)同步。 1. 应用场景 配合关系型数据库做高速缓存 高频次，热门访问的数据，降低数据库IO 分布式架构，做session共享 多样的数据结构存储持久化数据 2.安装官网：http://redis.io/ 中文官网：http://redis.cn/ 安装时，不考虑windows版本 步骤准备工作： 下载安装gcc编译器 安装c语言的编译环境 123yum install centos-release-scl scl-utils-buildyum install -y devtoolset-8-toolchainscl enable devtoolset-8 bash 测试gcc版本 1gcc --version 安装redis： 下载Redis安装包到opt目录下 解压：tar -zxvf redis-6.2.1.tar.gz 进入解压后的目录 在目录下再次执行make命令，若报错，运行：make distclean，再次执行：make命令 编译成功后，跳过make test，继续执行：make install，完成安装 安装目录：/usr/local/bin查看默认安装目录： redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何 redis-check-aof：修复有问题的 AOF 文件，rdb 和 aof 后面讲 redis-check-dump：修复有问题的 dump.rdb 文件 redis-sentinel：Redis 集群使用 redis-server：Redis 服务器启动命令 redis-cli：客户端，操作入口 启动： 前台启动：redis.server，不推荐使用，命令窗口不能关闭，否则服务器停止 后台启动：推荐 备份redis.conf配置文件到其他目录 1cp /opt/redis-3.2.5/redis.conf /myredis 后台启动设置 daemonize no 改成 yes：修改 redis.conf(128 行)文件将里面的 daemonize no 改成 yes，让服务在后台启动 启动：redis-server/myredis/redis.conf 客户端访问：redis-cli 多端口情况下：redis-cli -p6379 测试验证：ping 关闭： 单实例关闭：redis-cli shutdown 进入终端后关闭：shutdown 多实例关闭：redis-cli -p 6379 shutdown 介绍（redis） 默认 16 个数据库，类似数组下标从 0 开始，初始默认使用 0 号库 使用命令 select &lt;dbid&gt;来切换数据库。如: select 8 统一密码管理，所有库同样密码。 dbsize 查看当前数据库的 key 的数量 flushdb 清空当前库 flushall 通杀全部库 ==端口号：6379== Redis==是单线程+多路IO复用技术== 多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池） 串行 vs 多线程+锁（memcached） vs 单线程+多路 IO 复用(Redis） 与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用 三、常用五大数据类型redis常见数据类型操作指令： http://www.redis.cn/commands.html 1. Redis键（key） 命令 使用 keys * 查看当前库所有 key (匹配：keys *1) exists key 判断某个 key 是否存在 type key 查看你的 key 是什么类型 del key 删除指定的 key 数据 unlink key 根据 value 选择非阻塞删除。仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作。 expire key 10 10 秒钟：为给定的 key 设置过期时间 ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期 select 命令切换数据库 dbsize 查看当前数据库的 key 的数量 flushdb 清空当前库 flushall 通杀全部库 2. Redis字符串（String）简介： String是Redis最基本的类型，一个key对应一个value String类型是二进制安全的。意味着Redis的String可以包含任何数据。比如jpg图片或者序列化对象 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M 常用命令 set &lt;key&gt;&lt;value&gt;：添加键值对 *NX：当数据库中 key 不存在时，可以将 key-value 添加数据库 *XX：当数据库中 key 存在时，可以将 key-value 添加数据库，与 NX 参数互斥 *EX：key 的超时秒数 *PX：key 的超时毫秒数，与 EX 互斥 get &lt;key&gt;：查询对应键值 append &lt;key&gt;&lt;value&gt;：将给定的 追加到原值的末尾 strlen &lt;key&gt;：获得值的长度 setnx &lt;key&gt;&lt;value&gt;：只有在 key 不存在时 设置 key 的值 incr &lt;key&gt;：将 key 中储存的数字值增 1。只能对数字值操作，如果为空，新增值为 1 decr &lt;key&gt;：将 key 中储存的数字值减 1只能对数字值操作，如果为空，新增值为-1 incrby / decrby &lt;key&gt;&lt;步长&gt;：将 key 中储存的数字值增减。自定义步长。 mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....：同时设置一个或多个 key-value 对 mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....：同时获取一个或多个 value msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;：获得值的范围，类似 java 中的 substring，前包，后包 setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;：用 覆写所储存的字符串值，从&lt;起始位置&gt;开始(索引从 0 开始)。 setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;：设置键值的同时，设置过期时间，单位秒。 getset &lt;key&gt;&lt;value&gt;：以新换旧，设置了新值同时获得旧值 原子性： 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。 （1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。 （2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis 单命令的原子性主要得益于 Redis 的单线程 案例：java 中的 i++是否是原子操作？==不是==i=0;两个线程分别对 i 进行++100 次,值是多少？==2-200== ==原子性，有一个失败则都失败== 数据结构String 的数据结构为简单动态字符串(Simple Dynamic String,缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。 内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。 Redis列表（List）简介：单键多值： Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。 常用命令 命令 说明 lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... 从左边/右边插入一个或多个值。 lpop/rpop &lt;key&gt; 从左边/右边吐出一个值。值在键在，值光键亡。 rpoplpush &lt;key1&gt;&lt;key2&gt; 从列表右边吐出一个值，插到列表左边。 lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; 按照索引下标获得元素(从左到右) lrange mylist 0 -1 0 左边第一个，-1 右边第一个，（0-1 表示获取所有） lindex &lt;key&gt;&lt;index&gt; 按照索引下标获得元素(从左到右) llen &lt;key&gt; 获得列表长度 linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt; 在的后面插入插入值 lrem &lt;key&gt;&lt;n&gt;&lt;value&gt; 从左边删除 n 个 value(从左到右) lset&lt;key&gt;&lt;index&gt;&lt;value&gt; 将列表 key 下标为 index 的值替换成 value 数据结构List 的数据结构为快速链表 quickList。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。 它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当数据量比较多的时候才会改成 quicklist。 因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。 Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 Redis集合（Set）简介 Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以==自动排重==的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。 Redis 的 Set 是 string 类型的==无序集合。它底层其实是一个 value 为 null 的 hash 表==，所以添加，删除，查找的==复杂度都是 O(1)。== 一个算法，随着数据的增加，执行时间的长短，如果是 O(1)，数据增加，查找数据的时间不变 常用命令 命令 使用 sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略。smembers 取出该集合的所有值。 sismember &lt;key&gt;&lt;value&gt; 判断集合是否为含有该值，有 1，没有 0 scard&lt;key&gt; 返回该集合的元素个数。 srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... 删除集合中的某个元素。 spop &lt;key&gt; 随机从该集合中吐出一个值。 srandmember &lt;key&gt;&lt;n&gt; 随机从该集合中取出 n 个值。不会从集合中删除 。 smove &lt;source&gt;&lt;destination&gt;value 把集合中一个值从一个集合移动到另一个集合 sinter &lt;key1&gt;&lt;key2&gt; 返回两个集合的交集元素。 sunion &lt;key1&gt;&lt;key2&gt; 返回两个集合的并集元素。 sdiff &lt;key1&gt;&lt;key2&gt; 返回两个集合的差集元素(key1 中的，不包含 key2 中的) 数据结构 Set 数据结构是 dict 字典，字典是用哈希表实现的。 Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。 Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向一个内部值。 Redis哈希（Hash）简介 Redis hash 是一个键值对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 类似 Java 里面的 Map&lt;String,Object&gt; 用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用 普通的 key/value 结构来存储主要有以下 2 种存储方式： 每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大 用户 ID 数据冗余 通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题 常用命令 命令 使用 hset &lt;key&gt;&lt;field&gt;&lt;value&gt; 给集合中的 键赋值 hget &lt;key1&gt;&lt;field&gt; 从集合取出 value hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... 批量设置 hash 的值 hexists&lt;key1&gt;&lt;field&gt; 查看哈希表 key 中，给定域 field 是否存在。 hkeys &lt;key&gt; 列出该 hash 集合的所有 field hvals &lt;key&gt; 列出该 hash 集合的所有 value hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt; 为哈希表 key 中的域 field 的值加上增量 1 -1 hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt; 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在 数据结构Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。 Redis有序集合Zset（sorted set)简介 Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 常用命令 命令 使用 zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;… 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES] 返回有序集 key 中，下标在之间的元素。带 WITHSCORES，可以让分数一起和值返回到结果集。 zrangebyscore key minmax [withscores] [limit offset count] 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 zrevrangebyscore key maxmin [withscores] [limit offset count] 同上，改为从大到小排列。 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt; 为元素的 score 加上增量 zrem &lt;key&gt;&lt;value&gt; 删除该集合下，指定值的元素 zcount &lt;key&gt;&lt;min&gt;&lt;max&gt; 统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt; 返回该值在集合中的排名，从 0 开始。 数据结构 SortedSet(zset)是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。 zset 底层使用了两个数据结构 （1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。 （2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表 跳跃表（跳表）简介有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。 四、Redis6配置文件详解1. ###Units 单位### 配置大小单位,开头定义了一些基本的度量单位，只支持 bytes，不支持 bit 大小写不敏感 2. ###INCLUDES 包含### 类似 jsp 中的 include，多实例的情况可以把公用的配置文件提取出来 3. ###网络相关配置1.bind 默认情况 bind=127.0.0.1 只能接受本机的访问请求 不写的情况下，无限制接受任何 ip 地址的访问 生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉 ==如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis只允许接受本机的响应== 保存配置，停止服务，重启启动查看进程，配置生效 2.protected-mode 将本机访问保护模式设置 no 3.Port 端口号，默认 6379 4.tcp-backlog 设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和=未完成三次握手队列 + 已经完成三次握手队列。 在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。 注意 Linux 内核会将这个值减小到/proc/sys/net/core/somaxconn 的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果 5.timeout 一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。 6.tcp-keepalive 对访问客户端的一种心跳检测，每个 n 秒检测一次。 单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60 4. ###GENERAL 通用###1.daemonize 是否为后台进程，设置为 yes 守护进程，后台启动 2.pidfile 存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件 3.loglevel 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice 四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning 4.logfile 日志文件名称 5.databases 16 设定库的数量 默认 16，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id 5. ###SECURITY 安全###1.设置密码 访问密码的查看、设置和取消 在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。 永久设置，需要再配置文件中进行设置。 6. #### LIMITS 限制1.maxclients 设置 redis 同时可以与多少个客户端进行连接。 默认情况下为 10000 个客户端。 如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。 2.maxmemory 建议==必须设置==，否则，将内存占满，造成服务器宕机 设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定。 如果 redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等。 但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 redis 是主redis（说明你的 redis 有从 redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。 3.maxmemory-policy volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；（最近最少使用） allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键 allkeys-random：在所有集合 key 中，移除随机的 key volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key noeviction：不进行移除。针对写操作，只是返回错误信息 4.maxmemory-samples 设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis 默认会检查这么多个 key 并选择其中 LRU 的那个。 一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。 五、Redis6的发布和订阅1. 什么是发布和订阅 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者(sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 2. Redis 的发布和订阅 客户端可以订阅频道 当给这个频道发布消息后，消息就会发送给订阅的客户端 3. 发布订阅命令行实现 打开一个客户端订阅 channel1SUBSCRIBE channel1 打开另一个客户端，给 channel1 发布消息 hellopublish channel1 hello返回的值是订阅者数量 打开第一个客户端可以看到发送的消息 注：发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布的消息 六、Redis6新数据类型1. Bitmaps简介 现代计算机用二进制（位） 作为信息的基础单位， 1 个字节等于 8 位， 例如“abc”字符串是由 3 个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的 ASCII 码分别是 97、 98、 99， 对应的二进制分别是 01100001、01100010和 01100011， 合理地使用操作位能够有效地提高内存使用率和开发效率。 Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作： Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。 Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。 命令 setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;设置 Bitmaps 中某个偏移量的值（0 或 1）*offset:偏移量从 0 开始 getbit&lt;key&gt;&lt;offset&gt;获取 Bitmaps 中某个偏移量的值获取键的第 offset 位的值（从 0 开始算） bitcount统计字符串被设置为 1 的 bit 数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指 bit 组的字节的下标数，二者皆包含。 bitcount&lt;key&gt;[start end] 统计字符串从 start 字节到 end 字节比特值为 1 的数量 bitopbitop and(or/not/xor) &lt;destkey&gt; [key…]bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。 Bitmaps 与 set 对比 假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和Bitmaps 分别存储活跃用户。 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的 但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps 就不太合适了， 因为基本上大部分位都是 0。 2. HyperLogLog简介 在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量）,可以使用 Redis 的 incr、incrby 轻松实现。 但像 UV（UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。 解决基数问题有很多种方案： （1）数据存储在 MySQL 表中，使用 distinct count 计算不重复个数 （2）使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理 以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。 能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 什么是基数?比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8},基数(不重复元素)为 5。 基数估计就是在误差可接受的范围内，快速计算基数。 命令 pfadd &lt; element&gt; [element …] 添加指定元素到 HyperLogLog 中将所有元素添加到指定 HyperLogLog 数据结构中。如果执行命令后 HLL 估计的近似基数发生变化，则返回 1，否则返回 0。 pfcount [key …]计算 HLL 的近似基数，可以计算多个 HLL，比如用 HLL 存储每天的 UV，计算一周的 UV 可以使用 7 天的 UV 合并计算即可 pfmerge [sourcekey …]将一个或多个 HLL 合并后的结果存储在另一个 HLL 中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得 3. Geospatial简介Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。 命令 geoadd&lt; longitude&gt; [longitude latitude member…]添加地理位置（经度，纬度，名称） 两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。 有 效 的 经 度 从 -180 度 到 180 度 。 有 效 的 纬 度 从 -85.05112878 度 到85.05112878 度。 当坐标位置超出指定范围时，该命令将会返回一个错误。 已经添加的数据，是无法再次往里面添加的。 geopos [member…]获得指定地区的坐标值 geodist [m|km|ft|mi ] 获取两个位置之间的直线距离单位： m 表示单位为米[默认值]。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位 georadius&lt; longitude&gt;radius m|km|ft|mi以给定的经纬度为中心，找出某一半径内的元素 七、Jedis操作Redis6测试Jedis 所需要的 jar 包：12345&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 连接 Redis 注意事项 禁用 Linux 的防火墙：Linux(CentOS7)里执行命令systemctl stop/disable firewalld.service redis.conf 中注释掉 bind 127.0.0.1 ,然后 protected-mode no Jedis 常用操作测试程序： 123456789import redis.clients.jedis.Jedis;public class Demo01 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.137.3&quot;,6379); String pong = jedis.ping(); System.out.println(&quot;连接成功：&quot;+pong); jedis.close(); &#125;&#125; 数据读写测试： 123456789101112//keyjedis.set(&quot;k1&quot;, &quot;v1&quot;);jedis.set(&quot;k2&quot;, &quot;v2&quot;);jedis.set(&quot;k3&quot;, &quot;v3&quot;);Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);System.out.println(keys.size());for (String key : keys) &#123; System.out.println(key);&#125;System.out.println(jedis.exists(&quot;k1&quot;));System.out.println(jedis.ttl(&quot;k1&quot;));System.out.println(jedis.get(&quot;k1&quot;)); 123456789101112131415161718192021222324252627282930313233343536373839//Stringjedis.mset(&quot;str1&quot;,&quot;v1&quot;,&quot;str2&quot;,&quot;v2&quot;,&quot;str3&quot;,&quot;v3&quot;);System.out.println(jedis.mget(&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;));//ListList&lt;String&gt; list = jedis.lrange(&quot;mylist&quot;,0,-1);for (String element : list) &#123; System.out.println(element);&#125;//setjedis.sadd(&quot;orders&quot;, &quot;order01&quot;);jedis.sadd(&quot;orders&quot;, &quot;order02&quot;);jedis.sadd(&quot;orders&quot;, &quot;order03&quot;);jedis.sadd(&quot;orders&quot;, &quot;order04&quot;);Set&lt;String&gt; smembers = jedis.smembers(&quot;orders&quot;);for (String order : smembers) &#123; System.out.println(order);&#125;jedis.srem(&quot;orders&quot;, &quot;order02&quot;);//hashjedis.hset(&quot;hash1&quot;,&quot;userName&quot;,&quot;lisi&quot;);System.out.println(jedis.hget(&quot;hash1&quot;,&quot;userName&quot;));Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();map.put(&quot;telphone&quot;,&quot;13810169999&quot;);map.put(&quot;address&quot;,&quot;atguigu&quot;);map.put(&quot;email&quot;,&quot;abc@163.com&quot;);jedis.hmset(&quot;hash2&quot;,map);List&lt;String&gt; result = jedis.hmget(&quot;hash2&quot;, &quot;telphone&quot;,&quot;email&quot;);for (String element : result) &#123; System.out.println(element);&#125;//zsetjedis.zadd(&quot;zset01&quot;, 100d, &quot;z3&quot;);jedis.zadd(&quot;zset01&quot;, 90d, &quot;l4&quot;);jedis.zadd(&quot;zset01&quot;, 80d, &quot;w5&quot;);jedis.zadd(&quot;zset01&quot;, 70d, &quot;z6&quot;);Set&lt;String&gt; zrange = jedis.zrange(&quot;zset01&quot;, 0, -1);for (String e : zrange) &#123; System.out.println(e);&#125; 实例要求：1、输入手机号，点击发送后随机生成 6 位数字码，2 分钟有效2、输入验证码，点击验证，返回成功或失败3、每个手机号每天只能输入 3 次 实现： 123456789101112131415161718192021222324~~~# 八、Redis6与Spring Boot整合1. 在 pom.xml 文件中引入 redis 相关依赖 ~~~xml &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X 集成 redis 所需 common-pool2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; application.properties 配置 redis 配置 12345678910111213141516#Redis 服务器地址spring.redis.host=192.168.140.136#Redis 服务器连接端口spring.redis.port=6379#Redis 数据库索引（默认为 0）spring.redis.database= 0#连接超时时间（毫秒）spring.redis.timeout=1800000#连接池最大连接数（使用负值表示没有限制）spring.redis.lettuce.pool.max-active=20#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-wait=-1#连接池中的最大空闲连接spring.redis.lettuce.pool.max-idle=5#连接池中的最小空闲连接spring.redis.lettuce.pool.min-idle=0 添加 redis 配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;@Beanpublic RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactoryfactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new; StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key 序列化方式 template.setKeySerializer(redisSerializer); //value 序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap 序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template;&#125;@Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间 600 秒 RedisCacheConfiguration config =RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofSeconds(600)).serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)).serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory).cacheDefaults(config).build(); return cacheManager; &#125;&#125; RedisTestController 中添加测试方法 1234567891011121314@RestController@RequestMapping(&quot;/redisTest&quot;)public class RedisTestController &#123;@Autowiredprivate RedisTemplate redisTemplate;@GetMapping public String testRedis() &#123; //设置值到 redis redisTemplate.opsForValue().set(&quot;name&quot;,&quot;lucy&quot;); //从 redis 获取值 String name = (String)redisTemplate.opsForValue().get(&quot;name&quot;); return name; &#125;&#125; 九、Redis6的事务操作1. 定义 Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送过来的命令请求所打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队 2. Multi、Exec、discard从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec 后，Redis 会将之前的命令队列中的命令依次执行。 组队的过程中可以通过 discard 来放弃组队。 示例： 组队成功，提交成功 组队阶段报错，提交失败 组队成功，提交有成功有失败情况 3. 事务的错误处理 组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。 4. 为什么要做成事务满足高并发需求等 5. 事务冲突例子一个请求想给金额减8000 一个请求想给金额减5000 一个请求想给金额减1000 悲观锁 ==悲观锁(Pessimistic Lock),== 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。**==传统的关系型数据库里边就用到了很多这种锁机制==，比如行锁，表锁等，读锁，写锁**等，都是在做操作之前先上锁。 乐观锁 ==乐观锁(Optimistic Lock)==, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。==乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。== WATCH key [key …]在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务**执行之前这个(**或这些) key 被其他命令所改动，那么事务将被打断。 unwatch取消 WATCH 命令对所有 key 的监视。 如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。 http://doc.redisfans.com/transaction/exec.html 6. Redis事务三特性 单独的隔离操作 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行 不保证原子性 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 7.秒杀案例解决计数器和人员记录的事务操作 Redis事务，秒杀并发模拟 使用工具ab模拟测试 CentOS6 默认安装 CentOS7需要手动安装 命令：yum install httpd-tools 无网络情况下： 进入cd /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同） 顺序安装 123apr-1.4.8-3.el7.x86_64.rpmapr-util-1.5.2-6.el7.x86_64.rpmhttpd-tools-2.4.6-67.el7.centos.x86_64.rpm 测试： vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。 内容：prodid=0101&amp; ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded http://192.168.2.115:8081/Seckill/doseckill 超卖： 超卖 乐观锁实现 代码： 1234567891011121314151617//增加乐观锁jedis.watch(qtkey); //3.判断库存String qtkeystr = jedis.get(qtkey);if(qtkeystr==null || &quot;&quot;.equals(qtkeystr.trim())) &#123; System.out.println(&quot;未初始化库存&quot;); jedis.close(); return false ;&#125; int qt = Integer.parseInt(qtkeystr);if(qt&lt;=0) &#123; System.err.println(&quot;已经秒光&quot;); jedis.close(); return false;&#125; 增加事务： 12345678910111213141516171819202122//增加事务Transaction multi = jedis.multi(); //4.减少库存//jedis.decr(qtkey);multi.decr(qtkey); //5.加人//jedis.sadd(usrkey, uid);multi.sadd(usrkey, uid); //执行事务List&lt;Object&gt; list = multi.exec(); //判断事务提交是否失败if(list==null || list.size()==0) &#123; System.out.println(&quot;秒杀失败&quot;); jedis.close(); return false;&#125;System.err.println(&quot;秒杀成功&quot;);jedis.close(); 效果图： 增加并发连接有限制b -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ http://192.168.140.1:8080/seckill/doseckill 增加-r参数，-r Don’t exit on socket receive errors. ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’ http://192.168.140.1:8080/seckill/doseckill 秒光还有库存已经秒光，可是还有库存 ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ http://192.168.137.1:8080/seckill/doseckill 已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。 连接超时连接超时，通过连接池解决 连接池节省每次连接redis服务带来的消耗，把连接好的实例反复利用。 通过参数管理连接的行为 代码： 1234567891011121314151617181920212223242526272829303132333435import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class JedisPoolUtil &#123; private static volatile JedisPool jedisPool = null; private JedisPoolUtil() &#123; &#125; public static JedisPool getJedisPoolInstance() &#123; if (null == jedisPool) &#123; synchronized (JedisPoolUtil.class) &#123; if (null == jedisPool) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(200); poolConfig.setMaxIdle(32); poolConfig.setMaxWaitMillis(100*1000); poolConfig.setBlockWhenExhausted(true); poolConfig.setTestOnBorrow(true); // ping PONG jedisPool = new JedisPool(poolConfig, &quot;192.168.44.168&quot;, 6379, 60000 ); &#125; &#125; &#125; return jedisPool; &#125; public static void release(JedisPool jedisPool, Jedis jedis) &#123; if (null != jedis) &#123; jedisPool.returnResource(jedis); &#125; &#125;&#125; 链接池参数 MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。 maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例； MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException； testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的； 解决库存遗留lua脚本 Lua 是一个小巧的脚本语言，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。 很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。 这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。 https://www.w3cschool.cn/lua/ LUA脚本在Redis中的优势： 将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。 LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。 但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。 利用lua脚本淘汰用户，解决超卖问题。 redis 2.6版本以后，通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。 12345678910111213141516local userid=KEYS[1]; local prodid=KEYS[2];local qtkey=&quot;sk:&quot;..prodid..&quot;:qt&quot;;local usersKey=&quot;sk:&quot;..prodid.&quot;:usr&#x27;; local userExists=redis.call(&quot;sismember&quot;,usersKey,userid);if tonumber(userExists)==1 then return 2;endlocal num= redis.call(&quot;get&quot; ,qtkey);if tonumber(num)&lt;=0 then return 0; else redis.call(&quot;decr&quot;,qtkey); redis.call(&quot;sadd&quot;,usersKey,userid);endreturn 1; 秒杀实现项目结构： 第一版，普通实现少量访问的情况下，秒杀正常，此时未达到并发效果。 使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。 第二版，增加事务-乐观锁增加事务-乐观锁解决超卖问题，但出现遗留库存和连接超时 第三版，连接池解决超时问题第四版，LUA脚本解决库存遗留问题代码实现： JedisPoolUtil.java 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class JedisPoolUtil &#123; private static volatile JedisPool jedisPool = null; private JedisPoolUtil() &#123; &#125; public static JedisPool getJedisPoolInstance() &#123; if (null == jedisPool) &#123; synchronized (JedisPoolUtil.class) &#123; if (null == jedisPool) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(200); poolConfig.setMaxIdle(32); poolConfig.setMaxWaitMillis(100*1000); poolConfig.setBlockWhenExhausted(true); poolConfig.setTestOnBorrow(true); // ping PONG jedisPool = new JedisPool(poolConfig, &quot;192.168.44.168&quot;, 6379, 60000 ); &#125; &#125; &#125; return jedisPool; &#125; public static void release(JedisPool jedisPool, Jedis jedis) &#123; if (null != jedis) &#123; jedisPool.returnResource(jedis); &#125; &#125;&#125; SecKill_redis.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.atguigu;import java.io.IOException;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;import org.slf4j.LoggerFactory;import ch.qos.logback.core.rolling.helper.IntegerTokenConverter;import redis.clients.jedis.HostAndPort;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.ShardedJedisPool;import redis.clients.jedis.Transaction;/** * */public class SecKill_redis &#123; public static void main(String[] args) &#123; Jedis jedis =new Jedis(&quot;192.168.44.168&quot;,6379); System.out.println(jedis.ping()); jedis.close(); &#125; //秒杀过程 public static boolean doSecKill(String uid,String prodid) throws IOException &#123; //1 uid和prodid非空判断 if(uid == null || prodid == null) &#123; return false; &#125; //2 连接redis //Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379); //通过连接池得到jedis对象 JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis = jedisPoolInstance.getResource(); //3 拼接key // 3.1 库存key String kcKey = &quot;sk:&quot;+prodid+&quot;:qt&quot;; // 3.2 秒杀成功用户key String userKey = &quot;sk:&quot;+prodid+&quot;:user&quot;; //监视库存 jedis.watch(kcKey); //4 获取库存，如果库存null，秒杀还没有开始 String kc = jedis.get(kcKey); if(kc == null) &#123; System.out.println(&quot;秒杀还没有开始，请等待&quot;); jedis.close(); return false; &#125; // 5 判断用户是否重复秒杀操作 if(jedis.sismember(userKey, uid)) &#123; System.out.println(&quot;已经秒杀成功了，不能重复秒杀&quot;); jedis.close(); return false; &#125; //6 判断如果商品数量，库存数量小于1，秒杀结束 if(Integer.parseInt(kc)&lt;=0) &#123; System.out.println(&quot;秒杀已经结束了&quot;); jedis.close(); return false; &#125; //7 秒杀过程 //使用事务 Transaction multi = jedis.multi(); //组队操作 multi.decr(kcKey); multi.sadd(userKey,uid); //执行 List&lt;Object&gt; results = multi.exec(); if(results == null || results.size()==0) &#123; System.out.println(&quot;秒杀失败了....&quot;); jedis.close(); return false; &#125; //7.1 库存-1 //jedis.decr(kcKey); //7.2 把秒杀成功用户添加清单里面 //jedis.sadd(userKey,uid); System.out.println(&quot;秒杀成功了..&quot;); jedis.close(); return true; &#125;&#125; SecKill_redisByScript.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.atguigu;import java.io.IOException;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;import org.slf4j.LoggerFactory;import ch.qos.logback.core.joran.conditional.ElseAction;import redis.clients.jedis.HostAndPort;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.ShardedJedisPool;import redis.clients.jedis.Transaction;public class SecKill_redisByScript &#123; private static final org.slf4j.Logger logger =LoggerFactory.getLogger(SecKill_redisByScript.class) ; public static void main(String[] args) &#123; JedisPool jedispool = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis=jedispool.getResource(); System.out.println(jedis.ping()); Set&lt;HostAndPort&gt; set=new HashSet&lt;HostAndPort&gt;(); // doSecKill(&quot;201&quot;,&quot;sk:0101&quot;); &#125; static String secKillScript =&quot;local userid=KEYS[1];\\r\\n&quot; + &quot;local prodid=KEYS[2];\\r\\n&quot; + &quot;local qtkey=&#x27;sk:&#x27;..prodid..\\&quot;:qt\\&quot;;\\r\\n&quot; + &quot;local usersKey=&#x27;sk:&#x27;..prodid..\\&quot;:usr\\&quot;;\\r\\n&quot; + &quot;local userExists=redis.call(\\&quot;sismember\\&quot;,usersKey,userid);\\r\\n&quot; + &quot;if tonumber(userExists)==1 then \\r\\n&quot; + &quot; return 2;\\r\\n&quot; + &quot;end\\r\\n&quot; + &quot;local num= redis.call(\\&quot;get\\&quot; ,qtkey);\\r\\n&quot; + &quot;if tonumber(num)&lt;=0 then \\r\\n&quot; + &quot; return 0;\\r\\n&quot; + &quot;else \\r\\n&quot; + &quot; redis.call(\\&quot;decr\\&quot;,qtkey);\\r\\n&quot; + &quot; redis.call(\\&quot;sadd\\&quot;,usersKey,userid);\\r\\n&quot; + &quot;end\\r\\n&quot; + &quot;return 1&quot; ; static String secKillScript2 = &quot;local userExists=redis.call(\\&quot;sismember\\&quot;,\\&quot;&#123;sk&#125;:0101:usr\\&quot;,userid);\\r\\n&quot; + &quot; return 1&quot;; public static boolean doSecKill(String uid,String prodid) throws IOException &#123; JedisPool jedispool = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis=jedispool.getResource(); //String sha1= .secKillScript; String sha1= jedis.scriptLoad(secKillScript); Object result= jedis.evalsha(sha1, 2, uid,prodid); String reString=String.valueOf(result); if (&quot;0&quot;.equals( reString ) ) &#123; System.err.println(&quot;已抢空！！&quot;); &#125;else if(&quot;1&quot;.equals( reString ) ) &#123; System.out.println(&quot;抢购成功！！！！&quot;); &#125;else if(&quot;2&quot;.equals( reString ) ) &#123; System.err.println(&quot;该用户已抢过！！&quot;); &#125;else&#123; System.err.println(&quot;抢购异常！！&quot;); &#125; jedis.close(); return true; &#125;&#125; SecKillServlet.java 12345678910111213141516171819202122232425262728293031323334package com.atguigu;import java.io.IOException;import java.util.ArrayList;import java.util.LinkedList;import java.util.Random;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.xml.ws.soap.AddressingFeature.Responses;/** * 秒杀案例 */public class SecKillServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SecKillServlet() &#123; super(); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String userid = new Random().nextInt(50000) +&quot;&quot; ; String prodid =request.getParameter(&quot;prodid&quot;); //boolean isSuccess=SecKill_redis.doSecKill(userid,prodid); boolean isSuccess= SecKill_redisByScript.doSecKill(userid,prodid); response.getWriter().print(isSuccess); &#125;&#125; 十、Redis6持久化1. 简介 Redis 提供了2个不同形式的持久化方式。 RDB（Redis DataBase） AOF（Append OfFile） 2. RDB RDB是什么？ 在指定的==时间间隔==内将内存中的数据集==快照==写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 执行 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。==RDB的缺点是最后一次持久化后的数据可能丢失==。 Fork Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术” 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 RDB持久化： dump.rdb文件在redis.conf中配置文件名称，默认为dump.rdb 配置： rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下 dir “/myredis/“ 如何触发RDB快照；保持策略 配置文件中默认的快照配置 命令save VS bgsave save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。 bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。 可以通过lastsave 命令获取最后一次成功执行快照的时间 flushall命令： 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 ###SNAPSHOTTING快照### Save： 格式：save 秒钟 写操作次数 RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件， 默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。 禁用 不设置save指令，或者给save传入空字符串 stop-writes-on-bgsave-error 当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes. rdbcompression 压缩文件 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。 如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes. rdbchecksum 检查完整性 在存储快照后，还可以让redis使用CRC64算法来进行数据校验， 但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能 推荐yes. rdb的备份 先通过config get dir 查询rdb文件的目录 将*.rdb的文件拷贝到别的地方 rdb的恢复 关闭Redis 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb 启动Redis, 备份数据会直接加载 RDB优势 适合大规模的数据恢复 对数据完整性和一致性要求不高更适合使用 节省磁盘空间 恢复速度快 劣势 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。 如何停止动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略 小结 3. AOF概述 以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 持久化流程 客户端的请求写命令会被append追加到AOF缓冲区内； AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中； AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量； Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的； 补充AOF默认不开启 可以在redis.conf中配置文件名称，默认为 appendonly.aof AOF文件的保存路径，同RDB的路径一致。 优先级 AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失） AOF启动、修复、恢复 AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。 正常恢复 修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir) 恢复：重启redis然后重新加载 异常恢复 修改默认的appendonly no，改为yes 如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复 备份被写坏的AOF文件 恢复：重启redis，然后重新加载 AOF同步频率设置 appendfsync always 始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好 appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。 appendfsync no redis不主动进行同步，把同步时机交给操作系统。 Rewrite压缩 是什么： AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 重写原理，如何实现重写 AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 no-appendfsync-on-rewrite： 如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能） 如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低） 触发机制，何时重写 Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发 ==重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写==。 auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发） auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。 例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB 系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size, 如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 重写流程 bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。 主进程fork出子进程执行重写操作，保证主进程不会阻塞。 子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。 子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。 主进程把aof_rewrite_buf中的数据写入到新的AOF文件。 使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。 优势 备份机制更稳健，丢失数据概率更低。 可读的日志文本，通过操作AOF稳健，可以处理误操作。 劣势 比起RDB占用更多的磁盘空间。 恢复备份速度要慢。 每次读写都同步的话，有一定的性能压力。 存在个别Bug，造成恢复不能。 小结 4. 总结用哪个好 官方推荐两个都启用。 如果对数据不敏感，可以选单独用RDB。 不建议单独用 AOF，因为可能会出现Bug。 如果只是做纯内存缓存，可以都不用。 官方： RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储 AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式. 同时开启两种持久化方式 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。 性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。 如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。 代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。 只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。 默认超过原大小100%大小时重写可以改到适当的数值。 十一、Redis6的主从复制1. 概述 是什么 主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 能干什么 读写分离，性能扩展 容灾快速恢复 2. 使用 拷贝多个redis.conf文件include(写绝对路径) 开启daemonize yes Pid文件名字pidfile 指定端口port Log文件名字 dump.rdb名字dbfilename Appendonly 关掉或者换名字 流程 新建redis6379.conf，填写以下内容 1234include /myredis/redis.confpidfile /var/run/redis_6379.pidport 6379dbfilename dump6379.rdb 新建redis6380.conf，填写以下内容 新建redis6381.conf，填写以下内容 slave-priority 10 设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100 启动三台redis服务器 查看三台主机运行情况 info replication 打印主从复制的相关信息 配从(库)不配主(库) slaveof &lt;ip&gt;&lt;port&gt; 成为某个实例的从服务器 在6380和6381上执行: slaveof 127.0.0.1 6379 在主机上写，在从机上可以读取数据。在从机上写数据报错 主机挂掉，重启就行，一切如初 从机重启需重设：slaveof 127.0.0.1 6379 可以将配置增加到文件中。永久生效。 常用技巧一主二仆切入点问题： slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？ 从机是否可以写？set可否？ 主机shutdown后情况如何？从机是上位还是原地待命？ 主机又回来了后，主机新增记录，从机还能否顺利复制？ 其中一台从机down后情况如何？依照原有它能跟上大部队吗？ 薪火相传 上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。 用 slaveof &lt;ip&gt;&lt;port&gt; 中途变更转向:会清除之前的数据，重新建立拷贝最新的 风险是一旦某个slave宕机，后面的slave都没法备份 主机挂了，从机还是从机，无法写数据了 反客为主 当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。 用 slaveof no one 将从机变为主机。 复制原理 Slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行 哨兵模式反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 使用 调整为一主二仆模式，6379带着6380、6381 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错 配置哨兵,填写内容 sentinel monitor mymaster 127.0.0.1 6379 1 其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 启动哨兵 /usr/local/bin redis做压测可以用自带的redis-benchmark工具 执行redis-sentinel /myredis/sentinel.conf 当主机挂掉，从机选举中产生新的主机 (大概10秒左右可以看到哨兵窗口日志，切换了新的主机) 哪个从机会被选举为主机呢？根据优先级别：slave-priority 原主机重启后会变为从机。 复制延时 由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 故障恢复 优先级在redis.conf中默认：slave-priority 100，值越小优先级越高 偏移量是指获得原主机数据最全的 每个redis实例启动后都会随机生成一个40位的runid 主从复制123456789101112131415161718192021private static JedisSentinelPool jedisSentinelPool=null;public static Jedis getJedisFromSentinel()&#123;if(jedisSentinelPool==null)&#123; Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;(); sentinelSet.add(&quot;192.168.11.103:26379&quot;); JedisPoolConfig jedisPoolConfig =new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(10); //最大可用连接数 jedisPoolConfig.setMaxIdle(5); //最大闲置连接数 jedisPoolConfig.setMinIdle(5); //最小闲置连接数 jedisPoolConfig.setBlockWhenExhausted(true); //连接耗尽是否等待 jedisPoolConfig.setMaxWaitMillis(2000); //等待时间 jedisPoolConfig.setTestOnBorrow(true); //取连接的时候进行一下测试 ping pong jedisSentinelPool=new JedisSentinelPool(&quot;mymaster&quot;,sentinelSet,jedisPoolConfig); return jedisSentinelPool.getResource(); &#125;else&#123; return jedisSentinelPool.getResource(); &#125;&#125; 十二、Redis6集群1. 概述问题 容量不够，redis如何进行扩容？ 并发写操作， redis如何分摊？ 另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。 之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。 什么是集群 Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 2. 配置集群前置删除持久化数据：将rdb,aof文件都删除掉。 制作六个实例，6379,6380,6381,6389,6390,6391。包括一主二从及对应的备份主机。 配置基本信息： 开启daemonize yes Pid文件名字 指定端口 Log文件名字 Dump.rdb名字 Appendonly 关掉或者换名字 配置文件Redis cluster配置修改： cluster-enabled yes 打开集群模式 cluster-config-file nodes-6379.conf 设定节点配置文件名 cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。 123456789include /home/bigdata/redis.confport 6379pidfile &quot;/var/run/redis_6379.pid&quot;dbfilename &quot;dump6379.rdb&quot;dir &quot;/home/bigdata/redis_cluster&quot;logfile &quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 15000 修改好redis6379.conf文件，拷贝多个redis.conf文件 修改另外的五个文件查找替换使用：:%s/6379/6380 启动启动6个redis服务 将六个节点合成一个集群 组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。 组合： cd /opt/redis-6.2.1/src 1redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391 此处不要用127.0.0.1， 请用真实IP地址 –replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。 连接普通方式登录 可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。 -c 采用集群策略连接，设置数据会自动切换到相应的写主机 通过 cluster nodes 命令查看集群信息 redis cluster 如何分配这六个节点? 一个集群至少要有三个主节点。 选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。 什么是slots 一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中： 节点 A 负责处理 0 号至 5460 号插槽。 节点 B 负责处理 5461 号至 10922 号插槽。 节点 C 负责处理 10923 号至 16383 号插槽。 在集群中录入值 在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。 redis-cli客户端提供了 –c 参数实现自动重定向。 如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。 不在一个slot下的键值，是不能使用mget,mset等多键操作。 可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。 查询集群中的值 CLUSTER GETKEYSINSLOT 返回 count 个 slot 槽中的键。 故障恢复 如果主节点下线？从节点能否自动升为主节点？注意：15秒超时 主节点恢复后，主从关系会如何？主节点回来变成从机。 如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续? 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。 redis.conf中的参数 cluster-require-full-coverage 3. 集群的Jedis开发即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。 无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。 123456789public class JedisClusterTest &#123; public static void main(String[] args) &#123; Set&lt;HostAndPort&gt;set =new HashSet&lt;HostAndPort&gt;(); set.add(new HostAndPort(&quot;192.168.31.211&quot;,6379)); JedisCluster jedisCluster=new JedisCluster(set); jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;); System.out.println(jedisCluster.get(&quot;k1&quot;)); &#125;&#125; 4. 评价优点 实现扩容 分摊压力 无中心配置相对简单 不足 多键操作是不被支持的 多键的Redis事务是不被支持的。lua脚本不被支持 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。 十三、Redis6应用问题解决1. 缓存穿透概述key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 解决一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 解决方案： 对空值缓存： 如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟 设置可访问的名单（白名单）： 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。 采用布隆过滤器： (布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。 布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。) 将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。 4。 进行实时监控： 当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务 2. 缓存击穿概述key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。 解决问题： 预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长 实时调整：现场监控哪些数据热门，实时调整key的过期时长 使用锁： 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key； 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。 3. 缓存雪崩概述key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key 正常访问 缓存失效瞬间 解决缓存失效时的雪崩效应对底层系统的冲击非常可怕！ 解决方案： 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等） 使用锁或队列： 用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况 设置过期标志更新缓存： 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。 将缓存失效时间分散开： 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 4. 分布式锁概述随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 分布式锁主流的实现方案： 基于数据库实现分布式锁 基于缓存（Redis等） 基于Zookeeper 每一种分布式锁解决方案都有各自的优缺点： 性能：redis最高 可靠性：zookeeper最高 这里，我们就基于redis实现分布式锁。 解决redis:命令 # set sku:1:info “OK” NX PX 10000 EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。 PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 XX ：只在键已经存在时，才对键进行设置操作。 多个客户端同时获取锁（setnx） 获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del） 其他客户端等待重试 代码Redis:set num 0 12345678910111213141516171819202122232425262728@GetMapping(&quot;testLock&quot;)public void testLock()&#123; //1获取锁，setne Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;); //2获取锁成功、查询num的值 if(lock)&#123; Object value = redisTemplate.opsForValue().get(&quot;num&quot;); //2.1判断num为空return if(StringUtils.isEmpty(value))&#123; return; &#125; //2.2有值就转成成int int num = Integer.parseInt(value+&quot;&quot;); //2.3把redis的num加1 redisTemplate.opsForValue().set(&quot;num&quot;, ++num); //2.4释放锁，del redisTemplate.delete(&quot;lock&quot;); &#125;else&#123; //3获取锁失败、每隔0.1秒再获取 try &#123; Thread.sleep(100); testLock(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 重启服务集群，通过网关压力测试：ab -n 1000 -c 100 http://192.168.140.1:8080/test/testLock 查看redis中num的值： 基本实现。 问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放 解决：设置过期时间，自动释放锁。 优化过期时间设置过期时间有两种方式： 首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放） 在set时指定过期时间（推荐） 设置过期时间： 压力测试肯定也没有问题。自行测试 问题：可能会释放其他服务器的锁。 场景：如果业务逻辑的执行时间是7s。执行流程如下 index1业务逻辑没执行完，3秒后锁被自动释放。 index2获取到锁，执行业务逻辑，3秒后锁被自动释放。 index3获取到锁，执行业务逻辑 index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。 最终等于没锁的情况。 解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁 UUID防误删 问题：删除操作缺乏原子性。 场景： index1执行删除时，查询到的lock值确实和uuid相等uuid=v1set(lock,uuid)； index1执行删除前，lock刚好过期时间已到，被redis自动释放在redis中没有了lock，没有了锁。 index2获取了lockindex2线程获取到了cpu的资源，开始执行方法uuid=v2set(lock,uuid)； index1执行删除，此时会把index2的lock删除index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行删除的index2的锁！ LUA脚本保证删除的原子性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@GetMapping(&quot;testLockLua&quot;)public void testLockLua() &#123; //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中 String uuid = UUID.randomUUID().toString(); //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！ String skuId = &quot;25&quot;; // 访问skuId 为25号的商品 100008348542 String locKey = &quot;lock:&quot; + skuId; // 锁住的是每个商品的数据 // 3 获取锁 Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS); // 第一种： lock 与过期时间中间不写任何的代码。 // redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间 // 如果true if (lock) &#123; // 执行的业务逻辑开始 // 获取缓存中的num 数据 Object value = redisTemplate.opsForValue().get(&quot;num&quot;); // 如果是空直接返回 if (StringUtils.isEmpty(value)) &#123; return; &#125; // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！ int num = Integer.parseInt(value + &quot;&quot;); // 使num 每次+1 放入缓存 redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num)); /*使用lua脚本来锁*/ // 定义lua 脚本 String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; // 使用redis执行lua执行 DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(); redisScript.setScriptText(script); // 设置一下返回值类型 为Long // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型， // 那么返回字符串与0 会有发生错误。 redisScript.setResultType(Long.class); // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。 redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid); &#125; else &#123; // 其他线程等待 try &#123; // 睡眠 Thread.sleep(1000); // 睡醒了之后，调用方法。 testLockLua(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Lua 脚本详解： 项目中正确使用： 定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。 12String locKey =&quot;lock:&quot;+skuId; // 锁住的是每个商品的数据Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS); 总结加锁： 1234// 1. 从redis中获取锁,set k1 v1 px 20000 nxString uuid = UUID.randomUUID().toString();Boolean lock = this.redisTemplate.opsForValue() .setIfAbsent(&quot;lock&quot;, uuid, 2, TimeUnit.SECONDS); 使用lua释放锁： 12345678// 2. 释放锁 delString script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;// 设置lua脚本返回的数据类型DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();// 设置lua脚本返回类型为LongredisScript.setResultType(Long.class);redisScript.setScriptText(script);redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;),uuid); 重试： 12Thread.sleep(500);testLock(); 为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： - 互斥性。在任意时刻，只有一个客户端能持有锁。 - 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 - 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 - 加锁和解锁必须具有原子性。 十四、Redis6.0新功能1. ACL概述Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。 在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ： （1）接入权限:用户名和密码 （2）可以执行的命令 （3）可以操作的 KEY 参考官网：https://redis.io/topics/acl 命令1、使用acl list命令展现用户权限列表 （1）数据说明 2、使用acl cat命令 （1）查看添加权限指令类别 （2）加参数类型名可以查看类型下具体命令 3、使用acl whoami命令查看当前用户 4、使用aclsetuser命令创建和编辑用户ACL （1）ACL规则 下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。 ACL规则 ： 类型 参数 启动和禁用用户 on 激活某用户账号 off 禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。 权限的添加删除 +&lt;command&gt; 将指令添加到用户可以调用的指令列表中 -&lt;command&gt; 从用户可执行指令列表移除指令 +@&lt;category&gt; 添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。 -@&lt;actegory&gt; 从用户可调用指令中移除类别 allcommands +@all的别名 nocommand -@all的别名 可操作键的添加或删除 ~&lt;pattern&gt; 添加可作为用户可操作的键的模式。例如~*允许所有的键 （2）通过命令创建新用户默认权限 acl setuser user1 在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。 （3）设置有用户名、密码、ACL权限、并启用的用户 acl setuser user2 on &gt;password ~cached:* +get| (4)切换用户，验证权限 2. IO多线程概述Redis6终于支撑多线程了，告别单线程了吗？ IO多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程。Redis6执行命令依然是单线程。 原理Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下: 另外，多线程IO默认也是不开启的，需要再配置文件中配置 io-threads-do-reads yes io-threads 4 3. 工具支持Cluster之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。 4. 其他Redis6新功能还有： 1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信 2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。 3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。 4、Modules API Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。","categories":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://stary2020.gitee.io/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"http://stary2020.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":null},{"title":"JVM入门","slug":"java-2021-07-22-JVM","date":"2021-07-22T01:25:34.000Z","updated":"2021-08-19T02:34:08.450Z","comments":true,"path":"2021/07/22/java-2021-07-22-JVM/","link":"","permalink":"http://stary2020.gitee.io/2021/07/22/java-2021-07-22-JVM/","excerpt":"","text":"一、jvm概述jvm与java体系结构 前言 面向人群及参考书目 java及jvm简介 java发展的重大事件 虚拟机与java虚拟机 jvm的整体结构 java代码执行流程 jvm发架构模型 jvm的生命周期 jvm的发展历程 1.前言问题： 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM==（ OOM，全称“Out Of Memory”==，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。） 想解决线上jvm GC问题，但却无从下手 新项目上线，对各种jvm参数设置不了解 面试：实际项目中如何调优jvm参数，如何解决GC、OOM等问题 应用程序–》框架–》java API–》jvm 架构师： 应该如何让系统更快 如何避免系统出现瓶颈 高年薪： 参与现有系统的性能优化，重构，保证平台性能和稳定性 根据业务场景和需求，决定技术方向，做技术选型 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求 解决各类潜在系统风险，核心功能的架构与代码编写 分析系统瓶颈。解决各种疑难杂症，性能调优等 GC（Garbage Collection）： 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构，工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是java工程师进阶的必备技能。 2.面向人群 拥有一定开发经验的java平台开发人员 软件设计师、架构师 系统调优人员 有一定的java编程基础并希望进一步理解java的程序员 虚拟机爱好者，jvm实践者 参考书目： 《The java Virtual Machine Specification》 中文版：《深入理解Java虚拟机》第三版 3.java及jvm简介java生态圈 平台 文化 社区 跨平台的语言：javajava程序–》字节码文件–》win版JVM、Linux版JVM、Mac版JVM java程序可以在多个平台上运行，“一次编译，四处运行” 跨语言的平台：JVM不同种类的语言，编译成字节码文件后，都可以在JVM上运行 字节码： 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说，任何能在JVM平台上执行的字节码格式都是一样的。所以应该统称为：JVM字节码 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行 Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了java虚拟机指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。 多语言混合编程： java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向 例如：一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己的语言的原生API一样方便，因为他们最终都运行在一个虚拟机之上。 对这些运行与java虚拟机之上、java之外的语言，来自系统级的、底层的支持正在快速增强，以JSR-292为核心的一系列项目和功能改进，推动Java虚拟机从“java语言的虚拟机”向“多语言虚拟机”的方向发展 4.java发展的重大事件 1990年，在Sun计算机公司中，由Patrick Naughton、 MikeSheridan及James Gosling 领导的小组Green Team,开发出的新的程序语言，命名为0ak,后期命名为Java 1995年，Sun正式发 布Java和HotJava产品，Java 首次公开亮相。 1996年1月23日Sun Microsystems发布 了JDK 1.0。 1998年，JDK 1.2版本发布。同时，Sun发布了JSP/Servlet、 EJB规范，以及将Java分成了J2EE、 J2SE和J2ME。这 表明了Java开始向企业、 桌面应用和移动设备应用3大领域挺进。 2000年，JDK 1.3发布，Java HotSpot Virtual Machinei正式发布，成为Java的默认虚拟机。 2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台。 2003年年底，Java平台的Scalai正式发布，同年Groovy也加入了Java阵营。 2004年，JDK 1.5发布。同时JDK 1.5改 名为JavaSE 5.0。 2006年，JDK 6发布。同年，Java开源并建立了OpenJDK。 顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。 2007年，Java平台迎来了新伙伴Clojure。 2008年，Oracle收购了BEA, 得到了JRockit 虚拟机。 2009年，Twitter宜布把后台大部分程序从Ruby迁移到Scala,这是Java平台的又一次大规模应用。. 2010年，oracle收购了Sun,获得Java商标和最具价值的Hotspot虚拟机。此时，0racle拥有市场占用率最高的两款虚拟机Hotspot和JRockit,并计划在未来对它们进行整合: HotRockit 2011年，JDK7发布。在JDK 1.7u4中，正式启用了新的垃圾回收器G1。 2014年三月，JDK8发布。历史性版本。 2017年，JDK9发布。将G1设置为默认GC，替代CHS 同年，IBM的J9开源，形成了现在的open J9社区 2018年，Android的Java侵权案判决，Google赔偿oracleit88亿美元 同年，Oracle宣告JavaEE成为历史名词，JDBC、 JMS、Servlet赠了Eclipse基金会 同年，JDK11发布， LTS版木的JDK, 发布革命性的zGC,调整JDK授权许可 2019年，JDK12发布， 加入RedHat领导开发的Shenandoah GCA 5.虚拟机与java虚拟机 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机，它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机 Visual Box，VMware就属于系统虚拟机，他们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中 JVM是运行在操作系统之上的，它与硬件没有直接的交互 6.jvm的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一 它采用解释器与即时编译器并存的架构 在今天，Java程序的运行性能已经渐渐达到了可以和C、C++一较高下的地步 7.java代码执行流程 java源码 java编译器 词法分析 语法分析 语法、抽象语法树 语义分析 注解抽象语法树 字节码生成器 字节码 Java虚拟机 类加载器 字节码校验器 翻译字节码 JIT编译器（编译执行） 操作系统 注意： java编译器编译过程中，任何一个节点执行失败就会造成编译失败 虽然各个平台的Java虚拟机内部实现细节不尽相同，但是他们共同执行的字节码内容却是一样的 JVM的主要任务就是负责将字节码装载到其内部，解释、编译为对应平台上的机器指令。即：汇编语言，执行。 Java虚拟机使用类加载器（Class Loader）装载class文件 类加载完成之后，会进行字节码校验，字节码校验通过之后，JVM解释器会把字节码翻译成机器码，即汇编语言，交由操作系统执行 但不是所有的代码都是解释执行的，JVM对此做了优化，比如，以HotSpot虚拟机来说，它本身提供了JIT（Just In Time） 8.jvm发架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集结构则是基于寄存器的指令集架构 具体来说，这两种架构之间的区别： 基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统 避开了寄存器的分配难题，使用零地址指令方式分配 指令流中的指令大部分是零地址指令。其执行过程依赖于操作栈。指令集更小，编译器容易实现。 不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机 指令集架构则完全依赖硬件，可移植差 性能优秀和执行更高效 花费更少的指令去完成一项操作 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 举例，同样执行2+3这种逻辑操作，其指令分别如下： 基于栈式 12345678iconst_2 //常量2入栈istor_liconst_3 //常量3入栈istore_2iload_1iload_2iadd //常量2、3出栈，执行相加istore_0//结果5入栈 基于寄存器 12mov eax,2 //将eax寄存器的值设为2add eax,3 //使eax寄存器的值+3 总结 ==由于跨平台性的设计，Java的指令都是根据栈来设计的==。不同平台的CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样功能需要更多的指令。 栈： 跨平台性能，指令集小，指令多，执行性能比寄存器差 9.jvm的生命周期虚拟机的启动： Java虚拟机的启动是通过引导类加载器（BootStrap class loader）创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时它才运行，程序结束时他就停止 ==执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程== 10.jvm的发展历程Sun Classic VM 早在1996年Java1.0版本的时候，Sun公司发布了一款名为Sun Classic VM的Java虚拟机，它同时也是世界上第- -款商用Java虚拟机，JDK1 . 4时完全被淘汰。 这款虚拟机内部只提供解释器。 如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。 现在hotspot内置了此虚拟机。 Exact VM 为了解决 上一个虚拟机问题，jdk1.2时, sun提供了此虚拟机。 Exact Memory Management: 准确式内存管理 也可以叫Non-Conservative/Accurate Memory Management 虚拟机可以知道内存中某个位置的数据具体是什么类型。 具备现代高性能虚拟机的雏形 热点探测 编译器与解释器混合工.作模式 只在Solaris平台短暂使用， 其他平台上还是classic vm . 英雄气短，终被Hotspot虚拟机替换 SUN公司的HotSpot VM HotSpot历史 最初由一家名为”Longview tchnologies”的小公司设计 1997年, 此公司被Sun收购:;2009年, Sun公司被甲骨文收购。 JDK1.3时，HotSpot VIM成为默认虚拟机 目前Hotspot占有绝对的市场地位，称霸武林。 不管是现在仍在广泛使用的JDK6,还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot Sun/oracle JDK和OpenJDK的默认虚拟机 因此本课程中默认介绍的虚拟机都是HotSpot,相关机制也主要是指HotSpot的GC机制。(比如其他两个商用虚拟机都没有方法区的概念) 从服务器、桌而到移动端、嵌入式都有应用。 名称中的HotSpot指的就是它的热点代码探测技术。 通过计数器找到最具编译价值代码，触发即时编译或栈上:替换 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡 BEA的JRockit 专注于服务器端应用 它可以不太关注程序启动速度，囚此JRockit内部不包含解析器实现， 全部代码都靠即时编译器编译后执行。| 大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。 使用JRockit产品，客户已经体验到了显著的性能提高(一些超过了70号)和硬件成本的减少(达50%)。 优势:全面的Java运行时解决方案组合 JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或 微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 MissionContro1服务套件，它是一组以极低的开销来监控、管理和分析生产 环境中的应用程序的L具。 2008年，BEA被Oracle收购， Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在 HotSpot的基础上,移JRockit的优秀特性。 高斯林:目前就职于谷歌，研究人工智能和水下机器人 KVM和ICDC/CLDC Hotspot Oracle在Java ME产品线上:的两款虚拟机为: CDC/CLDC HotSpot Implementation VM KVM (Kilobyte) 是CLDC-HI早期产品 目前移动领域地位尴尬，智能手机被Android和ios.二分天下。 KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场 智能控制器、传感器 老人手机、经济欠发达地区的功能手机 所有的虚拟机的原则:一次编译,到处运行。 Azul VM 前面三大“高性能Java虚拟机”使用在通用硬件平台上 这里Azul VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机 高性能Java虚拟机中的战斗机。 Azul VM是Azul Systems公司在Hotspot基础上进行大量改进，运行于 Azul Systems公司的专有硬件Vega系统上的Java虚拟机。 每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的C时间的垃圾收集器、传有硬件优化的线程调度等优秀特性。 2010年，Azul systems公司开始从硬件转向软件， 发布了自己的zing JVM，可以在通用x86平台 上提供接近于Vega系统的特性。 TaobaoJVM 由AliJVM团队发布。阿里，国内使用Java最强大的公司， 覆盖云计算，金融、物流、电商等众多领城，需要解决高并发、 高可用、分布式的复合问题。有大量的开源产品。 基于OpenJDK开发了自己的定制版本AlibabaJDK, 简称AJDK. 是整个阿里Java体系的基石。 基于OpenfDK HotSpot VM发布的国内第一 个优化、深度定制且开源的高性能服务器版Java虚拟机。 创新的GCIH (GC invisible heap ) 技术实现了off-heap ,即将生命周期较长的Java对象Wheap中移到heap之外，并ALGC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。 GCIH中的对象还能够在多个Java虚拟机进程中实现共享 使用crc32指令实现JVM intrinsic降低JNI的调用开销 PMU hardware的Java profiling tool和诊断协助功能 针对大数据场录的ZenGC taobao vm应用在阿里产品上:性能高， 硬件严重依赖intel的cpu, 损失了兼容性,但提高了性能 目前已经在淘宝、天猫上线， 把oracle 官方JVM版本全部替换了。 Dalvik VM: 谷歌开发的，应用于FAndroid系统，并在Android2.2中提供了JIT, 发展迅猛。 Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循Java虚拟机规范 不能直接执行Java 的Class文件 基于寄存器架构,不是jvm的栈架构。 执行的是编译以后的dex (Dalvik Executable) 文件。执行效率比较高。 它执行的dex (Dalvik Executable)文件可以通过Class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。 Android 5.0使用支持提前编译(Ahead Of Time Compilation, AOT)的ART VM替换Dalvik WM。 Graal VM 2018年4月，Oracle Labs公开了Graal VM,号称”Run Programs Faster Anywhere”,勃勃野心。与1995年java的” write once, run anywhere” 遏相呼应。 Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括: Java、 Scala, Groovy, Kotlin; C. C++.JavaScript、Ruby、 Python、 R等 支持不同语言中混用对方的接口和对象， 支持这些语言使用已经编写好的木地库文件 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 如果说HotSpot有一天 真的被取代，Graal VM希 望最大。但是Java的软件生态没有丝毫变化。 二、类加载子系统 内存结构概述 类加载器与类的加载过程 类加载器分类 ClassLoader的使用说明 双亲委派机制 其他 1.内存结构概述 如果自己动手写一个java虚拟机，主要考虑结构：类加载器、执行引擎 2.类加载器与类的加载过程类加载子系统的作用 类加载器子系统负责从文件系统或者网络中加载class文件，class文件所在问价开头有特定的文件标识 ClassLoader只负责class文件的加载，至于文件是否可运行，则由Execution Engine决定 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射） 类加载器ClassLoader角色 class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例 class file加载到jvm中，被称为DNA元数据模板，放在方法区 在.class文件–》JVM–》最终成为元数据模板，此过程就需要一个运输工具（类装载器Class Loader），扮演一个快递员的角色 类加载过程 加载 链接 验证 准备 解析 初始化 加载： 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载.class文件的方式： 从本地系统中直接加载 通过网络获取，典型场景：web Applet 从zip压缩包中读取，成为日后jar、war格式的基础、 运行时计算生成，使用得最多的是：动态代理技术 由其他文件生成，典型场景：jsp应用 从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 验证： 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证 准备： 为类变量分配内存并设置该类变量的默认初始值，即零值 这里不包含用final修饰的static，因为final在编译时就会自动分配了，准备阶段会显式初始化 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中 解析： 将常量池内的符号引用转换为直接引用的过程 事实上没解析操作往往会伴随着jvm在执行完初始化之后再执行 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_indo、CONSTANT_Methodref_info等。 3.类加载器的分类 jvm支持两种类型的类加载器，分别为引导类加载器（Bootstrap Classloader）和自定义类加载器（User-Defined Classloader） 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范将所有派生于抽象类Classloader的类加载器都划分为自定义类加载器 程序中常见的类加载器只有三个：Bootstrap Classloader、Extension Classloader、System Classloader。都是继承于Classloader。 1234567891011121314151617181920212223242526public class ClassLoaderTest &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取其上层：扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d //获取其上层：获取不到引导类加载器 ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader);//null //对于用户自定义类来说：默认使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1);//null &#125;&#125; 虚拟机自带的加载器 启动类加载器（引导类加载器，Bootstrap Classloader） 这个类加载使用c/c++语言实现，嵌套在jvm内部 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar、resource.jar或sun.boot.class.path路径下的内容），用于提供自身需要的类 并不继承自java.lang.Classloader，没有父加载器 加载拓展类和程序类加载器，并指定为他们的父类加载器 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun、等开头的类 拓展类加载器（Extension Classloader) java语言编写，由sun.misc.Launcher$ExtClassloader实现 派生与Classloader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（拓展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器，AppClassloader） java语言编写，由sun.misc.launcher$AppClassloader实现 派生与ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性：java.class.path 指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载 通过Classloader#getSystemClassloader（）方法可以获取到该类加载器 用户自定义类加载器 在java的日常应用程序开发中，类加载几乎是由上述三种类加载器互相配合执行的，在必要时，用户可以自定义类加载器，来定制类的加载方式 原因： 隔离加载类 修改类的加载方式 扩展加载源 放置源码泄露 实现 继承抽象类java.lang.ClassLoader类 在jdk1.2之前，在自定义类加载器时，总会去继承Classloader类并重写loadClass（）方法，从而实现自定义的类加载类。在jdk1.2之后，建议吧自定义的类加载逻辑写在findClass（）方法中 在编写自定义类加载类时，如果没有太多过于复杂的需求，可以直接继承URLClassloader类，避免自己编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁 4.ClassLoader的使用说明ClassLoader：一个抽象类，其后所有的类加载器都继承自Classloader（不包括启动类加载器Bootstrap ClassLoader） 方法名称 描述 getParent（） 返回该类加载器的超类加载器 loadClass（String name) 加载名称为name的类，返回结果为java.lang.Class类的实例 findClass(String name) 查找名称为name的类，返回结果为java.lang.Class类的实例 findLoadClass(String name) 查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例 defineClass(String name,byte[] b,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例 resloveClass(Class&lt;?&gt; c) 连接指定的一个java类 sun.misc,Launcher是一个java虚拟机的入口应用 获取Classloader 获取当前类的ClassLoader：clazz.getClassLoader() 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader() 获取系统的ClassLoader：ClassLoader.getSystemClassLoader() 获取调用者的ClassLoader：DriverManager.getCallerClassLoader() 5.双亲委派机制java虚拟机对class文件采用的是按需加载的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式 工作原理 如果一个类加载器收到了类加载的请求，它不会自己先去加载，而是把这个请求委托给父类的加载器去执行 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器 如果父类加载器可以完成类加载任务，则成功返回，否则，其子类加载器尝试自己去加载 优势 避免类的重复加载 保护程序安全，防止核心API被随意篡改 沙箱安全机制自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类，这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 1234567891011package java.lang;public class String &#123; // static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125; //错误: 在类 java.lang.String 中找不到 main 方法 public static void main(String[] args) &#123; System.out.println(&quot;hello,String&quot;); &#125;&#125; 6.其他 在JVM中表示两个class对象是否为同一个了存在的两个必要条件： 类的完整类名必须一致，包括包名 加载这个类的ClassLoader必须相同 在JVM中，即使两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。 对类加载器的引用：JVM必须要知道一个类型是由启动加载器加载还是由用户类加载器加载的。如果一个类型是由用户加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的 类的主动使用和被动使用： 主动使用： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射 初始化一个类的子类 java虚拟机启动时被标明为启动类的类 jdk7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化 三、运行时数据区概述及线程 概述 线程 概述 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对内存的划分方式和管理机制存在着部分差异。 java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而自动创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 下图中，灰色的为单独线程私有的，红色的为多个线程共享的。即： 每个线程：独立包括程序计数器、栈、本地栈。 线程间共享：堆、堆外内存（永久代或元空间、代码缓存） 关于线程间共享的说明： 每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的部分：运行时环境。 线程 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。 操作系统负责所有的线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。 守护线程、普通线程： 如果使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用pubic static void main（String[] args)的main线程以及所有这个main线程自己创建的线程。 这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-word”的垃圾收集，线程收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。 四、程序计数器（PC寄存器） PC Register 介绍 举例说明 两个常见问题 1. PC Register 介绍 JVm中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能运行。 这里，并非是广义上所指的物理寄存器，将之称为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中PC寄存器是对物理PC寄存器的一种抽象模拟。 作用： PC寄存器用来存储向下一条指令的地址，也即将要执行的指令的代码。由执行引擎读取下一条指令。 说明： 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有他自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果实在执行native方法，则是未知的值（underfined）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域 2. 举例说明 3. 两个常见问题 使用PC寄存器存储字节码指令地址有什么用？ 为什么使用PC寄存器记录当前线程的执行地址？ 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 PC寄存器为什么会被设定为线程私有？ 所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复。为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法便是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 由于CPU时间片轮限制，众多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复。如何保证分毫不差？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 CPU时间片 CPU时间片，即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片 在宏观上，PC上可以打开多个应用程序，每个程序并行不悖，同时运行。 在微观上，，由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法是引入时间片，每个程序轮流执行。 ==并行和并发== 并行：vs串行 并发：cpu快速切换以达到模拟并行的效果 五、虚拟机栈 1.虚拟机栈概述 2.栈的存储单位 3.局部变量表 4.操作数栈 5.代码追踪 6.栈顶缓存技术 7.动态链接 8.方法的调用：解析与分派 9.方法返回地址 10.一些附加信息 11.栈的相关面试题 1.虚拟机栈概述背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 ==优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令==。 基本内容 栈是运行时的单位，堆是存储的单位。 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。 堆解决的是数据存储问题，即数据怎么放、放在哪。 栈 Java虚拟机栈是什么？ Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期 生命周期与线程一致 作用 主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址【对象实际存储在堆空间中】、部分结果，并参与方法的调用和返回。 局部变量：vs成员变量（或属性） 基本数据变量：vs引用类型变量（类、数组、接口） 特点 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器 JVM直接对Java栈的操作只有两个： 每个方法执行：伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾收集的问题 ==栈可能存在OOM，但是不存在GC== 面试题面试题：开发中遇到的异常有哪些？ 栈中可能出现的异常： Java虚拟机规范允许Java栈的大小是动态的或者固定不变的。 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出一个==StackOverflowError异常==。 如果Java虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个==OutOfMemoryError异常== 设置栈内存大小 我们可以使用参数-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 2.栈的存储单位栈中存储什么？ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame） 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息 复习： OOP（Object Oriented Programming）的基本概念：类、对象 类中的基本结构：field（属性、字段、域）、method 原理 JVM直接对Java栈的操作只有两个，就是对栈帧的==压栈==和==出栈==，遵循==“先进后出”/“后进先出”原则== 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为==当前栈帧（Current Frame）==，与当前栈帧对应的方法就是==当前方法（Current Method）==，定义这个方法的类就是==当前类（Current Class)==。 执行引擎运行的所有字节码指令只针对当前栈帧进行操作 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前帧。 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧 Java方法有两种返回函数的方式，==一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。== 栈帧的内部结构每个栈帧中存储着： ==局部变量表（Local Variables）== ==操作数栈（Operand Stack）（或表达式栈）== 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 3.局部变量表局部变量表 局部变量表也被称之为局部变量数组或本地变量表 ==定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量==，这些数据类型包括各类基本数据类型、对象引用（Reference)，以及returnAddress类型 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此==不存在数据安全问题== ==局部变量表所需要的容量大小是在编译期确定下来的==，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 ==方法嵌套调用的次数由栈的大小决定==。一般来说，==栈越大，方法嵌套调用次数越多==。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数会减少。 ==局部变量表中的变量只在当前方法调用中有效==。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。==当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。== Slot 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。 局部变量表，最基本的存储单元是Slot（变量槽） 局部变量中存放编译器可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量 在局部变量里，==32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。== byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true long和double则占两个slot JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会==按照顺序被复制==到局部变量表中的每一个slot上 ==如果需要访问局部变量中一个64bit的局部变量值，只需要使用前一个索引即可== 如果当前帧是由构造方法或者实例方法创建的，那么==该对象引用this将会存放在index为0的slot处==，其余的参数按照参数表顺序继续排列 Slot的重复利用 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 静态变量与局部变量的对比 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配 我们知道类变量表有两次初始化的机会，第一次是在“==准备阶段==”，执行系统初始化，对类变量设置零值，来一次则是在“==初始化==”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用 变量的分类： 按照数据类型分： 基本数据类型 引用数据类型 按照在类中声明的位置分： 成员变量：在使用前，都经历过默认初始化赋值 类变量：linking的prepare阶段，给类变量赋默认值—》initial阶段，给类变量显式赋值即静态代码赋值 实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值 局部变量：在使用前，必须进行显式赋值，否则编译不通过 补充说明 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递 ==局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。== 4.操作数栈 每一个独立的栈帧中除了包含局部变量表以外，还包含一个==后进先出==的操作数栈，也可以称之为==表达式栈== ==操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop)== 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用他们后再把结果压入栈 比如：执行复制、交换、求和等操作 操作数栈，==主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。== 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，==这个方法的操作数栈是空的== 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值 栈中任何一个元素都是可以任意的Java数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 操作数栈==并非采用访问索引的方式来进行数据访问==的，而是只能通过标准的入栈（push）和出栈（pop)操作来完成一次数据访问 ==如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中==，并更新PC寄存器中下一条需要执行的字节码指令 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证 另外，我们说Java虚拟机的==解释引擎是基于栈的执行引擎==，其中的栈指的就是操作数栈。 5.代码追踪 常见i++和++i的区别 6.栈顶缓存技术 基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，Hotspot JVM的设计者们提出了栈顶缓存技术，==将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。== 7.动态链接 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如invokedynamic指令 在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 为什么需要常量池？ 常量池的作用，就是为了提供一些符号和常量，便于指令的识别。 8.方法的调用：解析与分派在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 ==静态链接== 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。 ==动态链接== 如果被调用的方法在编译期间无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。 对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 ==早期绑定== 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 ==晚期绑定== 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然==这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。== Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 虚方法与非虚方法非虚方法： 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为虚方法。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他方法称为虚方法 在类加载的解析阶段就可以进行解析，如下是非虚方法举例 虚拟机中提供了以下几条方法调用指令： 普通调用指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法，私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用所有接口方法 动态调用指令： invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。 invokedynamic JVM字节码指令集一直比较稳定，知道Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。知道Java8的Lambda表达式出现，invokedynamic指令的生成在Java中才有了直接的生成方式。 Java7中增加对动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言编译器。 动态类型语言和静态类型语言： 动态类型语言和静态类型语言两者的区别就在于对类型的检查是编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 方法重写Java语言中方法重写的本质： 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 IllegalAccessError： 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 虚方法表 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（Virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口 虚方法表的创建： 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 9.方法返回地址 存放调用该方法的PC寄存器的值 一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，==调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址==。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 ==正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。== 当一个方法开始执行后，只有两种方式可以退出这个方法： 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口。 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含ireturn（当返回值是Boolean、byte、char、short和int类型时使用、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用 在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口 方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 本质上，方法的退出就是当前栈帧出栈的过程。，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值 10.一些附加信息 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。 11.栈的相关面试题 举例栈溢出的情况？（StackOverflowError) 通过-Xss设置栈的大小；OOM 调整栈大小，就能保证不出现溢出吗？不能 分配的栈内存越大越好吗？不是 垃圾回收是否会设计到虚拟机栈？不会的 方法中定义的局部变量是否线程安全？具体问题具体分析。 六、本地方法接口 什么是本地方法？ 简单地讲，一个Native Method 就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法；该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这样一个机制，比如在C++中，你可以使用extern “C”告知C++编译器去调用C的一个函数。 “A native method is a Java method whose implementation is provided by non-java code.” 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java所用，它的初衷是融合C/C++程序。 例子： ==标识符native可以与所有其它的java标识符连用，但是abstract除外== 为什么要使用Native MethodJava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 与Java环境外交互： ==有时候Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。==你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。 与操作系统交互 JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。==通过使用本地方法，我们得以用Java实现了jre的域底层系统的交互，甚至JVM的一些部分就是用C写的。==还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。 sun’s Java S==un的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互==。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriorty（）。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法啊最终将调用win32 SetPriority（） API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 现状： ==目前该方法的使用越来越少了，除非是与硬件有关的应用，==比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以在使用Socket通信，也可以使用Web Service等等。 七、本地方法栈 ==Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。== 本地方法栈，也是线程私有的 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常 本地方法是使用C语言实现的 它的具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载本地方法库 ==当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。== 本地方法可以通过本地方法接口来==访问虚拟机内部的运行时数据区== 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存。 ==并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等==。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。 八、堆 堆的核心概述 设置堆内存大小与OOM 年轻代与老年代 图解对象分配过程 Minor GC、Major GC、Full GC 堆空间分代思想 内存分配策略 为对象分配内存：TLAB 小结堆空间的参数设置 堆是分配对象的唯一选择吗 1. 堆的核心概述 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。 Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。 堆内存的大小是可以调节的。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。 《Java虚拟机规范》中对堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。 从实际使用角度看，应该是“几乎”所有的对象实例都在这里分配内存。 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。 现代垃圾收集器大部分都是基于分代收集理论设计，堆空间细分为： Java7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure Generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm Java8及之后堆内存逻辑上分为三个部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure Generation Space 养老区 Old/Tenure Meta Space 元空间 Meta 约定： 新生区=新生代=年轻代 养老区=老年区=老年代 永久区=永久代 2. 设置堆内存大小与OOMJava堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xmx”和”-Xms”来进行设置。 “-Xmx”用于表示堆区的起始内存，等价于-XX:InitialHeapSize “-Xms”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过”-Xms”所指定的最大内存时，将会抛出OutOfMemoryError异常 通常会将”-Xmx”和”-Xms”两个参数配置相同的值，其==目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。== 默认情况下，初始内存大小：物理电脑内存大小/64。最大内存大小：物理电脑内存大小/4。 OOM举例 3. 年轻代与老年代存储在JVM中的Java对象可以被划分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致 Java堆区进一步细分的话，可以划分为年轻代和老年代 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区） 下面这些参数开发中一般不会调： 新时代与老年代在堆结构的占比： 默认-XX:NewRatio=2，表示新时代占1，老年代占2，新时代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新时代占1，老年代占4，新时代占整个堆的1/5 在Hotspot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1 开发人员可以通过选项”-XX:SurvivorRatio”调整这个空间比例。比如”-XX:SurvivorRatio=8” ==几乎所有的==Java对象都是在Eden区被New出来的 绝大部分的Java对象的销毁都在新时代进行了。 IBM公司的专门研究表明，新时代中80%的对象都是“朝生暮死”的 可以使用选项”-Xmn”设置新时代的最大内存大小 这个参数一般使用默认值就可以了 4. 图解对象分配过程为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。 new的对象先放在伊甸园区，此区有大小限制。 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾收集器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。 然后将伊甸园中的剩余对象移动到幸存者0区 如果再次触发垃圾回收，此时上次幸存下来的放到幸存区0的，如果没有回收，就会放到幸存者1区 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区 啥时候能去养老区？可以设置次数，默认是15次。 ==可以设置参数：-XX:MaxTenuringThreshold=&lt;N&gt;进行设置== 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常 总结： 针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集 常用调优工具： JDK命令行 Eclipse：Memory Analyzer Tool Jconsole VisualVM Jprofiler Java Flight Recorder GCViewer GC Easy 5. Minor GC、Major GC、Full GCJVM在进行GC时，并非每次都对上面三个内存（新生代、老年代：方法区）区域一起回收的，大部分时候回收都是指新生代。 针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分手机（Partial GC），一种是整堆收集（Full GC） 部分收集：不是完整收集整个Java堆的垃圾收集器。其中又分为： 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集 老年代收集（Major GC /old GC）：只是老年代的垃圾收集器。 目前，只有CMS GC会有单独收集老年代的行为 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集 年轻代GC（Minor GC）触发机制：当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）。因为Java对象大多具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也会比较快。这一定义既清晰又易于理解。Minor GC会引发STW，暂停其他用户的进程，等待垃圾回收结束，用户线程才恢复运行。 触发条件老年代GC（Major GC/Full GC）触发机制:指发生在老年代的GC,对象从老年代消失时,我们说”Major GC” 或”Full GC”发生了. 出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对,在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。也就是在老年代空间不足时,会先尝试触发Minor GC Major GC的速度一般会比Minor GC慢10倍以上,STW的时间更长 如果Major GC后,内存还不足,就报爆OOM了, Major GC的速度一般会比Minor GC慢10倍以上。 Full GC触发机制触发Full GC执行的情况有如下五种： 123451.调用System.gc()时,系统建议执行Full GC,但是不必然执行2.老年代空间不足3.方法区空间不足4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存5. 由于Eden区,survivor Space0(From)区向survivor Space1(To)区复制时,对象大小小于To Space可用内存,则把该对象转存到老年代,且老年代的可用内存小于该对象的大小。 说明:Full GC是开发或调优中尽量要避免的,这样暂停时间会短一些 6. 堆空间分代思想为什么为什么需要把Java堆分代?不分代就不能正常工作了吗? 经研究,不同对象的生命周期不同。70%-99%的对象都是临时对象。 12新生代:有Eden、两块大小相同的Survivor(又称为from/to,s0/s1)构成,to总为空。老年代:存放新生代中经历多次GC仍然存活的对象。 其实不分代完全可以,分代的唯一理由就是优化GC性能。如果没有分代,那所有的对象都在一块,就如同把一个学校的人都关在一个教室。GC的时候就要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生暮死的,如果分代的话,把新创建的对象放到某一地方,当GC的时候先把这块存储朝生暮死对象的区域进行回收,这样就会腾出很大的空间出来 7. 内存分配策略如果对象在Eden出生并经历第一次Minor GC后任然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄设为1.对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认是15岁,其实每个GC都有所不同)时,就会被晋升到老年代中。 对象那个晋升到老年代的年龄阈值,可以通过选项:-XX:MaxTenuringThreshold来设置。 针对不同年龄段的对象分配原则如下所示: 优先分配到Eden 打对象直接分配到老年代——尽量避免程序中出现过多的大对象 长期存活的对象分配到老年代 动态对象年龄判断:如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象可以直接进入老年代,无需等到MaxTenuringThreshold中要求的年龄 空间分配担保:-XX:HandlePromotionFailure 8. 为对象分配内存：TLAB为什么有TLAB(Thread Local Allocation Buffer)? 123堆区是线程共享区域,任何线程都可以访问到堆区中的共享数据由于对象实例的创建在JVM中非常频繁,因此在并发环境下从堆区中划分内存空间是线程不安全的为避免多个线程操作同一地址,需要使用加锁等机制,进而影响分配速度。 什么是TLAB? 123从内存模型而不是垃圾收集的角度,对Eden区域继续进行划分,JVM为每个线程分配了一个私有缓存区域,它包含在Eden空间内。多线程同时分配内存时,使用TALB可以避免一系列的非线程安全问题,同时还能够提升内存分配的吞吐量,因此我们可以将这种内存分配方式称之为快速分配策略。(据说)所有的OpenJDK衍生出来的JVM都提供了TLAB的设计。 说明: 尽管不是所有的对象实例都能够在TLAB中成功分配内存,但是==JVM确实是将TLAB作为内存分配的首选==在程序中,开发人员可以通过选项”-XX:UserTLAB”设置是否开启TLAB空间 默认情况下,TLAB空间的内存非常小,仅占整个Eden空间的1%,当然我们可以通过选项”-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时,JVM就会尝试通过==使用加锁机制==确保数据操作的原子性,从而直接在Eden空间中分配内存。 9. 小结堆空间的参数设置 在发生Minor GC之前,==虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。== 如果大于,则此次Minor GC是安全的 如果小于,则虚拟机会查看-XX:HandlePromotionFailure设置是否允许担保失败。 如果HandlePromotionFailure=true,那么会继续==检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。== 如果大于,则尝试进行一次Minor GC,但这次Minor GC依然是有风险的, 如果小于,则改为进行一次Full GC 如果HandlePromotionFailure=false,则改进为进行一次Full GC 在JDK6 update=24之后,HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略,观察OpenJDK中的源码变化,虽然源码中还定义了HandlePromotionFailure参数,但是在代码中已经不会再使用它。==JDK6 update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC==。 10. 堆是分配对象的唯一选择吗《深入理解Java虚拟机》中关于堆内存的描述:随着JIT编译期的发展与==逃逸分析技术==逐渐成熟,==栈上分配、标量替换优化技术==将会导致一些微妙的变化,所有的对象都分配到堆上也渐渐变得不那么”绝对”了。 在Java虚拟机中,对象是在Java堆中分配内存的,这是一个普遍的常识。但是,有一种特殊的情况,那就是==如果经过逃逸分析(Escape Analysis)后发现,一个对象并没有逃逸出方法的话,那么就可能被优化成栈上分配==。这样就无需在堆上分配内存,也无须进行垃圾回收了,这也是最常见的堆外存储技术。 此外,前面提到的基于OpenJDK深度定制的TaoBaoVM,其中创新的GCIH(GC invisible heap)技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外,并且GC不能管理GCIH内部的Java对象,以此达到降低GC的回收频率和提升GC回收效率的目的。 逃逸分析如何将堆上的对象分配到栈,需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析,Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域: 当一个对象在方法中被定义后,对象只在方法内部使用,则认为没有发生逃逸。 当一个对象在方法中被定义后,它被外部方法所 引用,则认为发生逃逸。例如作为调用参数传递到其他地方中。 参数设置: 在JDK 6u23版本之后,HotSpot中默认就已经开启了逃逸分析。 如果使用的是较早的版本,开发人员则可通过: 选项”-XX:+DoEscapeAnalysis”显式开启逃逸分析 通过选项”-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果 ==结论:开发中能使用局部变量的,就不要使用在方法外定义== 代码优化使用逃逸分析,编译器可以对代码做如下优化: 一、栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配,要使指向该对象的指针永远不会逃逸,对象可以是栈分配的候选,而不是堆分配。 二、同步省略。如果一个对象被发现只能从一个线程访问到,那么对于这个对象的操作可以不考虑同步 三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到,那么对象的部分(或全部)可以不存储在内部,而是存储在CPU寄存器中。 JIT编译器在编译期间根据逃逸分析的结果,发现如果一个对象并没有逃逸出方法的话,就可能被优化成栈上分配。分配完成之后,继续在调用栈内执行,最后线程结束,栈空间被回收,局部变量对象也被回收。这样就无须进行垃圾回收了。 常见的栈上分配场景:给成员变量赋值、方法返回值]实例引用传递。 同步消除线程同步的代价是相当高的,同步的后果是降低并发性和性能。 在动态编译同步块的时候,JIT编译器可以借助逃逸分析来==判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程==。如果没有,那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略,也叫==锁消除==。 标量替换==标量(Scalar)==是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的,那些还可以分解的数据叫做==聚合量(Aggregate)==,Java中的对象就是聚合量,因为它可以分解成其他聚合量和标量。 在JIT阶段,如果经过逃逸分析,发现一个对象不会被外界访问的话,那么经过JIT优化,就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。 ==标量替换后,可以大大减少堆内存的占用==。因为一旦不需要创建对象了,那么久不需要分配堆内存了 标量替换为栈上分配提供了很好的基础。 标量替换参数设置:-XX:+EliminateAllocations:开启了标量替换(默认打开),允许将对象打散分配在栈上。 逃逸分析小结==逃逸分析并不成熟== 关于逃逸分析的论文在1999年就已经发表了,但是直到JDK1.6才有实现,而且这项技术到如今也不是十分成熟。 其根本原因就是==无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的,这其实也是一个相对耗时的过程。== 一个极端的例子,就是经过逃逸分析 之后,发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 虽然项技术并不十分成熟,但是它也是==即时编译器优化技术中一个十分重要的手段。== 注意到一些观点,认为通过逃逸分析,JVM会在栈上分配那些不会逃逸的对象,这在理论上是可行的,但是取决于JVM设计者的选择。(据说)Oracle HotSpot JVM中并没有这么做,所有的对象实例都是创建在堆上的 ==!!== 目前很多书籍都还是基于JDK7以前的版本,但是JDK以及发生了很大的变化,intern字符串的缓存和静态变量曾经都被分配在永久代上,而永久代已经被元数据区取代。但是,intern字符串缓存和静态变量并不是转移到元数据区,而是直接在堆上分配,所以这一点同样符合前面的结论;==对象实例都是分配在堆上。== 小结年轻代是对象的诞生、成长、消亡的区域,一个对象在这里产生、应用,最后被垃圾回收器收集,结束生命。 老年代 放置长生命周期的对象,通常都是从Survivor区域筛选拷贝过来的Java对象。当然,也有特殊情况,我们知道普通的对象会被分配在TLAB上,如果对象较大,JVM会试图直接分配在Eden其他位置上,如果对象太大,完全无法再新时代找到足够长的连续空闲空间,JVM就会直接分配到老年代。 当GC只发生在年轻代中,回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时,则被称为Major GC,或者Full GC。一般的,Minor GC的发送频率要比Major GC高很多,即老年代中垃圾回收发送的频率大大低于年轻代。 九、方法区栈、堆、方法区的交互关系 方法区的理解 设置方法区大小与OOM 方法区的内部结构 方法区的使用举例 方法区的演进细节 方法区的垃圾回收 总结 1. 栈、堆、方法区的交互关系运行时数据区结构图 2. 方法区的理解 《Java虚拟机规范》中明确说明:”尽管所有的方法区在逻辑上是属于堆的一部分,但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言,方法区还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开。所以,==方法区看做是一块独立于Java堆的内存空间。== 基本理解: 方法区(Method Area)与Java堆一样,是各个线程共享的内存区域。 方法区在JVM启动的时候被创建,并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。 方法区的大小,根堆空间一样,可以选择固定大小或者可拓展。 方法区的大小决定了系统可以保存多少个类,如果系统定义了太多的类,导致方法区溢出,虚拟机同样会抛出内存溢出错误:java.lang.OutOfMemoryError:PermGen space或者java.lang.OutOfMemoryError:Metespace。加载大量的第三方的jar包:Tomcat部署的工程多(30-50个),大量动态的生成反射类。 关闭JVM就会释放这个区域的内存。 HotSpot中方法区的演进: 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermsize上限） 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存 永久代、元空间二者并不只是名字变了，内部结构也调整了 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常 3. 设置方法区大小与OOM设置方法区内存的大小 方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 jdk7及以前 ==通过来设置永久代初始分配空间。默认值是20.75M==-XX:Permsize ==通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M==-XX:MaxPermsize 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。 JDK8以后 元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定 默认值依赖于平台。windows下，-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制。 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。 123456789101112131415161718192021222324252627/** * jdk8中： * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m * jdk6中： * -XX:PermSize=10m-XX:MaxPermSize=10m */public class OOMTest extends ClassLoader&#123; public static void main(String[] args)&#123; int j = 0; try&#123; OOMTest test = new OOMTest(); for (int i=0;i&lt;10000;i++)&#123; //创建Classwriter对象，用于生成类的二进制字节码 ClassWriter classWriter = new ClassWriter(0); //指明版本号，public，类名，包名，父类，接口 classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, nu1l, &quot;java/lang/Object&quot;, null); //返回byte[] byte[] code = classWriter.toByteArray(); //类的加载 test.defineClass(&quot;Class&quot; + i, code, 0, code.length); //CLass对象 j++; &#125; &#125; finally&#123; System.out.println(j); &#125; &#125;&#125; 解决: 要解决OOM异常或者heap space的异常,一般的手段是首先通过内存印象分析工具对dump出来的堆转储快照进行分析,重点是确认内存中的对象是否是必要的,也就是要先分清楚到底是出现了内存泄露(Memory Leak)还是内存溢出(Memory Overflow)。 如果是内存泄露,可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息,以及GC Roots引用链的信息,就可以比较准确地定位出泄露代码的位置。 如果不存在内存泄露,换句话说就是内存中的对象确实都还必须存活着,那就应当检查虚拟机的堆参数(-Xmx与-Xmx),与机器物理内存对比看是否还可以调大,从优化代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况,尝试减少程序运行期间的内存消耗。 4. 方法区的内部结构 方法区(Method Area)中存储什么? 《深入理解Java虚拟机》中对方法区(Method Area)存储内容描述如下:它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。 方法区的内部结构:类型信息: 对每个加载的类型(类class、接口interface、枚举enum、注解annotation),JVM必须在方法区中存储以下类型信息: 这个类型的完整有效名称(全类名=包名.类名) 这个类型直接父亲的完整有效名(对于interface或者是java.lang.object,都没有父类) 这个类型的修饰符(public,abstract,final的某个子集) 这个类型直接接口的一个有序列表 域(Field)信息: JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。域的相关信息包括:域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集) 方法(Method)信息: JVM必须保存所有的方法的以下信息,同域信息一样包括声明顺序:","categories":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://stary2020.gitee.io/tags/jvm/"}],"author":null},{"title":"javaWeb书城项目传统版","slug":"java-2021-07-14-JavaWebBookCity","date":"2021-07-14T13:57:09.000Z","updated":"2021-08-27T10:29:23.372Z","comments":true,"path":"2021/07/14/java-2021-07-14-JavaWebBookCity/","link":"","permalink":"http://stary2020.gitee.io/2021/07/14/java-2021-07-14-JavaWebBookCity/","excerpt":"","text":"概述javaWeb书城项目传统版是在尚硅谷的web培训教程的基础上，进一步完善的，具体资源以及教程都来自/参考尚硅谷课程。 本次复盘，是在老师原有上课的基础上，补充一些未完成的细节，完善功能，使整个项目看起来更合理一些。因时间原因，项目仍有很多缺点不足，有待改进。加之jsp技术过于老旧，后面可能采取SpringBoot的方式实现类似功能的项目。 总体设计整个项目主要由以下几个部分组成： 注册登录 图书模块 订单模块 数据库交互 MVC架构 注册登录注册登录模块主要是实现用户的管理，用户应该分为两种类型，即：常规买家用户和管理员用户，二者权限不同，对于非管理员用户，登录后，应该只能查看自己的订单，与执行签收操作，后台管理部分对其而言应该是隐藏的。 普通用户的操作有：查看商品，加入购物车，下单付款，确认收货。 管理员用户还需要维护图书模块和订单模块（发货等操作），所有的权限对管理员开放 注册与登录的实现： 注册注册的时候需要用户输入用户名称、用户密码、确认密码、电子邮箱以及验证码等信息，如下图 其中，用户名和密码、邮箱等，采用正则表达式在前端jsp页面进行检测，验证码使用的是google提供的验证码生成包。 若注册时用户名已存在，则采用ajax的形式部分刷新前端页面，重新注册。 注册成功后，将注册数据写入数据库表 登录登录的凭据是用户名和密码，采用cookie缓存登录信息（待补充），经由servlet处理后，返回登录结果 图书模块图书模块主要是向用户展示图书商品项 后台图书管理首先，在后台图书管理模块，需要实现以下功能：图书修改、图书删除、图书添加、以及最重要的图书查询。 这部分主要是与数据库进行交互，基于CRUD实现 图书信息展示不管是在后台还是在首页，都需要将图书信息展示出来，并且采用分页的形式输出 分页部分需要新建一个page对象，里面存储分页的相关信息，然后根据分页情况进行查询并返回查询结果到展示页面。 注意分页条的设计实现 也可以利用其它分页插件实现 此外，在首页，还需要设计一个根据价格区间查询图书的功能，底层原理是SQL的条件查询 订单模块订单模块包括了订单查询、订单管理、以及购物车几个部分，底层也是数据库 购物车购物车部分采用的是session域来保存数据，避免页面跳转、重定向时丢失数据，理论上应该将数据存到数据库。这部分功能有待完善。 订单管理用户将商品添加到购物车后，可以选择付款，付款后，会由系统自动生成一个订单号，并将订单数据保存到数据库 用户可以在“我的订单”处查看已有的订单，并执行“签收”操作 管理员可以在后台查看所有的订单，并执行“发货”操作 订单查询订单查询类似图书查询功能，但对普通用户而言，只能查看自己的订单项。 需要采用分页设计，待改进 数据库交互使用Druid数据库连接池服务。通过jdbcUtils连接数据库，所有的SQL操作类都继承自BaseDao类，所有的CRUD都归结于update和“查询”两个操作。考虑到查询的特殊性，查询又分为返回单个值的和返回对象列表两个种类。这三个基本类几乎涵盖了所有的基础的dao操作。后续需要实现的所有数据库操作，都可以由此得到。 jdbcUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.atguigu.utils;import com.alibaba.druid.pool.DataSourceClosedException;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @ClassName JdbcUtils * @Description: TODO * @Author stary * @Date 2021/4/29 21:43 * @Version 1.0 **/public class JdbcUtils &#123; private static DruidDataSource dataSource; private static ThreadLocal&lt;Connection&gt; conns=new ThreadLocal&lt;Connection&gt;(); static&#123; try &#123; Properties properties=new Properties(); InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);// com.mysql.cj.jdbc.ConnectionImpl@4f9a3314 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection()&#123; Connection conn=conns.get(); if(conn==null)&#123; try &#123; //从数据库连接池获取连接 conn = dataSource.getConnection(); //保存到ThreadLocal对象中，供后面的jdbc操作使用 conns.set(conn); //设置为手动管理 conn.setAutoCommit(false); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; return conn; &#125; //提交事务，并关闭释放连接 public static void commitAndClose()&#123; Connection connection=conns.get(); //说明使用过连接操作过数据库 if(connection!=null)&#123; try &#123; connection.commit();//提交事务 &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; try &#123; connection.close();//关闭连接 &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; //执行remove操作（因为tomcat服务器底层使用了线程池） conns.remove(); &#125; //回滚事务，并关闭释放连接 public static void rollbackAndClose()&#123; Connection connection=conns.get(); //说明使用过连接操作过数据库 if(connection!=null)&#123; try &#123; connection.rollback();//提交事务 &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; try &#123; connection.close();//关闭连接 &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; //执行remove操作（因为tomcat服务器底层使用了线程池） conns.remove(); &#125; /* public static void close(Connection conn)&#123; if(conn!=null) try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/&#125; BaseDao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.atguigu.dao.impl;import com.alibaba.druid.proxy.jdbc.JdbcParameter;import com.atguigu.utils.JdbcUtils;import com.mysql.cj.QueryResult;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;/** * @ClassName BaseDao * @Description: TODO * @Author stary * @Date 2021/4/30 13:16 * @Version 1.0 **/public abstract class BaseDao &#123; //使用dbUtils操作数据库 private QueryRunner queryRunner=new QueryRunner(); public int update(String sql,Object ...args)&#123; Connection connection= JdbcUtils.getConnection(); try &#123; return queryRunner.update(connection,sql,args); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public &lt;T&gt; T queryForOne(Class&lt;T&gt;type,String sql,Object ...args)&#123; Connection connection=new JdbcUtils().getConnection(); try &#123; return queryRunner.query(connection,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt;type, String sql, Object ...args)&#123; Connection connection=new JdbcUtils().getConnection(); try &#123; return queryRunner.query(connection,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public Object queryForSingleValue(String sql,Object...args)&#123; Connection connection=JdbcUtils.getConnection(); try &#123; return queryRunner.query(connection,sql,new ScalarHandler(),args); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; MVC架构mvc三层架构：dao、service、servlet，三层。dao层负责数据库交互，service层负责业务处理，servlet层负责页面分发。 基本逻辑是：前端页面访问servlet获取服务。servlet通过service处理请求。service调用dao层获取数据。 dao层与数据库保持一致，service层负责需要处理的各项业务，实现例如查询全部图书、修改订单状态之类的功能。而servlet层从前端获取数据，调用service获得返回值，然后将结果以页面的形式展现 BaseServletBaseServlet是servlet层最核心的一个类，其他子类通过继承他，可以简化其他类的操作。通过反射实现对前端请求的响应。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;/** * @ClassName BaseServlet * @Description: TODO * @Author stary * @Date 2021/5/7 20:16 * @Version 1.0 **/public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决中文乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String action = req.getParameter(&quot;action&quot;); //反射实现 try &#123; Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); method.invoke(this, req, resp); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e);//把异常抛给servlet程序 &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125; WebUtilsWebUtils是一个工具类，其主要具有两项功能： 包装，即将前端传输过来的数据包装成bean类 转换，将前端传送过来的String类型变量转化为Integer类型，并设置默认值（0），避免空指针异常 12345678910111213141516171819202122232425262728293031323334353637383940import com.atguigu.pojo.User;//import com.sun.deploy.net.HttpResponse;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.InvocationTargetException;import java.util.Map;/** * @ClassName WebUtils * @Description: TODO * @Author stary * @Date 2021/5/7 20:33 * @Version 1.0 **/public class WebUtils &#123; public static &lt;T&gt; T copyParamToBean(Map values, T bean)&#123; try &#123; BeanUtils.populate(bean,values); &#125; catch (Exception e) &#123;// e.printStackTrace(); &#125; return bean; &#125; public static int parseInt(String strInt,int defaultValue)&#123; try &#123; return Integer.parseInt(strInt); &#125; catch (Exception e) &#123;// e.printStackTrace(); &#125; return defaultValue; &#125;&#125; 过滤器与事务处理在实际应用中，考虑到会出现许多问题，所以在对数据库进行操作的时候，需要进行事务管理，避免因为意外导致数据库错误，出现脏读、幻读等 其次，采用过滤器对权限进行管理。 设计实现1. 准备前端打开idea，新建一个项目，注意命名方式，任何时候，命名方式都尽量保持无空格无中文 在新的项目下，新建一个模块，作为开发的主体 右键模块名，为模块添加框架支持 勾选web application ，为模块添加web支持。记得勾选创建 web.xml，这是web工程的配置文件，点击OK完成 导入前端文件，前端文件包括了页面（存储在page目录下），静态资源（jQuery、css、image等，存储在static下），首页index 至此，前端准备工作基本完成，后期根据需求进行修改 运行环境接下来需要配置运行环境，用的是tomcat 先配置artifact，修改项目名称 接下来配置服务器，根据需求配置，建议修改为热部署，其他默认就好。 导入jar包本次是在之前的基础上复盘，这里直接导入所有需要使用的jar包，在WEB-INF目录下，新建lib文件夹，导入需要使用的jar包，这里包括了后端前端所需要使用的jar包 选中全体jar包，右键，添加到库 最后，jar包出现可以展开的符号，表示添加成功 也可以使用File、Project Structure的方式导入jar包 运行tomcat，浏览器正确打开首页， 至此，前期准备工作完成 mysql前期准备基本完成，但是考虑到后面需要使用到数据库，也一并配置数据库 包括一个用户表和商品表 sql参考 1234567891011121314151617181920212223242526SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for t_book-- ----------------------------DROP TABLE IF EXISTS `t_book`;CREATE TABLE `t_book` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `price` decimal(11, 2) NULL DEFAULT NULL, `author` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `sales` int NULL DEFAULT NULL, `stock` int NULL DEFAULT NULL, `img_path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 30 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of t_book-- ----------------------------INSERT INTO `t_book` VALUES (1, &#x27;java从入门到放弃&#x27;, 80.00, &#x27;国哥&#x27;, 10009, 9, &#x27;static/img/default.jpg&#x27;);INSERT INTO `t_book` VALUES (2, &#x27;数据结构与算法&#x27;, 78.50, &#x27;严敏君&#x27;, 6, 15, &#x27;static/img/default.jpg&#x27;);SET FOREIGN_KEY_CHECKS = 1; 12345678910111213141516171819202122SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for t_user-- ----------------------------DROP TABLE IF EXISTS `t_user`;CREATE TABLE `t_user` ( `id` int NOT NULL AUTO_INCREMENT, `username` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL, `password` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL, `email` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `username`(`username`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of t_user-- ----------------------------INSERT INTO `t_user` VALUES (1, &#x27;admin&#x27;, &#x27;admin&#x27;, &#x27;admin@atguigu.com&#x27;);SET FOREIGN_KEY_CHECKS = 1; 此外还需要存储购物车和订单等的数据表，此处略，后面添加 2. 登录与注册登录注册功能，当前端点击登录、注册的按钮时，会触发相应的功能，详情见总体设计 DaoUser类的主要字段，后期需要修改增加权限控制字段 12345private Integer id;private String username;private String password;private String email; 数据库中存在相同的表单项，保存用户的信息。注册是将前端传来的数据写入，登录则是比较前端数据与数据库是否一致。 Dao层需要实现的接口： 12345678910public interface UserDao &#123; //查询 public User queryUserByUsername(String username); public User queryUserByUsernameAndPassword(String username,String password); //保存用户信息 public int saveUser(User user);&#125; Serviceservice层需要实现的接口： 12345public void registUser(User user);public User login(User user);public boolean existsUsername(String username); servletservlet层，对于UserServlet，继承自BaseDao，提供三个服务，regist、login、loginOut。注意servlet需要在web.xml中注册。 判断验证码是否正确 123456//获取并删除验证码 String token=(String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); String code = req.getParameter(&quot;code&quot;); System.out.println(&quot;code=&quot;+code); System.out.println(&quot;token=&quot;+token); 注意登录成功后，需要将数据回传给前端，登录注册失败、登录错误也需要回传数据 3. 页面优化将前端的页面进行优化，抽取相同的页面元素放在common，便于后期维护 这部分主要是前端的工作，目前对前端技术掌握不是太好，只是有个基本了解，此处就不再具体赘述 4. 图书管理daoBook的pojo类，数据库中同样要存在类似的表，用来存储图书信息 123456789public class Book &#123; private Integer id; private String name; private String author; private BigDecimal price; private Integer sales; private Integer stock; private String imgPath=&quot;static/img/default.jpg&quot;;&#125; Page的pojo类，用来实现分页功能 12345678910111213141516public class Page &lt;T&gt;&#123; public static final Integer page_size=4; //当前页码 private Integer pageNo; //总页码 private Integer pageTotal; //当前页显示数量 private Integer pageSize=page_size; //总记录数 private Integer pageTotalCount; //当前页数据 private List&lt;T&gt; items; //分页条地址 private String url;&#125; 需要实现的dao接口 12345678910111213141516171819202122232425import com.atguigu.pojo.Book;import java.util.List;public interface BookDao &#123; //添加图书 public int addBook(Book book); //删除图书 public int deleteBookById(Integer id); //更新书籍信息 public int updateBook(Book book); //根据id查询 public Book queryBookById(Integer id); //查询所有图书 public List&lt;Book&gt; queryBooks(); //查询分页数 Integer queryForPageTotalCount(); //查询指定区间的图书 List&lt;Book&gt; queryForPageItems(int begin, int pageSize); //按价格区间查询分页数 Integer queryForPageTotalCountByPrice(int min, int max); //查询指定价格区间中指定分页区间的图书 List&lt;Book&gt; queryForPageItemsByPrice(int begin, int pageSize, int min, int max);&#125; service12345678910111213public interface BookService &#123; public void addBook(Book book); public void deleteBookById(Integer id); public void updateBook(Book book); public Book queryBookById(Integer id); public List&lt;Book&gt; queryBooks(); Page&lt;Book&gt; page(int pageNo, int pageSize); Page&lt;Book&gt; pageByPrice(int pageNo, int pageSize, int min, int max);&#125; servletadd、update、delete、list、getBook、page几个功能。其中page实现分页功能，实际应用的过程中，会替换掉list（查询全部书籍），getBook是获取要修改的图书的信息。 分页实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243//分页 protected void page(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException &#123; //获取请求参数pageNo、pageSize int pageNo= WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.page_size); //调用bookservice。page Page&lt;Book&gt; page=bookService.page(pageNo,pageSize); page.setUrl(&quot;client/clientbookServlet?action=page&quot;); //保存page对象到request域中 req.setAttribute(&quot;page&quot;,page); //请求转发 req.getRequestDispatcher(&quot;/pages/client/index.jsp&quot;).forward(req,resp); &#125; protected void pageByPrice(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException &#123; //获取请求参数pageNo、pageSize int pageNo= WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.page_size); int min=WebUtils.parseInt(req.getParameter(&quot;min&quot;),0); int max=WebUtils.parseInt(req.getParameter(&quot;max&quot;),Integer.MAX_VALUE); //调用bookservice。page Page&lt;Book&gt; page=bookService.pageByPrice(pageNo,pageSize,min,max); StringBuilder sb=new StringBuilder(&quot;client/clientbookServlet?action=pageByPrice&quot;); //若有min请求参数，追加到分页条地址请求参数中 if(req.getParameter(&quot;min&quot;)!=null)&#123; sb.append(&quot;&amp;min=&quot;).append(req.getParameter(&quot;min&quot;)); &#125; //若有min请求参数，追加到分页条地址请求参数中 if(req.getParameter(&quot;max&quot;)!=null)&#123; sb.append(&quot;&amp;max=&quot;).append(req.getParameter(&quot;max&quot;)); &#125; page.setUrl(sb.toString()); //保存page对象到request域中 req.setAttribute(&quot;page&quot;,page); //请求转发 req.getRequestDispatcher(&quot;/pages/client/index.jsp&quot;).forward(req,resp); &#125; 5. 订单管理订单管理模块又细分为购物车和订单管理 daodao层有四个pojp类，分别归属于购物车和订单。 其中Cart记录购物车的基础信息，CartItem保存购物车中的详细商品项。 同理，Order记录订单基础信息，OrderItem保存订单中的详细商品项。 Cart 1234public class Cart &#123; private Integer totalCount; private BigDecimal totalPrice; private Map&lt;Integer,CartItem&gt; items=new LinkedHashMap&lt;Integer,CartItem&gt;(); CartItem 1234567public class CartItem &#123; private Integer id; private String name; private Integer count; private BigDecimal price; private BigDecimal totalPrice;&#125; Order 1234567public class Order &#123; private String orderId; private Date createTime; private BigDecimal price; //0未发货，1已发货，2表示已签收 private Integer status=0; private Integer userId; OrderItem 12345678public class OrderItem &#123; private Integer id; private String name; private Integer count; private BigDecimal price; private BigDecimal totalPrice; private String orderId;&#125; 需要实现的接口： 由于购物车模块没有保存到数据库中，所以这里的购物车就不需要与数据库进行交互 OrderDao 1234567public interface OrderDao &#123; public int saveOrder(Order order); public List&lt;Order&gt; queryOrders(); public int changeOrderStatus(String status,String orderId); public List&lt;Order&gt; queryOrdersByUserId(Integer userId);&#125; OrderItemDao 1234567public interface OrderItemDao &#123; public int saveOrderItem(OrderItem orderItem); public List&lt;OrderItem&gt; queryOrderItemByOrderId(String orderId);&#125; serviceservice层也只有订单项一种服务 123456789101112131415public interface OrderService &#123; //生成订单 public String createOrder(Cart cart,Integer userId); //查询全部订单 public List&lt;Order&gt; showAllOrders(); //发货 public void sendOrder(String orderId); //查看订单详情 public List&lt;OrderItem&gt; showOrderDetail(String orderId); //查看我的订单 public List&lt;Order&gt; showMyOrders(Integer id); //签收订单、确认收货 public void receiveOrder(String orderId);&#125; 注意生成订单的服务： 生成订单项，需要将购物车中的数据，转化为订单项的数据，保存到数据库后，清空购物车。 12345678910111213141516171819202122232425@Override public String createOrder(Cart cart, Integer userId) &#123; String orderId=System.currentTimeMillis()+&quot;&quot;+userId; Order order=new Order(orderId,new Date(),cart.getTotalPrice(),0,userId); orderDao.saveOrder(order); //遍历购物车中每一个商品项，转化为订单项保存到数据库 for(Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123; //获取每个购物车中的商品项 CartItem cartItem=entry.getValue(); //转换为每一个订单项 OrderItem orderItem=new OrderItem(null,cartItem.getName(),cartItem.getCount(),cartItem.getPrice(),cartItem.getTotalPrice(),orderId); //保存订单项到数据库 orderItemDao.saveOrderItem(orderItem); //更新库存和销量 Book book = bookDao.queryBookById(cartItem.getId()); book.setSales(book.getSales()+cartItem.getCount()); book.setStock(book.getStock()-cartItem.getCount()); bookDao.updateBook(book); &#125; //清空购物车 cart.clear(); return orderId; &#125; servletOrderServlet和CartServlet两个servlet，分别处理购物车和订单的请求 CartServlet：addItem添加（被ajaxAddItem替换）、deleteItem删除、clear清空、updateCount修改数量 OrderServlet：createOrder生成订单、showAllOrder查看所有订单、sendOrder发货、showOrderDetail查看订单详情、showMyOrder查看我的订单、receiveOrder签收订单 ajaxAddItem： 12345678910111213141516171819202122232425262728293031protected void ajaxAddItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数、商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用bookservice。queryBookById，得到图书信息 Book book = bookService.queryBookById(id); //把图书信息转换为cartItem信息 CartItem cartItem = new CartItem(book.getId(), book.getName(), 1, book.getPrice(), book.getPrice()); //调用cart。addItem，添加商品项 Cart cart=(Cart)req.getSession().getAttribute(&quot;cart&quot;); if(cart==null)&#123; cart=new Cart(); req.getSession().setAttribute(&quot;cart&quot;,cart); &#125; cart.addItem(cartItem); //保存最后一次添加的商品名称到session域 req.getSession().setAttribute(&quot;lastName&quot;,cartItem.getName()); //ajax返回 Map&lt;String ,Object&gt; resultMap=new HashMap&lt;String ,Object&gt;(); resultMap.put(&quot;totalCount&quot;,cart.getTotalCount()); resultMap.put(&quot;lastName&quot;,cartItem.getName()); Gson gson=new Gson(); String resultMapJsonString=gson.toJson(resultMap); resp.getWriter().write(resultMapJsonString);&#125; 小结总结 泛型的使用。 反射的应用。 面向接口编程 空指针异常 前后端交互。json数据流与对象 MVC三层架构 事务处理与权限管理（拦截器） “导包”。使用功能前，必“导包”，包括jar包和html、jsp的引用 问题时区报错，修改配置文件： 1url=jdbc:mysql://localhost:3306/book?serverTimezone=GMT%2B8 tomcat乱码修改配置文件。找到tomcat安装目录conf下logging.properties文件，打开后搜索：java.util.logging.ConsoleHandler.encoding修改为GBK 查询为空查询时出现查出数据为空的情况：大概率是pojo类与数据表项名字不一致，解决方式：在sql语句中添加别名 foreach查询不出数据，在jsp中添加&lt;%@taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot;%&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"web","slug":"web","permalink":"http://stary2020.gitee.io/tags/web/"},{"name":"jsp","slug":"jsp","permalink":"http://stary2020.gitee.io/tags/jsp/"}],"author":null},{"title":"设计模式","slug":"tools-2021-07-11-DesignPatterns","date":"2021-07-11T01:37:47.000Z","updated":"2021-08-27T10:26:22.692Z","comments":true,"path":"2021/07/11/tools-2021-07-11-DesignPatterns/","link":"","permalink":"http://stary2020.gitee.io/2021/07/11/tools-2021-07-11-DesignPatterns/","excerpt":"","text":"1.概述1.经典面试题原型设计模式 有请使用UML类图画出原型模式核心角色 原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写 clone方法实现深拷贝、使用序列化来实现深拷贝) 在Spring框架中哪里使用到原型模式，并对源码进行分析 beans.xml Spring中原型bean的创建，就是原型模式的应用 代码分析+Debug源码 设计模式的七大原则: 要求： 七大设计原则核心思想 能够以类图的说明设计原则 在项目实际开发中，你在哪里使用到了ocp原则 金融借贷平台项目：借贷平台的订单，有审核\u0002发布-抢单 等等 步骤，随着操作的不同，会改 变订单的状态, 项目中的这个模块实现就会使用 到状态模式，请你使用状态模式进行设计，并 完成实际代码问题分析 ： 这类代码难以应对变化，在添加一种状态时， 我们需要手动添加if/else，在添加一种功能时， 要对所有的状态进行判断。因此代码会变得越 来越臃肿，并且一旦没有处理某个状态，便会 发生极其严重的BUG，难以维护 解释器设计模式 介绍解释器设计模式是什么? 画出解释器设计模式的UML类图, 分析设计模式中的各个角色是什 么? 请说明Spring的框架中，哪里 使用到了解释器设计模式，并 做源码级别的分析 解释器模式在Spring框架应用的源码剖析 Spring框架中 SpelExpressionParser就使用到解释器模式 代码分析+Debug源码+模式角色分析说明 单例设计模式单例设计模式一共有几种实现方式？请分别用代码实现，并说明各个实现方式的 优点和缺点? 单例设计模式一共有8种写法， 饿汉式 两种 懒汉式 三种 双重检查 静态内部类 枚举 2.概述设计模式设计模式的重要性 ： 软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人 在1990年代从建筑设计领域引入到计算机科学的 大厦 VS 简易房 拿实际工作经历来说, 当一个项目开发完后，如果客户提出增新功能，怎么办?。 如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (维护性[可读性、 规范性]) 目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中 使用过什么 设计模式，怎样使用的，解决了什么问题。 设计模式在软件中哪里？面向对象(oo)=&gt;功能模块[设计模式+算法(数据结构)]=&gt;框 架[使用到多种设计模式]=&gt;架构 [服务器集群] 如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的. 设计原则核心思想 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程，而不是针对实现编程 为了交互对象之间的松耦合设计而努力 3.UML类图基本介绍 UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果 UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: 使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模 画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理， UML图分类： 用例图(use case) 静态结构图：类图、对象图、包图、组件图、部署图 动态行为图：交互图（时序图与协作图）、状态图、活动图 UML类图： 用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合 依赖：只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编 绎都通过不了小结 类中用到了对方 如果是类的成员属性 如果是方法的返回类型 是方法接收的参数类型 方法中使用到 泛化：泛化关系实际上就是继承关系，他是依赖关系的特例小结： 泛化关系实际上就是继承关系 如果A类继承了B类，我们就说A和B存在泛化关系 实现：实现关系实际上就是A类实现B接口，他是依赖关系的特例 关联：关联关系实际上就是类与类之间的联系，他是依赖关系的特例 关联具有导航性：即双向关系或单向关系 关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个）， “0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m 个）。 聚合：聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚 合关系是关联关系的特例，所以他具有关联的导航性与多重性。 如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个 配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示： 组合：组合关系：也是整体与部分的关系，但是整体与部分不可以分开。再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和 Person 就是 组合，IDCard 和 Person 就是聚合。 2.七大原则1.设计模式目的编写软件过程中，程序员面临着来自耦合性、内聚性以及可维护性、可拓展性、重用性、灵活性等多方面的挑战，设计模式是为了让程序（软件）具有更好的： 代码重用性 (即：相同功能的代码，不用多次编写) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) 使程序呈现高内聚，低耦合的特性 分享金句： 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计 （OOA/D）的精要” Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是 前者手背上有很多伤疤 2.七大原则设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据） 七大原则： 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特原则 合成复用原则 3. 单一职责原则基本介绍：对类来说的，即一个类应该只负责一项职责。如类A负责两个不同的职责：职责1、职责2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1、A2 代码示例：略 注意事项与细节： 降低类的复杂度，一个类只负责一项职责 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则，只有类中方法数量足够少，可以在方法级别保持单一职责原则 接口隔离原则基本介绍 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法 按隔离原则优化：将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。 依赖倒转原则基本介绍依赖倒转原则是指： 高层模块不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 依赖倒转的中心思想是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定得多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不设计任何具体的操作，把展现细节的任务交给他们的实现类去完成 代码示例12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.principle.inversion.improve;public class DependecyInversion &#123; public static void main(String[] args) &#123; //客户端无需改变 Person person = new Person(); person.receive(new Email()); person.receive(new WeiXin()); &#125;&#125;//定义接口interface IReceiver &#123; public String getInfo();&#125;class Email implements IReceiver &#123; public String getInfo() &#123; return &quot;电子邮件信息: hello,world&quot;; &#125;&#125;//增加微信class WeiXin implements IReceiver &#123; public String getInfo() &#123; return &quot;微信信息: hello,ok&quot;; &#125;&#125;//方式2class Person &#123; //这里我们是对接口的依赖 public void receive(IReceiver receiver ) &#123; System.out.println(receiver.getInfo()); &#125;&#125; 细节说明依赖关系传递的三种方式： 接口传递 构造方法传递 setter方式传递 注意： 低层模块尽量有抽象类或接口，或者两者都有，程序稳定性更好 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象之间，就存在一个缓冲层，利于程序的拓展和优化 继承时遵循里氏替换原则 里氏替换原则基本介绍OO中的继承性： 继承包含这样的一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承类会给程序带来侵入性，程序的可移植性降低，增加对象之间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到的子类的功能都有可能产生故障 问题提出：在编程中，如何正确的使用继承？====》里氏替换原则 基本介绍： 里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用积累的地方必须能透明底使用其子类的对象 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过 聚合，组合，依赖 来解决问题 开闭原则基本介绍 开闭原则是编程中最基础、最重要的设计原则 一个软件实体如类、模块和函数，应该对拓展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现拓展细节 当软件需要变化时，尽量通过拓展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.atguigu.principle.ocp.improve;public class Ocp &#123; public static void main(String[] args) &#123; //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); &#125;&#125;//这是一个用于绘图的类 [使用方]class GraphicEditor &#123; //接收Shape对象，调用draw方法 public void drawShape(Shape s) &#123; s.draw(); &#125; &#125;//Shape类，基类abstract class Shape &#123; int m_type; public abstract void draw();//抽象方法&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(&quot; 绘制矩形 &quot;); &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(&quot; 绘制圆形 &quot;); &#125;&#125;//新增画三角形class Triangle extends Shape &#123; Triangle() &#123; super.m_type = 3; &#125; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(&quot; 绘制三角形 &quot;); &#125;&#125;//新增一个图形class OtherGraphic extends Shape &#123; OtherGraphic() &#123; super.m_type = 4; &#125; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(&quot; 绘制其它图形 &quot;); &#125;&#125; 迪米特原则基本介绍 一个对象应该对其他对象保持最少的了解 类与类的关系越密切，耦合度越大 迪米特原则也叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息 迪米特原则还有个更简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他的对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数】方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部 细节注意 迪米特原则的核心是降低类之间的耦合 注意：由于每个类都减少了不必要的依赖，依次迪米特原则只是要求降低类间（对象间）的耦合关系，并不是要求完全没有依赖。 合成复用原则基本介绍原则是尽量使用合成、聚合的方式，而不是使用聚合 3.二十三种设计模式设计模式介绍 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， 模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern） 代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时 间的试验和错误总结出来的。 设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂 度。 &lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”） 设计模式并不局限于某种语言，java，php，c++ 都有设计模式. 设计模式类型设计模式分为三种类型，共23种 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。 单例设计模式所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类==只能存在一个对象实例==，并且该类只提供一个取得其对象实例的方法（静态方法）。 比如Hibernate的SessionFactory，它充当数据存储源的代理，并且负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFanctory就够，这就是单例模式 单例模式的八种方式： ==饿汉式（静态常量）== ==饿汉式（静态代码块）== 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） ==双重检查== ==静态内部类== ==枚举== 饿汉式（静态常量）应用实例步骤： 构造器私有化（防止new） 类的内部创建对象 向外暴露一个静态的公共方法。getInstance 例子： 123456789101112131415161718//饿汉式(静态变量)class Singleton &#123; //1. 构造器私有化, 外部能new private Singleton() &#123; &#125; //2.本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() &#123; return instance; &#125; &#125; 说明 优点：这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步的问题 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终未使用过这个实例，则会造成内存的浪费 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或其他的静态方法）导致类装载，这时候初始化instance就没有达到Lazy Loading的效果 结论：这种单例模式==可用，但可能造成内存浪费==。 饿汉式（静态代码块）应用实例1234567891011121314151617181920212223//饿汉式(静态变量)class Singleton &#123; //1. 构造器私有化, 外部能new private Singleton() &#123; &#125; //2.本类内部创建对象实例 private static Singleton instance; static &#123; // 在静态代码块中，创建单例对象 instance = new Singleton(); &#125; //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() &#123; return instance; &#125; &#125; 说明 和和饿汉式（静态常量）类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点同饿汉式（静态常量） 结论：这种单例模式可用，但是可能造成内存浪费 懒汉式（线程不安全）应用1234567891011121314class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; //提供一个静态的公有方法，当使用到该方法时，才去创建 instance //即懒汉式 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明 起到了Lazy Loading的效果，但是只能在单线程下使用 如果在多线程下，一个线程进入了if（singleton==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式 结论：在实际开发中，不要使用这种方式 懒汉式（线程安全，同步方法）应用123456789101112131415// 懒汉式(线程安全，同步方法)class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 //即懒汉式 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明 解决了线程不安全的问题 效率太低，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得的该类实例，直接return就行了。方法进行同步效率太低 结论：在实际开发中，不推荐使用这种方式 懒汉式（线程安全，同步代码块）应用123456789101112131415// 懒汉式(线程安全，同步代码块)class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; synchronized(Singleton.class)&#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 说明 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的代码块 ==但是这种同步并不能起到线程同步的作用==。跟第三种实现方式遇到的情形一直，加入一个线程进入if（singleton==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例 结论：在实际开发中，不能使用这种方式 双重检查应用123456789101112131415161718192021// 懒汉式(线程安全，同步方法)class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123;&#125; //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题 //同时保证了效率, 推荐使用 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; synchronized (Singleton.class) &#123; if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 说明 Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if（singleton==null）检查，这样就可以保证线程安全了 这样，实例化代码只用执行一次，后面再次进行访问时，判断if（singleton==null），直接return实例化对象，也避免反复进行方法同步 线程安全，延迟加载，效率较高 结论：在实际开发中，推荐使用这种单例设计模式 静态内部类应用12345678910111213141516171819// 静态内部类完成， 推荐使用class Singleton &#123; private static volatile Singleton instance; //构造器私有化 private Singleton() &#123;&#125; //写一个静态内部类,该类中有一个静态属性 Singleton private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE public static synchronized Singleton getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 说明 这种方式采用了类装载的机制来保证初始化实例时只有一个线程 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 结论：推荐使用 枚举应用1234567//使用枚举，可以实现单例, 推荐enum Singleton &#123; INSTANCE; //属性 public void sayOK() &#123; System.out.println(&quot;ok~&quot;); &#125;&#125; 说明 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程的同步问题，而且还能防止反序列化重新创建新的对象 这种方式是Effective Java作者Josh Bloch提倡的方式 结论：推荐使用 单例模式在JDK应用的源码分析 在JDK中，java.lang.Runtime就是经典的单例模式（饿汉式） 单例模式说明 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new 单例模式使用的场景： 需要频繁的进行创建和销毁的对象 创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象 工具类对象 频繁访问数据库或文件的对象（比如数据源、Session工厂等） 工厂模式简单工厂模式需求分析看一个披萨的项目：要便于披萨种类的扩展，要便于维护 披萨的种类很多(比如 GreekPizz、CheesePizz 等) 披萨的制作有 prepare，bake, cut, box 完成披萨店订购功能。 传统方式的优缺点： 优点是比较好理解，简单易操作。 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增 加新功能的时候，尽量不修改代码，或者尽可能少修改代码. 比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做修改 改进：分析：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味 着，也需要修改，而创建Pizza的代码，往往有多处。思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该 类就可，其它有创建到Pizza对象的代码就不需要修改了.-&gt; 简单工厂模式 基本介绍 简单工厂模式是属于创建型模式，是工厂模式的一种。==简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例==。简单工厂模式是工厂模式家族中最简单实用的模式 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码） 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 应用 简单工厂模式的设计方案：定义一个可以实例化对象的类，封装创建对象的代码 示例： 1234567891011121314//编写简单工厂类public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; System.out.println(&quot;使用简单工厂模式~~&quot;); Pizza pizza = null; if (type.equals(&quot;cheese&quot;)) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(&quot;greek&quot;)) &#123; pizza = new GreekPizza(); &#125; else if (type.equals(&quot;pepper&quot;)) &#123; pizza = new PepperPizza(); return pizza; &#125; &#125; 工厂方法模式需求分析披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。 思路1：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory等，但是考虑到项目规模扩大、以及软件的可维护性、可拓展性，这种方式不是太好 思路2：使用工厂方法模式 基本介绍 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类 应用1234567891011121314~~~### 抽象工厂模式#### 基本介绍1. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或称为进一步抽象）4. 将工厂抽象成两层，AbsFactory和具体实现的工厂子类。程序员可以根据创建对象使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展#### 应用~~~java 工厂模式小结工厂模式在JdK-Calendar中的应用： 应用了简单工厂模式 工厂模式意义： 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的拓展和维护性 三种工厂模式： 简单工厂模式 工厂方法模式 抽象工厂模式 设计模式的抽象原则： 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。 不要让类继承具体类，而是继承抽象类或者是实现interface接口 不要覆盖基类中已经实现的方法 原型模式问题现有一只羊tom，姓名为tom，年龄为1，颜色为白，请编写程序创建和tom羊属性完全相同的10只羊 传统模式分析： 优点是容易理解，简单易操作 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活 改进思路：java中Object类是所有类的根类，Object类提供了一个clone（）方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制能力===》原型模式 原型模式基本介绍 原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实现创建，即：对象.clone() 说明uml图： Prototype：原型类，声明一个克隆自己的接口 ConcretePrototype：具体的原型类，实现一个克隆自己的操作 Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样） 应用使用原型模式改进传统方式，让程序具有更高的效率和拓展性 1234567891011121314151617181920212223~~~#### 实际应用Spring中原型bean的创建，就是 原型模式的应用#### 拷贝浅拷贝介绍：1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值3. 浅拷贝使用默认的clone()方法来实现，例如：sheep=（Sheep）super.clone()；深拷贝介绍：1. 复制对象的所有基本数据类型的成员变量值2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝3. 深拷贝的实现方式1：重写clone方法实现深拷贝 ~~~java 深拷贝的实现方式2：通过对象序列化实现深拷贝（推荐） 12345678910111213141516171819202122232425 ~~~### 细节1. 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率2. 不用重新初始化对象，而是动态地获得对象运行时的状态3. 如果原始对象发生变化（增加或者减少属性），其他克隆的对象也会发生相应的变化，无需修改代码4. 在实现深克隆的时候可能需要比较复杂的代码5. **缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改器源代码，违背了OCP原则。 OCP原则：开闭原则，Open Closed Principle## 建造者模式### 需求盖房项目需求：1. 需要建房子：这一过程为打桩、砌墙、封顶2. 房子有各种各样的，比如普通房、高楼、别墅，各种房子的建造过程虽然一样，但是要求不要相同的### 传统方式~~~java 优点是比较好理解，简单易操作 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，也就是说，这种设计方案，把产品（房子）和创建产品的过程（建造房子的流程）封装在一起，耦合性增强了 解决方案：将产品和产品建造的过程解耦==》建造者模式 建造者模式基本介绍 建造者模式（Builder Pattern），又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构建出不同表现（属性）的对象 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节 建造者模式的四个角色： Product，产品角色：衣蛾具体的产品对象 Builder，抽象建造者：创建一个Product对象的各个部件指定的接口/抽象类。 ConcreteBuilder，具体建造者：实现接口，构建和装配各个部件 Director，指挥者：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程 建造者模式的原理图： 应用解决盖房子需求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445~~~源码应用：1. java.lang.StringBuilder中的建造者模式： 源码中建造者模式角色分析 ： * Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建 造者, 定义了抽象方法 * AbstractStringBuilder 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化 * StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的 实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder### 细节1. 客户端（使用程序）==不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象==2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以方便地替换具体建造者或增加新的具体建造者，==用户使用不同的具体建造者即可得到不同的产品对象==3. ==可以更加精细地控制产品的创建过程==。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程4. ==增加新的具体建造者无需修改原有库类的代码==，指挥者类针对抽象建造者类编程，系统拓展方便，符合开闭原则。5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，==如果产品之间的差异性很大，则不适合使用建造者模式==，因此其使用范围受到一定的限制6. 如果产品发内部变化复制，可能会导致需要定义很多具体建造类来实现这种变化，导致系统变得很庞大，因此在这种情况下，需要考虑是否选择建造者模式7. ==抽象工厂模式VS建造者模式== 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而生产一个新产品## 适配器模式#### 基本介绍1. 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）2. 适配器模式属于结构型模式3. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式#### 工作原理1. 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容2. 从用户的角度看不到被适配者，是解耦的3. 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法4. 用户收到反馈结果，感觉只是和目标接口交互### 类适配器模式Adapter类，通过继承src类，实现dst类接口，完成src-》dst的适配#### 应用~~~java 细节 java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定的局限性 src类的方法在Adapter中都会暴露出来，也增加了使用成本 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了 对象适配器介绍 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题，即：持有src类，实现dst接口，完成src=》dst的适配 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系 对象适配器模式是适配器模式常用的一种 应用1234567891011121314151617181920212223242526272829303132333435363738~~~#### 细节1. 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口2. 使用成本更低，更灵活### 接口适配器#### 介绍1. 一些书籍成为：适配器模式（Default Adapter Pattern）或缺省适配器模式2. 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每一个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求3. 适用于一个接口不想使用其所有的方法的情况#### 应用应用实例：1. Android中的属性动画ValueAnimator类可以 通过addListener(AnimatorListener listener)方 法添加监听器， 那么常规写法如下： ~~~java ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100); valueAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); valueAnimator.start(); 有时候我们不想实现 Animator.AnimatorListener接口的全部方法， 我们只想监听onAnimationStart，我们会如 下写 12345678ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100);valueAnimator.addListener(new AnimatorListenerAdapter() &#123;@Overridepublic void onAnimationStart(Animator animation) &#123;//xxxx具体实现&#125;&#125;);valueAnimator.start(); AnimatorListenerAdapter类，就是一个 接口适配器，代码如下:它空实现了 Animator.AnimatorListener类(src)的所 有方法. 123456789101112131415161718192021public abstract class AnimatorListenerAdapter implements Animator.AnimatorListenerAnimator.AnimatorPauseListener &#123;@Override //默认实现public void onAnimationCancel(Animator animation) &#123;&#125;@Overridepublic void onAnimationEnd(Animator animation) &#123;&#125;@Overridepublic void onAnimationRepeat(Animator animation) &#123;&#125;@Overridepublic void onAnimationStart(Animator animation) &#123;&#125;@Overridepublic void onAnimationPause(Animator animation) &#123;&#125;@Overridepublic void onAnimationResume(Animator animation) &#123;&#125;&#125; AnimatorListener是一个接口. 123456public static interface AnimatorListener &#123;void onAnimationStart(Animator animation);void onAnimationEnd(Animator animation);void onAnimationCancel(Animator animation);void onAnimationRepeat(Animator animation);&#125; 程序里的匿名内部类就是Listener 具体实现类 123456new AnimatorListenerAdapter() &#123;@Overridepublic void onAnimationStart(Animator animation) &#123;//xxxx具体实现&#125;&#125; 源码应用： 适配器模式在SpringMVC框架中的应用 SpringMvc中的HandlerAdapter, 就使用了适配器模式 SpringMVC处理请求的流程 使用HandlerAdapter的原因分析：可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么 如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则 代码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 ~~~ 5. SpringMVC通过适配器设计模式获取到对应的Controller的源码 6. 说明 * Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类 * 适配器代替controller执行相应的方法 * 扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展### 注意1. 三种命名方式，是根据src是以怎样的形式给到Adapter来命名的2. 类适配器：以类给到，在Adapter里，就是将src当作类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现3. Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作4. 实际开发中，实现起来不拘泥这三种经典模式## 桥接模式### 问题传统方案解决手机操作问题分析：1. 拓展性问题（类爆炸），如果我们增加手机的样式，则需要增加各个品牌手机的类。同理，如果增加一个手机品牌，也要在各个手机样式类下增加。2. 违反了单一职责原则，当我们增加手机样式时，需要同时增加所有品牌的手机，这样增加了代码维护成本3. 解决方案：使用桥接模式### 基本介绍1. 桥接模式（Bridge模式）是指：将实现与抽象放在两个不同的类层中，使两个层次可以独立改变2. 是一种结构型设计模式3. Bridge模式基于类的最小设计原则通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是吧抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展原理图：![image-20210714124346974](2021-07-11-DesignPatterns/image-20210714124346974.png)1. Client类：桥接模式的调用者2. 抽象类（abstraction）：维护了Implementor，即它的实现类ConcreteImplemenetorA……，二者是聚合关系，Abstraction充当桥接类### 应用解决手机问题：~~~java 桥接模式在JDBC源码应用 jdbc的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle得到Driver，这些就可以当作实现接口类 细节 桥接模式实现了抽象和实现部分的分离，从而极大提高了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他部分有具体业务来完成。 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。 桥接模式的引入增加了系统的理解和设计难度由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样发应用场景。 桥接模式的其他应用场景： 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用 常见的应用场景 JDBC驱动程序 银行转账系统转账分类、转账用户类型 消息管理消息类型、消息分类 装饰者设计模式问题星巴克咖啡订单项目（咖啡馆）： 咖啡种类 调料 要求在拓展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 使用OO来计算不同种类咖啡的费用，可以单点，也可以咖啡+调料 介绍装饰者模式：动态将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则 原理：应用组合模式问题基本介绍 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系 组合模式依据树形结构来组合对象，用来表示部分以及整体层次 这种类型的设计模式属于结构型模式 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象 应用细节 简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题 具有较强的扩展性，当我们需要更改组合对象时，我们只需要调整内部的层次关系，客户端不需要作出任何改动 方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式 外观模式问题介绍 外观模式（Facade)，也叫“过程模式”，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节 应用细节 外观模式对外屏蔽了子系统的细节，因此外观模式降低利率客户端对子系统的复杂性 外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展 通过合理的使用外观模式，可以帮我们更好的划分访问的层次 当系统需要进行分层设计时，可以考虑使用Facade模式 在维护一个遗留的大型项目时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性 不能过多的或不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要让系统有层次，利于维护为目的 享元模式问题小型外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同： 有客户要求以新闻的形式发布 有客户要求以博客的形式发布 有客户希望以微信公众号的形式发布 传统解决方案 直接复制粘贴一份，然后根据不同的要求，进行定制修改 给每一个网站租用一个空间 方案设计示意图 分析 需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器资源的浪费 解决思路：整合到一个网站中，共享器相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都是可以达成共享，减少服务器资源 对于代码来说，由于是一份实例，维护和扩展都更加容易 即：享元模式 基本介绍 享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似的对象，需要缓冲池时。不需要总是创建新的对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率 享元模式经典的应用场景就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式 原理图： 内部状态和外部状态 享元模式提出了两个需求：细粒度和共享对象。即将对象的信息分为两个部分：内部状态和外部状态 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。 应用解决网站问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344~~~享元模式在JDK-Interger中的应用：### 细节1. 在享元模式这样理解，“享”就表示共享，“元”表示对象2. 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式3. 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储4. 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率5. 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是使用享元模式时需要注意的6. 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。7. 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池### 代理模式### 介绍1. 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能2. 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象3. 代理模式有不同发形式，主要有三种：静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态创建对象，而不需要实现接口，它是属于动态代理的范畴）4. 代理模式示意图### 静态代理静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象与代理对象一起实现相同的接口或者是继承相同父类#### 应用实例：具体要求：1. 定义一个接口：ITeacherDao2. 目标对象TeacherDao实现接口ITeacherDao3. 使用静态代理方式，就需要在代理对象TeacherDaoProxy中也实现ITeacherDao4. 调用的时候，通过调用代理对象的方法来调用目标对象5. 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法代码：~~~java 分析静态代理 优点：在不修改目标对象的功能前提下，能通过dialing对象实现对目标功能扩展 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类 一旦接口增加方法，目标对象与代理对象都需要维护 动态代理介绍动态代理模式的基本介绍 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象 动态代理也叫做：JDK代理、接口代理 JDK中生成代理对象的API 代理类所在的包：java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstence方法，但是该方法需要接受三个参数，完整的写法是： 12static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) 应用代码实现 12345678910111213141516171819202122232425~~~### Cglib代理#### 介绍Cglib代理模式基本介绍1. 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理2. Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展，有些书也将Cglib代理归属到动态代理3. Cglib是一个强大的高性能代码生成包，它可以运行期扩展java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP ，实现方法拦截4. 在AOP编程中如何选择代理模式： * 目标对象需要实现接口，用JDK代理 * 目标对象不需要实现接口，用Cglib代理5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类#### 实现1. 需要引入Cglib的jar文件2. 在内存中动态构建子类，注意代理的类不能为final，否则报错。因为final类不能被继承，也就没有子类3. 目标对象的方法如果为final、static，那么就不会被拦截，即不会执行目标对象额外的业务方法代码：~~~java 代理变体几种常见的代理模式变体 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问 缓存代理：比如，当请求图片文件等资源时，先到缓存代理取，如果取到资源则OK，如果取不到资源，再到公网或者数据库取，然后缓存 远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息 同步代理：主要使用在多线程编程中，完成多线程间同步工作 模板方法模式问题编写制作豆浆的程序： 制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎 通过添加不同的配料，可以制作出不同口味的豆浆 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的 介绍 模板方法模式（Template Method Pattern），又叫模板方法模式（Template Pattern），在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需求重写方法实现，但调用将以抽象类中定义的方式进行 简单来说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤 这种类型的设计模式属于行为型模式 原理： 说明： AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨 架，具体子类需要去实现 其它的抽象方法operationr2,3,4 ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步 骤 应用代码： 123456789~~~#### 模板方法模式中的钩子方法* 在模板方法模式的父类中，我们可定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。代码：~~~java 模板方法模式在Spring框架中的应用： Spring IOC容器初始化时运行用到的模板方法模式 细节模板方法模式的注意事项和细节 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改 实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现 该模式的不足之处：每一个不同的实现类都需要一个子类实现，导致类的个数增加，使得系统更加庞大 一般模板方法都加上final关键字，防止子类重写模板方法 模板方法的使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤方法基本相同，但其个别步骤在实现时，可能不同。通常考虑模板方法模式来处理 命令模式问题 我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就 可以控制对这些家电工作。 2 这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个App，分别控制，我 们希望只要一个app就可以控制全部智能家电。 要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口 给app调用，这时 就可以考虑使用命令模式。 命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来. 在我们的例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品 基本介绍命令模式基本介绍 命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪一个我们只知道在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦 在命令模式中会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作 通俗易懂的理解：将军发布命令，士兵去执行，其中将军就是命令发布者，士兵便是具体执行者，其中命令连接了将军和士兵 原理图： 说明： Invoker 是调用者角色 Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类 Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作 ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute 应用代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455~~~实例：* 命令模式在Spring框架JdbcTemplate中使用### 注意命令模式的注意事项和细节1. 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的excute（）方法就可以让接受者工作，而不必知道具体的接受者对象是谁、是如何实现的，命令对象起到了纽带桥梁的作用2. 容易设计一个命令队列，只要把命令对象放到队列就可以多线程的执行命令3. 容易实现对请求的销毁和重做4. 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候需要注意5. 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们没按下一个按键都需要判空，这给我们编码带来了一定的麻烦6. 命令模式经典的应用场景：界面的每一个按钮都是一条命令、模拟CMD（DOS命令）、订单的撤销/恢复、触发-反馈机制## 访问者模式### 问题测评系统：* 将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对 该歌手不同的评价(评价 有不同的种类，比如 成功、失败 等)### 介绍访问者模式基本介绍1. 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作2. 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题3. 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口4. 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决原理图：![image-20210714185223773](2021-07-11-DesignPatterns/image-20210714185223773.png)说明：1. Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作 2. ConcreteVisitor ：是一个具体的访问值 实现每个有Visitor 声明的操作，是每个操作实现的部分. 3. ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素 4. Element 定义一个accept 方法，接收一个访问者对象5. ConcreteElement 为具体元素，实现了accept 方法### 应用代码：~~~java 小结： 上面提到了双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。 双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型 以上述实例为例，假设我们要添加一个Wait的状态类，考察Man类和Woman类的反 应，由于使用了双分派，只需增加一个Action子类即可在客户端调用即可，不 需要改动任何其他类的代码。 注意访问者模式的注意事项和细节 优点： 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常该 访问者模式可以对功能进行统一，可以做报表、UI、拦截器和过滤器，适用于数据结构相对稳定的系统 缺点： 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的 迭代器模式问题编写程序展示一个学校院系结构： 要在一个页面中展示出学校的院系组成 一个学校有一个学院 一个学院有多个系 介绍迭代器模式基本介绍 迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式 如果我们的集合元素是用不同的方法实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候，就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑用迭代器模式解决 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构 原理图： 说明： Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove ConcreteIterator : 具体的迭代器类，管理迭代 Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦 应用代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162~~~具体实例：迭代器模式在JDK-ArrayList集合中的应用* JDK的ArrayList集合中就使用了迭代器模式分析* 内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类 * List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象 * ArrayList 是实现聚合接口List 的子类，实现了iterator() * Iterator 接口系统提供 * 迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题### 注意迭代器模式的注意事项和细节优点：1. 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了2. 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成3. 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做==单一责任原则==）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来，集合改变的话，只会影响到聚合对象。如果遍历方式改变的话，只影响到了迭代器4. 当要展示一组相似的对象，或者遍历一组相同对象时使用，适合使用迭代器模式缺点：1. 每个聚合对象都要一个迭代器，会产生多个迭代器，不好管理类## 观察者模式### 问题天气预报项目需求,：1. 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如 发布到自己的网站或第三方)。 2. 需要设计开放型API，便于其他第三方也能接入气象站获取数据。 3. 提供温度、气压和湿度的接口4. 测量数据更新时，要能实时的通知给第三方### 介绍观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject， 依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是 Subject，是1的一方。用户时Observer，是多的一方优点：1. 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除 和通知。 2. 这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核 心类WeatherData不会修改代码，遵守了ocp原则。### 应用代码实现~~~java 实例应用： jdk的Observable类就使用了观察者模式 分析： Observable 的作用和地位等价于 我们前面讲过Subject Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer 的方法 add.. delete .. notify… Observer 的作用和地位等价于我们前面讲过的 Observer, 有update Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是 类，通过继承来实现观察者模式 中介者模式问题智能家庭项目： 智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等 主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流 程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放 传统的方式的问题分析 ： 当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂 各个电器对象彼此联系，你中有我，我中有你，不利于松耦合. 各个电器对象之间所传递的消息(参数)，容易混乱 当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性 都不理想  考虑中介者模式 介绍中介模式基本介绍 中介模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互性 中介者模式属于行为模式，使代码易于维护 比如MVC模式，C(Controller控制器)是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用 原理图： 说明： Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口 Colleague 是抽象同事类 应用代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849~~~### 注意中介者模式的注意事项和细节1. 多个类相互耦合，会形成网状结构，使用中介者模式，将网状结构分离为星型结构，进行解耦2. 减少类间依赖，降低了耦合，符合迪米特原则3. 中介者承担了较多的责任，一旦中介者出了问题，整个系统都会受到影响4. 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意## 备忘录模式### 问题游戏角色状态恢复问题： 游戏角色有攻击力和防御力，在大战Boss前保存自身的状态(攻击力和防御力)，当大 战Boss后攻击力和防御力下降，从备忘录对象恢复到大战前的状态传统的方式的问题分析 ：1. 一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不 利于管理，开销也很大. 2. 传统的方式是简单地做备份，new出另外一个对象出来，再把需要备份的数据放到 这个新对象，但这就暴露了对象内部的细节 3. 解决方案： =&gt; 备忘录模式### 介绍备忘录模式基本介绍1. 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持这个状态。这样以后就可以将该对象恢复到原先保存的状态2. 理解：现实生活中备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作3. 备忘录模式属于行为模式原理图：说明：1. originator : 对象(需要保存 状态的对象) 2. Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态 3. Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效 率 4. 说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要 要 HashMap ### 应用代码实现~~~java 注意备忘录模式注意事项和细节 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不必关系状态的保存细节 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意 适用的场景： 后悔药 打游戏时的存档 windows里的ctrl+z ie中的后退 数据库的事务管理 为了节约内存，备忘录模式可以和原型模式配合适用 解释器模式问题通过解释器模式来实现四则运算 先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复 在分别输入a ,b, c, d, e 的值 最后求出结果 传统方案解决四则运算问题分析 ： 编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果 问题分析：如果加入新的运算符，比如 * / ( 等等，不利于扩展，另外让一个方法来 解析会造成程序结构混乱，不够清晰. 解决方案：可以考虑使用解释器模式， 即： 表达式 -&gt; 解释器(可以有多种) -&gt; 结 果 基本介绍 在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器 解释器模式（Interpreter Pattern）：是指给一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式） 应用场景： 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来表示 一个简单语法需要解释的场景 更多：编译器、运算表达式、正则表达式、机器人等 原理图： 说明： Context: 是环境角色,含有解释器之外的全局信息. AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所 共享 TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作 NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作. 说明： 输入Context he TerminalExpression 信息通过Client 输入即可 应用代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960~~~实际应用：* Spring框架中SpelExpressionParser就使用到解释器模式### 注意解释器模式的注意事项和细节1. 当有一个语言需要解释器执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，这让程序具有良好的扩展性2. 应用场景：编译器、运算表达式计算、正则表达式、机器人等3. 使用解释器可能会带来的问题： * 解释器模式会引起类膨胀 * 解释器模式采用递归调用方法，将会导致调试非常复杂 * 效率可能降低## 状态模式### 问题APP抽奖活动问题1. 假如每参加一次这个活动要 扣除用户50积分，中奖概率 是10% 2. 奖品数量固定，抽完就不能 抽奖 3. 活动有四个状态: 可以抽奖、 不能抽奖、发放奖品和奖品 领完 4. 活动的四个状态转换关系图![image-20210714200011180](2021-07-11-DesignPatterns/image-20210714200011180.png)### 介绍状态模式基本介绍1. 状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以互相转换2. 当一个对象的内在状态发生改变时，允许改变其行为，这个对象看起来好像是改变了其类原理图：说明：1. Context 类为环境角色, 用于维护State实例,这个实例定义当前状态 2. State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为3. ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为### 应用代码实现~~~java 应用实例： 借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的 状态, 项目中的这个模块实现就会使用到状态模式 注意状态模式的注意事项和细节 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中 方便维护。将容易产生问题的if-else的语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错 符合开闭原则。容易增删状态 会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多的类，加大维护难度 应用场景：当一个事件或者对象有很多种状态，状态之间会互相转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式 策略模式问题鸭子项目： 有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等) 显示鸭子的信息 传统方式： 其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的 上面说的1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改 动，会影响其他部分。会有溢出效应 为了改进1问题，我们可以通过覆盖fly 方法来解决 =&gt; 覆盖解决 问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要ToyDuck去覆盖Duck 的所有实现的方法 解决思路 策略模式 (strategy pattern) 介绍策略模式基本介绍 策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 这种算法体现了几个设计原则： 把变化的代码从不变的代码中分离出来 针对接口编程而不是具体类（定义了策略接口） 多用组合/聚合，少用继承（客户通过组合方式使用策略） 原理图： 应用代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364~~~实例：* JDK的Arrays的Comparator就使用了策略模式### 注意策略模式的注意事项和细节1. 策略模式的关键是：分析项目中变化部分与不变部分2. 策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性3. 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或行为）即可，避免了使用多重转移语句（if-else）4. 提供了可以替换继承关系的办法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使他易于切换、易于理解、易于扩展5. 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大## 职责链模式### 问题学校OA系统的采购审批项目：1. 采购员采购教学器材 2. 如果金额 小于等于5000, 由教学主任审批 （0&lt;=x&lt;=5000）3. 如果金额 小于等于10000, 由院长审批 (5000）4. 如果金额 小于等于30000, 由副校长审批 (10000&lt;x&lt;=30000)5. 如果金额 超过30000以上，有校长审批 ( 30000&lt;x）传统方案解决OA系统审批问题分析：1. 传统方式是：接收到一个采购请求后，根据采购金额来调用对应的Approver (审批 人)完成审批。2. 传统方式的问题分析 : 客户端这里会使用到 分支判断(比如 switch) 来对不同的采 购请求处理， 这样就存在如下问题 ： 1. 如果各个级别的人员审批金额发生变化，在 客户端的也需要变化 2. 客户端必须明确的知道 有多少个审批级别和访问3. 这样 对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代 码的扩展和维护4. 解决方案 =》 职责链模式### 介绍职责链模式基本介绍1. 责任链模式（Chain Of Responsibility Pattern），又叫责任链模式，为请求创建了一个接受者对象的链。这种模式对请求的发送者和接受者进行解耦2. 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接受者，依此类推3. 这种类型的设计模式属于行为型模式原理图：说明：1. Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler 2. ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处 理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链 3. Request ， 含义很多属性，表示一个请求### 应用代码实现~~~java 实例： SpringMVC-HandlerExecutionChain 类就使用到职责链模式 说明： springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式 HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不 处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责 链本身与处理逻辑之间的耦合,规范了处理流程 HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应 的拦截器. 细节职责链模式的注意事项和细节 将请求和处理分开，实现解耦，提高系统的灵活性 简化了对象，使对象不需要知道链的结构 性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext（）方法中判断是否已经超过阈值，超过则不允许该链的建立，避免出现超长链无意识地破坏系统性能 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂 最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、java Web中tomcat对encoding的处理、拦截器 补充说明： 有一点需要说明：设计模式是程序员在编程中，有意或者是无意使用到的(也不是 所有的程序员都学习过设计模式)，并且同一种设计模式实现方式也不是100%的一 样，设计模式主要是提高程序的扩展性，可读性，可维护性、规范性。 对于框架源码，源码中部分使用了A设计模式，还部分使用了B设计模式，也是有 可能的，也就是说设计模式是可以结合使用的 因为设计模式主要是一种编程思想，既然是思想，具体实现方式，就不可能100% 的一样(当然，程序的设计结构基本是一样的)","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":null},{"title":"vue的使用(入门)","slug":"language-2021-07-10-vue","date":"2021-07-10T13:09:01.000Z","updated":"2021-08-19T02:34:47.881Z","comments":true,"path":"2021/07/10/language-2021-07-10-vue/","link":"","permalink":"http://stary2020.gitee.io/2021/07/10/language-2021-07-10-vue/","excerpt":"","text":"","categories":[{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://stary2020.gitee.io/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://stary2020.gitee.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":null},{"title":"JavaWeb","slug":"java-2021-07-10-JavaWeb","date":"2021-07-10T13:07:37.000Z","updated":"2021-08-19T02:35:25.351Z","comments":true,"path":"2021/07/10/java-2021-07-10-JavaWeb/","link":"","permalink":"http://stary2020.gitee.io/2021/07/10/java-2021-07-10-JavaWeb/","excerpt":"","text":"","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"JavaSE","slug":"java-2021-07-10-JavaSE","date":"2021-07-10T13:06:37.000Z","updated":"2021-08-19T02:35:30.204Z","comments":true,"path":"2021/07/10/java-2021-07-10-JavaSE/","link":"","permalink":"http://stary2020.gitee.io/2021/07/10/java-2021-07-10-JavaSE/","excerpt":"","text":"提示 短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，从而提高效率。在实际编程时，应该优先考虑使用短路与和短路或。 其他运算符除了前面介绍的主要运算符，Java还有一些其他运算符。三元运算符（? :）。例如x?y:z;，其中x、y和z都为表达式。小括号。起到改变表达式运算顺序的作用，它的优先级最高。中括号。数组下标。引用号（.）。对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作符。赋值号（=）。赋值是用等号运算符（=）进行的。instanceof。判断某个对象是否为属于某个类。new。对象内存分配运算符。箭头（-&gt;）。Java 8新增加的，用来声明Lambda表达式。双冒号（::）。Java 8新增加的，用于Lambda表达式中方法的引用。 二元运算符计算顺序从左向右，但是先级15的赋值运算符的计算顺序从右向左的 不规则数组： 123456789101112131415161718192021222324252627public class HelloWorld &#123;public static void main(String[] args) &#123;int intArray[][] = new int[4][]; //先初始化高维数组为4//逐一初始化低维数组intArray[0] = new int[2];intArray[1] = new int[1];intArray[2] = new int[3];intArray[3] = new int[3];//for循环遍历for (int i = 0; i &lt; intArray.length; i++) &#123;for (int j = 0; j &lt; intArray[i].length; j++) &#123;intArray[i][j] = i + j;&#125;&#125;//for-each循环遍历for (int[] row : intArray) &#123; ①for (int column : row) &#123; ②System.out.print(column);//在元素之间添加制表符，System.out.print(&#x27;\\t&#x27;);&#125;//一行元素打印完成后换行System.out.println();&#125;//System.out.println(intArray[0][2]); //发生运行期错误 ③&#125;&#125; 空字符串不是null，空字符串是分配内存空间，而null是没有分配内存空间。 不可变字符串和可变字符串，它们区别在于当字符串进行拼接等修改操作时，不可变字符串会创建新的字符串对象，而可变字符串不会创建新对象。 Java中不可变字符串类是String java.lang包中的类时不需要引入（import）该包，因为它是由解释器自动引入的。 ==运算符比较的是两个引用是否指向相同的对象 Java中的不可变字符串String常量，采用字符串池（String Pool）管理技术，字符串池是一种字符串驻留技术。采用字符串常量赋值时，会字符串池中查找”Hello”字符串常量，如果已经存在把引用赋值给s9，否则创建”Hello”字符串对象，并放到池中。但此原理并不适用于new所创建的字符串对象，代码运行到第①行后，会创建”Hello”字符串对象，而它并没有放到字符串池中。代码第②行又创建了一个新的”Hello”字符串对象，s7和s8是不同的引用，指向不同的对象。 String 拼接只是会产生一个新的对象 可变字符串在追加、删除、修改、插入和拼接等操作不会产生新的对象。Java提供了两个可变字符串类StringBuffer和StringBuilder，中文翻译为“字符串缓冲区”。 StringBuffer是线程安全的，它的方法是支持线程同步 ，线程同步会操作串行顺序执行，在单线程环境下会影响效率。StringBuilder是StringBuffer单线程版本，Java 5之后发布的，它不是线程安全的，但它的执行效率很高。 类体方法声明 123456class className &#123; [public | protected | private ] [static] [final | abstract] [native] [synchronized] type methodName([paramList]) [throws exceptionList] &#123; //方法体 &#125;&#125; 一个引用变量没有通过new分配内存空间，这个对象就是空对象， 提示 产生空对象有两种可能性：第一是程序员自己忘记了实例化，第二是空对象是别人传递过来的。程序员必须防止第一种情况的发生，应该仔细检查自己的代码，为自己创建的所有对象进行实例化并初始化。第二种情况需要通过判断对象非null进行避免。 有时候需要在运行时判断一个对象是否属于某个引用类型，这时可以使用instanceof运算符，instanceof运算符语法格式如下：obj instanceof type 引用类型可以进行转换，但并不是所有的引用类型都能互相转换，只有属于同一棵继承层次树中的引用类型才可以转换。 归纳抽象类与接口区别如下： 接口支持多继承，而抽象类（包括具体类）只能继承一个父类。 接口中不能有实例成员变量，接口所声明的成员变量全部是静态常量，即便是变量不加public static final修饰符也是静态常量。抽象类与普通类一样各种形式的成员变量都可以声明。 接口中没有包含构造方法，由于没有实例成员变量，也就不需要构造方法了。抽象类中可以有实例成员变量，也需要构造方法。 抽象类中可以声明抽象方法和具体方法。Java 8之前接口中只有抽象方法，而Java 8之后接口中也可以声明具体方法，具体方法通过声明默认方法实现。 提示 学习了接口默认方法后，有些读者还会有这样的疑问，Java 8之后接口可以声明抽象方法和具体方法，这就相当于抽象类一样了吗？在多数情况下接口不能替代抽象类，例如当需要维护一个对象的信息和状态时只能使用抽象类，而接口不行，因为维护一个对象的信息和状态需要存储在实例成员变量中，而接口中不能声明实例成员变量。 枚举： 123456789101112131415161718192021222324252627282930313233//WeekDays.java文件package com.a51work6;public enum WeekDays &#123; // 枚举常量列表 MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY&#125;//调用//HelloWorld.java文件package com.a51work6;public class HelloWorld &#123; public static void main(String[] args) &#123; // day工作日变量 WeekDays day = WeekDays.FRIDAY; System.out.println(day); switch (day) &#123; case MONDAY: System.out.println(&quot;星期一&quot;); break; case TUESDAY: System.out.println(&quot;星期二&quot;); break; case WEDNESDAY: System.out.println(&quot;星期三&quot;); break; case THURSDAY: System.out.println(&quot;星期四&quot;); break; default: //case FRIDAY: System.out.println(&quot;星期五&quot;); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334//WeekDays.java文件package com.a51work6;public enum WeekDays &#123; // 枚举常量列表 MONDAY(&quot;星期一&quot;, 0), TUESDAY(&quot;星期二&quot;, 1), WEDNESDAY(&quot;星期三&quot;, 2),THURSDAY(&quot;星期四&quot;, 3), FRIDAY(&quot;星期五&quot;, 4); // 实例变量 private String name; private int index; // 静态变量 private static int staticVar = 100; private WeekDays(String name, int index) &#123; this.name = name; this.index = index; &#125; // 覆盖父类中的toString()方法 @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(name); sb.append(&#x27;-&#x27;); sb.append(index); return sb.toString(); &#125; // 实例方法 public String getInfo() &#123; // 调用父类中toString()方法 return super.toString(); &#125; // 静态方法 public static int getStaticVar() &#123; return staticVar; &#125;&#125; 在Java类引用类型进行比较时，有两种比较方法==和equals，==比较的是两个引用是否指向同一个对象，equals是比较对象内容是否相同。但是，枚举引用类型中==和equals都是一样的，都是比较两个引用是否指向同一个实例，枚举类中每个枚举常量无论何时都只有一个实例 Java 5之后提供了拆箱(unboxing )功能，拆箱能够将包装类对象自动转换为基本数据类型的数值，而不需要使用intValue()或doubleValue()等方法。类似Java 5还提供了相反功能，自动装箱( autoboxing )，装箱能够自动地将基本数据类型的数值自动转换为包装类对象，而不需要使用构造方法。 在自动装箱和拆箱时，要避免空对象。试图访问空对象的方法和成员变量，就会抛出运行期NullPointerException异常。 上述代码第①行~第③行是声明或初始化三个输入流，三条语句放到在try语句后面小括号中，语句之间用分号“;”分隔，这就是自动资源管理技术了，采用了自动资源管理后不再需要finally代码块，不需要自己close这些资源，释放过程交给了JVM。注意 所有可以自动管理的资源需要实现AutoCloseable接口，上述代码中三个输入流FileInputStream、InputStreamReader和BufferedReader从Java 7之后实AutoCloseable接口，具体哪些资源实现AutoCloseable接口需要查询API文档。 自定义异常类： 1234567public class MyException extends Exception &#123; public MyException() &#123; &#125; public MyException(String message) &#123; super(message); &#125;&#125; 提示 使用join()方法的场景是，一个线程依赖于另外一个线程的运行结果，所以调用另一个线程的join()方法等它运行完成。 程序员之间的语言之争又未尝不是如此。写系统语言的鄙视托管语言低下的执行效率；写托管语言的则取笑系统语言需要手动管理内存；写动态语言的不屑于静态语言那冗余的类型系统；写静态语言的则嘲讽动态语言里面各种光陆离的运行时错误。","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"MyBatis","slug":"tools-2021-07-10-MyBatis","date":"2021-07-10T13:06:15.000Z","updated":"2021-08-27T10:14:58.806Z","comments":true,"path":"2021/07/10/tools-2021-07-10-MyBatis/","link":"","permalink":"http://stary2020.gitee.io/2021/07/10/tools-2021-07-10-MyBatis/","excerpt":"","text":"说明本文档参考自尚硅谷的MyBatis教程及资料。 一、简介MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录. 历史原是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation 迁移到了Google Code，随着开发团队转投Google Code 旗下， iBatis3.x正式更名为MyBatis ，代码于2013年11月迁移到Github（下载地址见后）。 iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO） 为什么要使用MyBatis？MyBatis是一个半自动化的持久化层框架。 JDBC – SQL夹在Java代码块里，耦合度高导致硬编码内伤 – 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 Hibernate和JPA– 长难复杂SQL，对于Hibernate而言处理也不容易 – 内部自动生产的SQL，不容易做特殊优化。 – 基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。 对开发人员而言，核心sql还是需要自己优化 sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。 地址：https://github.com/mybatis/mybatis-3/ 二、HelloWord– 创建一张测试表 – 创建对应的javaBean – 创建mybatis配置文件，sql映射文件 – 测试 MyBatis操作数据库1、创建MyBatis全局配置文件 – MyBatis 的全局配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息、如数据库连接池信息等。指导着MyBatis进行工作。我们可以参照官方文件的配置示例。 2、创建SQL映射文件 – 映射文件的作用就相当于是定义Dao接口的实现类如何工作。这也是我们使用MyBatis时编写的最多的文件。 测试1、根据全局配置文件，利用SqlSessionFactoryBuilder创建SqlSessionFactory 2、使用SqlSessionFactory获取sqlSession对象。一个SqlSession对象代表和数据库的一次会话。 使用SqlSession根据方法id进行操作 HelloWorld-接口式编程– 创建一个Dao接口 – 修改Mapper文件 – 测试 使用SqlSession获取映射器进行操作 SqlSessionSqlSession 的实例不是线程安全的，因此是不能被共享的。 SqlSession每次使用完成后需要正确关闭，这个关闭操作是必须的 SqlSession可以直接调用方法的id进行数据库操 作，但是我们一般还是推荐使用SqlSession获取到Dao接口的代理类，执行代理对象的方法，可以更安全的进行类型检查操作 三、MyBatis-全局配置文件MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。文档的顶层结构如下： • configuration 配置 • properties 属性 • settings 设置 • typeAliases 类型命名 • typeHandlers 类型处理器 • objectFactory 对象工厂 • plugins 插件 • environments 环境 • environment 环境变量 • transactionManager 事务管理器 • dataSource 数据源 • databaseIdProvider 数据库厂商标识 • mappers 映射器 在Eclipse中引入XML的dtd约束文件，方便编写XML的时候有提示 properties属性 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： – 在 properties 元素体内指定的属性首先被读取。 – 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 – 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 setting设置这是 MyBatis 中极为重要的调整设置，它们会改变MyBatis 的运行时行为 typeAliases别名处理器 • 类型别名是为 Java 类型设置一个短的名字，可以方便我们引用某个类。 类很多的情况下，可以批量设置别名这个包下的每一个类创建一个默认的别名，就是简单类名小写 • 也可以使用@Alias注解为其指定一个别名 值得注意的是，MyBatis已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，我们在起别名的时候千万不要占用已有的别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator typeHandlers类型处理器 • 无论是 MyBatis 在预处理语句（PreparedStatement）中 设置一个参数时，还是从结果集中取出一个值时， 都会 用类型处理器将获取的值以合适的方式转换成 Java 类型。 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的NUMERIC 或BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或SHORT INTEGER IntegerTypeHandler java.lang.Integer, int 数据库兼容的NUMERIC 或INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的NUMERIC 或LONG INTEGER FloatTypeHandler java.lang.Float, float 数据库兼容的NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR 日期类型的处理日期和时间的处理，JDK1.8以前一直是个头疼的问题。我们通常使用JSR310规范领导者Stephen Colebourne创建的Joda-Time来操作。1.8已经实现全部的JSR310规范了。 • 日期时间处理上，我们可以使用MyBatis基于JSR310（Date and Time API）编写的各种日期时间类型处理器。 • MyBatis3.4以前的版本需要我们手动注册这些处 理器，以后的版本都是自动注册的 自定义类型处理器 我们可以重写类型处理器或创建自己的类型处理 器来处理不支持的或非标准的类型。 步骤： 1）、实现org.apache.ibatis.type.TypeHandler接口或者继承org.apache.ibatis.type.BaseTypeHandler 2）、指定其映射某个JDBC类型（可选操作） 3）、在mybatis全局配置文件中注册 plugins插件插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。后面会有专门的章节我们来介绍mybatis运行原理以及插件 1234Executor (update, query, flushStatements, commit, rollback,getTransaction, close, isClosed);ParameterHandler (getParameterObject, setParameters);ResultSetHandler (handleResultSets, handleOutputParameters);StatementHandler (prepare, parameterize, batch, update, query); environments环境MyBatis可以配置多种环境，比如开发、测试和生产环境需要有不同的配置。每种环境使用一个environment标签进行配置并指 定唯一标识符。可以通过environments标签中的default属性指定一个环境的标识符来快速的切换环境 environment-指定具体环境 id：指定当前环境的唯一标识 transactionManager、和dataSource都必须有 transactionManager • type： JDBC | MANAGED | 自定义 – JDBC：使用了 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务范围。JdbcTransactionFactory – MANAGED：不提交或回滚一个连接、让容器来管理 事务的整个生命周期（比如 JEE 应用服务器的上下文）。 ManagedTransactionFactory – 自定义：实现TransactionFactory接口，type=全类名/ 别名 dataSource type： UNPOOLED | POOLED | JNDI | 自定义 – UNPOOLED：不使用连接池， UnpooledDataSourceFactory – POOLED：使用连接池， PooledDataSourceFactory – JNDI： 在EJB 或应用服务器这类容器中查找指定的数据源 – 自定义：实现DataSourceFactory接口，定义数据源的获取方式。 • 实际开发中我们使用Spring管理数据源，并进行事务控制的配置来覆盖上述配置 databaseIdProvider环境 • MyBatis 可以根据不同的数据库厂商执行不同的语句。 • Type： DB_VENDOR – 使用MyBatis提供的VendorDatabaseIdProvider解析数据库厂商标识。也可以实现DatabaseIdProvider接口来自定义。 • Property-name：数据库厂商标识 • Property-value：为标识起一个别名，方便SQL语句使用 databaseId属性引用 • DB_VENDOR – 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短 • MyBatis匹配规则如下： – 1、如果没有配置databaseIdProvider标签，那么databaseId=null – 2、如果配置了databaseIdProvider标签，使用标签配置的name去匹配数据库信息，匹配上设置databaseId=配置指定的值，否则依旧为null – 3、如果databaseId不为null，他只会找到配置databaseId的sql语句 – 4、MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库databaseId 属性的所有语句。如果同时找到带有 databaseId 和不带databaseId 的相同语句，则后者会被舍弃。 mapper映射mapper逐个注册SQL映射文件 • 或者使用批量注册： • 这种方式要求SQL映射文件名必须和接口名相同并且在同一目录下 四、MyBatis-映射文件• 映射文件指导着MyBatis如何进行数据库增删改查， 有着非常重要的意义； 1234567891011121314151617•cache –命名空间的二级缓存配置•cache-ref – 其他命名空间缓存配置的引用。•resultMap – 自定义结果集映射•parameterMap – 已废弃！老式风格的参数映射•sql –抽取可重用语句块。•insert – 映射插入语句•update – 映射更新语句•delete – 映射删除语句•select – 映射查询语句 insert、update、delete元素 主键生成方式 若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置useGeneratedKeys=”true”，然后再把keyProperty 设置到目标属性上。 主键生成方式• 而对于不支持自增型主键的数据库（例如Oracle），则可以使用 selectKey 子元素： selectKey 元素将会首先运行，id会被设置，然后插入语句会被调用 selectKey 参数（Parameters）传递 • 单个参数 – 可以接受基本类型，对象类型，集合类型的值。这种情况 MyBatis可直接使用这个参数，不需要经过任何处理。 • 多个参数 – 任意多个参数，都会被MyBatis重新包装成一个Map传入。Map的key是param1，param2，0，1…，值就是参数的值。 • 命名参数 – 为参数使用@Param起一个名字，MyBatis就会将这些参数封 装进map中，key就是我们自己指定的名字 • POJO – 当这些参数属于我们业务POJO时，我们直接传递POJO • Map – 我们也可以封装多个参数为map，直接传递 参数处理参数也可以指定一个特殊的数据类型： – javaType 通常可以从参数对象中来去确定 – 如果 null 被当作值来传递，对于所有可能为空的列， jdbcType 需要被设置 – 对于数值类型，还可以设置小数点后保留的位数： – mode 属性允许指定 IN，OUT 或 INOUT 参数。如果参数为 OUT 或 INOUT，参数对象属性的真实值将会被改变， 就像在获取输出参数时所期望的那样。 参数处理 • 参数位置支持的属性 – javaType、jdbcType、mode、numericScale、 resultMap、typeHandler、jdbcTypeName、expression • 实际上通常被设置的是： 可能为空的列名指定 jdbcType • **#{key}：获取参数的值，预编译到SQL中。安全。** • **${key}：获取参数的值，拼接到SQL中。有SQL注入问** 题。ORDER BY ${name} select元素 • Select元素来定义查询操作。 • Id：唯一标识符。 – 用来引用这条语句，需要和接口的方法名一致 • parameterType：参数类型。 – 可以不传，MyBatis会根据TypeHandler自动推断 • resultType：返回值类型。 – 别名或者全类名，如果返回的是集合，定义集合中元素的类型。不能和resultMap同时使用 自动映射• 1、全局setting设置 – autoMappingBehavior默认是PARTIAL，开启自动映射 的功能。唯一的要求是列名和javaBean属性名一致 – 如果autoMappingBehavior设置为null则会取消自动映射 – 数据库字段命名规范，POJO属性符合驼峰命名法，如A_COLUMNàaColumn，我们可以开启自动驼峰命名规 则映射功能，mapUnderscoreToCamelCase=true。 • 2、自定义resultMap，实现高级结果集映射。** resultMap • constructor - 类在实例化时, 用来注入结果到构造方法中 – idArg - ID 参数; 标记结果作为 ID 可以帮助提高整体效能 – arg - 注入到构造方法的一个普通结果 • id – 一个 ID 结果; 标记结果作为 ID 可以帮助提高整体效能 • result – 注入到字段或 JavaBean 属性的普通结果 • association – 一个复杂的类型关联;许多结果将包成这种类型 – 嵌入结果映射 – 结果映射自身的关联,或者参考一个 • collection – 复杂类型的集 – 嵌入结果映射 – 结果映射自身的集,或者参考一个 • discriminator – 使用结果值来决定使用哪个结果映射 – case – 基于某些值的结果映射 • 嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相同的元素,或者它可以参照一个外部的结果映射。 id &amp; result• id 和 result 映射一个单独列的值到简单数据类型 (字符串,整型,双精度浮点数,日期等)的属性或字段。 association • 复杂对象映射 • POJO中的属性可能会是一个对象我们可以使用联合查询，并以级联属性的方式封 装对象。 • 使用association标签定义对象的封装规则 association-嵌套结果集 association-分段查询 select：调用目标的方法查询当前属性的值column：将指定列的值传入目标方法 association-分段查询&amp;延迟加载 开启延迟加载和属性按需加载 • 旧版本的MyBatis需要额外的支持包 – asm-3.3.1.jar – cglib-2.2.2.jar Collection-集合类型&amp;嵌套结果集 Collection-分步查询&amp;延迟加载 扩展-多列值封装map传递 • 分步查询的时候通过column指定，将对应的列的数据传递过去，我们有时需要传递多列数据。 • 使用{key1=column1,key2=column2…}的形式 • association或者collection标签的fetchType=eager/lazy可以覆盖全局的延迟加载策略， 指定立即加载（eager）或者延迟加载（lazy） 五、MyBatis-动态SQL• 动态 SQL是MyBatis强大特性之一。极大的简化我们拼装 SQL的操作。 • 动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。 • MyBatis 采用功能强大的基于 OGNL 的表达式来简化操作。 1234– if– choose (when, otherwise)– trim (where, set)– foreach if choose (when, otherwise) trim (where, set) where set trim foreach 动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候 • 当迭代列表、集合等可迭代对象或者数组时 – index是当前迭代的次数，item的值是本次迭代获取的元素 • 当使用字典（或者Map.Entry对象的集合）时 – index是键，item是值 bind• bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如： Multi-db vendor support • 若在 mybatis 配置文件中配置了 databaseIdProvider , 则可以使用 “**_databaseI**d”变量，这样就可以根据不同的数据库厂商构建特定的语句 OGNL（ Object Graph Navigation Language ）对象图导航语言，这是一种强大的****表达式语言，通过它可以非常方便的来操作对象属性。 类似于我们的EL，SpEL等 访问对象属性： person.name 调用方法： person.getName() 调用静态属性/方法： @java.lang.Math@PI @java.util.UUID@randomUUID() 调用构造方法： new com.atguigu.bean.Person(‘admin’).name运算符： +,-*,/,% 逻辑运算符： in,not in,&gt;,&gt;=,&lt;,&lt;=,==,!= 注意：xml中特殊符号如”,&gt;,&lt;等这些都需要使用转义字符 访问集合伪属性： 类型 伪属性 伪属性对应的Java 方法 List、Set、Map size、isEmpty List/Set/Map.size(),List/Set/Map.isEmpty() List、Set iterator List.iterator()、Set.iterator() Map keys、values Map.keySet()、Map.values() Iterator next、hasNext Iterator.next()、Iterator.hasNext() 六、MyBatis-缓存机制• MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。 • MyBatis系统中默认定义了两级缓存。 • 一级缓存和二级缓存。 – 1、默认情况下，只有一级缓存（SqlSession级别的缓存， 也称为本地缓存）开启。 – 2、二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 – 3、为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存 • 一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。当 Session flush 或 close 后, 该Session 中的所有 Cache 将被清空。 • 本地缓存不能被关闭, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域。在mybatis3.1之后, 可以配置本地缓存的作用域. 在 mybatis.xml 中配置 一级缓存演示&amp;失效情况 • 同一次会话期间只要查询过的数据都会保存在当 前SqlSession的一个Map中 • key:hashCode+查询的SqlId+编写的sql查询语句+参数 • 一级缓存失效的四种情况 – 1、不同的SqlSession对应不同的一级缓存 – 2、同一个SqlSession但是查询条件不同 – 3、同一个SqlSession两次查询期间执行了任何一次增删改操作 – 4、同一个SqlSession两次查询期间手动清空了缓存 二级缓存 • 二级缓存(second level cache)，全局作用域缓存 • 二级缓存默认不开启，需要手动配置 • MyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口 • 二级缓存在 SqlSession 关闭或提交****之后才会生效 • 使用步骤 – 1、全局配置文件中开启二级缓存 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; – 2、需要使用二级缓存的映射文件处使用cache配置缓存 1&lt;cache /&gt; – 3、注意：POJO需要实现Serializable接口 缓存相关属性• eviction=“FIFO”：缓存回收策略： • LRU – 最近最少使用的：移除最长时间不被使用的对象。 • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 • 默认的是 LRU。 • flushInterval：刷新间隔，单位毫秒 • 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 • size：引用数目，正整数 • 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 • readOnly：只读，true/false • true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象 不能被修改。这提供了很重要的性能优势。 • false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些， 但是安全，因此默认是 false。 缓存有关设置• 1、全局setting的cacheEnable： – 配置二级缓存的开关。一级缓存一直是打开的。 • 2、select标签的useCache属性： – 配置这个select是否使用二级缓存。一级缓存一直是使用的 • 3、sql标签的flushCache属性： – 增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。 查询默认flushCache=false。 • 4、sqlSession.clearCache()： – 只是用来清除一级缓存。 • 5、当在某一个作用域 (一级缓存Session/二级缓存 Namespaces) 进行了 C/U/D 操作后，默认该作用域下所有select 中的缓存将被clear。 第三方缓存整合 • EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 • MyBatis定义了Cache接口方便我们进行自定义扩展。 • 步骤： – 1、导入ehcache包，以及整合包，日志包 ehcache-core-2.6.8.jar、mybatis-ehcache-1.0.3.jar slf4j-api-1.6.1.jar、slf4j-log4j12-1.6.2.jar – 2、编写ehcache.xml配置文件 – 3、配置cache标签 1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt; • 参照缓存：若想在命名空间中共享相同的缓存配置和实例。可以使用 cache-ref 元素来引用另外一个缓存。 当执行一条查询SQL时，流程为 从二级缓存中进行查询进入一级缓存中查询执行 JDBC 查询。 七、MyBatis-Spring整合1、查看不同MyBatis版本整合Spring时使用的适配包； http://www.mybatis.org/spring/ 2、下载整合适配包https://github.com/mybatis/spring/releases MyBatis-Spring MyBatis Spring 1.0.0 and 1.0.1 3.0.1 to 3.0.5 3.0.0 or higher 1.0.2 3.0.6 3.0.0 or higher 1.1.0 or higher 3.1.0 or higher 3.0.0 or higher 1.3.0 or higher 3.4.0 or higher 3.0.0 or higher • 3、官方整合示例，jpetstore https://github.com/mybatis/jpetstore-6 整合关键配置1234567891011121314151617&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&lt;!-- 指定mybatis全局配置文件位置--&gt;&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis-config.xml&quot;&gt;&lt;/property&gt;&lt;!--指定数据源 --&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;!--mapperLocations：所有sql映射文件所在的位置--&gt;&lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mybatis/mapper/*.xml&quot;&gt;&lt;/property&gt;&lt;!--typeAliasesPackage：批量别名处理--&gt;&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.atguigu.bean&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--自动的扫描所有的mapper的实现并加入到ioc容器中 --&gt;&lt;bean id=&quot;configure&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;&lt;!– basePackage:指定包下所有的mapper接口实现自动扫描并加入到ioc容器中--&gt;&lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.dao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 八、MyBatis-逆向工程• MyBatis Generator： • 简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写 • 官方文档地址：http://www.mybatis.org/generator/ • 官方工程地址：https://github.com/mybatis/generator/releases MBG使用 • 使用步骤： 1）编写MBG的配置文件（重要几处配置） 1）jdbcConnection配置数据库连接信息 2）javaModelGenerator配置javaBean的生成策略 3）sqlMapGenerator 配置sql映射文件生成策略4）javaClientGenerator配置Mapper接口的生成策略 5）table 配置要逆向解析的数据表 tableName：表名 domainObjectName：对应的javaBean名 – 2）运行代码生成器生成代码 • 注意： Context标签 targetRuntime=“MyBatis3“可以生成带条件的增删改查 targetRuntime=“MyBatis3Simple“可以生成基本的增删改查 如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。 MBG配置文件123456789101112131415161718192021222324&lt;generatorConfiguration&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;//数据库连接信息配置&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/bookstore0629&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt;&lt;/jdbcConnection&gt;//javaBean的生成策略&lt;javaModelGenerator targetPackage=&quot;com.atguigu.bean&quot; targetProject=&quot;.\\src&quot;&gt;&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;&lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;&lt;/javaModelGenerator&gt;//映射文件的生成策略&lt;sqlMapGenerator targetPackage=&quot;mybatis.mapper&quot; targetProject=&quot;.\\conf&quot;&gt;&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;&lt;/sqlMapGenerator&gt;//dao接口java文件的生成策略&lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.dao&quot; targetProject=&quot;.\\src&quot;&gt;&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;&lt;/javaClientGenerator&gt;//数据表与javaBean的映射&lt;table tableName=&quot;books&quot; domainObjectName=&quot;Book&quot;&gt;&lt;/table&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt; 生成器代码 12345678910public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 测试查询： QBC风格的带条件查询 123456789101112131415@Testpublic void test01()&#123; SqlSession openSession = build.openSession(); DeptMapper mapper = openSession.getMapper(DeptMapper.class); DeptExample example = new DeptExample(); //所有的条件都在example中封装 Criteria criteria = example.createCriteria(); //select id, deptName, locAdd from tbl_dept WHERE //( deptName like ? and id &gt; ? ) criteria.andDeptnameLike(&quot;%部%&quot;); criteria.andIdGreaterThan(2); List&lt;Dept&gt; list = mapper.selectByExample(example); for (Dept dept : list) &#123; System.out.println(dept); &#125;&#125; 九MyBatis-工作原理 十、MyBatis-插件开发• MyBatis在四大对象的创建过程中，都会有插件进行介入。插件可以利用动态代理机制一层层的包装目标对象，而实现在目标对象执行目标方法之前进行拦截的效果。 • MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。 • 默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： 12345• Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)• ParameterHandler (getParameterObject, setParameters)• ResultSetHandler (handleResultSets, handleOutputParameters)• StatementHandler (prepare, parameterize, batch, update, query) 插件开发 • 插件开发步骤 编写插件实现Interceptor接口，并使用@Intercepts注解完成插件签名 – 2）、在全局配置文件中注册插件 插件原理• 1）、按照插件注解声明，按照插件配置顺序调用插件plugin方 法，生成被拦截对象的动态代理 • 2）、多个插件依次生成目标对象的代理对象，层层包裹，先声明的先包裹；形成代理链 • 3）、目标方法执行时依次从外到内执行插件的intercept方法。 • 4）、多个插件情况下，我们往往需要在某个插件中分离出目标对象。可以借助MyBatis提供的SystemMetaObject类来进行获取最后一层的h以及target属性的值 Interceptor接口• Intercept：拦截目标方法执行 • plugin：生成动态代理对象，可以使用MyBatis提供的Plugin类的wrap方法 • setProperties：注入插件配置时设置的属性 常用代码： 从代理链中分离真实被代理对象 1、分离代理对象。由于会形成多次代理，所以需要通过一个 while 循环分离出最终被代理对象，从而方便提取信息 1234MetaObject metaObject = SystemMetaObject.forObject(target); while(metaObject.hasGetter(&quot;h&quot;)) &#123; Object h = metaObject.getValue(&quot;h&quot;); metaObject = SystemMetaObject.forObject(h);&#125; 2、获取到代理对象中包含的被代理的真实对象 1Object obj = metaObject.getValue(&quot;target&quot;); 3、获取被代理对象的MetaObject方便进行信息提取 1MetaObject forObject = SystemMetaObject.forObject(obj); 扩展：MyBatis实用场景 • 1）、PageHelper插件进行分页 • 2）、批量操作 • 3）、存储过程 • 4）、typeHandler处理枚举 PageHelper插件进行分页 • PageHelper是MyBatis中非常方便的第三方分页插件。 官 方 文 档 ： https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md • 我们可以对照官方文档的说明，快速的使用插件 使用步骤 • 1、导入相关包pagehelper-x.x.x.jar 和 jsqlparser- 0.9.5.jar。 • 2、在MyBatis全局配置文件中配置分页插件。 • 3、使用PageHelper提供的方法进行分页 • 4、可以使用更强大的PageInfo封装返回结果 批量操作 • 默认的 openSession() 方法没有参数,它会创建有如下特性的 – 会开启一个事务(也就是不自动提交) – 连接对象会从由活动环境配置的数据源实例得到。 – 事务隔离级别将会使用驱动或数据源的默认设置。 – 预处理语句不会被复用,也不会批量处理更新。 • openSession 方法的 ExecutorType 类型的参数，枚举类型: – ExecutorType.SIMPLE: 这个执行器类型不做特殊的事情（这是默认装配的）。它为每个语句的执行创建一个新的预处理语句。 – ExecutorType.REUSE: 这个执行器类型会复用预处理语句。 – ExecutorType.BATCH: 这个执行器会批量执行所有更新语句 • 批量操作我们是使用MyBatis提供的BatchExecutor进行的， 他的底层就是通过jdbc攒sql的方式进行的。我们可以让他攒够一定数量后发给数据库一次。 1234567891011public void test01() &#123;SqlSession openSession = build.openSession(ExecutorType.BATCH); UserDao mapper = openSession.getMapper(UserDao.class);long start = System.currentTimeMillis();for (int i = 0; i &lt; 1000000; i++) &#123;String name = UUID.randomUUID().toString().substring(0, 5);mapper.addUser(new User(null, name, 13));&#125;openSession.commit(); openSession.close();long end = System.currentTimeMillis();System.out.println(&quot;耗时时间：&quot;+(end-start));&#125; • 与Spring整合中，我们推荐，额外的配置一个可以专 门用来执行批量操作的sqlSession • 需要用到批量操作的时候，我们可以注入配置的这个批量SqlSession。通过他获取到mapper映射器进行操作。 • 注意： • 1、批量操作是在session.commit()以后才发送sql语句给数据库进行执行的 • 2、如果我们想让其提前执行，以方便后续可能的查询操作获取数据，我们可以使用sqlSession.flushStatements()方法，让其直接冲刷到数据库进行执行。 存储过程• 实际开发中，我们通常也会写一些存储过程， MyBatis也支持对存储过程的调用 • 一个最简单的存储过程 12345delimiter $$create procedure test() beginselect &#x27;hello&#x27;;end $$delimiter ; • 存储过程的调用 1、select标签中statementType=“CALLABLE” 2、标签体中调用语法： 1&#123;call procedure_name(#&#123;param1_info&#125;,#&#123;param2_info&#125;)&#125; 存储过程-游标处理 • MyBatis对存储过程的游标提供了一个JdbcType=CURSOR的支持， 可以智能的把游标读取到的数据，映射到我们声明的结果集中 调用实例： 123orcl.driver=oracle.jdbc.OracleDriver orcl.url=jdbc:oracle:thin:@localhost:1521:orcl orcl.username=scottorcl.password=123456 123456public class PageEmp &#123; private int start; private int end; private int count; private List&lt;Emp&gt; emps;&#125; 1234567891011121314&lt;environment id=&quot;oracle_dev&quot;&gt;&lt;transactionManager type=&quot;JDBC&quot; /&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;&lt;property name=&quot;driver&quot; value=&quot;$&#123;orcl.driver&#125;&quot; /&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;orcl.url&#125;&quot; /&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;orcl.username&#125;&quot; /&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;orcl.password&#125;&quot; /&gt;&lt;/dataSource&gt;&lt;/environment&gt;&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;&lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;&lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt;&lt;/databaseIdProvider&gt; 自定义TypeHandler处理枚举• 我们可以通过自定义TypeHandler的形式来在设置参数或者取出结果集的时候自定义参数封装策略。 • 步骤： – 1、实现TypeHandler接口或者继承BaseTypeHandler – 2、使用@MappedTypes定义处理的java类型 使用@MappedJdbcTypes定义jdbcType类型 – 3、在自定义结果集标签或者参数处理的时候声明使用自定义TypeHandler进行处理 或者在全局配置TypeHandler要处理的javaType • 测试实例 一个代表部门状态的枚举类 测试全局配置EnumOrdinalTypeHandler • 2、测试全局配置EnumTypeHandler • 3、测试参数位置设置自定义TypeHandler 自定义TypeHandler","categories":[{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://stary2020.gitee.io/tags/MyBatis/"}],"author":null},{"title":"Spring5","slug":"java-2021-07-10-Spring5","date":"2021-07-10T13:05:59.000Z","updated":"2021-08-27T10:29:11.569Z","comments":true,"path":"2021/07/10/java-2021-07-10-Spring5/","link":"","permalink":"http://stary2020.gitee.io/2021/07/10/java-2021-07-10-Spring5/","excerpt":"","text":"1. 概述1、Spring 是轻量级的开源的 JavaEE 框架2、Spring 可以解决企业应用开发的复杂性3、Spring 有两个核心部分：IOC 和 Aop（1）IOC：控制反转，把创建对象过程交给 Spring 进行管理（2）Aop：面向切面，不修改源代码进行功能增强4、Spring 特点（1）方便解耦，简化开发（2）Aop 编程支持（3）方便程序测试（4）方便和其他框架进行整合（5）方便进行事务操作（6）降低 API 开发难度 入门案例1、下载Spring5 的依赖，https://repo.spring.io/release/org/springframework/spring/ 2、打开 idea 工具，创建普通 Java 工程 3、导入 Spring5 相关 jar 包 4、创建普通类，在这个类创建普通方法 12345public class User &#123; public void add() &#123; System.out.println(&quot;add......&quot;); &#125;&#125; 5、创建 Spring 配置文件，在配置文件配置创建的对象（1）Spring 配置文件使用 xml 格式 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置 User 对象创建--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring5.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 6、进行测试代码编写 12345678910@Testpublic void testAdd() &#123; //1 加载 spring 配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //2 获取配置创建的对象 User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add();&#125; 2. IOC 容器IOC 底层原理1、什么是 IOC(==Inversion of Control==)（1）控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理（2）使用 IOC 目的：为了耦合度降低（3）做入门案例就是 IOC 实现 2、IOC 底层原理（1）xml 解析、工厂模式、反射 3、画图讲解 IOC 底层原理 IOC 接口（BeanFactory）1、IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 2、Spring 提供 IOC 容器实现两种方式：（两个接口）（1）BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 （2）ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用 加载配置文件时候就会把在配置文件对象进行创建 3、ApplicationContext 接口有实现类 IOC 操作 Bean 管理（基于 xml）1、什么是 Bean 管理（0）Bean 管理指的是两个操作（1）Spring 创建对象（2）Spirng 注入属性 2、Bean 管理操作有两种方式（1）基于 xml 配置文件方式实现（2）基于注解方式实现 1、基于 xml 方式创建对象 （1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建（2）在 bean 标签有很多属性，介绍常用的属性 id 属性：唯一标识 class 属性：类全路径（包类路径）（3）创建对象时候，默认也是执行无参数构造方法完成对象创建 2、基于 xml 方式注入属性 （1）DI：依赖注入，就是注入属性 3、第一种注入方式：使用 set 方法进行注入 （1）创建类，定义属性和对应的 set 方法 123456789101112131415/*** 演示使用 set 方法进行注入属性*/public class Book &#123;//创建属性 private String bname; private String bauthor; //创建属性对应的 set 方法 public void setBname(String bname) &#123; this.bname = bname; &#125; public void setBauthor(String bauthor) &#123; this.bauthor = bauthor; &#125;&#125; （2）在 spring 配置文件配置对象创建，配置属性注入 123456789&lt;!--2 set 方法注入属性--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot;&gt; &lt;!--使用 property 完成属性注入 name：类里面属性名称 value：向属性注入的值 --&gt; &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 4、第二种注入方式：使用有参数构造进行注入（1）创建类，定义属性，创建属性对应有参数构造方法 12345678910111213/*** 使用有参数构造注入*/public class Orders &#123; //属性 private String oname; private String address; //有参数构造 public Orders(String oname,String address) &#123; this.oname = oname; this.address = address; &#125;&#125; （2）在 spring 配置文件中进行配置 12345&lt;!--3 有参数构造注入属性--&gt;&lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 5、p 名称空间注入（了解）（1）使用 p 名称空间注入，可以简化基于 xml 配置方式第一步 添加 p 名称空间在配置文件中 12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemalLocation=&quot;http://www.springframework.org/schema/beans &quot;&gt;&lt;/beans&gt; 第二步 进行属性注入，在 bean 标签里面进行操作 123&lt;!--2 set 方法注入属性--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt; xml 注入其他类型属性1、字面量（1）null 值 1234&lt;!--null 值--&gt;&lt;property name=&quot;address&quot;&gt; &lt;null/&gt;&lt;/property&gt; （2）属性值包含特殊符号 1234567&lt;!--属性值包含特殊符号1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;2 把带特殊符号内容写到 CDATA--&gt;&lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 2、注入属性-外部 bean （1）创建两个类 service 类和 dao 类（2）在 service 调用 dao 里面的方法（3）在 spring 配置文件中进行配置 1234567891011public class UserService &#123; //创建 UserDao 类型属性，生成 set 方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add() &#123; System.out.println(&quot;service add...............&quot;); userDao.update(); &#125;&#125; 123456789&lt;!--1 service 和 dao 对象创建--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring5.service.UserService&quot;&gt; &lt;!--注入 userDao 对象 name 属性：类里面属性名称 ref 属性：创建 userDao 对象 bean 标签 id 值 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 3、注入属性-内部 bean（1）一对多关系：部门和员工一个部门有多个员工，一个员工属于一个部门部门是一，员工是多（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示 1234567891011121314151617181920212223//部门类public class Dept &#123; private String dname; public void setDname(String dname) &#123; this.dname = dname; &#125;&#125;//员工类public class Emp &#123; private String ename; private String gender; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125;&#125; （3）在 spring 配置文件中进行配置 123456789101112&lt;!--内部 bean--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 4、注入属性-级联赋值（1）第一种写法 1234567891011&lt;!--级联赋值--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; （2）第二种写法 123456789//员工属于某一个部门，使用对象形式表示private Dept dept;//生成dept的get方法public void setDept(Dept dept)&#123; this.dept=dept;&#125;public void getDept()&#123; return dept;&#125; 123456789101112&lt;!--级联赋值--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; xml注入集合属性1、注入数组类型属性2、注入 List 集合类型属性3、注入 Map 集合类型属性（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 12345678910111213141516171819202122public class Stu &#123; //1 数组类型属性 private String[] courses; //2 list 集合类型属性 private List&lt;String&gt; list; //3 map 集合类型属性 private Map&lt;String,String&gt; maps; //4 set 集合类型属性 private Set&lt;String&gt; sets; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125;&#125; （2）在 spring 配置文件进行配置 12345678910111213141516171819202122232425262728293031&lt;!--1 集合类型属性注入--&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java 课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list 类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map 类型属性注入--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set 类型属性注入--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 4、在集合里面设置对象类型值 1234567891011121314&lt;!--创建多个 course 对象--&gt;&lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5 框架&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis 框架&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--注入 list 集合类型，值是对象--&gt;&lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt;&lt;/property&gt; 5、把集合注入部分提取出来（1）在 spring 配置文件中引入名称空间 util 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; （2）使用 util 标签完成 list 集合注入提取 12345678910&lt;!--1 提取 list 集合类型属性注入--&gt;&lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt;&lt;/util:list&gt;&lt;!--2 提取 list 集合类型属性注入使用--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;&lt;/bean&gt; FactoryBean1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 2、普通 bean：在配置文件中定义 bean 类型就是返回类型 3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 12345678910111213141516171819202122232425public class MyBean implements FactoryBean&lt;Course&gt; &#123; //定义返回 bean @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(&quot;abc&quot;); return course; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125;@Testpublic void test3() &#123; ApplicationContext context =new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Course course = context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course);&#125; 12&lt;bean id=&quot;myBean&quot; class=&quot;com.atguigu.spring5.factorybean.MyBean&quot;&gt;&lt;/bean&gt; bean 作用域1、在 Spring 里面，设置创建 bean 实例是单实例还是多实例 2、在 Spring 里面，默认情况下，bean 是单实例对象 3、如何设置单实例还是多实例（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例（2）scope 属性值第一个值 默认值，singleton，表示是单实例对象第二个值 prototype，表示是多实例对象（3）singleton 和 prototype 区别第一 singleton 单实例，prototype 多实例第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用getBean 方法时候创建多实例对象 bean 生命周期1、生命周期（1）从对象创建到对象销毁的过程 2、bean 生命周期（1）通过构造器创建 bean 实例（无参数构造）（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）（3）调用 bean 的初始化的方法（需要进行配置初始化的方法）（4）bean 可以使用了（对象获取到了）（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 3、演示 4、bean 的后置处理器，bean 生命周期有七步（1）通过构造器创建 bean 实例（无参数构造）（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）（3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization（4）调用 bean 的初始化的方法（需要进行配置初始化的方法）（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization（6）bean 可以使用了（对象获取到了）（7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）5、演示添加后置处理器效果（1）创建类，实现接口 BeanPostProcessor，创建后置处理器 123456789101112public class MyBeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName)throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName)throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125; 12&lt;!--配置后置处理器--&gt;&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.atguigu.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt; xml 自动装配1、什么是自动装配（1）根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 2、演示自动装配过程（1）根据属性名称自动注入 12345678910&lt;!--实现自动装配 bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值： byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样 byType 根据属性类型注入--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt; （2）根据属性类型自动注入 12345678910&lt;!--实现自动装配bean 标签属性 autowire，配置自动装配autowire 属性常用两个值：byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样byType 根据属性类型注入--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byType&quot;&gt;&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt; 外部属性文件1、直接配置数据库信息（1）配置德鲁伊连接池（2）引入德鲁伊连接池依赖 jar 包 12345678&lt;!--直接配置连接池--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;&lt;property name=&quot;url&quot;value=&quot;jdbc:mysql://localhost:3306/userDb&quot;&gt;&lt;/property&gt;&lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、引入外部属性文件配置数据库连接池（1）创建外部属性文件，properties 格式文件，写数据库信息（2）把外部 properties 属性文件引入到 spring 配置文件中 引入 context 名称空间 1234567891011&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 在 spring 配置文件使用标签引入外部属性文件 123456789&lt;!--引入外部属性文件--&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!--配置连接池--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; IOC 操作 Bean 管理（基于注解）1、什么是注解（1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)（2）使用注解，注解作用在类上面，方法上面，属性上面（3）使用注解目的：简化 xml 配置2、Spring 针对 Bean 管理中创建对象提供注解（1）@Component（2）@Service（3）@Controller（4）@Repository 上面四个注解功能是一样的，都可以用来创建 bean 实例3、基于注解方式实现对象创建第一步 引入依赖 第二步 开启组件扫描 12345&lt;!--开启组件扫描1 如果扫描多个包，多个包使用逗号隔开2 扫描包上层目录--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; 第三步 创建类，在类上面添加创建对象注解 123456789//在注解里面 value 属性值可以省略不写，//默认值是类名称，首字母小写//UserService -- userService@Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;public class UserService &#123; public void add() &#123; System.out.println(&quot;service add.......&quot;); &#125;&#125; 4、开启组件扫描细节配置 123456789101112131415161718&lt;!--示例 1use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filtercontext:include-filter ，设置扫描哪些内容--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;&lt;context:include-filter type=&quot;annotation&quot;expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--示例 2下面配置扫描包所有内容context:exclude-filter： 设置哪些内容不进行扫描--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;context:exclude-filter type=&quot;annotation&quot;expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 5、基于注解方式实现属性注入（1）@Autowired：根据属性类型进行自动装配第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解 123456789101112@Servicepublic class UserService &#123;//定义 dao 类型属性//不需要添加 set 方法//添加注入属性注解 @Autowired private UserDao userDao; public void add() &#123; System.out.println(&quot;service add.......&quot;); userDao.add(); &#125;&#125; （2）@Qualifier：根据名称进行注入这个@Qualifier 注解的使用，和上面@Autowired 一起使用 123456//定义 dao 类型属性//不需要添加 set 方法//添加注入属性注解@Autowired //根据类型进行注入@Qualifier(value = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao; （3）@Resource：可以根据类型注入，可以根据名称注入 123//@Resource //根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao; （4）@Value：注入普通类型属性 12@Value(value = &quot;abc&quot;)private String name; 6、完全注解开发（1）创建配置类，替代 xml 配置文件 1234@Configuration //作为配置类，替代 xml 配置文件@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class SpringConfig &#123;&#125; （2）编写测试类 12345678910@Testpublic void testService2() &#123;//加载配置类 ApplicationContext context= new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add();&#125; 3. AOP1、什么是 AOP（1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能（3）使用登录例子说明 AOP 底层原理1、AOP 底层使用动态代理（1）有两种情况动态代理第一种 有接口情况，使用 JDK 动态代理 创建接口实现类代理对象，增强类的方法第二种 没有接口情况，使用 CGLIB 动态代理 创建子类的代理对象，增强类的方法 JDK 动态代理1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象（1）调用 newProxyInstance 方法方法有三个参数：第一参数，类加载器第二参数，增强方法所在的类，这个类实现的接口，支持多个接口第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分2、编写 JDK 动态代理代码（1）创建接口，定义方法 1234public interface UserDao &#123; public int add(int a,int b); public String update(String id);&#125; （2）创建接口实现类，实现方法 12345678910public class UserDaoImpl implements UserDao &#123; @Override public int add(int a, int b) &#123; return a+b; &#125; @Override public String update(String id) &#123; return id; &#125;&#125; （3）使用 Proxy 类创建接口代理对象 123456789101112131415161718192021222324252627282930313233343536public class JDKProxy &#123; public static void main(String[] args) &#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;; // Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,new InvocationHandler() &#123;// @Override// public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123;// return null;// &#125;// &#125;); UserDaoImpl userDao = new UserDaoImpl(); UserDao dao =(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(&quot;result:&quot;+result); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler &#123; //1 把创建的是谁的代理对象，把谁传递过来 //有参数构造传递 private Object obj; public UserDaoProxy(Object obj) &#123; this.obj = obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; //方法之前 System.out.println(&quot;方法之前执行....&quot;+method.getName()+&quot; :传递的参数...&quot;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(&quot;方法之后执行....&quot;+obj); return res; &#125;&#125; AOP术语1、连接点:类里面那些方法可以被增强，这些方法称为连接点 2、切入点:实际被真正增强的方法，称为切入点 3、通知(增强) 实际增强的逻辑部分称为通知(增强) 通知有多种类型 前置通知 后置通知 环绕通知 异常通知 最终通知 …… 4、切面是动作，即把通知应用到切入点的过程 AOP操作(准备工作)1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作（1）AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作2、基于 AspectJ 实现 AOP 操作（1）基于 xml 配置文件实现（2）基于注解方式实现（使用）3、在项目工程里面引入 AOP 相关依赖 4、切入点表达式（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] 方法名称 )举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强execution(* com.atguigu.dao.BookDao.add(..))举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强execution(* com.atguigu.dao.BookDao.* (..))举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强execution(* com.atguigu.dao.. (..)) AOP 操作（AspectJ 注解）1、创建类，在类里面定义方法 12345public class User &#123; public void add() &#123; System.out.println(&quot;add.......&quot;); &#125;&#125; 2、创建增强类（编写增强逻辑）（1）在增强类里面，创建方法，让不同方法代表不同通知类型 123456//增强的类public class UserProxy &#123; public void before() &#123;//前置通知 System.out.println(&quot;before......&quot;); &#125;&#125; 3、进行通知的配置（1）在 spring 配置文件中，开启注解扫描 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 开启注解扫描 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt; （2）使用注解创建 User 和 UserProxy 对象 1234567//被增强的类@Componentpublic class User&#123; &#125;//增强的类@Componentpublic class UserProxy&#123;&#125; （3）在增强类上面添加注解 @Aspect 1234//增强的类@Component@Aspect //生成代理对象public class UserProxy &#123;&#125; （4）在 spring 配置文件中开启生成代理对象 12&lt;!-- 开启 Aspect 生成代理对象--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4、配置不同类型的通知（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 123456789101112131415161718192021222324252627282930313233343536//增强的类@Component@Aspect //生成代理对象public class UserProxy &#123; //前置通知 //@Before 注解表示作为前置通知 @Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void before() &#123; System.out.println(&quot;before.........&quot;); &#125; //后置通知（返回通知） @AfterReturning(value = &quot;execution(*com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterReturning() &#123; System.out.println(&quot;afterReturning.........&quot;); &#125; //最终通知 @After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void after() &#123; System.out.println(&quot;after.........&quot;); &#125; //异常通知 @AfterThrowing(value = &quot;execution(*com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterThrowing() &#123; System.out.println(&quot;afterThrowing.........&quot;); &#125; //环绕通知 @Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前.........&quot;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后.........&quot;); &#125;&#125; 5、相同的切入点抽取 12345678910//相同切入点抽取@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)public void pointdemo() &#123;&#125;//前置通知//@Before 注解表示作为前置通知@Before(value = &quot;pointdemo()&quot;)public void before() &#123; System.out.println(&quot;before.........&quot;);&#125; 6、有多个增强类多同一个方法进行增强，设置增强类优先级（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 1234@Component@Aspect@Order(1)public class PersonProxy 7、完全使用注解开发（1）创建配置类，不需要创建 xml 配置文件 12345@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true)public class ConfigAop &#123;&#125; AOP 操作（AspectJ 配置文件）1、创建两个类，增强类和被增强类，创建方法2、在 spring 配置文件中创建两个类对象 123&lt;!--创建对象--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt; 3、在 spring 配置文件中配置切入点 1234567891011&lt;!--配置 aop 增强--&gt;&lt;aop:config&gt;&lt;!--切入点--&gt;&lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(*com.atguigu.spring5.aopxml.Book.buy(..))&quot;/&gt;&lt;!--配置切面--&gt;&lt;aop:aspect ref=&quot;bookProxy&quot;&gt;&lt;!--增强作用在具体的方法上--&gt;&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt; 4. JdbcTemplate概念1、什么是 JdbcTemplate（1）Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作2、准备工作（1）引入相关 jar 包 （2）在 spring 配置文件配置数据库连接池 12345678&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;&lt;/bean&gt; （3）配置 JdbcTemplate 对象，注入 DataSource 12345&lt;!-- JdbcTemplate 对象 --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!--注入 dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; （4）创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 配置文件 12&lt;!-- 组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; Service 123456@Servicepublic class BookService &#123;//注入 dao@Autowiredprivate BookDao bookDao;&#125; Dao 123456@Repositorypublic class BookDaoImpl implements BookDao &#123;//注入 JdbcTemplate@Autowiredprivate JdbcTemplate jdbcTemplate;&#125; JdbcTemplate 操作数据库（添加）1、对应数据库创建实体类 123456789public class User&#123; private String userId; private String username; private String ustatus; public User()&#123; &#125; ……&#125; 2、编写 service 和 dao（1）在 dao 进行数据库添加操作（2）调用 JdbcTemplate 对象里面 update 方法实现添加操作 有两个参数 第一个参数：sql 语句 第二个参数：可变参数，设置 sql 语句值 1234567891011121314151617@Repositorypublic class BookDaoImpl implements BookDao &#123; //注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; //添加的方法 @Override public void add(Book book) &#123; //1 创建 sql 语句 String sql = &quot;insert into t_book values(?,?,?)&quot;; //2 调用方法实现 Object[] args = &#123;book.getUserId(), book.getUsername(),book.getUstatus()&#125;; int update = jdbcTemplate.update(sql,args); System.out.println(update); &#125;&#125; 3、测试类 123456789101112@Testpublic void testJdbcTemplate() &#123; ApplicationContext context =new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;,BookService.class); Book book = new Book(); book.setUserId(&quot;1&quot;); book.setUsername(&quot;java&quot;); book.setUstatus(&quot;a&quot;); bookService.addBook(book);&#125; JdbcTemplate 操作数据库（修改和删除）1、修改 1234567@Overridepublic void updateBook(Book book) &#123; String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;; Object[] args = &#123;book.getUsername(),book.getUstatus(),book.getUserId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update);&#125; 2、删除 123456@Overridepublic void delete(String id) &#123; String sql = &quot;delete from t_book where user_id=?&quot;; int update = jdbcTemplate.update(sql, id); System.out.println(update);&#125; JdbcTemplate 操作数据库（查询返回某个值）1、查询表里面有多少条记录，返回是某个值2、使用 JdbcTemplate 实现查询返回某个值代码有两个参数 第一个参数：sql 语句 第二个参数：返回类型 Class 1234567//查询表记录数@Overridepublic int selectCount() &#123; String sql = &quot;select count(*) from t_book&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count;&#125; JdbcTemplate 操作数据库（查询返回对象）1、场景：查询图书详情2、JdbcTemplate 实现查询返回对象有三个参数 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql 语句值 123456789//查询返回对象@Overridepublic Book findBookInfo(String id) &#123; String sql = &quot;select * from t_book where user_id=?&quot;; //调用方法 Book book = jdbcTemplate.queryForObject(sql, newBeanPropertyRowMapper&lt;Book&gt;(Book.class), id); return book;&#125; JdbcTemplate 操作数据库（查询返回集合）1、场景：查询图书列表分页…2、调用 JdbcTemplate 方法实现查询返回集合有三个参数 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql 语句值 123456789//查询返回集合@Overridepublic List&lt;Book&gt; findAllBook() &#123; String sql = &quot;select * from t_book&quot;; //调用方法 List&lt;Book&gt; bookList = jdbcTemplate.query(sql, newBeanPropertyRowMapper&lt;Book&gt;(Book.class)); return bookList;&#125; JdbcTemplate 操作数据库（批量操作）1、批量操作：操作表里面多条记录2、JdbcTemplate 实现批量添加操作 有两个参数 第一个参数：sql 语句 第二个参数：List 集合，添加多条记录数据 1234567891011121314151617//批量添加@Overridepublic void batchAddBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;insert into t_book values(?,?,?)&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125;//批量添加测试List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;&quot;3&quot;,&quot;java&quot;,&quot;a&quot;&#125;;Object[] o2 = &#123;&quot;4&quot;,&quot;c++&quot;,&quot;b&quot;&#125;;Object[] o3 = &#123;&quot;5&quot;,&quot;MySQL&quot;,&quot;c&quot;&#125;;batchArgs.add(o1);batchArgs.add(o2);batchArgs.add(o3);//调用批量添加bookService.batchAdd(batchArgs); 3、JdbcTemplate 实现批量修改操作 1234567891011121314151617//批量修改@Overridepublic void batchUpdateBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125;//批量修改List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;&quot;java0909&quot;,&quot;a3&quot;,&quot;3&quot;&#125;;Object[] o2 = &#123;&quot;c++1010&quot;,&quot;b4&quot;,&quot;4&quot;&#125;;Object[] o3 = &#123;&quot;MySQL1111&quot;,&quot;c5&quot;,&quot;5&quot;&#125;;batchArgs.add(o1);batchArgs.add(o2);batchArgs.add(o3);//调用方法实现批量修改bookService.batchUpdate(batchArgs); 4、JdbcTemplate 实现批量删除操作 123456789101112131415//批量删除@Overridepublic void batchDeleteBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from t_book where user_id=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125;//批量删除List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;&quot;3&quot;&#125;;Object[] o2 = &#123;&quot;4&quot;&#125;;batchArgs.add(o1);batchArgs.add(o2);//调用方法实现批量删除bookService.batchDelete(batchArgs); 5. 事务管理概念1、什么事务（1）事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败（2）典型场景：银行转账 12lucy 转账 100 元 给 marylucy 少 100，mary 多 100 2、事务四个特性（ACID）（1）原子性（2）一致性（3）隔离性（4）持久性 事务操作（搭建事务操作环境） 1、创建数据库表，添加记录 2、创建 service，搭建 dao，完成对象创建和注入关系（1）service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource 3、在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法） 4、如果正常执行没有问题的，但是如果代码执行过程中出现异常，有问题例如10/0的异常模拟 使用事务解决: 事务操作过程: 事务操作（Spring 事务管理介绍）1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）2、在 Spring 进行事务管理操作（1）有两种方式：编程式事务管理和声明式事务管理（使用）3、声明式事务管理（1）基于注解方式（使用）（2）基于 xml 配置文件方式4、在 Spring 进行声明式事务管理，底层使用 AOP 原理5、Spring 事务管理 API（1）提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 事务操作（注解声明式事务管理）1、在 spring 配置文件配置事务管理器 123456&lt;!--创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!--注入数据源--&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、在 spring 配置文件，开启事务注解（1）在 spring 配置文件引入名称空间 tx 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; （2）开启事务注解 123&lt;!--开启事务注解--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 3、在 service 类上面（或者 service 类里面方法上面）添加事务注解（1）@Transactional，这个注解添加到类上面，也可以添加方法上面（2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务（3）如果把这个注解添加方法上面，为这个方法添加事务 123@Service@Transactionalpublic class UserService &#123;&#125; 事务操作（声明式事务管理参数配置）1、在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数 2、propagation：事务传播行为（1）多事务方法直接进行调用，这个过程中事务 是如何进行管理的 3、ioslation：事务隔离级别（1）事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题（2）有三个读问题：脏读、不可重复读、虚（幻）读（3）脏读：一个未提交事务读取到另一个未提交事务的数据（4）不可重复读：一个未提交事务读取到另一提交事务修改数据（5）虚读：一个未提交事务读取到另一提交事务添加数据（6）解决：通过设置事务隔离级别，解决读问题 4、timeout：超时时间（1）事务需要在一定时间内进行提交，如果不提交进行回滚（2）默认值是 -1 ，设置时间以秒单位进行计算5、readOnly：是否只读（1）读：查询操作，写：添加修改删除操作（2）readOnly 默认值 false，表示可以查询，可以添加修改删除操作（3）设置 readOnly 值是 true，设置成 true 之后，只能查询6、rollbackFor：回滚（1）设置出现哪些异常进行事务回滚7、noRollbackFor：不回滚（1）设置出现哪些异常不进行事务回滚 事务操作（XML 声明式事务管理）1、在 spring 配置文件中进行配置第一步 配置事务管理器第二步 配置通知第三步 配置切入点和切面 1234567891011121314151617181920212223&lt;!--1 创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!--注入数据源--&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--2 配置通知--&gt;&lt;tx:advice id=&quot;txadvice&quot;&gt;&lt;!--配置事务参数--&gt;&lt;tx:attributes&gt;&lt;!--指定哪种规则的方法上面添加事务--&gt;&lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--3 配置切入点和切面--&gt;&lt;aop:config&gt;&lt;!--配置切入点--&gt;&lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(*com.atguigu.spring5.service.UserService.*(..))&quot;/&gt;&lt;!--配置切面--&gt;&lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt;&lt;/aop:config&gt; 事务操作（完全注解声明式事务管理）1、创建配置类，使用配置类替代 xml 配置文件 123456789101112131415161718192021222324252627282930313233@Configuration //配置类@ComponentScan(basePackages = &quot;com.atguigu&quot;) //组件扫描@EnableTransactionManagement //开启事务public class TxConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource;&#125;//创建 JdbcTemplate 对象@Beanpublic JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123; //到 ioc 容器中根据类型找到 dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入 dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate;&#125;//创建事务管理器@Beanpublic DataSourceTransactionManagergetDataSourceTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager transactionManager = newDataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125; 6. Spring5 新特性1、整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方法在代码库中删除2、Spring 5.0 框架自带了通用的日志封装（1）Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2（2）Spring5 框架整合 Log4j2第一步 引入 jar 包 第二步 创建 log4j2.xml 配置文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;ALL --&gt;&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;&lt;configuration status=&quot;INFO&quot;&gt; &lt;!--先定义所有的 appender--&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;/appenders&gt; &lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt; &lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为默认的日志输出--&gt; &lt;loggers&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 3、Spring5 框架核心容器支持@Nullable 注解（1）@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空（2）注解用在方法上面，方法返回值可以为空（3）注解使用在方法参数里面，方法参数可以为空（4）注解使用在属性上面，属性值可以为空4、Spring5 核心容器支持函数式风格 GenericApplicationContext 12345678910111213//函数式风格创建对象，交给 spring 进行管理@Testpublic void testGenericApplicationContext() &#123; //1 创建 GenericApplicationContext 对象 GenericApplicationContext context = new GenericApplicationContext(); //2 调用 context 的方法对象注册 context.refresh(); context.registerBean(&quot;user1&quot;,User.class,() -&gt; new User()); //3 获取在 spring 注册的对象 // User user =(User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;); User user = (User)context.getBean(&quot;user1&quot;); System.out.println(user);&#125; 5、Spring5 支持整合 JUnit5（1）整合 JUnit4第一步 引入 Spring 相关针对测试依赖第二步 创建测试类，使用注解方式完成 12345678910@RunWith(SpringJUnit4ClassRunner.class) //单元测试框架@ContextConfiguration(&quot;classpath:bean1.xml&quot;) //加载配置文件public class JTest4 &#123; @Autowired private UserService userService; @Test public void test1() &#123; userService.accountMoney(); &#125;&#125; （2）Spring5 整合 JUnit5第一步 引入 JUnit5 的 jar 包第二步 创建测试类，使用注解完成 12345678910@ExtendWith(SpringExtension.class)@ContextConfiguration(&quot;classpath:bean1.xml&quot;)public class JTest5 &#123; @Autowired private UserService userService; @Test public void test1() &#123; userService.accountMoney(); &#125;&#125; （3）使用一个复合注解替代上面两个注解完成整合 123456789@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)public class JTest5 &#123; @Autowired private UserService userService; @Test public void test1() &#123; userService.accountMoney(); &#125;&#125; Spring5 框架新功能（Webflux）1、SpringWebflux 介绍（1）是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流程响应式编程出现的框架。（2）使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现的。（3）解释什么是异步非阻塞 异步和同步 非阻塞和阻塞 ** 上面都是针对对象不一样** 异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不等着对方回应就去做其他事情就是异步** 阻塞和非阻塞针对被调用者，被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞（4）Webflux 特点：第一 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程第二 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求（5）比较 SpringMVC 第一 两个框架都可以使用注解方式，都运行在 Tomet 等容器中第二 SpringMVC 采用命令式编程，Webflux 采用异步响应式编程2、响应式编程（Java 实现）（1）什么是响应式编程响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。（2）Java8 及其之前版本 提供的观察者模式两个类 Observer 和 Observable 1234567891011121314public class ObserverDemo extends Observable &#123;public static void main(String[] args) &#123; ObserverDemo observer = new ObserverDemo(); //添加观察者 observer.addObserver((o,arg)-&gt;&#123; System.out.println(&quot;发生变化&quot;); &#125;); observer.addObserver((o,arg)-&gt;&#123; System.out.println(&quot;手动被观察者通知，准备改变&quot;); &#125;); observer.setChanged(); //数据变化 observer.notifyObservers(); //通知 &#125;&#125; 3、响应式编程（Reactor 实现）（1）响应式编程操作中，Reactor 是满足 Reactive 规范框架（2）Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作符。Flux 对象实现发布者，返回 N 个元素；Mono 实现发布者，返回 0 或者 1 个元素（3）Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者 （4）代码演示 Flux 和 Mono 第一步 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;version&gt;3.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 第二步 编程代码 123456789101112public static void main(String[] args) &#123; //just 方法直接声明 Flux.just(1,2,3,4); Mono.just(1); //其他的方法 Integer[] array = &#123;1,2,3,4&#125;; Flux.fromArray(array); List&lt;Integer&gt; list = Arrays.asList(array); Flux.fromIterable(list); Stream&lt;Integer&gt; stream = list.stream(); Flux.fromStream(stream);&#125; （5）三种信号特点 错误信号和完成信号都是终止信号，不能共存的 如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流 如果没有错误信号，没有完成信号，表示是无限数据流 （6）调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生的 （7）操作符对数据流进行一道道操作，成为操作符，比如工厂流水线第一 map 元素映射为新元素第二 flatMap 元素映射为流把每个元素转换流，把转换之后多个流合并大的流 4、SpringWebflux 执行流程和核心 APISpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻塞的框架（1）NettyBIONIO（2）SpringWebflux 执行过程和 SpringMVC 相似的SpringWebflux 核心控制器 DispatchHandler，实现接口 WebHandler接口 WebHandler 有一个方法（3）SpringWebflux 里面 DispatcherHandler，负责请求的处理HandlerMapping：请求查询到处理的方法HandlerAdapter：真正负责请求处理HandlerResultHandler：响应结果处理（4）SpringWebflux 实现函数式编程，两个接口：RouterFunction（路由处理）和 HandlerFunction（处理函数） 5、SpringWebflux（基于注解编程模型）SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型使用注解编程模型方式，和之前 SpringMVC 使用相似的，只需要把相关依赖配置到项目中，SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器第一步 创建 SpringBoot 工程，引入 Webflux 依赖第二步 配置启动端口号第三步 创建包和相关类实体类创建接口定义操作的方法 123456789//用户操作接口public interface UserService &#123; //根据 id 查询用户 Mono&lt;User&gt; getUserById(int id); //查询所有用户 Flux&lt;User&gt; getAllUser(); //添加用户 Mono&lt;Void&gt; saveUserInfo(Mono&lt;User&gt; user);&#125; 接口实现类 12345678910111213141516171819202122232425262728public class UserServiceImpl implements UserService &#123; //创建 map 集合存储数据 private final Map&lt;Integer,User&gt; users = new HashMap&lt;&gt;(); public UserServiceImpl() &#123; this.users.put(1,new User(&quot;lucy&quot;,&quot;nan&quot;,20)); this.users.put(2,new User(&quot;mary&quot;,&quot;nv&quot;,30)); this.users.put(3,new User(&quot;jack&quot;,&quot;nv&quot;,50)); &#125; //根据 id 查询 @Override public Mono&lt;User&gt; getUserById(int id) &#123; return Mono.justOrEmpty(this.users.get(id)); &#125; //查询多个用户 @Override public Flux&lt;User&gt; getAllUser() &#123; return Flux.fromIterable(this.users.values()); &#125; //添加用户 @Override public Mono&lt;Void&gt; saveUserInfo(Mono&lt;User&gt; userMono) &#123; return userMono.doOnNext(person -&gt; &#123; //向 map 集合里面放值 int id = users.size()+1; users.put(id,person); &#125;).thenEmpty(Mono.empty()); &#125;&#125; 创建 controller 12345678910111213141516171819202122@RestControllerpublic class UserController &#123; //注入 service @Autowired private UserService userService; //id 查询 @GetMapping(&quot;/user/&#123;id&#125;&quot;) public Mono&lt;User&gt; geetUserId(@PathVariable int id) &#123; return userService.getUserById(id); &#125; //查询所有 @GetMapping(&quot;/user&quot;) public Flux&lt;User&gt; getUsers() &#123; return userService.getAllUser(); &#125; //添加 @PostMapping(&quot;/saveuser&quot;) public Mono&lt;Void&gt; saveUser(@RequestBody User user) &#123; Mono&lt;User&gt; userMono = Mono.just(user); return userService.saveUserInfo(userMono); &#125;&#125; 说明SpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC+Servlet+TomcatSpringWebflux 方式实现，异步非阻塞 方式，基于 SpringWebflux+Reactor+Netty 6、SpringWebflux（基于函数式编程模型）（1）在使用函数式编程模型操作时候，需要自己初始化服务器（2）基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）。核心任务定义两个函数式接口的实现并且启动需要的服务器。（ 3 ） SpringWebflux 请 求 和 响 应 不 再 是 ServletRequest 和 ServletResponse ， 而 是ServerRequest 和 ServerResponse第一步 把注解编程模型工程复制一份 ，保留 entity 和 service 内容第二步 创建 Handler（具体实现方法） 1234567891011121314151617181920212223242526272829303132public class UserHandler &#123; private final UserService userService; public UserHandler(UserService userService) &#123; this.userService = userService; &#125; //根据 id 查询 public Mono&lt;ServerResponse&gt; getUserById(ServerRequest request) &#123; //获取 id 值 int userId = Integer.valueOf(request.pathVariable(&quot;id&quot;)); //空值处理 Mono&lt;ServerResponse&gt; notFound = ServerResponse.notFound().build(); //调用 service 方法得到数据 Mono&lt;User&gt; userMono = this.userService.getUserById(userId); //把 userMono 进行转换返回 //使用 Reactor 操作符 flatMap return userMono.flatMap(person -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(fromObject(person))).switchIfEmpty(notFound); &#125; //查询所有 public Mono&lt;ServerResponse&gt; getAllUsers() &#123; //调用 service 得到结果 Flux&lt;User&gt; users = this.userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(users,User.class); &#125; //添加 public Mono&lt;ServerResponse&gt; saveUser(ServerRequest request) &#123; //得到 user 对象 Mono&lt;User&gt; userMono = request.bodyToMono(User.class); returnServerResponse.ok().build(this.userService.saveUserInfo(userMono)); &#125;&#125; 第三步 初始化服务器，编写 Router创建路由的方法 123456789//1 创建 Router 路由public RouterFunction&lt;ServerResponse&gt; routingFunction() &#123; //创建 hanler 对象 UserService userService = new UserServiceImpl(); UserHandler handler = new UserHandler(userService); //设置路由 return RouterFunctions.route(GET(&quot;/users/&#123;id&#125;&quot;).and(accept(APPLICATION_JSON)),handler::getUserById).andRoute(GET(&quot;/users&quot;).and(accept(APPLICATION_JSON)),handler::getAllUsers);&#125; 创建服务器完成适配 1234567891011//2 创建服务器完成适配public void createReactorServer() &#123; //路由和 handler 适配 RouterFunction&lt;ServerResponse&gt; route = routingFunction(); HttpHandler httpHandler = toHttpHandler(route);ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler); //创建服务器 HttpServer httpServer = HttpServer.create(); httpServer.handle(adapter).bindNow();&#125; 最终调用 123456public static void main(String[] args) throws Exception&#123; Server server = new Server(); server.createReactorServer(); System.out.println(&quot;enter to exit&quot;); System.in.read();&#125; （4）使用 WebClient 调用 12345678910111213141516171819public class Client &#123;public static void main(String[] args) &#123; //调用服务器地址 WebClient webClient = WebClient.create(&quot;http://127.0.0.1:5794&quot;); //根据 id 查询 String id = &quot;1&quot;; User userresult = webClient.get().uri(&quot;/users/&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(User.class).block(); System.out.println(userresult.getName()); //查询所有 Flux&lt;User&gt; results = webClient.get().uri(&quot;/users&quot;).accept(MediaType.APPLICATION_JSON).retrieve().bodyToFlux(User.class); results.map(stu -&gt; stu.getName()).buffer().doOnNext(System.out::println).blockFirst(); &#125;&#125; 课程总结1、Spring 框架概述（1）轻量级开源 JavaEE 框架，为了解决企业复杂性，两个核心组成：IOC 和 AOP（2）Spring5.2.6 版本2、IOC 容器（1）IOC 底层原理（工厂、反射等）（2）IOC 接口（BeanFactory）（3）IOC 操作 Bean 管理（基于 xml）（4）IOC 操作 Bean 管理（基于注解）3、Aop（1）AOP 底层原理：动态代理，有接口（JDK 动态代理），没有接口（CGLIB 动态代理）（2）术语：切入点、增强（通知）、切面（3）基于 AspectJ 实现 AOP 操作4、JdbcTemplate（1）使用 JdbcTemplate 实现数据库 curd 操作（2）使用 JdbcTemplate 实现数据库批量操作5、事务管理（1）事务概念（2）重要概念（传播行为和隔离级别）（3）基于注解实现声明式事务管理（4）完全注解方式实现声明式事务管理6、Spring5 新功能（1）整合日志框架（2）@Nullable 注解（3）函数式注册对象（4）整合 JUnit5 单元测试框架（5）SpringWebflux 使用 maven实现常用依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 &lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--数据库用--&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.24&lt;/version&gt;&lt;/dependency&gt;&lt;!--jdbctemplate--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt; 动态代理12345678910111213141516171819202122232425262728293031323334353637383940//UserDao接口public interface UserDao &#123; public void add();&#125;//实现类public class UserDaoImp implements UserDao&#123; @Override public void add() &#123; System.out.println(&quot;add run ....&quot;); &#125;&#125;//代理类public class UserDaoProxy implements InvocationHandler &#123; private Object obj; public UserDaoProxy(Object obj)&#123; this.obj=obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// 方法之前 System.out.println(&quot;方法执行之前。。。&quot;+method.getName()); Object invoke = method.invoke(obj, args); System.out.println(&quot;方法执行之后。。。&quot;+obj); return invoke; &#125;&#125;//运行public static void main(String[] args) &#123; Class[] inter= &#123;UserDao.class&#125;; UserDaoImp userDaoImp=new UserDaoImp(); UserDao dao= (UserDao) Proxy.newProxyInstance(Main.class.getClassLoader(),inter,new UserDaoProxy(userDaoImp)); dao.add();&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}],"author":null},{"title":"SpringMVC","slug":"java-2021-07-10-SpringMVC","date":"2021-07-10T13:04:41.000Z","updated":"2021-08-27T10:29:17.198Z","comments":true,"path":"2021/07/10/java-2021-07-10-SpringMVC/","link":"","permalink":"http://stary2020.gitee.io/2021/07/10/java-2021-07-10-SpringMVC/","excerpt":"","text":"","categories":[{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"java学习路线","slug":"java-2021-07-06-JavaRoute","date":"2021-07-06T00:10:35.000Z","updated":"2021-08-19T02:35:34.611Z","comments":true,"path":"2021/07/06/java-2021-07-06-JavaRoute/","link":"","permalink":"http://stary2020.gitee.io/2021/07/06/java-2021-07-06-JavaRoute/","excerpt":"","text":"英格版java全站培训javaSE 课程大纲 课程内容 备注 java语言概述 1.java编程语言发展简史2.java编程语言主要特性3.java技术体系及开发平台介绍4.java核心机制与JVM运行原理5.搭建java开发环境6.JDK的安装与配置7.开发第一个Java程序8.java程序的执行原理9.字节码反编译（jd-gui.exe、javap）10.变量的声明与使用11.变量内存空间分配与原理12.进制转换与位运算13.八大基本数据类型14.基本数据类型之间的转换15.Eclipse使用16.Idea使用17.变量的运算与底层运算原理18.常见面试题讲解 流程控制 1.java代码的执行流程介绍2.if选择结构3.Scanner键盘录入4.switch选择结构5.使用Random生成随机数6.while循环结构7.do-while循环结构8.for训话结构及执行顺序9.跳转语法：break、continue、return10.多重循环及指定跳出循环11.方法的声明与使用12.方法调用的内存分析13.方法重载Overload 数组 1.数组的创建与使用2.一维数组与多维数组3.数组的默认初始化与内存分析4.数组作为方法形参传递5.数组的遍历操作6.数组的常见算法分析7.操作数组的工具类array8.理解main方法（args)9.方法的可变参数10.使用jar命令打包应用程序11.数组数据结构的优势和劣势分析12.常见的数组面试题讲解 面向对象编程（基础） 1.面向过程和面向对象的区别2.类和对象的概述3.类的属性和方法4.构造方法（construtor）5.创建对象内存分析6.DataType数据类型传递7.this关键字解析8.static关键字详解9.局部代码块、构造代码块和静态代码块10.package和import详解 面向对象编程（进阶） 1.面向对象的三大特性2.面向对象之-封装3.访问权限修饰符4.set和get方法5.javaDoc生成API文档6.面向对象之-继承7.方法重写Override8.supper关键字详解9.继承中对象创建的内存分析10.final关键字详解11.Object类型详解12.面向对象之多态(polymorphism)13.向上转型和向下转型14.instanceof运算符15.编译时和运行时详解16.抽象类和抽象方法17.接口的定义与实现18.接口与抽象类的区别19.接口应用：内部比较器（comparable）20.接口应用：外部比较器comparator21.内部类详解22.java的内存管理与垃圾回收 异常机制 1.异常的概述2.异常的继承体系3.error错误类4.运行时异常和编译时异常5.异常的原理分析6.try-catch-finally捕捉异常7.throw抛出异常8.throws声明异常9.自定义异常 java常用类 1.Wrapper包装类2.自动装箱和自动拆箱3.包装类的缓存分析4.字符串处理类5.java.long.String类的使用与内存原理6.String类的算法分析7.StringBuff与StringBuilder8.java.long.System类9.java.util.Data类10.java.text.SimpleDateFormat类11.java.util.Calendar类12.java.long.Math类13.BigInteger类和BigDecimal类14.常见的面试题讲解与分析 集合（容器） 1.集合和数组的联系与区别2.Collection框架（Set接口与List接口）3.java.util.ArrayList源码与数据结构分析4.java.util.LinkedList源码分析5.java.util.HashSet内部原理6.java.util.TreeSet数据结构分析7.java7中Map系列集合与数据结构分析8.Iterator与ListIterator讲解9.java.util.Collections工具类10.集合中使用泛型11.自定义泛型12.泛型通配13.ArrayList、LinkedList、Vector的区别和联系14.HashMap和Hashtable的区别于联系15.使用集合实现商品和购物车16.集合选择依据 IO流 1.IO流的概念2.IO流的分类及其原理3.文件流InputStream，OutputStream4.缓冲流BufferedOutputStream、BufferedInputStream5.转换流InputStreamReader、OutputStreamWrite6.打印流PrintWrite7.数组流ByteArrayOutputStream、ByteInputStream8.数据流DataInputStream、DataOutputStream9.对象流ObjectInputStream、ObjectOutputStream 多线程 1.线程原理2.线程的创建与启动3.创建线程的集中方式对比4.线程控制5.线程的调度6.线程的优先级7.线程的声明周期8.多线程的安全问题与解决办法9.线程的同步10.互斥锁11.线程的死锁问题12.线程通信 XML&amp;正则表达式 1.XML定义和概述2.XML特点和优势3.XML验证和DTD验证4.使用DTD解析XML5.了解正则表达式的使用6.熟悉正则表达式的规则7.使用Java处理正则 反射技术 1.java反射机制的研究与应用2.反射的原理分析3.JVM与类4.类的价值、连接、初始化5.类的加载机制6.开启反射的源头Class7.获取Class实例的几种方式比较8.从Class中获取类的结构信息9.获取Constructor、Field和Method10.泛型和Class类11.使用反射模拟Servlet获取XML文件信息 设计模式 1.创建型模式（5）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式2.结构型模式（7）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式3.行为型模式（11）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 javaWeb基础（数据库)数据库在企业中使用频率极高，几乎每个项目都离不开，此阶段可以应聘DBA职位。数据库是java程序员必会的技术 课程大纲 课程内容 备注 MySQL基础 1.MySQL服务器安装与配置2.MySQL客户端使用3.用户权限管理4.SQL语句的类型5.Select单表查询6.排序，聚合查询 MySQL进阶 1.创建和管理表2.约束管理3.DML操作4.内连接查询5.外连接查询6.自连接查询7.子查询8.常用函数9.分页查询 连接查询和子查询 1.SQL92-笛卡尔积2.SQL92-等值连接3.SQL92-非等值连接4.SQL92-外连接5.SQL92-自连接6.SQL99-交叉连接7.SQL99-自然连接8.SQL99-Using连接9.SQL99-内连接10.SQL99-外连接11.单行子查询12.多行子查询 数据库对象 1.用户和权限管理2.数据库表管理3.约束创建和管理4.序列5.索引6.视图7.事务8.分页查询9.导入导出数据10.锁11.事务隔离级别12.游标 JDBC 1.JDBC概述2.使用JDBC完成添加、更新、删除操作3.使用JDBC完成查询操作4.JDBC常用接口5.使用preparedStatement6.数据库访问DBUtils类7.JDBC Template8.连接池 JDBC进阶 1.使用事务执行批处理2.MVC分层开发3.使用properties文件抽取连接参数4.DAO层开发5.使用反射抽取BaseDao接口及实现类6.基于MVC开发员工管理系统7.jdbc template MySQL优化 1.MySQL架构2.存储引擎3.SQL优化总体思路4.通用查询日志5.错误日志6.二进制文件7.慢查询日志8.执行计划9.索引及其优化策略 web前端 课程大纲 课程内容 备注 HTML标签 1.HTML发展史2.HTML基础标签3.img标签和a标签4.HTML表格标签5.HTML表单标签6.框架和字符实体 CSS层叠样式 1.CSS基础语法2.CSS参考知识（长度单位、颜色单位和路径）3.CSS常见选择器4.CSS背景属性、文本属性和列表属性5.CSS元素分类（块级、行级和行内块级）6.CSS浮动和定位属性7.CSS盒子模型 JavaScript 1.JavaScript概述和特点2.JavaScript和ECMAScript联系3.js基础语法，语句、注释、标识符4.js变量和变量提升5.js数据类型和数据类型转换6.js运算符和流程控制语句7.js数组和字符串8.js函数和韩淑华编程思想9.js对象和面向对象简介10.js常见内置类：Math和Data11.js定时器12.正则表达式 jQuery 1.Jquery简介及快速入门2.JQuery的入口函数3.JQuery选择器4.JQuery事件，事件、事件源和事件驱动程序5.JQuery对象与DOM对象互相转换6.JQuery内容节点操作7.jQuery属性节点操作8.jQuery样式9.jQuery元素节点操作10.jQuery遍历节点和each方法11.jQuery链式语法12.jQuery动画效果和自定义动画 bootstrap 1.bootstrap框架概述与引入2.栅格系统3.全局CSS样式4.组件5.bootstrap插件 Vue 1.Vue基本指令2.Vue基本组件3.Vue动画4.Vue网络请求5.Vue路由设置6.VueX7.Vue第三方组件 javaEE 阶段 课程大纲 课程内容 Tomcat、HTTP 1.web开发概述2.Tomcat服务器概述3.Tomcat下载、安装、启动4.手动创建静态web应用5.Idea配置Tomcat6.创建web应用及发布和访问7.HTTP介绍8.GET和POST请求的区别9.HTTP请求消息，请求头参数说明10.HTTP响应消息&amp;响应头参数说明&amp;响应码 JSP基础 1.JSP技术介绍2.JSP的优势3.JSP的结构，处理过程4.JSP指令5.JSP动作元素6.JSP隐式对象7.JSP表单处理8.欢迎页配置 EL+JSTL 1.EL介绍与使用2.EL取值原理3.EL隐式对象4.EL逻辑运算5.JSTL核心标签库6.JSTL函数标签库7.JSTL-fmt标签库8.自定义标签 Servlet基础 1.Servlet概述2.Servlet快速入门3.Servlet生命周期4.HttpServletRequest5.HttpServletResponse6.请求转发与重定向的区别 会话技术与Servlet域对象 1.cookie机制2.cookie的创建域使用3.Session原理4.Session失效5.Url重写6.token令牌应用7.Session活化、钝化8.session四大作用域对象 文件上传/下载 1.文件上传原理2.文件上传表单设计3.Servlet3.0文件上传处理4.文件下载原理5.文件下载响应头6.使用IO处理文件下载 JSON与Ajax 1.JSON盖帘及基本结构2.JSON解析-Jsonlib库3.JSON解析-FastJson库4.JSON解析-Gson库5.Ajax作用和技术组成及运用范围6.jQuery-ajax方法7.jQuery-post方法8.jquery-get方法9.Ajax实现用户名唯一性验证10.Ajax实现搜索框自动补全 高级框架 课程大纲 课程内容 备注 MyBatis 1.Mybatis概述2.Mybatis入门配置3.基本的CRUD操作4.核心配置文件详解5.Mapper.xml基础详解6.模糊查询7.分页的实现及插件PageHelper的使用8.动态sql+sql片段的使用9.一对多、多对一的关系处理10.注解的使用11.一级缓存和二级缓存说明及使用12.generator逆向工程使用 Spring 1.Spring框架介绍2.IOC/DI解耦合及实现原理3.Spring的入门配置4.Spring相关配置详解5.XML方式重构三层结构6.注解方式重构三层结构7.AOP的概述8.代理模式深入理解9.AOP开发（XML）10.AOP开发（注解）11.Spring-jdbc Template12.声明式事务配置及嵌套事务处理 SpringMVC 1.SpringMVC框架介绍2.……13.Spring、SpringMVC和MyBatis整合 Git/GitLab 1.Git的下载与安装2.Git与SVN对比3.Git创建版本库4.Git版本控制5.Git远程仓库6.Git、分支管理7.Git标签管理8.GitLba的下载和安装9.使用GitLab管理版本 Maven 1.Maven的概述2.Maven的下载安装3.eclipse集成Maven插件4.Idea集成maven插件5.Maven常用命令介绍6.Maven创建Java项目7.Maven项目聚合的两种方式8.Maven分项目聚合的设计方式9.Maven创建Web项目10.Maven项目的自动部署配置11.Maven本地Jar包的依赖方式 Linux/CentOS 1.虚拟机介绍和应用场景2.VMware的安装和使用3.linux/centos系统简介4.CentOS系统目录结构5.centOS常用命令6.CentOS安装java7.CentOS安装Tomcat8.CentOS安装MySQL，MySQL主从复制9.linuxShell编程10.linux运维指南 Nginx 1.Nginx的简介与安装2.Nginx的原型图3.Nginx架构模型4.Nginx负载均衡5.Nginx+Vsftpd文件服务器6.Nginx日志切分，备份，分析 Zookeeper 1.Zoopeeper简介与安装2.Zoopeeper概念解释3.Zoopeeper数据模型4.Zoopeeper原生API操作5.ZClient操作Zoopeeper6.使用Zoopeeper实现配置文件中心7.Zoopeeper节点类型8.Zoopeeper分布式锁 分布式/微服务 课程大纲 课程内容 备注 RPC 1.RMI远程调用2.webService+XML3.HttpClient+JSON4.OkHttpClient+JSON5.JDK动态代理+Socket实现RPC6.Cglib+Netty实现RPC7.RestTemplate8.protobuf序列化 Dubbo/Dubbox 1.Dubbo简介2.Dubbo架构分析3.Dubbo的入门案例4.Dubbo-admin的安装和使用5.Dubbo注册中心6.Dubbo提供者以及配置优化7.Dubbo消费者和配置优化8.Dubbo高可用、Dubbo负载均衡&lt;br /9.Dubbox实现Restful10.Dubbox启动Kryo和FST RabbitMQ 1.MQ简介和应用场景2.ActiveMQ安装3.ActiveMQ模型分析4.java操作ActiveMQ5.Spring集成ActiveMQ6.JMS操作ActiveMQ7.ActiveMQ持久化设置8.ActiveMQ群集的安装 Solr 1.Solr简介与安装（tomcat）2.Solr和lucene对比3.Solr库创建4.Solr中文分词5.SolrJ操作6.Solr数据导入7.SolrCloud方案和集群搭建8.Solr增量导入 Redis 1.Redis简介与安装2.Redis持久化介绍3.Redis的作用以及数据结构4.Redis穿透和雪崩及其解决方案5.Redis哨兵模式 JVM 1.JVM简介2.JVM组成结构3.JVM堆、栈原理4.JVM垃圾收集机制5.JVM堆内存调优6.垃圾回收策略 FastDFS 1.FastDFS简介与安装2.FastDFS模型分析3.java操作FastDFS4.FastDFS实践 SpringBoot 1.Spring和SpringBoot的对比和介绍2.包扫描实现3.SpringBoot的配置类和配置文件4.Restful设计开发5.SpringBoot添加拦截器6.SpringBoot跨域请求7.SpringBoot Stater原理8.SpringBoot核心开发 SpringCloud Bus 1.SpringCloud框架简介2.SpringCloud 和Dubbo的区别3.SpringCloud Netflix：核心组件4.Rest连接 尚硅谷版java路线快速学习路线 JavaSE:https://www.bilibili.com/video/BV1Kb411W75N MySQL基础:https://www.bilibili.com/video/BV1xW411u7ax JDBC:https://www.bilibili.com/video/BV1eJ411c7rf JavaWeb:https://www.bilibili.com/video/BV1Y7411K7zz Spring5:https://www.bilibili.com/video/BV1Vf4y127N5 SpringMVC:https://www.bilibili.com/video/BV1mW411M7YA MyBatis:https://www.bilibili.com/video/BV1mW411M737 Maven:https://www.bilibili.com/video/BV1TW411g7hP SSM框架整合案例:https://www.bilibili.com/video/BV17W411g7zP Git/Github:https://www.bilibili.com/video/BV1vy4y1s7k6 Redis6:https://www.bilibili.com/video/BV1Rv41177Af MySQL高级优化:https://www.bilibili.com/video/BV1KW411u7vy MyBatisPlus:https://www.bilibili.com/video/BV1Ds411E76Y Spring注解驱动开发:https://www.bilibili.com/video/BV1gW411W7wy Zookeeper:https://www.bilibili.com/video/BV1PW411r7iP Dubbo:https://www.bilibili.com/video/BV1ns411c7jV 消息中间件ActiveMQ:https://www.bilibili.com/video/BV164411G7aB RabbitMQ:https://www.bilibili.com/video/BV1cb4y1o7zz SpringBoot2:https://www.bilibili.com/video/BV19K4y1L7MT SpringCloud:https://www.bilibili.com/video/BV18E411x7eT 尚筹网项目:https://www.bilibili.com/video/BV1bE411T7oZ 在线教育项目:https://www.bilibili.com/video/BV1dQ4y1A75e 谷粒商城项目:https://www.bilibili.com/video/BV1np4y1C7Yf 尚医通项目:https://www.bilibili.com/video/BV1V5411K7rT 尚融宝项目:https://www.bilibili.com/video/BV1VV411n7nR 高频面试题第一季:https://www.bilibili.com/video/BV1Eb411P7bP 大厂面试题第二季:https://www.bilibili.com/video/BV18b411M7xz 大厂面试题第三季:https://www.bilibili.com/video/BV1Hy4y1B78T https://www.bilibili.com/read/cv5216534?spm_id_from=333.788.b_636f6d6d656e74.5 不开心就喝开水(==水哥出品==)==以下部分是科班生和培训生的分水岭，有些公司很喜欢考(尤其数据结构和算法)== 1. 计算机网络(速览速背) 分层架构 TCP/UDP 区别 TCP三次握手，四次挥手 HTTP/HTTPS 区别 无状态 长连接、短连接 状态码 Cookie和session URI和URL 2. 操作系统(能理解最好，不理解先背，不要花太多时间) 线程和进程 区别 状态 同步 死锁 3. 数据结构和算法 数据结构(找带图的学习资源，可以结合Java动手学习) 数组 链表 栈 队列 树 堆 算法(重点把最简单的几个排序查找看) https://www.zhihu.com/question/24964987 4. 设计模式(23种)==会实现== 单例模式 工厂 代理 ==能看懂== 适配器 观察者 模板 5. 实操工具(==这块面试中问的不多，但是如果你虚构了工作经验，这块东西不熟练会露馅==) Git/SVN Maven/Gradle Linux基本操作 Nginx ELK postman 6. Java基础语言基础HELLOWORD Java特点、优点 环境 JDK JRE 开发环境配置 基础语法 语法 关键字 数据类型 逻辑控制语句 面向对象 思想 细细品 对象之间的关系 依赖 关系 聚合 组合 原则 继承 封装 多态 四个常考关键字 static final this super 初始化 属性和方法 构造方法 重载和重写 向上转型、向下转型 内部类 接口和抽象类(==这是一道考烂了的题，背也要背会==)集合(==重要==) 集合家谱:https://www.runoob.com/java/java-collections.html ==原理、特点、异同、线程安全、常用操作及其复杂度== 各种List 各种Set 各种Map ==后续学习和工作中非常有用的东西，建议玩明白== 注解反射泛型==东西不多，实操踩一遍，考前刷刷题== 泛型I/O枚举异常==初学者反复学不明白挺正常，学两遍，在实战项目中找机会实践一下。可以选择把几个常见问题背下来，先上车后补票。== 多线程 线程池 并发容器 原子类 线程与进程 并发与并行 死锁 生命周期和状态 两个常问的关键字 synchronize volatile 初学者比较抽象，如果时间比较紧，可安排在面试前突击记忆，这些内容空缺并不影响后面的学习 JVM 内存模型 垃圾回收 类加载机制 调优 7. 数据库(MySQL)==CRUD(Create Retrieve Update，Delete)工程师的基本素养，至少把链接里的内容看完== SQL基本能力:https://www.runoob.com/sql/sql-tutorial.html 事务 索引 锁 连接池 分库分表 为什么分? 如何分? 水平 垂直 用什么? Mycat 主从 读写分离 ==很多教程学完这些后会开启一个小实战项目，个人认为学习时间紧可以跳过小项目，待后面学完框架后一并实战，还有就是，跳过JSP吧。== 8. JavaWeb==走马观花，随用随抄即可，不要在这个上面浪费时间== html css js ajax vue ==这个要学明白，为SpringMVC做基础== Servlet ==在实战中边学边用，三周中间件至少学好一种，能聊几句原理那种== 9. 中间件==面试最容易问的中间件== 缓存 Redis 数据类型 String hash list set zset 基础学习:https://www.runoob.com/redis/redis-tutorial.html 常见问题 数据类型 持久化 集群 通道 事务 Redis分布式锁 ==是什么?原因，如何避免== 缓存穿透 缓存雪崩 缓存击穿 ==消息队列一般的业务rabbitMQ已经足够使用了，学会一个，面试考到其他的，把话题往用过的上面引，了解几种MQ的异同和优缺点== 消息队列 rabbiMQ rocketMQ kafka 搜索引擎 elasticsearch(==主要==) solar ==熟练运用，结合实战项目学习== 10. 框架Spring AOP IOC BeanFactory bean的作用域、生命周期 事务隔离级别 SpringMVC 工作流程图 DispatchServlet WebApplicationContext MyBatisSpringBoot 启动过程、自动装配原理? ==直接找一个SpringCloud全家桶教程从头到尾，把每个组件是做什么的弄清楚，先会用。服务发现/注册可以认真学一下，这块容易问。== 11.0 微服务/分布式理论 CAP BASE ==相同作用的，会一个就行，但是名字要记一下，最好能知道他们的区别和优缺点，面试官问到了至少知道是做什么用的，快速定位同类组件自己会的那一个，把问题接下来，聊自己会的，下同。== 服务发现/注册 Eureka(==学这个就行==) zookeeper etcd Nacos Consul 网关 Zuul Gateway 负载均衡 Ribbon 服务调用 Feign 熔断降级 Hystrix 统一配置 Config Nacos 链路追踪 Sleuth zipkin skywalking 认证、鉴权、单点登录 Shiro Spring Security OAuth2 SSo 消息总线Bus SpringCloud和dubbo的对比12. 简历优化 简历优化 校招:https://www.bilibili.com/video/BV1Af4y1472Z/ 社招:https://www.bilibili.com/video/BV1hr4y1N7hp/ 面试准备与技巧:https://www.bilibili.com/video/BV1j44y1r7nd/","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"springBoot2","slug":"java-2021-07-04-springBoot2","date":"2021-07-04T10:29:15.000Z","updated":"2021-08-27T10:29:04.295Z","comments":true,"path":"2021/07/04/java-2021-07-04-springBoot2/","link":"","permalink":"http://stary2020.gitee.io/2021/07/04/java-2021-07-04-springBoot2/","excerpt":"","text":"参考：https://www.yuque.com/atguigu/springboot 概述前置要求掌握Spring，Maven ps：需要对springMVC、redis有一定了解 环境要求： java8或以上， maven3.3+ 简介spring能做什么：IOP，AOC，web spring：微服务。将大型应用拆分为许多小模块。 SpringBoot是一个高层框架、一站式框架，Boot：开始。可以帮助整合整个Spring的生态框架。帮助我们快捷地创建出一个生产级别的应用，快速开发的脚手架。 Spring的生态，涵盖了：web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理…… jdk1.8更新接口适配器模式，Spring5更新响应式编程 SpringBoot优点： 创建独立的Spring应用。之前使用Spring的应用能够快捷地移植到SpringBoot，且功能不会减少 内嵌服务器，不需要再额外部署到tomcat之类的服务器上 自动配置Spring以及第三方的功能 提供生产级别的监控，健康检查以及外部化配置 无代码生成，无需编写xml。 基于自动装配 缺点：迭代快（人称版本帝）、封装深（不易精通） 时代背景微服务构建导致分布式 ps：（php开发小型后台快） 分布式开发困难，需要统一调度 远程调用 服务发现 负载均衡 服务容错 配置管理 服务监控 链路追踪 日志管理 任务调度 …… 云原生中要处理的问题 服务自愈 弹性伸缩 服务隔离 自动化部署 灰度发布 流量治理 …… 云原生技术路线（运维方向）：Docker，星际级容器编排Kubernetes，企业CI/CD、构建企业云平台，新一代架构Service Mesh 和serverless， 学习官网地址： https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started hello SpringBoot2快速开始SpringBoot2中整合了常用的框架，所以，只需要在maven中导入需要的相关依赖，新建运行的主类，然后就可以快速编写controller方法，实现业务。如果需要数据库操作，导入数据库的场景依赖，然后设置数据库相关配置，便可以进行业务开发。 新建一个maven工程 导入依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!--导入web的场景依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 新建主类： 12345678/*注解告诉这是一个SpringBoot应用*/@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 新建控制类： 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01()&#123; return &quot;hello,springBoot 2!&quot;; &#125;&#125; 运行截图： 配置文件： application.properties 一个配置文件配置所有。参考官网的配置文件说明，有默认值。 包含运行环境的jar包： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 可以打一个可以直接运行的jar包，在命令行输入下列命令直接运行（jar包中包含了tomcat，所以移植性极佳） 1java -jar [name.jar] 正式开发在idea中新建一个SpringBoot项目：file-new- project，选择Spring Initializr，填写相关信息。 点击下一步，配置场景。点击finish，完成项目的创建 目录说明： 报错： 无法找到run方法 SpringApplication错写成SpringBootApplication 无法运行： 注意8080端口是否被tomcat服务占用 原理依赖管理版本仲裁父项目做依赖管理：父项目的父项目中定义了很多常用的版本依赖。 自动仲裁版本管理 12345678910111213141516&lt;properties&gt; &lt;activemq.version&gt;5.15.13&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.82&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.12.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.16.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;awaitility.version&gt;4.0.3&lt;/awaitility.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.10.14&lt;/byte-buddy.version&gt; &lt;caffeine.version&gt;2.8.5&lt;/caffeine.version&gt; …… …… 自定义修改版本号：查看spring-dependency中规定的当前依赖的版本用的key。然后重写依赖（maven中的就近原则）。 start场景管理开发导入start场景管理 当引入了某个场景后，会自动引入场景所需要的所有的依赖 官方start和第三方start。 所有场景的启动器是spring-boot-start，最基础的启动器。 ps：当引入不在版本仲裁的jar包时，需要额外写依赖。 自动配置 自动配好了tomcat 引入tomcat依赖 配置tomcat 自动配好了SpringMVC的常用场景（乱码，视图解析器，文件上传解析器） 引入SpringMVC全套组件 自动配置好SpringMVC常用组件 自动配置好web常见功能，如字符编码问题等（需要导入场景依赖） 自动配置了默认包结构，主程序及其所在的包结构下的所有包都能被扫描。 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来 无需配置以前的包扫描配置 想要改变扫描路径：修改主程序注解，放大扫描的包的层级@SpringBootApplication(scanBasePackages = &quot;com.atguigu&quot;) 或用@ComponentScan标识需要扫描的包，注意@SpringBootApplication是一个合成注解，使用时需要将@SpringBootApplication替换成三个字注解 各种配置拥有默认值 默认配置最终都是映射到某个类上，如：MultipartProperties 配置文件的值最终都会绑定到每个类上，这个类会在容器中创建对象 按需加载所有的自动配置项 根据Start加载，引入那些场景，这个场景的自动配置才会开启 SpringBoot所有的自动配置功能都在spring-boot-autoconfigure包中 容器功能组件添加： @Configuration Full模式与Lite模式 配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 配置类组件之间有依赖关系，方法调用得到之前的单实例组件，使用Full。 @Bean、@Component、@Controller、@Service、@Repository 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#############################Configuration使用示例######################################################/** * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的 * 2、配置类本身也是组件 * 3、proxyBeanMethods：代理bean的方法 * Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】 * Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】 * 组件依赖必须使用Full模式默认。其他默认是否Lite模式 * * * */@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123; /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125;&#125;################################@Configuration测试代码如下########################################@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.atguigu.boot&quot;)public class MainApplication &#123; public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; //3、从容器中获取组件 Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class); Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;组件：&quot;+(tom01 == tom02)); //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892 MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。 //保持组件单实例 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); User user01 = run.getBean(&quot;user01&quot;, User.class); Pet tom = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom)); &#125;&#125; @ComponentScan、@Import 1234567891011 * 4、@Import(&#123;User.class, DBHelper.class&#125;) * 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名 * * * */@Import(&#123;User.class, DBHelper.class&#125;)@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123;&#125; @Conditional 条件装配，满足Conditional指定的条件，则进行组件注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647=====================测试条件装配==========================@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件//@ConditionalOnBean(name = &quot;tom&quot;)@ConditionalOnMissingBean(name = &quot;tom&quot;)public class MyConfig &#123; /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom22&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125;&#125;public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; boolean tom = run.containsBean(&quot;tom&quot;); System.out.println(&quot;容器中Tom组件：&quot;+tom); boolean user01 = run.containsBean(&quot;user01&quot;); System.out.println(&quot;容器中user01组件：&quot;+user01); boolean tom22 = run.containsBean(&quot;tom22&quot;); System.out.println(&quot;容器中tom22组件：&quot;+tom22); &#125; 配置文件原生配置文件引入 @ImportResource 12345678910111213141516======================beans.xml=========================&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;haha&quot; class=&quot;com.atguigu.boot.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;hehe&quot; class=&quot;com.atguigu.boot.bean.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tomcat&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678@ImportResource(&quot;classpath:beans.xml&quot;)public class MyConfig &#123;&#125;======================测试================= boolean haha = run.containsBean(&quot;haha&quot;); boolean hehe = run.containsBean(&quot;hehe&quot;); System.out.println(&quot;haha：&quot;+haha);//true System.out.println(&quot;hehe：&quot;+hehe);//true 配置绑定使用java读取properties文件中的内容，并将之封装至JavaBean中以供随时使用： 传统方式： 12345678910111213public class getProperties&#123; public static void main(String[] args) throws FileNoFoundException,IOException&#123; Properties pps=new properties(); pps.load(new FileInputStream(&quot;a.properties&quot;)); Enumeration enum1=pps.propertyNames(); while(enum1.hasMoreElements())&#123; String strKey=(String)enum1.nextElement(); String strValue=pps.getProperty(strKey); System.out.println(strKet+&quot;=&quot;+strValue); //封装到javaBean类中 &#125; &#125;&#125; PS：SpringBoot中可以只有一个配置文件（properties或yaml），可以自动识别配置文件中需要配置的属性。 注解实现： @ConfigurationProperties 12345678910111213141516171819202122232425262728293031323334/** * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 */@Component@ConfigurationProperties(prefix = &quot;mycar&quot;)public class Car &#123; private String brand; private Integer price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Integer getPrice() &#123; return price; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; @EnableConfigurationProperties+@ConfigurationProperties @Component+@ConfigurationProperties 12345@EnableConfigurationProperties(Car.class)//1、开启Car配置绑定功能//2、把这个Car这个组件自动注册到容器中public class MyConfig &#123;&#125; 自动配置原理引导加载自动配置类 12345@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication&#123;&#125; @SpringBootConfiguration @Configuration。代表当前是一个配置类 @ComponentScan。指定扫描那些Spring注解 @EnableAutoConfiguration 123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; AutoConfigurationPackage。自动配置包，指定了默认的包规则 12345@Import(AutoConfigurationPackages.Registrar.class) //给容器中导入一个组件public @interface AutoConfigurationPackage &#123;&#125;//利用Registrar给容器中导入一系列组件//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。 @Import（AutoConfigurationImportSelector.class） 12345671、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件4、从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories 文件中写死了Spring-boot一启动就要给容器中加载的所有配置类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131文件里面写死了spring-boot一启动就要给容器中加载的所有配置类spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 按需开启自动配置项 修改默认配置项12345678910 @Bean @ConditionalOnBean(MultipartResolver.class) //容器中有这个类型组件 @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件 public MultipartResolver multipartResolver(MultipartResolver resolver) &#123; //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。 //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; &#125;//给容器中加入了文件上传解析器； SpringBoot默认会在底层配好所有的组件。以用户自己配置的优先。 小结 SpringBoot先加载所有的自动配置类。xxxx.AutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件默认的值。对应的值从xxx.Properties中获取，两者进行了绑定 生效的配置类会给容器中装配很多的组件 只要容器中有这些组件，就相当于拥有这些功能 定制化配置 用户自己@Bean替换底层的组件 用户查找这个组件是获取配置文件的什么值就去修改。 开发小技巧1.Lombok作用：简化JavaBean开发： maven中引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; idea中搜索安装lombok插件，使用下列三个注解来替代get、set等方法 @Data@ToString@EqualsAndHashCode 12345678910111213141516171819202122232425262728293031===============================简化JavaBean开发===================================@NoArgsConstructor//@AllArgsConstructor@Data@ToString@EqualsAndHashCodepublic class User &#123; private String name; private Integer age; private Pet pet; public User(String name,Integer age)&#123; this.name = name; this.age = age; &#125;&#125;================================简化日志开发===================================@Slf4j@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01(@RequestParam(&quot;name&quot;) String name)&#123; log.info(&quot;请求进来了....&quot;); return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name; &#125;&#125; 2.dev-toolsmaven中导入依赖。项目或者页面修改后，按住Ctrl+F9，快速编译 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 3.快速创建SpringBoot项目参考：正式开发 引入场景依赖 查看自动配置的参数（是否需要修改） debug=true，查看自动配置报告 banner图修改 ctrl+f9 项目重新编译，配合热部署插件使用 ctrl+h，查看继承树 核心功能 配置文件 web开发 数据访问 单元测试 指标监控 原理解析 配置文件文件类型：xxx.properties。xxx.yaml yaml“YAML Ain’t Markup Language”(YAML不是一种标记语言)的递归缩写。在开发这种语言时，YAML的意识其实是：”Yet Another Markup Langeage”(仍是一种标记语言)。YAML非常适合用来作为以数据为中心的配置文件。 基本语法： key: value;key和value之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许使用空格 缩进空格数不重要，只要相同层级的元素左对齐即可 #表示注释 字符串无需加引号，如果要加，单引号表示字符内容会被转义。例如/n就输出/n。双引号则表示字符内容不会被转义，例如，/n的输出效果是换行。 数据类型 字面量：单个的、不可再分的值。例如：date、boolean、string、number、null 对象：键值对的集合。map、hash、set、object 123456行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125;#或k: k1: v1 k2: v2 k3: v3 数组：一组按次序排列的值。array、list、queue。 123456行内写法： k: [v1,v2,v3]#或者k: - v1 - v2 - v3 示例： 1234567891011121314151617181920212223242526# yaml表示person: userName: zhangsan boss: false birth: 2019/12/12 20:12:33 age: 18 pet: name: tomcat weight: 23.4 interests: [篮球,游泳] animal: - jerry - mario score: english: first: 30 second: 40 third: 50 math: [131,140,148] chinese: &#123;first: 128,second: 136&#125; salarys: [3999,4999.98,5999.99] allPets: sick: - &#123;name: tom&#125; - &#123;name: jerry,weight: 47&#125; health: [&#123;name: mario,weight: 47&#125;] web开发 SpringMVC自动配置概览 简单功能分析 请求参数处理 数据响应与内容协商 视图解析与模板引擎 拦截器 异常处理 原生Servlet组件 嵌入式Web开发 定制化原理 1.SpringMVC自动配置概览2.简单功能分析静态资源访问 静态资源目录 只要静态资源放在类路径下：/static、/public、/resource、/META-INF/resource 访问：当前项目根路径/+静态资源名 原理：静态映射/**请求进来，先去找Controller看能不能处理。不能处理的所有请求都交给静态资源处理器。静态资源也找不到则响应404页面。 改变默认的静态资源路径： 123456spring: mvc: static-path-pattern: /res/** resources: static-locations: [classpath:/haha/] 静态资源访问前缀： 123spring: mvc: static-path-pattern: /res/** 当前项目+static-path-pattern+静态资源名 webjar自动映射/webjars/**。导入相关的web的jar包，网址：https://www.webjars.org。例如： 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 导入jQuery后，可以在：http://localhost:8080/webjars/jquery/3.5.1/jquery.js中访问jQuery。 欢迎页支持 静态资源路径下，index.html页面会被自动识别为首页 可以配置静态资源路径 但是不可用配置静态资源访问前缀。否则导致index.html不能被默认访问。 或者用controller处理/index页面跳转。自定义/请求的跳转页面。 自定义Favicon自定义网站的图标，favicon.ico文件放在静态资源目录下即可 静态资源配置原理 SpringBoot启动默认加载xxx.AutoConfiguration类（自动配置类） SpringMVC功能的自动配置类：WebMVCAutoConfiguration，生效 12345678@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;&#125; 给容器中配置了： 12345@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;&#125; 配置文件的相关属性和xxx进行了绑定|WebMVCProperties==spring.mvc、ResourceProperties==spring.resource 源码解析 配置类只有一个有参构造器 123456789101112131415161718192021 //有参构造器所有参数的值都会从容器中确定//ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象//WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象//ListableBeanFactory beanFactory Spring的beanFactory//HttpMessageConverters 找到所有的HttpMessageConverters//ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。=========//DispatcherServletPath //ServletRegistrationBean 给应用注册Servlet、Filter.... public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123; this.resourceProperties = resourceProperties; this.mvcProperties = mvcProperties; this.beanFactory = beanFactory; this.messageConvertersProvider = messageConvertersProvider; this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable(); this.dispatcherServletPath = dispatcherServletPath; this.servletRegistrations = servletRegistrations; &#125; 资源处理的默认规则： 1234567891011121314151617181920212223@Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); //webjars的规则 if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; // String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; 123456spring:# mvc:# static-path-pattern: /res/** resources: add-mappings: false 禁用所有静态资源规则 1234567891011@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; 欢迎页的处理规则 1234567891011121314151617181920212223242526HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations()); return welcomePageHandlerMapping; &#125; WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123; //要用欢迎页功能，必须是/** logger.info(&quot;Adding welcome page: &quot; + welcomePage.get()); setRootViewName(&quot;forward:index.html&quot;); &#125; else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; // 调用Controller /index logger.info(&quot;Adding welcome page template: index&quot;); setRootViewName(&quot;index&quot;); &#125;&#125; favicon 3.请求参数处理请求映射 rest使用与原理。 @xxxMapping Rest风格支持（使用HTTP请求方式动词来表示对资源的操作） 以前：/getUser 获取用户 、/deleteUser 删除用户、/editUser 修改用户、/saveUser 保存用户 现在：/user GET-获取用户，DELETE-删除用户、PUT-修改用户、POST-保存用户 核心Filter：HiddenHttpMethodFilter 用法：表单method=post，隐藏域：_method=put SpringBoot中手动开启 拓展：自定义_method的名字 12345678910111213141516171819202122232425262728293031323334353637 @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET) public String getUser()&#123; return &quot;GET-张三&quot;; &#125; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public String saveUser()&#123; return &quot;POST-张三&quot;; &#125; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT) public String putUser()&#123; return &quot;PUT-张三&quot;; &#125; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE) public String deleteUser()&#123; return &quot;DELETE-张三&quot;; &#125; @Bean @ConditionalOnMissingBean(HiddenHttpMethodFilter.class) @ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false) public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; return new OrderedHiddenHttpMethodFilter(); &#125;//自定义filter @Bean public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123; HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter(); methodFilter.setMethodParam(&quot;_m&quot;); return methodFilter; &#125; Rest原理（表单提交要使用REST的时候） 表单提交会带上_method=PUT 请求过来会被HiddenHttpMethodFilter拦截 请求正常，且是POST 获取到_method的值 兼容以下请求：PUT、DELETE、PATCH 原生request（post），包装模式requestWrapper重写了getMethod方法，返回的是传入的值 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requestWrapper Rest如何使用客户端工具 使用PostMan直接发送put、delete等方式请求，无需Filter 开启表单的Rest功能： 12345spring: mvc: hiddenmethod: filter: enabled: true #开启页面表单的Rest功能 请求映射原理 SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch（） RequestMappingHandlerMapping：保存了所有@RequestMapping和handle的映射规则 所有的请求映射都在HandleMapping中 SpringBoot自动配置欢迎页的WelcomePageHandleMapping。访问/ 能访问到index.html SpringBoot自动配置默认的RequestMappingHandleMapping 请求进来，挨个尝试所有的HandleMapping看是否有请求信息 如果有就找到这个请求对应的handle 如果没有就是下一个HandleMapping 我们需要一些自定义的映射处理，我们也可以自己给容器中放HandleMapping，自定义HandleMapping 1234567891011protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 普通参数与基本注解 注解：@PathVariable、@RequestHandle、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@RestControllerpublic class ParameterTestController &#123; // car/2/owner/zhangsan @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;) public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String,String&gt; pv, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String,String&gt; header, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params, @CookieValue(&quot;_ga&quot;) String _ga, @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;id&quot;,id);// map.put(&quot;name&quot;,name);// map.put(&quot;pv&quot;,pv);// map.put(&quot;userAgent&quot;,userAgent);// map.put(&quot;headers&quot;,header); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params&quot;,params); map.put(&quot;_ga&quot;,_ga); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/save&quot;) public Map postMethod(@RequestBody String content)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;,content); return map; &#125; //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125;&#125; Servlet APIWebRequest、ServletRequest、MultipartSession、HttpSession、javax.servlet.http.PushBuild、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、Zoneld 复杂参数Map、Model（map、model里面的数据会被放在request的请求域request.setAttribute）、Error/BindingResult、RedirectAttribute（重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder Map、Model类型的参数，会返回mavContainer.getModel()；—&gt;BindingAwareModelMap是Model也是MapmavContainer.getModel()；获取到值的 自定义对象：可以自动类型转换与格式化，可以级联封装 POJO封装过程 ServletModelAttributeMethodProcessor 参数处理原理 HandlerMapping中找到能处理请求的Handle（Controller.method()) 为当前Handle找一个适配器HandleAdapter；RequestMappingHandlerAdapter 适配器执行目标方法并确定方法参数的每一个值 HandlerAdapter 执行目标方法 参数解析器-HandlerMethodArgumentResolver确认将要执行的目标方法的每一个参数的值是什么。SpringMVC目标方法能写多少种参数类型，取决于参数解析器 当前解析器是否支持解析这种参数 支持就调用resolveArgument 返回值处理器 如何确定目标方法每一个参数的值 123456789101112131415161718192021222324252627282930313233343536============InvocableHandlerMethod==========================protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args; &#125; 挨个判断所有参数解析器那个支持解析这个参数 1234567891011121314@Nullableprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123; HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter); if (result == null) &#123; for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123; if (resolver.supportsParameter(parameter)) &#123; result = resolver; this.argumentResolverCache.put(parameter, result); break; &#125; &#125; &#125; return result;&#125; 解析这个参数的值 1调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可 自定义参数类型、封装POJOServletModelAttributeMethodProcessor，这个参数处理器支持是否为简单类型 12345678910111213public static boolean isSimpleValueType(Class&lt;?&gt; type) &#123; return (Void.class != type &amp;&amp; void.class != type &amp;&amp; (ClassUtils.isPrimitiveOrWrapper(type) || Enum.class.isAssignableFrom(type) || CharSequence.class.isAssignableFrom(type) || Number.class.isAssignableFrom(type) || Date.class.isAssignableFrom(type) || Temporal.class.isAssignableFrom(type) || URI.class == type || URL.class == type || Locale.class == type || Class.class == type)); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Override @Nullable public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; Assert.state(mavContainer != null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;); Assert.state(binderFactory != null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;); String name = ModelFactory.getNameForParameter(parameter); ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class); if (ann != null) &#123; mavContainer.setBinding(name, ann.binding()); &#125; Object attribute = null; BindingResult bindingResult = null; if (mavContainer.containsAttribute(name)) &#123; attribute = mavContainer.getModel().get(name); &#125; else &#123; // Create attribute instance try &#123; attribute = createAttribute(name, parameter, binderFactory, webRequest); &#125; catch (BindException ex) &#123; if (isBindExceptionRequired(parameter)) &#123; // No BindingResult parameter -&gt; fail with BindException throw ex; &#125; // Otherwise, expose null/empty value and associated BindingResult if (parameter.getParameterType() == Optional.class) &#123; attribute = Optional.empty(); &#125; bindingResult = ex.getBindingResult(); &#125; &#125; if (bindingResult == null) &#123; // Bean property binding and validation; // skipped in case of binding failure on construction. WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); if (binder.getTarget() != null) &#123; if (!mavContainer.isBindingDisabled(name)) &#123; bindRequestParameters(binder, webRequest); &#125; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new BindException(binder.getBindingResult()); &#125; &#125; // Value type adaptation, also covering java.util.Optional if (!parameter.getParameterType().isInstance(attribute)) &#123; attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter); &#125; bindingResult = binder.getBindingResult(); &#125; // Add resolved attribute and BindingResult at the end of the model Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel(); mavContainer.removeAttributes(bindingResultModel); mavContainer.addAllAttributes(bindingResultModel); return attribute; &#125; 1WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); WebDataBinder：web数据绑定器，将请求参数的值绑定到指定的JavaBean里面WebDataBinder：利用它里面的Converters将请求数据转成指定的数据类型。再次封装到JavaBean中GenericConversionService：在设置每一个值的时候，找它里面的所有Converter那个可以将这个数据类型（request带来的参数的字符串）转到指定的类型@FunctionalInterface public interface Converter&lt;S,T&gt; 给WebDataBinder里面放自己的Converter：private static final class StringToNumberimplements Converter&lt;String,T&gt;自定义converter: 1234567891011121314151617181920212223242526272829303132//1、WebMvcConfigurer定制化SpringMVC的功能@Beanpublic WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); // 不移除；后面的内容。矩阵变量功能就可以生效 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new Converter&lt;String, Pet&gt;() &#123; @Override public Pet convert(String source) &#123; // 啊猫,3 if(!StringUtils.isEmpty(source))&#123; Pet pet = new Pet(); String[] split = source.split(&quot;,&quot;); pet.setName(split[0]); pet.setAge(Integer.parseInt(split[1])); return pet; &#125; return null; &#125; &#125;); &#125; &#125;;&#125; 目标方法执行完成将所有数据都放在ModelAndViewContainer；包含要去的页面地址View，还包含Model数据。 处理派发结果 123processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); 1234567891011121314151617181920212223242526272829303132333435363738InternalResourceView：@Override protected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() + &quot;]: Check that the corresponding file exists within your web application archive!&quot;); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;); &#125; rd.include(request, response); &#125; else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;); &#125; rd.forward(request, response); &#125; &#125; 1234567891011121314151617暴露模型作为请求域属性// Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request);protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123; //model中的所有数据遍历挨个放在请求域中 model.forEach((name, value) -&gt; &#123; if (value != null) &#123; request.setAttribute(name, value); &#125; else &#123; request.removeAttribute(name); &#125; &#125;); &#125; 4.数据响应与内容协商数据响应： 响应页面 响应数据 json xml xls 图片、音视频 自定义协议数据 响应jsonjackson.jar+@ResponseBody 1234567891011 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;web场景自动引入了json场景 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 给前端自动返回json数据 返回值解析器 返回值解析器原理 返回值处理器判断是否支持这种类型返回值：supportsReturnType 返回值处理器调用handleReturnValue进行处理 RequestResponseBodyMethodProcess可以处理返回值标了@ResponseBody注解的 利用MessageConverters进行处理，将 数据写为json 内容协商：浏览器默认会以请求头的方式告诉服务器他能接收什么样的内容类型 服务器最终根据自身的能力，决定服务器能生产出什么样内容类型的数据 SpringMVC会挨个遍历所有的底层的HttpMessageConverter，看谁能处理 得到MappingJackson2HttpMessageConverter可以将对象写为json 利用MappingJackson2HttpMessageConverter将对象转为json再写出去 SpringMVC支持的返回值： 12345678910111213141516ModelAndViewModelViewResponseEntity ResponseBodyEmitterStreamingResponseBodyHttpEntityHttpHeadersCallableDeferredResultListenableFutureCompletionStageWebAsyncTask有 @ModelAttribute 且为对象类型的@ResponseBody 注解 ---&gt; RequestResponseBodyMethodProcessor； HTTPMessageConverter原理： MessageConverter规范：HttpMessageConverter：看是否支持将此class类型的对象，转化为MediaType类型的数据 默认的MessageConverter 0：只支持Byte类型的 1：String 2：String 3：Resource 4：ResourceRegion 5：DOMSource.class\\SAXSource.class\\StAXSource.class\\StreamSource.class\\Source.class 6：MutiValueMap 7：true 8：true 9：支持注解方式xml处理 最终MappingJack2HttpMessageConverter把对象转化为JSON（利用底层的jackson的objectMapping转换的） 内容协商根据客户的接收能力不同，返回不同媒体类型的数据。 引入xml依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; postman分别测试返回json和xml只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型 开启浏览器参数方式内容协商功能开启基于请求参数的内容协商功能： 123spring: contentnegotiation: favor-parameter: true #开启请求参数内容协商模式 测试： 发请求： http://localhost:8080/test/person?format=json http://localhost:8080/test/person?format=xml确定客户端接收什么样的内容类型 Parameter策略优先确定是要返回json的数据（获取请求头中的format的值） 最终进行内容协商返回给客户端json即可 内容协商原理 判断当前响应头中是否已经有确定的媒体类型。MediaType 获取客户端（PostMan、浏览器等）支持接收的内容类型。（客户端Accept请求头字段） contentNegotiationManager内容协商管理器，默认使用基于请求头的策略 HeaderContentNegotiationStrategy确定客户端可以接收的内容类型 遍历循环所有当前系统的MessageConverter，看谁支持操作这个对象 找到支持操作此对象的Converter，把converter支持的媒体类型统计出来 总结客户端需要的媒体类型，与服务端的能力（能提供的媒体类型） 进行内容协商的最佳匹配媒体类型 将对象转为最佳匹配媒体类型的converter，调用它进行转化 自定义MessageConverter实现多协议数据兼容 @ResponseBody响应数据处理调用：RequestResponseBodyethodProcessor处理 Processor处理方法返回值，通过MessageConverter处理 所有MessageConverter合起来可以支持各种媒体类型数据的操作（读、写） 内容协商找到最终的MessageConverter SpringMVC的什么功能，衣蛾入口给容器中添加衣蛾WebMvcConfigurer 12345678910@Bean public WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125; &#125; &#125; 有可能我们添加的自定义功能会覆盖默认的很多功能，导致一些默认的功能失效。 5.视图解析与模板引擎视图解析：SpringBoot默认不支持jsp，需要引入第三方模板引擎技术实现页面渲染 视图解析： 视图处理方式： 转发 重定向 自定义视图 视图解析原理流程 目标方法处理的过程中，所有数据都会被放在ModelAndViewContainer里面，包括数据和视图地址 方法的参数是一个自定义类型对象（从请求参数中确定的），把他重写放在ModelAndViewContainer 任何目标方法执行完成以后都会返回ModelAndView（数据和视图地址） processDispatchResult处理派发结果 根据方法的String返回值得到view对象（定义了页面渲染逻辑） 所有视图解析器尝试是否能根据当前返回值得到view对象 得到了redirect:/main.html，—-》Thymeleaf new RedirectView() ContentNegotiationViewResolver里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象 view.render(mv.getModelInternal(),request,response)，视图对象调用自定义的render进行页面渲染工作 RedirectView如何渲染：重定向到一个页面 获取目标url地址 response.sendRedirect(encodeURL) 视图解析： 返回值以forward：开始：new InternalResourceView(forwardUrl);—-&gt;转发。request.getRequestDispatcher(path).forward(request,response); 返回值以redirect：开始：new RedirectView()—-&gt;render就是重定向 返回值是普通字符串：new ThymeleafView()—–&gt; 自定义视图+自定义视图解析器。。。。略 模板引擎thymeleafthymeleaf：参考官网。不推荐使用，建议使用vue 基本语法：表达式： 表达式名字 语法 变量取值 ${…} 选择变量 *{…} 消息 #{…} 链接 @{…} 片段表达式 ~{…} 使用： 引入start： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 自动配置自动配置策略： 所有的thymeleaf的配置值都在ThymeleafProperties 配置好了SpringTemplateEngine 配好了ThymeleafViewResolve 我们只需要开发页面 页面开发：注意，需要引入thymeleaf的命名空间：xmlns:th=&quot;http://www.thymeleaf.org&quot; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;哈哈&lt;/h1&gt;&lt;h2&gt; &lt;a href=&quot;www.atguigu.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;去百度&lt;/a&gt; &lt;br/&gt; &lt;a href=&quot;www.atguigu.com&quot; th:href=&quot;@&#123;link&#125;&quot;&gt;去百度2&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 构建后台管理系统： 项目创建 静态资源处理 路径构建 模板抽取 页面跳转 数据渲染 具体项目：略。参考完整的springBoot+vue项目 6.拦截器 HandlerInterceptor接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 登录检查 * 1、配置好拦截器要拦截哪些请求 * 2、把这些配置放在容器中 */@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; /** * 目标方法执行之前 * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI = request.getRequestURI(); log.info(&quot;preHandle拦截的请求路径是&#123;&#125;&quot;,requestURI); //登录检查逻辑 HttpSession session = request.getSession(); Object loginUser = session.getAttribute(&quot;loginUser&quot;); if(loginUser != null)&#123; //放行 return true; &#125; //拦截住。未登录。跳转到登录页 request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);// re.sendRedirect(&quot;/&quot;); request.getRequestDispatcher(&quot;/&quot;).forward(request,response); return false; &#125; /** * 目标方法执行完成以后 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView); &#125; /** * 页面渲染以后 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex); &#125;&#125; 配置拦截器： 123456789101112131415/** * 1、编写一个拦截器实现HandlerInterceptor接口 * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors） * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】 */@Configurationpublic class AdminWebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;,&quot;/js/**&quot;); //放行的请求 &#125;&#125; 拦截器原理： 根据当前请求，找到HandlerExecutionChain（可以处理请求的handler以及handler的所有拦截器） 顺序执行所有拦截器的preHandle方法 如果当前拦截器prehandler返回值为true，则执行下一个拦截器的preHandler 如果当前拦截器返回为false，直接倒序执行所有已经执行了的拦截器的afterCompletion 如果任何一个拦截器返回false，直接跳出不执行目标方法 如果所有拦截器都返回True，执行目标方法 倒序执行所有拦截器的postHandle方法 前面的所有步骤有任何的异常都会直接触发afterCompletion 页面成功渲染完成以后，也会倒序触发afterCompletion： 7.文件上传 页面表单： 1234&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 文件上传代码： 1234567891011121314151617181920212223242526272829303132333435/** * MultipartFile 自动封装上传过来的文件 * @param email * @param username * @param headerImg * @param photos * @return */@PostMapping(&quot;/upload&quot;)public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; log.info(&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;, email,username,headerImg.getSize(),photos.length); if(!headerImg.isEmpty())&#123; //保存到文件服务器，OSS服务器 String originalFilename = headerImg.getOriginalFilename(); headerImg.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); &#125; if(photos.length &gt; 0)&#123; for (MultipartFile photo : photos) &#123; if(!photo.isEmpty())&#123; String originalFilename = photo.getOriginalFilename(); photo.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); &#125; &#125; &#125; return &quot;main&quot;;&#125; 自动配置原理文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties 自动配置好了StandardServletMultipartResolver（文件上传解析器） 原理步骤： 请求进来使用文件上传解析器判断（isMultipart）并封装（resolverMultipart，返回MultipartHttpServletRequest）文件上传请求 参数解析器来解析请求中的文件内容封装成MultipartFile 将request中文件信息封装为一个Map；MultiValueMap&lt;String,MultipartFile&gt; FileCopyUtils。实现文件流的拷贝 12345@PostMapping(&quot;/upload&quot;)public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) 8.异常处理 错误处理 默认规则 默认情况下，SpringBoot提供/error处理所有错误的映射 对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“whitelabel”错误视图，以HTML的格式呈现相同的数据 要对其进行自定义，添加View解析为error 要完全替换默认行为，可以实现ErrorController并注册该类的Bean定义，或添加ErrorAttributes类的组件以使用现有机制但替换其内容 error/下的4xx，5xx页面会被自动解析 定制错误处理逻辑 自定义错误页：error/ 下的页面，有精确的错误状态码页面就精确匹配，没有就找4xx.html，如果还没有就触发空白页 @ControllerAdvice+@ExceptionHandler处理全局异常，底层是ExceptionHandlerExceptionResolve，把responsestatus注解的信息底层调用response.sendError(ststusCode,resolvedReason)；tomcat发送的/error Spring底层的异常，如参数类型转换异常；DefaultHandlerExceptionResolver处理框架底层的异常response.sendError(HttpServletResponse.SC_BAD_REQUEST,ex.getMessage()); 自定义实现HandlerExceptionResolve处理异常，可以作为默认的全局异常处理规则 ErrorViewResolver实现自定义处理异常： response.sendError。error请求就会转给controller 你的异常没有任何人能够处理。tomcat底层response.sendError。error请求就会转给controller basicErrorController要去的页面地址是：ErrorViewResolver 异常处理自动配置原理 ErrorMvcAutoConfiguration自动配置异常处理规则： 容器中的组件：类型：DefaultErrorAttributes—-》id：errorAttributes public class DefaultErrorAttributes implements ErrorAttributes，HandlerExceptionResolver DefaultErrorAttributes：定义错误页面中可以包含哪些数据 容器中的组件：类型：BasicErrorController—》id：basicErrorController（json+白页 适配响应） 处理默认/error路径的请求：页面响应new ModelAndView(“error”,model); 容器中有组件View–》id是error；响应默认错误页 容器中放组件BeanNameViewResolver（视图解析器）；按照返回的视图名字作为组件的id去容器中找View对象 容器中的组件：类型：DefaultErrorViewResolver—》id：conventionErrorViewResolver 如果发生错误，会以HTTP的状态码作为视图页地址（viewName），找到真正的页面 如果想要返回页面，就会找error视图（StaticView）。默认是一个空白页 异常处理步骤流程 执行目标方法，目标方法运行期间有任何异常都会被catch、而且标志当前请求结束，并且用dispatchException 进入视图解析流程（页面渲染？）processDispatchResolver（processedRequest，response，mappedHandler，mv，dispatchException）； mv=processHandlerException，处理handler发生的异常，处理完返回ModelAndView 遍历所有的handlerExceptionResolvers，看谁能处理当前异常（HandlerExceptionResolvers处理器异常解析器） 系统默认的 异常解析器： DefaultErrorAttributes先来处理异常，把异常信息保存到request域，并返回null 默认没有任何人能处理异常，所以异常会被抛出 如果没有任何人能处理，最终底层就会发送/error请求，会被底层的BasicErrorController处理 解析错误视图，遍历所有的ErrorViewResolver，看谁能解析 默认的DefaultErrorViewResolver，作用是吧响应状态码作为错误页的地址。例如：/error/500.html 模板引擎最终响应这个页面：/error/500.html 9.web原生组件注入 使用Servlet API@ServletComponentScan（basePackages=”com.example.servlet”）:指定原生servlet组件都放在那里@WebServlet（urlPatterns=”/my”）:效果：直接响应，没有经过Spring的拦截器@Webfilter（urlPatterns={“/css”,”/images/*”}）@WebListener拓展：DispatchServlet如何注册进来： 容器中自动配置了DispatchServlet属性绑定到WebMvcProperties；对应的配置文件配置项是：Spring.mvc。 通过ServletRegistrationBean&lt;DispatcherServlet&gt;把DispatchServlet配置进来 默认映射的是/路径 Tomcat-Servlet:多个Servlet都能处理到同一层路径，精确优先原则 使用RegistrationBeanServletRegistrationBean, FilterRegistrationBean, and ServletListenerRegistrationBean 123456789101112131415161718192021222324252627@Configurationpublic class MyRegistConfig &#123; @Bean public ServletRegistrationBean myServlet()&#123; MyServlet myServlet = new MyServlet(); return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;); &#125; @Bean public FilterRegistrationBean myFilter()&#123; MyFilter myFilter = new MyFilter();// return new FilterRegistrationBean(myFilter,myServlet()); FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean myListener()&#123; MySwervletContextListener mySwervletContextListener = new MySwervletContextListener(); return new ServletListenerRegistrationBean(mySwervletContextListener); &#125;&#125; 10.嵌入式Web开发 切换嵌入式Servlet容器 默认支持的webServlet Tomcat、Jetty、Undertow ServletWebServerApplicationContext容器启动寻找ServletWebServerFactory并引导创建服务器 切换服务器 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 原理 SpringBoot应用启动发现当前是web应用。Web场景包，导入tomcat web应用会创建一个web版的ico容器ServletWebServerApplicationContext ServletWebServerApplicationContext启动的时候寻找ServletWebServerFactory（Servlet的web服务器工厂——》Servlet的web服务器） SpringBoot底层默认有很多的WebServer工厂：TomcatServletWebServerFactoryJettyServletWebServerFactoryUndertowServletWebServerFactory 底层直接会有一个自动配置类：ServletWebServerFactoryAutoConfiguration ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration配置类 ServletWebServerFactoryConfiguration配置类根据动态判断系统中到底导入了那个web服务器的包。（默认是web-starter导入tomcat包，容器中就有TomcatServletWebServerFactory） TomcatServletWebServerFactory创建出Tomcat服务器并启动；TomcatServletWebServer的构造器拥有初始化方法：initialize—-this.tomcat.start()； 内嵌服务器，就是手动吧启动服务器的代码调用（tomcat核心jar包存在） 定制Servlet容器 实现：WenServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;把配置文件的值和ServletWebServerFactory进行绑定 修改配置文件：server.xxx 直接自定义ConfigurableServletWebFactoryxxxCustomizer:定制化器，可以改变xxx的默认规则： 12345678910111213import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;import org.springframework.stereotype.Component;@Componentpublic class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123; @Override public void customize(ConfigurableServletWebServerFactory server) &#123; server.setPort(9000); &#125;&#125; 11.定制化原理 定制化的常见方式 修改配置文件 xxxxCustomizer 编写自定义配置类xxxConfiguration；+@Bean替换、增加容器中默认组件；视图解析器 Web应用，编写一个配置类实现WebMvcConfigurer即可定制化web功能；+@Bean给容器中在拓展一些组件 12@Configurationpublic class AdminWebConfig implements WebMvcConfigurer @EnableWebMvc+WebMvcConfigurer+@Bean，可以全面接管SpringMVC，所有的规则全部自己重新配置，实现定制和拓展功能 原理： WebMvcAutoConfiguration默认的SpringMVC的自动配置功能类，静态资源、欢迎页…… 一旦使用@EnableWebMvc，会@Import(DelegationWebMvcConfiguration.class) DelegationWebMvcConfiguration的作用，只保证SpringMVC最基本的使用 把所有系统中的WebMvcConfigurer拿过来。所有功能的地址都是这些WebMvcConfigurer合起来一起生效 自动配置了一些非常底层的组件。RequestMappingHandlerMapping这些组件依赖的组件都是从容器中获取 public class DelegationWebMvcConfiguration extends WebMvcAutoConfigurationSupport WebMvcAutoConfiguration里面的配置要能生效，必须@ConditionalOnMissingBean（WebMvcAutoConfigurationSupport.class） @EnableWebMvc导致了WebMvcAutoConfiguration没有生效 原理分析套路：场景starter—xxxAutoConfiguration—导入xxx组件—绑定xxxProperties—绑定配置文件项 数据访问1.SQL1.数据源的自动配置-HikariDataSource 导入JDBC场景 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 数据库驱动：为什么导入JDBC场景：官方不知道我们要操作什么数据库，所以官方没有导入 数据库版本和驱动版本要对应 1234567891011121314默认版本：&lt;mysql.version&gt;8.0.22&lt;/mysql.version&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;!-- &lt;version&gt;5.1.49&lt;/version&gt;--&gt; &lt;/dependency&gt;想要修改版本1、直接依赖引入具体版本（maven的就近依赖原则）2、重新声明版本（maven的属性的就近优先原则） &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt; &lt;/properties&gt; 分析自动配置 自动配置的类 DataSourceAutoConfiguration：数据源的自动配置 修改数据源的相关配置：spring.datasource 数据库连接池的配置，是自己容器中没有DataSource才自动配置 底层配置好的连接池是：HikariDataSource DataSourceTransactionManagerAutoConfiguration：事务管理器的自动配置 JdbcTemplateAutoConfiguration：JdbcTemplate的自动配置，可以来对数据库进行crud 可以修改这个配置项@ConfigurationProperties(prefix=”spring.jdbc”)来修改JdbcTemplate @Bean@Primary JdbcTemplate；容器中有这个组件 JndiDataSourceAutoConfiguration：Jndi的自动配置 XAdataSourceAutoConfiguration：分布式事务相关的 修改配置项 123456spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 测试 123456789101112131415161718@Slf4j@SpringBootTestclass Boot05WebAdminApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() &#123;// jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)// jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,) Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class); log.info(&quot;记录总数：&#123;&#125;&quot;,aLong); &#125;&#125; 2. 使用Druid数据源 Druid官方地址：https://github.com/alibaba/druid整合第三方技术的两种方式： 自定义 找starter 自定义方式 创建数据源 12345678910111213141516171819202122 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;20&quot; /&gt; StatViewServlet用途： 提供监控信息展示的html页面 提供监控信息的JSON API 12345678&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; StatFilter用于统计监控信息，如SQL监控、URL监控 123需要给数据源中配置如下属性；可以允许多个filter，多个用，分割；如：&lt;property name=&quot;filters&quot; value=&quot;stat,slf4j&quot; /&gt; 系统中所有的filter： 别名 Filter类名 default com.alibaba.druid.filter.stat.StatFilter stat com.alibaba.druid.filter.stat.StatFilter mergeStat com.alibaba.druid.filter.stat.MergeStatFilter encoding com.alibaba.druid.filter.encoding.EncodingConvertFilter log4j com.alibaba.druid.filter.logging.Log4jFilter log4j2 com.alibaba.druid.filter.logging.Log4j2Filter slf4j com.alibaba.druid.filter.logging.Slf4jLogFilter commonlogging com.alibaba.druid.filter.logging.CommonsLogFilter ​ 慢SQL记录配置： 123456&lt;bean id=&quot;stat-filter&quot; class=&quot;com.alibaba.druid.filter.stat.StatFilter&quot;&gt; &lt;property name=&quot;slowSqlMillis&quot; value=&quot;10000&quot; /&gt; &lt;property name=&quot;logSlowSql&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;使用 slowSqlMillis 定义慢SQL的时长 使用官方starter的方式： 引入druid-starter 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 分析自动配置 扩展配置项：spring.datasource.druid DruidSpringAopConfiguration.class，监控SpringBean的，配置项：spring.datasource.druid.aop-patterns DruidStatViewServletConfiguration.class，监控页的配置：spring.datasource.druid.stat-view-servlet-filter；默认开启 DruidFilterConfiguration.class，所有Druid自己filter 的配置 配置示例 1234567891011121314151617181920212223242526272829303132spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver druid: aop-patterns: com.atguigu.admin.* #监控SpringBean filters: stat,wall # 底层开启功能，stat（sql监控），wall（防火墙） stat-view-servlet: # 配置监控页功能 enabled: true login-username: admin login-password: admin resetEnable: false web-stat-filter: # 监控web enabled: true urlPattern: /* exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27; filter: stat: # 对上面filters里面的stat的详细配置 slow-sql-millis: 1000 logSlowSql: true enabled: true wall: enabled: true config: drop-table-allow: false SpringBoot配置示例https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter 配置项列表https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8 3. 整合MyBatishttps://github.com/mybatis starterSpringBoot官方的Starter：spring-boot-starter-*第三方的： *-spring-boot-starter 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt; 配置模式： 全局配置文件 SQLSessionFactory：自动配置好了 SqlSession：自动配置了SqlSessiontemplate组合了SqlSession @Import（AutoConfiguredMapperScannerRegistrar.class） Mapper：只要我们写的操作MyBatis的接口标准了 @Mapper就会被自动扫描进来 123456@EnableConfigurationProperties(MybatisProperties.class) ： MyBatis配置项绑定类。@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)public class MybatisAutoConfiguration&#123;&#125;@ConfigurationProperties(prefix = &quot;mybatis&quot;)public class MybatisProperties 可以修改配置文件中MyBatis开始的所有： 12345678910111213141516# 配置mybatis规则mybatis: config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 Mapper接口---&gt;绑定Xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.admin.mapper.AccountMapper&quot;&gt;&lt;!-- public Account getAcct(Long id); --&gt; &lt;select id=&quot;getAcct&quot; resultType=&quot;com.atguigu.admin.bean.Account&quot;&gt; select * from account_tbl where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 配置private Configuration Configuration；mybatis.configuration下面的所有，就是相当于改MyBatis全局配置文件中的值： 12345678# 配置mybatis规则mybatis:# config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml configuration: map-underscore-to-camel-case: true 可以不写全局；配置文件，所有全局配置文件的配置都放在configuration配置项中即可 步骤： 导入MyBatis官方的starter 编写mapper接口。标准@Mapper注解 编写Sql映射文件并绑定Mapper接口 在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息。建议配置在mybatis.configuration 注解模式： 123456789@Mapperpublic interface CityMapper &#123; @Select(&quot;select * from city where id=#&#123;id&#125;&quot;) public City getById(Long id); public void insert(City city);&#125; 混合模式： 123456789@Mapperpublic interface CityMapper &#123; @Select(&quot;select * from city where id=#&#123;id&#125;&quot;) public City getById(Long id); public void insert(City city);&#125; 最佳实战： 引入mybatis-starter 配置application.yaml中，指定mapper-location位置即可 编写Mapper接口并标注@Mapper注解 简单方法直接注解方式 复杂方法编写mapper.xml进行绑定映射 @MapperScan(“com.atguigu.admin.mapper”) 简化，其他的接口就可以不用标注@Mapper注解 4. 整合MyBatis-Plus完成CRUD MyBatis-plus：MyBatis-plus是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提升效率而生详情参考官网建议在IDEA中配合插件：MyBatisX使用 整合MyBatis-plus： 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 自动配置： MyBatisPlusAutoConfiguration配置类，MyBatisPlusProperties配置项绑定。 SqlSessionFactory自动配置好，底层是容器中默认的数据源 mapperLocations自动配置好的，有默认值classpath*:/mapper/**/*.xml；任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。建议：以后sql映射文件，放在mapper下 容器中也自动配置好了SQLSessiontemplate @Mapper标注的接口也会被自动扫描；建议直接@MapperScan(“com.example.admin.mapper”)批量扫描 优点：只需要我们的Mapper继承BaseMapper就可以拥有crud能力 CRUD功能 123456789101112131415161718192021222324252627282930313233343536373839404142 @GetMapping(&quot;/user/delete/&#123;id&#125;&quot;) public String deleteUser(@PathVariable(&quot;id&quot;) Long id, @RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn, RedirectAttributes ra)&#123; userService.removeById(id); ra.addAttribute(&quot;pn&quot;,pn); return &quot;redirect:/dynamic_table&quot;; &#125; @GetMapping(&quot;/dynamic_table&quot;) public String dynamic_table(@RequestParam(value=&quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn,Model model)&#123; //表格内容的遍历// response.sendError// List&lt;User&gt; users = Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),// new User(&quot;lisi&quot;, &quot;123444&quot;),// new User(&quot;haha&quot;, &quot;aaaaa&quot;),// new User(&quot;hehe &quot;, &quot;aaddd&quot;));// model.addAttribute(&quot;users&quot;,users);//// if(users.size()&gt;3)&#123;// throw new UserTooManyException();// &#125; //从数据库中查出user表中的用户进行展示 //构造分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(pn, 2); //调用page进行分页 Page&lt;User&gt; userPage = userService.page(page, null);// userPage.getRecords()// userPage.getCurrent()// userPage.getPages() model.addAttribute(&quot;users&quot;,userPage); return &quot;table/dynamic_table&quot;; &#125; 123456789@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125;public interface UserService extends IService&lt;User&gt; &#123;&#125; 5.NoSQLRedis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串（String）、散列（Hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）与范围查询、bitmaps、hyperloglogs和地理空间（geospatial）索引半径查询。Redis内置了复制、LUA脚本、LRU驱动事件、事务和不同级别的磁盘持久化，并通过Redis哨兵和自动分区提高可用性。 Redis自动配置 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 自动配置： RedisAutoConfiguration自动配置类。Redisproperties属性类—》spring.redis.xxx是对redis的配置 连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration 自动注入了Redistemplate&lt;Object,Object&gt; 自动注入了StringRedisTemplate：k: v都是String key: value 底层只要我们使用StringRedisTemplate、RedisTemplate就可以操作redis Redis环境搭建（阿里） 阿里云付费 申请redis的公网连接地址 修改白名单，允许0.0.0.0/0（任意网段）访问 RedisTemplate与Lettuce 123456789@Testvoid testRedis()&#123; ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue(); operations.set(&quot;hello&quot;,&quot;world&quot;); String hello = operations.get(&quot;hello&quot;); System.out.println(hello);&#125; 切换至jedis 12345678910 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- 导入jedis--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 123456789spring: redis: host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com port: 6379 password: lfy:Lfy123456 client-type: jedis jedis: pool: max-active: 10 单元测试1. JUnit5的变化SpringBoot2.2.0版本开始引入JUnit5作为测试单元默认库 JUnit5=JUnit Platform+JUnit Jupiter+JUnit Vintage JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。 注意： SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test****） JUnit 5’s Vintage Engine Removed from spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 当前版本： 1234567@SpringBootTestclass Boot05WebAdminApplicationTests &#123; @Test void contextLoads() &#123; &#125;&#125; 以前： @SpringBootTest + @RunWith(SpringTest.class) SpringBoot整合Junit以后。 编写测试方法：@Test标注（注意需要使用junit5版本的注解） Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚 2. JUnit5常用注解JUnit5的注解与JUnit4的注解有所变化 https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations **@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 **@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍 **@RepeatedTest :**表示方法可重复执行，下方会有详细介绍 **@DisplayName :**为测试类或者测试方法设置展示名称 **@BeforeEach :**表示在每个单元测试之前执行 **@AfterEach :**表示在每个单元测试之后执行 **@BeforeAll :**表示在所有单元测试之前执行 **@AfterAll :**表示在所有单元测试之后执行 **@Tag :**表示单元测试类别，类似于JUnit4中的@Categories **@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore **@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误 **@ExtendWith :**为测试类或测试方法提供扩展类引用 12345678910import org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！public class TestDemo &#123; @Test @DisplayName(&quot;第一次测试&quot;) public void firstTest() &#123; System.out.println(&quot;hello world&quot;); &#125; 3、断言（assertions）断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别： 检查业务逻辑返回的数据是否合理。 所有的测试运行结束以后，会有一个详细的测试报告； 简单断言用来对单个值进行简单的验证。如： 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 12345678910111213141516@Test@DisplayName(&quot;simple assertion&quot;)public void simple() &#123; assertEquals(3, 1 + 2, &quot;simple math&quot;); assertNotEquals(3, 1 + 1); assertNotSame(new Object(), new Object()); Object obj = new Object(); assertSame(obj, obj); assertFalse(1 &gt; 2); assertTrue(1 &lt; 2); assertNull(null); assertNotNull(new Object());&#125; 数组断言通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等 12345@Test@DisplayName(&quot;array assertion&quot;)public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125; 组合断言IassertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言 12345678@Test@DisplayName(&quot;assert all&quot;)public void all() &#123; assertAll(&quot;Math&quot;, () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) );&#125; 异常断言在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows()** ,配合函数式编程就可以进行使用。 12345678@Test@DisplayName(&quot;异常测试&quot;)public void exceptionTest() &#123; ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125; 超时断言Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间 123456@Test@DisplayName(&quot;超时测试&quot;)public void timeoutTest() &#123; //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125; 快速失败通过 fail 方法直接使得测试失败 12345@Test@DisplayName(&quot;fail&quot;)public void shouldFail() &#123; fail(&quot;This should fail&quot;);&#125; 4、前置条件JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。 1234567891011121314151617181920@DisplayName(&quot;前置条件&quot;)public class AssumptionsTest &#123; private final String environment = &quot;DEV&quot;; @Test @DisplayName(&quot;simple&quot;) public void simpleAssume() &#123; assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;)); assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;)); &#125; @Test @DisplayName(&quot;assume then do&quot;) public void assumeThenDo() &#123; assumingThat( Objects.equals(this.environment, &quot;DEV&quot;), () -&gt; System.out.println(&quot;In DEV&quot;) ); &#125;&#125; assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。 5、嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@DisplayName(&quot;A stack&quot;)class TestingAStackDemo &#123; Stack&lt;Object&gt; stack; @Test @DisplayName(&quot;is instantiated with new Stack()&quot;) void isInstantiatedWithNew() &#123; new Stack&lt;&gt;(); &#125; @Nested @DisplayName(&quot;when new&quot;) class WhenNew &#123; @BeforeEach void createNewStack() &#123; stack = new Stack&lt;&gt;(); &#125; @Test @DisplayName(&quot;is empty&quot;) void isEmpty() &#123; assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(&quot;throws EmptyStackException when popped&quot;) void throwsExceptionWhenPopped() &#123; assertThrows(EmptyStackException.class, stack::pop); &#125; @Test @DisplayName(&quot;throws EmptyStackException when peeked&quot;) void throwsExceptionWhenPeeked() &#123; assertThrows(EmptyStackException.class, stack::peek); &#125; @Nested @DisplayName(&quot;after pushing an element&quot;) class AfterPushing &#123; String anElement = &quot;an element&quot;; @BeforeEach void pushAnElement() &#123; stack.push(anElement); &#125; @Test @DisplayName(&quot;it is no longer empty&quot;) void isNotEmpty() &#123; assertFalse(stack.isEmpty()); &#125; @Test @DisplayName(&quot;returns the element when popped and is empty&quot;) void returnElementWhenPopped() &#123; assertEquals(anElement, stack.pop()); assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(&quot;returns the element when peeked but remains not empty&quot;) void returnElementWhenPeeked() &#123; assertEquals(anElement, stack.peek()); assertFalse(stack.isEmpty()); &#125; &#125; &#125;&#125; 6、参数化测试参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。 利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 @ValueSource**: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型** @NullSource**: 表示为参数化测试提供一个null的入参** @EnumSource**: 表示为参数化测试提供一个枚举入参** @CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参 @MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流) 当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。 1234567891011121314151617181920@ParameterizedTest@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)@DisplayName(&quot;参数化测试1&quot;)public void parameterizedTest1(String string) &#123; System.out.println(string); Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(&quot;method&quot;) //指定方法名@DisplayName(&quot;方法来源参数&quot;)public void testWithExplicitLocalMethodSource(String name) &#123; System.out.println(name); Assertions.assertNotNull(name);&#125;static Stream&lt;String&gt; method() &#123; return Stream.of(&quot;apple&quot;, &quot;banana&quot;);&#125; 7、迁移指南在进行迁移的时候需要注意如下的变化： 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。 把@Before 和@After 替换成@BeforeEach 和@AfterEach。 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。 把@Ignore 替换成@Disabled。 把@Category 替换成@Tag。 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。 指标监控1. SpringBootActuator 简介：未来微服务在云上部署以后，需要对其进行监控、追踪、审计、控制等 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 1.x与2.x的区别： 如何使用： 引入场景 访问：http://localhost:8080/actuator/** 暴露所有监控信息为HTTP： 123456management: endpoints: enabled-by-default: true #暴露所有端点信息 web: exposure: include: &#x27;*&#x27; #以web方式暴露 可视化：https://github.com/codecentric/spring-boot-admin 2. Actuator Endpoint 常用端点： ID 描述 auditevents 暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。 beans 显示应用程序中所有Spring Bean的完整列表。 caches 暴露可用的缓存。 conditions 显示自动配置的所有条件信息，包括匹配或不匹配的原因。 configprops 显示所有@ConfigurationProperties。 env 暴露Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。 health 显示应用程序运行状况信息。 httptrace 显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。 info 显示应用程序信息。 integrationgraph 显示Spring integrationgraph 。需要依赖spring-integration-core。 loggers 显示和修改应用程序中日志的配置。 liquibase 显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。 shutdown 使应用程序正常关闭。默认禁用。 startup 显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。 threaddump 执行线程转储。 如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点： ID 描述 heapdump 返回hprof堆转储文件。 jolokia 通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。 logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。 prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。 最常用的Endpoint Health：监控状况 Metrics：运行时指标 Loggers：日志记录 Health Endpoint 健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。 重要的几点： health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告 很多的健康检查默认已经自动配置好了，比如：数据库、redis等 可以很容易的添加自定义的健康检查机制 Metrics Endpoint 提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到； 通过Metrics对接多种监控系统 简化核心Metrics开发 添加自定义Metrics或者扩展已有Metrics 管理Endpoints 开启与禁用Endpoints 默认所有的Endpoint除过shutdown都是开启的。 需要开启或者禁用某个Endpoint。配置模式为 **management.endpoint.**&lt;endpointName&gt;.enabled = true 1234management: endpoint: beans: enabled: true 或者禁用所有的Endpoint然后手动开启指定的Endpoint 123456789management: endpoints: enabled-by-default: false endpoint: beans: enabled: true health: enabled: true 2. 暴露Endpoints 支持的暴露方式 * HTTP：默认只暴露**health**和**info** Endpoint * **JMX**：默认暴露所有Endpoint * 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则 ID JMX Web auditevents Yes No beans Yes No caches Yes No conditions Yes No configprops Yes No env Yes No flyway Yes No health Yes Yes heapdump N/A No httptrace Yes No info Yes Yes integrationgraph Yes No jolokia N/A No logfile N/A No loggers Yes No liquibase Yes No metrics Yes No mappings Yes No prometheus N/A No scheduledtasks Yes No sessions Yes No shutdown Yes No startup Yes No threaddump Yes No 3、定制 Endpoint 定制 Health 信息 12345678910111213141516171819202122232425262728import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; int errorCode = check(); // perform some specific health check if (errorCode != 0) &#123; return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build(); &#125; return Health.up().build(); &#125;&#125;构建HealthHealth build = Health.down() .withDetail(&quot;msg&quot;, &quot;error service&quot;) .withDetail(&quot;code&quot;, &quot;500&quot;) .withException(new RuntimeException()) .build();management: health: enabled: true show-details: always #总是显示详细信息。可显示每个模块的状态信息 12345678910111213141516171819202122232425262728293031@Componentpublic class MyComHealthIndicator extends AbstractHealthIndicator &#123; /** * 真实的检查方法 * @param builder * @throws Exception */ @Override protected void doHealthCheck(Health.Builder builder) throws Exception &#123; //mongodb。 获取连接进行测试 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 检查完成 if(1 == 2)&#123;// builder.up(); //健康 builder.status(Status.UP); map.put(&quot;count&quot;,1); map.put(&quot;ms&quot;,100); &#125;else &#123;// builder.down(); builder.status(Status.OUT_OF_SERVICE); map.put(&quot;err&quot;,&quot;连接超时&quot;); map.put(&quot;ms&quot;,3000); &#125; builder.withDetail(&quot;code&quot;,100) .withDetails(map); &#125;&#125; 定制info信息常用两种方式 编写配置文件 12345info: appName: boot-admin version: 2.0.1 mavenProjectName: @project.artifactId@ #使用@@可以获取maven的pom文件值 mavenProjectVersion: @project.version@ 编写InfoContributor 12345678910111213141516import java.util.Collections;import org.springframework.boot.actuate.info.Info;import org.springframework.boot.actuate.info.InfoContributor;import org.springframework.stereotype.Component;@Componentpublic class ExampleInfoContributor implements InfoContributor &#123; @Override public void contribute(Info.Builder builder) &#123; builder.withDetail(&quot;example&quot;, Collections.singletonMap(&quot;key&quot;, &quot;value&quot;)); &#125;&#125; http://localhost:8080/actuator/info 会输出以上方式返回的所有info信息 定制Metrics信息 SpringBoot支持自动适配的Metrics JVM metrics, report utilization of: Various memory and buffer pools Statistics related to garbage collection Threads utilization Number of classes loaded/unloaded CPU metrics File descriptor metrics Kafka consumer and producer metrics Log4j2 metrics: record the number of events logged to Log4j2 at each level Logback metrics: record the number of events logged to Logback at each level Uptime metrics: report a gauge for uptime and a fixed gauge representing the application’s absolute start time Tomcat metrics (server.tomcat.mbeanregistry.enabled must be set to true for all Tomcat metrics to be registered) Spring Integration metrics 增加定制Metrics 1234567891011121314151617class MyService&#123; Counter counter; public MyService(MeterRegistry meterRegistry)&#123; counter = meterRegistry.counter(&quot;myservice.method.running.counter&quot;); &#125; public void hello() &#123; counter.increment(); &#125;&#125;//也可以使用下面的方式@BeanMeterBinder queueSize(Queue queue) &#123; return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);&#125; 定制Endpoint 12345678910111213141516@Component@Endpoint(id = &quot;container&quot;)public class DockerEndpoint &#123; @ReadOperation public Map getDockerInfo()&#123; return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;); &#125; @WriteOperation private void restartDocker()&#123; System.out.println(&quot;docker restarted....&quot;); &#125;&#125; 场景：开发ReadinessEndpoint来管理程序是否就绪，或者Liveness****Endpoint来管理程序是否存活； 当然，这个也可以直接使用 https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes 原理解析1、Profile功能为了方便多环境适配，springboot简化了profile功能。 application-profile功能 默认配置文件 application.yaml；任何时候都会加载 指定环境配置文件 application-{env}.yaml 激活指定环境 配置文件激活 命令行激活：java -jar xxx.jar –spring.profiles.active=prod –person.name=haha 修改配置文件的任意值，命令行优先 默认配置与环境配置同时生效 同名配置项，profile配置优先 ofile条件装配功能 1234567@Configuration(proxyBeanMethods = false)@Profile(&quot;production&quot;)public class ProductionConfiguration &#123; // ...&#125; profile分组 1234spring.profiles.group.production[0]=proddbspring.profiles.group.production[1]=prodmq使用：--spring.profiles.active=production 激活 2、外部化配置https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config Default properties (specified by setting SpringApplication.setDefaultProperties). @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins. Config data (such as **application.properties** files) A RandomValuePropertySource that has properties only in random.*. OS environment variables. Java System properties (System.getProperties()). JNDI attributes from java:comp/env. ServletContext init parameters. ServletConfig init parameters. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). Command line arguments. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application. @TestPropertySource annotations on your tests. Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active. 外部配置源常用：Java属性文件、YAML文件、环境变量、命令行参数； 配置文件查找位置 (1) classpath 根路径 (2) classpath 根路径下config目录 (3) jar包当前目录 (4) jar包当前目录的config目录 (5) /config子目录的直接子目录 配置文件加载顺序： 当前jar包内部的application.properties和application.yml 当前jar包内部的application-{profile}.properties 和 application-{profile}.yml 引用的外部jar包的application.properties和application.yml 引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml 指定环境优先，外部优先，后面的可以覆盖前面的同名配置项 3、自定义starter starter启动原理 starter-pom引入 autoconfigurer 包 autoconfigure包中配置使用 META-INF/spring.factories 中 EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类 编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties @Configuration @Conditional @EnableConfigurationProperties @Bean ……引入starter — xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —- 配置项 自定义starteratguigu-hello-spring-boot-starter（启动器）atguigu-hello-spring-boot-starter-autoconfigure（自动配置包） 4、SpringBoot原理Spring原理【Spring注解】、SpringMVC原理、自动配置原理、SpringBoot原理 SpringBoot启动过程 创建 SpringApplication 保存一些信息。 判定当前应用的类型。ClassUtils。Servlet bootstrappers****：初始启动引导器（List）：去spring.factories文件中找 org.springframework.boot.Bootstrapper 找 ApplicationContextInitializer；去spring.factories找 ApplicationContextInitializer List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers 找 ApplicationListener ；应用监听器。去spring.factories找ApplicationListener List&lt;ApplicationListener&lt;?&gt;&gt; listeners 运行 SpringApplication、StopWatch 记录应用的启动时间 创建引导上下文（Context环境）createBootstrapContext() 获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置 让当前应用进入headless模式。java.awt.headless 获取所有 *RunListener***（运行监听器）【为了方便所有Listener进行事件感知】 getSpringFactoriesInstances 去spring.factories找** SpringApplicationRunListener. 遍历 SpringApplicationRunListener 调用 starting 方法； 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。 保存命令行参数；ApplicationArguments 准备环境 prepareEnvironment（）; 返回或者创建基础环境信息对象。StandardServletEnvironment 配置环境信息对象。 读取所有的配置源的配置属性值。 绑定环境信息 监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成 创建IOC容器（createApplicationContext（）） 根据项目类型（Servlet）创建容器， 当前会创建 AnnotationConfigServletWebServerApplicationContext 准备ApplicationContext IOC容器的基本信息 prepareContext() 保存环境信息 IOC容器的后置处理流程。 应用初始化器；applyInitializers； 遍历所有的 ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能 遍历所有的 listener 调用 *contextPrepared。EventPublishRunListenr；通知所有的监听器***contextPrepared 所有的监听器 调用** contextLoaded。通知所有的监听器 contextLoaded； 刷新IOC容器。refreshContext 创建容器中的所有组件（Spring注解） 容器刷新完成后工作？afterRefresh 所有监听 器 调用 listeners.started(context); 通知所有的监听器 started 调用所有runners；callRunners() 获取容器中的 ApplicationRunner 获取容器中的 CommandLineRunner **合并所有runner并且按照@Order进行排序 遍历所有的runner。调用 run** 方法 如果以上有异常， 调用Listener 的 failed 调用所有监听器的 running 方法 listeners.running(context); 通知所有的监听器 running running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；****通知所有的监听器 failed 123456789public interface Bootstrapper &#123; /** * Initialize the given &#123;@link BootstrapRegistry&#125; with any required registrations. * @param registry the registry to initialize */ void intitialize(BootstrapRegistry registry);&#125; 12345678910111213141516171819202122@FunctionalInterfacepublic interface ApplicationRunner &#123; /** * Callback used to run the bean. * @param args incoming application arguments * @throws Exception on error */ void run(ApplicationArguments args) throws Exception;&#125;@FunctionalInterfacepublic interface CommandLineRunner &#123; /** * Callback used to run the bean. * @param args incoming main method arguments * @throws Exception on error */ void run(String... args) throws Exception;&#125; Application Events and Listeners https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners ApplicationContextInitializer ApplicationListener SpringApplicationRunListener ApplicationRunner 与 CommandLineRunner","categories":[{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot2","slug":"SpringBoot2","permalink":"http://stary2020.gitee.io/tags/SpringBoot2/"}],"author":null},{"title":"git和GitHub的使用","slug":"tools-2021-07-04-gitAndGitHub","date":"2021-07-04T02:18:56.000Z","updated":"2021-08-19T02:34:26.711Z","comments":true,"path":"2021/07/04/tools-2021-07-04-gitAndGitHub/","link":"","permalink":"http://stary2020.gitee.io/2021/07/04/tools-2021-07-04-gitAndGitHub/","excerpt":"","text":"概述git：分布式版本控制，区别于集中式版本控制。 版本控制在本地进行。需要远程库协同，进行代码的克隆与推送。不再需要担心单点服务器故障（集中式）。 常见代码仓库：github、gitee（码云）。。。 工作区（git add）-暂存区（git commit）-本地库（生成历史版本）（git push）-远程库 安装注意非中文无空格目录下。 windows和linux中换行符不一样。 无脑安装。 打开git bush ，ctrl+滚轮调整字体大小。 常用命令 命令 作用 设置用户签名 git config –global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m “日志消息” 文件名 提交到本地库 git reflog 查看历史记录 git reset –hard 版本号 版本穿梭 首次安装git必须设置用户签名 用于区分不同的代码提交者（与远程仓库账号没有关系） 初始化选择一个文件夹，运行git init，生成.git的隐藏文件，查看本地库状态git status, vim中，yy复制，p粘贴 ll查看文件。 git add [名字] 添加到暂存区，追踪文件。此时可以删除文件。git rm --cached [文件名]删除暂存区文件，此时工作区不受影响。 git commit -m &quot;提交信息&quot; [文件名] 提交到本地库 git log查看详细日志消息 git中按行记录文件信息 分支命令： 命令名称 作用 git branch [branch name] 创建分支 git branch -v 查看分支 git checkout [branch name] 切换分支 git merge [branch name] 把指定的分支合并到当前分支上 **合并分支时注意代码冲突 ** 远程库git push 推送到远程库 git clone 拉取远程库 git pull 对本地库进行更新 fork从别的远程库获取所有的历史和记录到自己的远程库。pull request 拉取请求 github上传到远地库远程库的名字最好和当前的本地库的名字相同 git remote -v 查看当前的别名 git remote add [name][链接]创建别名，替换链接 git push [name]/[链接] [branch name] 推送是以分支为单位的 推送整个分支到仓库 拉取远程库到本地库git pull [name]/[链接] [branch name] git clone [链接] [branch name] 克隆代码不需要登录，且会自动创建别名 团队合作fork 和pull request 免密登录添加ssh 参见hexo篇 idea集成git配置忽略文件why：与实际项目功能无关，不参与服务器上部署运行，例如idea的配置文件等。一般项目只需要源码（src+pom.xml）,屏蔽ide工具之间的差异 注意项目的导入方式，例如maven的导入方式。 how：创建忽略规则文件：XXX.ignore(建议：git.ignore)，建议放置在用户家目录下 123456789101112131415161718192021222324252627282930# Compiled class file*.class# Log file*.log# BlueJ file*.ctxt# Mobile Tools for Java(J2EE).mtj.tmp/# Package Files*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# Virtual machine crash logs,see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml 在.gitconfig文件中引用忽略配置文件。.gitconfig文件在用户根目录下。 12345[user] …… ……[core] excludesfile=C:/Users/[name]/git.ignore 注意需要使用斜线，不能使用反斜线 idea中使用定位git新建项目-&gt;settings-&gt;version control-&gt;git-&gt;path to git executable。设置git的安装目录，”Test”进行测试，直到idea识别到git。至此，准备环境完毕 让Git管理程序VCS（Version control settings）-&gt;Import into Version Control -&gt;Create git repository。创建git的本地库。 当idea中的文件变红时，代表git托管成功，此时表示此文件未添加到暂存区。绿色文件代表已添加到暂存区，但为提交到本地库。此时的状态不影响代码的执行。文件名变为黑色，表示此时不需要操作。蓝色的文件表示提交过，但发生了修改。 存到暂存区： 右键文件，git，add 提交到本地库： 右键文件，git，commit directory，添加提交信息，commit。 版本切换查看版本：idea左下角，version control 切换版本：选择需要切换的版本，右键，checkout Reversion [版本号] 分支创建分支： 右键项目名，git，Repository，branches 。new branch。 右下角，git [branch name] 切换分支同理 分支合并： 正常合并：Merge into Current， 代码冲突：两个都修改的分支进行合并。Merge手动合并。x表示不要这部分代码，箭头表示需要这部分代码。变黑表示合并成功并主动提交。 idea集成settings，Version control，github（若没有github，点击plugs，下载github插件）， 在github中设置github账号，右侧加号，登录账号。建议使用口令的方式登录（use token） 项目上传到githubVCS，import into Version control,share project on github。将自己的工程分项到远程库。===自动创建远程库+上传 常用功能pull、push、clone： 右键，git，repository VCS，git 默认使用http协议，建议使用ssh协议（网络原因） push，项目名，Define Remote，加入ssh连接为url。 push操作：本地库版本一定得比远程库版本高，否则会失败。若本地库代码已经落后，需要先pull拉取远程代码，将本地代码更新到最新之后，在修改，提交，推送。即：push之前，先pull。 拉取前需要注意本地代码是否修改，否则拉取过程中容易出现冲突 clone代码到本地库： ​ 打开idea，首页：get from Version Control，填入连接 git（码云）开源中国推出的，基于git的代码托管项目。中文友好 和github类似。 码云国内http使用方便。 github项目迁移到giteegitee，新建仓库，导入已有仓库，放入github链接，注意选择https协议。 github中项目更新后，在gitee中选择强制更新（项目名称后面的更新按钮）。 gitlab搭建使用基于MIT许可证的基于网络的Git仓库管理工具。使用Git作为代码管理工具的web项目。 安装官网，install Gitlab， 需要有服务器（高版本的服务器） “ee”表示旗舰版，“ce”表示免费社区版。 修改linux ip地址 1/etc/sysconfig/network-scripts/ifconfig-ens33 修改主机名 1/etc/hostsname 此外，还需要修改windows中的hosts，将linux的ip地址和主机名加入。 前期准备完成后，安装步骤参考官网 初始化gitlab服务，成功标志，gitlab reconfigure 1gitlab-ctl reconfigure 启动gitlab服务，停止命令（gitlab-ctl stop） 1gitlab-ctl start 启动成功后，浏览器访问 ip访问，默认为80端口 主机名访问，需要配置windows的hosts 登录成功后，首先需要修改root密码 使用root登录后，正常使用 idea集成gitlab安装插件gitlab version control，gitlab 使用详情参考github","categories":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"http://stary2020.gitee.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://stary2020.gitee.io/tags/github/"}],"author":null},{"title":"未来网络技术课程设计小结","slug":"course-2021-07-04-SDNnetANDDDos","date":"2021-07-04T02:18:24.000Z","updated":"2021-08-27T10:31:07.340Z","comments":true,"path":"2021/07/04/course-2021-07-04-SDNnetANDDDos/","link":"","permalink":"http://stary2020.gitee.io/2021/07/04/course-2021-07-04-SDNnetANDDDos/","excerpt":"","text":"博客内容为课设个人小结，具体课设参考课设报告 资料查找这次课设的题目是在老师给的题目中四选一，在初步选定做DDos的检测与防御之后，就需要在网络上查询相关的资料、以及前人的设计方案，最初使用搜索引擎直接搜索关键字和题目，经过筛选后，有用的结果主要就一篇博文，其他的大多是类似的内容，博文写得比较详细，但是设计方案比较简略，无法有效地达到实现目的要求（自主检测与防御）。 从这，可以看出，从事相关方面的研究的人并不是太多，至少没有广泛的编写博客并被搜索引擎检测到。不过，值得注意的是，同等的筛选条件下，google比百度的结果要好很多，当然，不能否认百度的搜索结果更加贴近日常生活中，比较符合国人习惯，但是如果需要查询专业一些的资料、文献的话，还是优先考虑google、bing等搜索引擎。至于国内其他的搜索引擎，例如搜狗、360、神马等，在资料收集方面，甚至还不如百度。 其次是很多资料并不一定会被搜索引擎所检索到，需要到专门的论坛、网站去搜索，这方面也是google比百度强的一个因素。对于一个比较热门的技术或实现架构，可以尝试在B站或者知乎、CSDN上寻找相关的教学视频、博文。但如果这几个地方都找不到的话，就需要去相关工具的官网，或者github上寻找相关的项目，现在许多开源的项目都把代码托管到了github上，可以在上面查看使用说明、官方文档，遇到问题的时候，在github的issue上面找找，或许能够解决问题。 最重要也是难度比较高的资料收集方式，便是查找论文，不过论文主要对于不需要太大代码量的设计比较友好，对于需要大量编程来实现的项目，通过论文的方式只能获取实现的思路与基本算法，具体代码实现仍旧是一个十分困难的事儿，所以，对于项目而言，最佳的方式仍旧是官网和使用手册。其次是YouTube，YouTube类似B站，可以在上面找到许多相关的教学视频。 对于it行业来说，前言的技术、架构，多是国外开发的，代码也是英文编写的，所以英语在编程的学习过程中至关重要，因为使用手册大概率是英文的、官网也很有可能是英文的，代码肯定是英文的，而代码中的注释也大概率是英文的。所以，在遇到不懂的东西的时候，需要查找东西的时候，你所查询得到的结果，大概率也是英文。对于非英语母语的我而言，看下去，是最困难的一件事，但是却必须坚持看下去，值得一提的是，google翻译很好用，但是很多时候，自动翻译的情况下，它会将一些很重要的信息也给翻译成中文，所以，如果时间允许的情况下，最好还是直接看英文原文。 工具使用工具的使用一般网上都有教程，大多时候跟着教程一步一步走即可，但是这里面最容易出现却又最容易忽略的问题，便是版本问题。 在进行仿真实验等的过程中，往往需要同时使用多个工具进行协同，如果版本没有控制好，极大可能造成，每一步都是正确的，但是合起来就不正确了。 Example：本次实验需要用到的工具主要有，VMware、Ubuntu、mininet、floodligh、sFlow。大体流程是在VMware中创建Ubuntu虚拟机，在虚拟机中安装mininet用来搭建SDN仿真网络，使用floodlight下发流表控制，使用sFlow进行流量监控。但是需要注意的一点是，floodlight的使用需要预先安装jdk环境，在Ubuntu中使用命令安装时jdk时，14的Ubuntu默认安装的是1.7的jdk，16的Ubuntu默认安装的是1.8的jdk。但是对于floodlight而言，1.0以下的版本是基于jdk1.7的，而1.0以后的则是需要jdk1.8的环境才能运行，所以，如果在14版本的Ubuntu中安装了1.7的jdk，然后安装1.0以后版本的floodlight，那floodlight便无法顺利运行。 其次是编译，在本次实验中，floodlight的编译需要使用ant，或者maven。相较于传统的项目而言，maven确实要好用很多，很适合项目的移植，而且在IDE中导入maven项目也比较方便。不过在这次的floodlight工程中，每次打包都需要编译、测试等，每次都执行测试步骤，有些浪费时间。 最后是关于日志。一个工具的使用过程，必然伴随着日志的产生，通过分析日志，可以比较清晰明了地知道工具的状态。例如，在使用ant编译过程中报错，不能一看到“100个错”就被吓退，去仔细看日志文件，检查是什么地方出错，事实上，最后发现，所谓的100个错，是中文编码字符集不统一导致的，这也进一步说明了，在平时编码的过程中，字符集的统一的重要性，值得一提的一点是，编码不同往往会导致中文乱码，但是英文不会，所以，如果条件允许，注释什么的，也尽量使用英文编写。此外，在确实发生乱码的情况下，使用编码转换工具，最好不要生硬地改变编码，这样容易导致乱码（中文）。除了工具本身提供的日志之外，我们在编写一个项目的过程中，也应该注意日志的使用，一个项目在运行过程中，其内部的运行过程与结果对我们而言是封闭的（debug）除外，我们不知道编写的代码是否出错，在那里错。所以日志输出就显得很重要，在合适的位置插入日志输入，可以便于我们在控制台上检测、判断我们的程序的问题是出在那里。输出某些关键的参数，一方面能够让我们直观地知道程序的运行状态，另一方面也能方面我们后面调试修改程序。 模块设计在floodlight中添加模块： 编写类继承特定的接口并实现接口的抽象类，然后在两个配置文件中将模块注册，这样floodlight在启动的时候便可以开启相应的模块，然后再模块的startUp方法中定义自己需要添加的功能。可以通过调用接口的实现类来获取对象，（例如switch信息），根据获取的对象，便可以获取整个floodlight中的开放的参数。 获取参数后，将参数信息传到处理的函数中，从所有信息中解析出我们实验所需要的信息，然后对信息进行二次封装，方便其他类对信息进行使用。 自主检测与防御。将获取到的信息与阈值进行比较（这里提供一个想法，阈值可不可以通过某种自主学习的算法实现），根据判断结果来执行后续的操作。 下发流表进行控制。在命令行中下发流表可以通过直接敲命令的方式实现，但在编程中，下发流表需要经过开启连接-传递参数-关闭连接的过程，而且着重要注意对参数的封装。现在主流的参数传递方法为json，能够比较友好地在前端和后端进行数据传输。 标准的格式在制作PPT和Word报告是，平时做的比较随意，在一些格式、细节上不是太重视，这也进一步导致了文档本身的不够规范问题。 对于一份标准的word格式的论文。封面，样式，字体，是否有横线，页边距。目录的缩进、字体、行距。正文中的各级标题，行距，字体，西文字体，代码格式，页眉页脚，题注表注等内容，以及对参考文献的引用等。这些细节或许很小，可以忽略，但是对于一份正式的报告而言，这些细节却是必须的。 PPT。PPT主要是用来作演示的，所以PPT的排版需要着重考虑观者的感受，PPT中不一定非得有很多内容，但是一定得把自己要体现的核心东西表现出来。PPT不一定非得很多页，但是每页需要体现出每页的价值。对于一些比较正式的汇报，PPT中则不应该出现太多花里胡哨的东西，对于正式的汇报而言，需要着重突出“学术性”和“庄重性”，其他的元素过多容易喧宾夺主，也容易影响观众观感。奥卡姆剃刀原则：如无必要，勿增实体。此外，对于某个特定主题的PPT而言，尽量不要出现过多其他的元素，PPT中的任何一个图片，应该有它存在的价值，不能为了有图片而存在图片，每一个元素都应该对他的存在负责。 流程图。流程图是一个很有必要的东西，很多时候，我们可以把冗长的文字描述转换为流程图，或者其他的图标，这样做最大的好处便是直观，方便观众去理解我们所要表达的东西，其次是简化页面，报告中与其全是文字，何不如将部分文字转化为图表，这样的排版，更能让人有看下去的想法。类似的还有结构图，拓扑图等。","categories":[{"name":"课设","slug":"课设","permalink":"http://stary2020.gitee.io/categories/%E8%AF%BE%E8%AE%BE/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://stary2020.gitee.io/tags/ubuntu/"},{"name":"SDN","slug":"SDN","permalink":"http://stary2020.gitee.io/tags/SDN/"}],"author":null},{"title":"maven的使用","slug":"tools-2021-06-30-mavenUse","date":"2021-06-30T01:41:37.000Z","updated":"2021-08-19T02:34:30.352Z","comments":true,"path":"2021/06/30/tools-2021-06-30-mavenUse/","link":"","permalink":"http://stary2020.gitee.io/2021/06/30/tools-2021-06-30-mavenUse/","excerpt":"","text":"安装maven核心程序 检查java的JAVA_HOME环境变量的配置 解压maven的核心程序，放在非中文无空格的路径下 配置maven的环境变量 MAVEN_HOME或M2_HOME 配置path变量 验证：mvn -v maven的核心概念 约定的目录结构 POM 坐标 依赖 仓库 生命周期 继承 聚合 maven工程的创建 创建约定的目录结构 123456789Hello |---src |---|---main |---|---|---java |---|---|---resources |---|---test |---|---|---java |---|---|---resources |---pom.xml 约定&gt;配置&gt;编码 pom.xml文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--坐标--&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--工程名--&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;!--依赖的文件--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 手动运行maven 在main和test目录下创建对应的主程序和测试程序，利用dos命令运行maven。 常用maven命令： 12345678mvn clean 清理mvn compile 编译主程序mvn test-compile 编译测试程序mvn test 执行测试mvn package 打包mvn install 安装mvn site 生成站点※注意：运行Maven命令时一定要进入pom.xml文件所在的目录！ 修改默认本地仓库的位置：maven解压目录下的config/settings.xml 1234567&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;--&gt; pom:Project Object Model,核心配置文件，必须 坐标：groupId：公司或组织名。artificiatId:模块名。version：版本 1234&lt;!--坐标--&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 例如： 依赖：对于自己创建的工程，执行mvn install，将自己创建的工程添加到本地仓库中。 依赖的范围： 1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;compile： 主程序的可见， 对测试程序也可见， 参与打包test： 主程序不可见， 测试程序可见， 不参与打包provided： 主程序可见， 测试程序可见， 不参与打包 开发时用，部署时忽略，由服务器提供，例如：servlet接口， 生命周期 Clean Site Default 生命周期开始一样，从最初的位置开始执行，执行到指定的位置，自动化构建 生命周期阶段，插件目标，插件。在生命周期阶段，插件调用指定目标生成对应程序。 eclipse中maven的使用不建议使用插件自带的（不稳定） 指定仓库的位置 基本操作 创建maven版的java工程 创建maven版的web工程 执行maven命令 eclipse中，添加开始菜单项：windows-customize Respective-Menu Visibility-File-New。 设置通过maven创建的工程的JDK版本。 config/settings.xml文件 在profiles标签中加入如下配置 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 创建新建一个maven工程，勾选simple，填写坐标信息 不必选择quarkstart，创建的目录不完全。 1234&lt;!--坐标--&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 在对应位置填写相关代码 执行maven命令 在Maven build 。。。中添加compile 建立web工程修改新建项目时的打包方式：默认为jar包，修改为war包 修改工程设置 工程导入file-import-选择existing maven project 注意无法复制 识别依据是pom.xml 依赖具有传递性 直接依赖与间接依赖可以传递的依赖不必再每个工程模块中都重复声明。但是，注意非compile范围的依赖无法传递 依赖的排除 不稳定的jar包对项目造成影响 版本冲突依赖排除的设置，从中间掐断的方式解除依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 依赖的原则 解决jar包的冲突问题 ​ 就近优先原则，路径最短​ 路径相同时，先声明者优先，根据dependency中的顺序 统一版本管理 建议配置：使用properties标签内使用自定义标签统一声明版本号 在需要统一的版本位置，使用${自定义标签名}引用声明的版本号凡是需要统一引用的场合都可以采用properties 123&lt;properties&gt; &lt;atguigu.spring.version&gt;4.0.0.RELEASE&lt;/atguigu.spring.version&gt;&lt;/properties&gt; 引用： 1&lt;version&gt;$&#123;atguigu.spring.version&#125;&lt;/version&gt; 继承 例如：test范围内的Junit不能传递，必然分散在各个模块中，造成版本不一致。解决思路，将Junit版本统一提取到父工程中，在子工程中不在设置，则以父工程为基准，便于修改。 操作：创建一个maven工程作为父工程，选择打包方式为pom。 在子工程中声明对父工程的引用。 12345&lt;parent&gt; 父工程坐标 &lt;!--以当前文件未基准的父工程pom.xml文件的相对路径--&gt; &lt;relationPath&gt;../Parent/pom.xml&lt;/relationPath&gt;&lt;/parent&gt; 将子工程的坐标中与父工程冲突的部分删除。 在父工程中统一管理 1234567&lt;dependencymanagement&gt; &lt;dependencies&gt; &lt;dependency&gt; //配置依赖 &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencymanagement&gt; 继承后，执行install安装时需要先安装父工程 聚合作用：一键安装各种需要使用的模块配置聚合：指定各个子工程的相对路径 12345&lt;modules&gt; &lt;module&gt;../hello&lt;/module&gt; &lt;module&gt;../hellofriend&lt;/module&gt; &lt;module&gt;../makefriend&lt;/module&gt;&lt;/modules&gt; 在聚合工程的pom.xml选择安装。（mvn insatll） web工程配置当前工程构建过程中的特殊配置 123456789101112131415161718192021222324252627282930313233343536&lt;!---Web工程自动部署--&gt; &lt;build&gt; &lt;finalName&gt;AtguiguWeb&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;tomcat6x&lt;/containerId&gt; &lt;home&gt;D:\\DevInstall\\apache-tomcat-6.0.39&lt;/home&gt; &lt;/container&gt; &lt;configuration&gt; &lt;type&gt;existing&lt;/type&gt; &lt;home&gt;D:\\DevInstall\\apache-tomcat-6.0.39&lt;/home&gt; &lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt; &lt;!-- &lt;properties&gt; &lt;cargo.servlet.port&gt;8989&lt;/cargo.servlet.port&gt; &lt;/properties&gt; --&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;cargo-run&lt;/id&gt; &lt;phase&gt;install&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 自动部署不适合在eclipse中使用 适合在命令行中用：cmd：mvn deploy maven依赖获取 到http://mvnrepository.com/搜索需要的 jar 包的依赖信息。 常用依赖： 1","categories":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":null},{"title":"hexo安装与使用","slug":"tools-2021-06-29-hexoInstallAndUse","date":"2021-06-29T02:00:32.000Z","updated":"2021-08-27T10:26:51.612Z","comments":true,"path":"2021/06/29/tools-2021-06-29-hexoInstallAndUse/","link":"","permalink":"http://stary2020.gitee.io/2021/06/29/tools-2021-06-29-hexoInstallAndUse/","excerpt":"","text":"1.安装hexohexo简介：hexo是一个静态博客框架，基于node.js，可以方便托管到github或者gitee。 hexo在本地编写、保存文件，通过Git发布到github的仓库中，github中有提供相关静态页面访问的服务，借此完成一个静态博客的搭建。相较于其他方式搭建博客，Hexo资源占用更小，结合github使用，不需要额外的域名，也不需要租用服务器（服务器到期是一个比较麻烦的问题）。且由于是静态网页，基本不用担心后台入侵的问题，整个过程中，数据从本地到github，不需要其他环节参与。 其次是Hexo的可定制化高，主题、插件丰富，可定制化程度也比较高，markdown （我主要使用）的写作方式也比较符合未来的发展与规划，对程序员比较友好，较大的缺点是md文档在使用图片时不是太理想，如果能够将图片文件直接保存在md文件中就好了，但估计实现（不可能）难度较大。 安装步骤 安装Git 安装Node.js 安装Hexo Github创建个人仓库 生成ssh并添加到GitHub 将Hexo部署到Github 其他 1.安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。 windows：git官网上下载，Download git：https://gitforwindows.org/。下载后打开Git Bash工具，用这个工具来使用git。 linux： 1sudo apt-get install git 2.安装Node.js由于Hexo是基于node.js编写的，使用需要安装node.js和npm工具 windows：官网下载：https://nodejs.org/en/download/ linux： 12sudo apt-get install nodejssudo apt-get install npm 3.安装Hexo在Git Bash中，进入要建立博客的文件夹，或者在该文件夹下，右键使用Git Bash打开。此目录是博客目录的父目录。 Git Bash进入这个目录后，输入： 1npm install -g hexo-cli 使用hexo -v检查hexo版本，测试是否暗转成功。 初始化Hexo：其中blogName是博客的名字，可以随便取，这个文件夹，即是博客文件夹。进入文件夹，并在这个文件夹中安装博客系统。 123hexo init blogNamecd blogNamenpm install 安装完成后，指定文件夹目录下有： node_moduls： #依赖包 public：#存放生成的页面 scaffold：#生成文章的模板 source：#存放文章、页面的目录 themes：#主题 _config.yml：#配置文件 在Git Bash中输入（博客文件夹下）下列命令，开启本地服务。正常情况下，在浏览器中输入localhost:4000便可以打开博客。使用ctrl+c停止服务运行。 12hexo ghexo server 常用的命令还有： 1234hexo clean 简写：hexo cl 清除旧的静态资源hexo gender 简写：hexo g 生成静态文件hexo deploy 简写：hexo d 部署文件到网站hexo server 简写：hexo s 启动服务 生成文章：建议title为英文。可在配置文件中开启默认标题，加上创建时期，便于区分。 12hexo new [layout] &lt;title&gt;或简写：hexo &lt;title&gt; 4 Github创建个人仓库 注册/登录github账号 创建一个新的仓库（new repository），仓库名称为自己的用户名，后面加上.github.io 完整名称应为：用户名/用户名.github.io 生成ssh并添加到Github中在git bash中输入，其中youname和youemail为github的用户名和邮箱。 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 输入下列命令检查，正确无误后，输入第三条创建ssh，将youemail替换为github邮箱，一路回车默认，正常情况下可以在C:\\Users\\用户名\\.ssh文件夹中找到ssh的公私秘钥。 123git config user.namegit config user.emailssh-keygen -t rsa -C &quot;youremail&quot; 选择id_rsa.pub，打开并复制里面的文本内容。 在github中，点击设置，找到ssh keys，选择new ssh key，将复制的公钥消息粘贴进去。 在git bash中验证是否成功 1ssh -T git@github.com 如果显示： 1Hi 用户名! You&#x27;ve successfully authenticated, but GitHub does not provide shell access 则表示ssh部署成功 6将hexo部署到Github打开博客文件夹下的_config.yml配置文件，在最末尾，修改配置文件：其中repo也可以选择 &#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;:用户名/用户名.github.io.git的方式，之前做的时候，使用https的方式提交失败，后面采用git的方式提交。具体地址也可以在github仓库中复制。brash则是提交到github仓库的哪一个分支中。 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 安装插件并部署到github：插件必须安装，否则无法用命令将博客部署到Github。这个阶段如果报错，主要检查仓库名称是否正确，repo地址是否正确。 1234npm install hexo-deployer-git --savehexo cleanhexo generatehexo deploy 部署成功后，可以在https://yourname.github.io查看博客 7其他设置 设置个性域名 购买域名后，在域名服务商将购买的域名解析至Github的即可，Github地址可以在域名查询网站查询。 登录Github，进入博客的仓库，点击仓库的setting，设置Custom domain，输入购买的域名。 最后在博客的source中创建一个名为CNAME的文件，无后缀，在文件中写入域名。 最后在git bash中重新部署一遍博客（clean，g，d），便可以通过个性域名访问博客。 2.Hexo配置（简单版）1._config.yml配置文件修改这里主要修改几项常用的，其他可以根据需求查看官方文档进行修改 参数 描述 title 网站标题 description 网站描述 author 您的名字 url 网址, 即为本博客的网址 new_post_name 新文章的文件名称，建议修改为:year-:month-:day-:title.md theme 当前主题名称。值为false时禁用主题 详细配置参数可以参考官网：https://hexo.io/zh-cn/docs/configuration 2.更换主题主题商店链接：https://hexo.io/themes/ 可以在主题商店选择喜欢的主题，可以预览样式，点击主题名称，可以查看主题github项目地址。一般主题中都有README.md文档，里面有相对详细的功能说明。 注意 主题的安装过程中，主题必须放在themes文件夹下，更换主题只需要更换博客根目录中的主题名称即可。注意通过clone下载的主题中可能会有一个”.git”的隐藏文件夹，需要手动删除，不然会影响项目的上传（不能嵌套.git）。 各种主题中有各种功能，很多都需要安装插件，所以，在clone主题，修改配置文件中的主题后，还需要安装相应的插件。还有就是，很多功能时依赖于配置文件来设置的，当运行报错的时候，仔细检查配置文件中是否有某样功能处于开启状态，但是却没有配置相关参数。 更换主题后报错，首先检查插件是否装对，其次检查各种操作是否符合README.md文档的说明，检查相关参数是否设置完毕。可以根据报错的信息，大概判断错误是在哪个部位。最后，可以去主题的仓库，里面有个issue的部分，说不定别人也遇到了相同的问题，最后，也可以虚心向作者请教。 3.使用hexo基础使用在git bash中，进入博客的目录。输入 1hexo new postname 在source/_post/文件夹中创建一个名字为postname的markdown文件。（如果修改默认标题的话，以修改的为准），使用markdown编辑器，对md文件进行编辑，编写自己的文章，文章编写完成后，使用 123hexo clhexo ghexo d 便可以将文章推送到github。 在scaffolds文件下，有个post.md文件，里面是创建一个新的post时默认使用的模板： 1234567title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: &#123;&#123; author &#125;&#125;tags: - defaultcategories: - default 这一段消息会被默认添加到每一篇文章中，包括了文章标题、创建的日期、作者、标签、分类。其中标签可以由多个，分类只能有一个。 高级使用SEO优化略 评论系统略 文章统计略 更换主页hexo默认的主页是显示文章列表，当我们不想首页显示文章列表时，可以自定义主页。 在source目录下，新建一个index文件夹，index文件夹中，新建一个index.md文件，填入： 123title: indextype: &quot;index&quot;permalink: index.html 接下来填入需要在主页显示的内容，例如我的： 12345* [主页](../home/)* [标签](../tages/)* [分类](../categories/)* [归档](../assort/)* [关于](../about/) 打开根目录配置文件：_config.yml，修改path为’/index/‘，保存文件，重启服务器即可。 12345678# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;) &#x27;/intro/&#x27;# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;/index/&#x27; per_page: 10 order_by: -date final 踩坑主题异常在使用主题时，开启服务后不断报错，报错显示，有未定义的变量 无法运行，最后发现，是因为博客默认开启了评论功能，但是我没有再配置文件中添加相关的配置，于是就出现了”未定义的变量”的错误。 hexo图片显示异常 设置路径 使用typora编辑md文件后，插入的图片如果是采用截图的方式，图片资源将会保存在临时文件中，图片的引用路径也是临时文件的路径。 首先，需要修改typora的图片设置：文件-偏好设置-图像，设置插入图片时的相关参数，选择复制图片到指定路径，指定路径为md文件的同名文件夹，并设置本地应用规则，如果对应服务器有账号，也可以选择上传到对应的服务器中（未尝试）。 hexo安装插件 修改配置文件_config.yml：设置post_asset_folder 为 true 安装插件 asset-image: 1npm install https://github.com/CodeFalling/hexo-asset-image 运行测试： 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s 注意修改图片路径 注意修改图片路径中的\\为/。 且文件名尽量不要为中文。 其他方案 将图片放入source/images目录下,每次generate都会生成图片,在使用相对或绝对路径进行引用 配置hexo的_config.yml文件, 将 post_asset_folder 设置为true, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. 使用hexo官方的解决方案,使用模版变量, &#123;% asset_img slug [title] %&#125; 前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了markdown的意义。顾采用上述方案，保证本地文件显示正常，且网页正常显示。 参考： https://cloud.tencent.com/developer/article/1702112 https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"},{"name":"hexo","slug":"hexo","permalink":"http://stary2020.gitee.io/tags/hexo/"}],"author":null},{"title":"markdown语法","slug":"language-2021-06-29-markdown语法","date":"2021-06-29T02:00:08.000Z","updated":"2021-08-27T10:27:34.731Z","comments":true,"path":"2021/06/29/language-2021-06-29-markdown语法/","link":"","permalink":"http://stary2020.gitee.io/2021/06/29/language-2021-06-29-markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"[toc] 1.基本语法1.1 字体设置（斜体、粗体、删除线）正常文字斜体文字斜体文字加粗文字斜体加粗删除线 1.2分级标题标题用#+空格+标题内容表示，一个#号表示一级标题，最多为六级标题。 写法二： 略，待更新 1.3 链接插入图片为了便于迁移文档，建议在文档同名目录下，新建一个文件夹用作保存图片资源。 在typora中，可以开启自动保存图片的设置，方便编写文档，否则，截屏的图片资源默认是存在临时文件夹中的，当清理系统时，临时文件会被删除，文档中的图片资源链接也会随之失效。 插入网页链接，可以用&lt;链接&gt;引起来，也可以直接输入链接地址，会自动转换。 超链接 格式为[内容]+(链接) 例如：百度 1.4分割线在一行中用三个以上的星号（*），减号（-），底线（_)来建立分割线。注意行内不能有其他东西（可以插入空格） 1.5代码块1批量代码a:两种方式创建代码块，a：利用缩进tab（或四个空格） 未成功？？待更新 b:利用英文反引号，”`”,一般在键盘左上角。在代码的始末位置连续使用三个反引号。 123456public class hello&#123;public static void main(String args[])&#123; Syetem.out.println(&quot;hello markdown!&quot;); &#125;&#125; 2行内式代码在行内引用代码，使用一对反引号包裹代码内容，例如：这是一个code。 3代码高亮在反引号后面加上对应的代码语言 12345public class hello&#123; public static void main(String args[])&#123; Syetem.out.println(&quot;hello markdown!&quot;); &#125; &#125; ​ 4代码块中包含html在代码块区域，&amp;、&lt;、&gt;会自动转换为html实体，顾代码块中的html会显示为html样式。 例如： ??? 12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;course&lt;/th&gt; &lt;th&gt;day 1&lt;/th&gt; &lt;th&gt;day 2&lt;/th&gt; &lt;th&gt;day 3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Kangkang&lt;/tr&gt; &lt;th&gt;Mary&lt;/tr&gt; &lt;th&gt;Jan&lt;/tr&gt; &lt;/tr&gt;&lt;/table&gt; 1.6引用在被引用的文本前添加&gt;符号和一个空格。 引用 引用嵌套： ? 引用其他要素 ？ 1.7列表 无序列表使用*，+，-跟随空格表示无序列表 列表一 列表二 有序列表 使用数字和英文句点表示有序列表，后跟空格。 无序和有序可嵌套使用 上一级和下一级之间敲三个空格（或者在缩进后直接敲） 列表与其他混用 文字 注意事项 加粗效果不能直接用于列表标题，但可以嵌套在列表中使用 列表中包含代码块，前面需要两个tab且空一行 使用列表时，数字后面+英文点号+空格，可能会被误判为列表，需使用转义字符\\。 1.8表格表格的使用: 注意行与行之间不能有空格，按回车时建议使用shift 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 2快捷键 功能 快捷键 加粗 ctrl+b 斜体 ctrl+i 引用 ctrl+q 插入链接 ctrl+l 插入代码 ctrl+k 插入图片 ctrl+g 提升标题 ctrl+h 有序列表 ctrl+o 无序列表 ctrl+u 横线 ctrl+r 撤销 ctrl+z 重做 ctrl+y 3.常用技巧3.1换行 方法1：连续两个以上空格+回车 方法2：使用html中的 3.2缩进字符3.3 特殊字符 对于markdown中的语法符号，前方添加反斜线\\即可显示符号本身 其他字符查看对于的Unicode码，参考网站：https://unicode-table.com/cn/ 3.4 字体，字号，颜色利用html内嵌代码实现 3.5 高级链接 行内式 参考式连接 内容目录在段落中填写[TOC]以显示全文内容的目录 [TOC] 锚点： 即页内超链接 注脚[^注脚名字]，实现，例如[^1] 背景色采用内置html实现 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景色是：orange emoji表情符号 emoji表情使用:EMOJICODE:的格式，详细列表可见https://www.webpagefx.com/tools/emoji-cheat-sheet/ 4高级用法4.1latex数学公式1.行内公式：使用两个”$”符号引用公式: $公式$ 2.行间公式：使用两对”$$”符号引用公式： $$公式$$ 输入$\\sqrt{x^{2}}$$\\sqrt{x^{2}}$具体可以参考 markdown编辑器使用LaTex数学公式（https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Ftestcs_dn%2Farticle%2Fdetails%2F44229085） latex数学符号详见：常用数学符号的 LaTeX 表示方法 4.2流程图 4.3 待办事项：Todo列表： 4.4 绘制序列图 4.5绘制甘特图 参考文章： https://blog.csdn.net/u014061630/article/details/81359144 https://www.jianshu.com/p/191d1e21f7ed http://markdown.p2hp.com/basic-syntax/","categories":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://stary2020.gitee.io/tags/markdown/"}],"author":null},{"title":"MySQL","slug":"default-4-30-MySQL","date":"2021-06-28T10:12:38.000Z","updated":"2021-08-19T02:36:03.386Z","comments":true,"path":"2021/06/28/default-4-30-MySQL/","link":"","permalink":"http://stary2020.gitee.io/2021/06/28/default-4-30-MySQL/","excerpt":"","text":"1.Idea连接MySQL常见报错a.驱动版本与MySQL版本不同 b.时区错误：连接MySQL后，输入下列命令。 c.驱动弃用修改配置文件驱动 注意： d.加密方式变化MySQL8.0后加密方式变化，可能出现连接不上的问题 报错：Client does not support authentication protocol requested by server; consider upgrading MySQL client mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password","categories":[],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":null},{"title":"firefox主页被劫持","slug":"default-firefox主页被劫持","date":"2021-06-28T10:12:38.000Z","updated":"2021-08-27T10:30:00.682Z","comments":true,"path":"2021/06/28/default-firefox主页被劫持/","link":"","permalink":"http://stary2020.gitee.io/2021/06/28/default-firefox%E4%B8%BB%E9%A1%B5%E8%A2%AB%E5%8A%AB%E6%8C%81/","excerpt":"","text":"问题描述：打开浏览器，自动弹出360的界面 解决：解决方案一： 进行主页修复，重设火狐主页，详情请访问： http://doc.firefoxchina.cn/document/repair/ 解决方案二：如果无法修改选项中火狐主页的地址，可能中了恶意扩展或者火狐配置被篡改。 1.检查 附加组件 – 扩展 中是否有可疑扩展，禁用掉。2.在地址栏里输入”about:support”3.单击配置文件夹后的”显示文件夹”按钮。4.在弹出来的文件夹中找到那个叫做”user.js”的文件，右键选择”编辑”。5.在弹出来的窗口中找到user_pref(“browser.startup.homepage”, “被锁定的网址”)6.直接删除”user.js”或者删除这行代码。 解决方案三： 如果还不行，就在你安装的路径打开火狐，如果打开没没被劫持就是快捷方式被篡改了，将快捷方式去掉，重新生成。","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":"stary"},{"title":"Hello World","slug":"default-hello-world","date":"2021-06-28T10:12:38.000Z","updated":"2021-08-20T06:30:12.344Z","comments":true,"path":"2021/06/28/default-hello-world/","link":"","permalink":"http://stary2020.gitee.io/2021/06/28/default-hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"}],"author":"stary"},{"title":"idea 使用指南","slug":"default-idea使用指南","date":"2021-06-28T10:12:38.000Z","updated":"2021-08-19T02:36:11.882Z","comments":true,"path":"2021/06/28/default-idea使用指南/","link":"","permalink":"http://stary2020.gitee.io/2021/06/28/default-idea%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"快捷键1.try-catch 、生成测试ctrl+alt+t 2.快速生成get、set等函数alt+insert 3.debug断点+debug run模式和debug模式 修改配置文件需要重新部署例如：web.xml 修改代码热部署即可","categories":[{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"},{"name":"idea","slug":"idea","permalink":"http://stary2020.gitee.io/tags/idea/"}],"author":"stary"}],"categories":[{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/categories/default/"},{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/categories/java/"},{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/categories/%E6%A1%86%E6%9E%B6/"},{"name":"课设","slug":"课设","permalink":"http://stary2020.gitee.io/categories/%E8%AF%BE%E8%AE%BE/"}],"tags":[{"name":"实践","slug":"实践","permalink":"http://stary2020.gitee.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"网络","slug":"网络","permalink":"http://stary2020.gitee.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"项目","slug":"项目","permalink":"http://stary2020.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"群集","slug":"群集","permalink":"http://stary2020.gitee.io/tags/%E7%BE%A4%E9%9B%86/"},{"name":"docker","slug":"docker","permalink":"http://stary2020.gitee.io/tags/docker/"},{"name":"java","slug":"java","permalink":"http://stary2020.gitee.io/tags/java/"},{"name":"android","slug":"android","permalink":"http://stary2020.gitee.io/tags/android/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://stary2020.gitee.io/tags/SpringBoot/"},{"name":"default","slug":"default","permalink":"http://stary2020.gitee.io/tags/default/"},{"name":"笔记","slug":"笔记","permalink":"http://stary2020.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"springCloud","slug":"springCloud","permalink":"http://stary2020.gitee.io/tags/springCloud/"},{"name":"面试","slug":"面试","permalink":"http://stary2020.gitee.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://stary2020.gitee.io/tags/SpringCloud/"},{"name":"Redis","slug":"Redis","permalink":"http://stary2020.gitee.io/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"http://stary2020.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"jvm","slug":"jvm","permalink":"http://stary2020.gitee.io/tags/jvm/"},{"name":"web","slug":"web","permalink":"http://stary2020.gitee.io/tags/web/"},{"name":"jsp","slug":"jsp","permalink":"http://stary2020.gitee.io/tags/jsp/"},{"name":"工具","slug":"工具","permalink":"http://stary2020.gitee.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"vue","slug":"vue","permalink":"http://stary2020.gitee.io/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://stary2020.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://stary2020.gitee.io/tags/MyBatis/"},{"name":"框架","slug":"框架","permalink":"http://stary2020.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot2","slug":"SpringBoot2","permalink":"http://stary2020.gitee.io/tags/SpringBoot2/"},{"name":"git","slug":"git","permalink":"http://stary2020.gitee.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://stary2020.gitee.io/tags/github/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://stary2020.gitee.io/tags/ubuntu/"},{"name":"SDN","slug":"SDN","permalink":"http://stary2020.gitee.io/tags/SDN/"},{"name":"hexo","slug":"hexo","permalink":"http://stary2020.gitee.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://stary2020.gitee.io/tags/markdown/"},{"name":"idea","slug":"idea","permalink":"http://stary2020.gitee.io/tags/idea/"}]}